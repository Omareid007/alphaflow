var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc23) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc23 = __getOwnPropDesc(from, key)) || desc23.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// shared/schema/auth.ts
import { sql } from "drizzle-orm";
import {
  pgTable,
  text,
  varchar,
  timestamp,
  boolean,
  jsonb,
  index,
  unique,
  integer
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var users, sessions, passwordResetTokens, adminSettings, auditLogs, insertUserSchema, insertPasswordResetTokenSchema, insertSessionSchema, insertAdminSettingSchema, insertAuditLogSchema;
var init_auth = __esm({
  "shared/schema/auth.ts"() {
    "use strict";
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      username: text("username").notNull().unique(),
      password: text("password").notNull(),
      email: text("email"),
      isAdmin: boolean("is_admin").default(false).notNull()
    });
    sessions = pgTable(
      "sessions",
      {
        id: text("id").primaryKey(),
        userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        expiresAt: timestamp("expires_at").notNull(),
        createdAt: timestamp("created_at").defaultNow().notNull()
      },
      (table) => [
        index("sessions_user_id_idx").on(table.userId),
        index("sessions_expires_at_idx").on(table.expiresAt)
      ]
    );
    passwordResetTokens = pgTable(
      "password_reset_tokens",
      {
        id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
        userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        token: text("token").notNull().unique(),
        expiresAt: timestamp("expires_at").notNull(),
        used: boolean("used").default(false).notNull(),
        createdAt: timestamp("created_at").defaultNow().notNull()
      },
      (table) => [
        index("password_reset_tokens_user_id_idx").on(table.userId),
        index("password_reset_tokens_token_idx").on(table.token),
        index("password_reset_tokens_expires_at_idx").on(table.expiresAt)
      ]
    );
    adminSettings = pgTable(
      "admin_settings",
      {
        id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
        namespace: text("namespace").notNull(),
        key: text("key").notNull(),
        value: jsonb("value").notNull(),
        description: text("description"),
        isSecret: boolean("is_secret").default(false).notNull(),
        isReadOnly: boolean("is_read_only").default(false).notNull(),
        updatedBy: varchar("updated_by").references(() => users.id, {
          onDelete: "set null"
        }),
        createdAt: timestamp("created_at").defaultNow().notNull(),
        updatedAt: timestamp("updated_at").defaultNow().notNull()
      },
      (table) => [
        index("admin_settings_namespace_idx").on(table.namespace),
        index("admin_settings_key_idx").on(table.key),
        unique("admin_settings_namespace_key_unique").on(
          table.namespace,
          table.key
        )
      ]
    );
    auditLogs = pgTable(
      "audit_logs",
      {
        id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
        userId: varchar("user_id").references(() => users.id, {
          onDelete: "set null"
        }),
        username: text("username"),
        action: text("action").notNull(),
        resource: text("resource").notNull(),
        resourceId: text("resource_id"),
        method: text("method").notNull(),
        path: text("path").notNull(),
        ipAddress: text("ip_address"),
        userAgent: text("user_agent"),
        requestBody: jsonb("request_body"),
        responseStatus: integer("response_status"),
        errorMessage: text("error_message"),
        timestamp: timestamp("timestamp").defaultNow().notNull()
      },
      (table) => [
        index("audit_logs_user_id_idx").on(table.userId),
        index("audit_logs_action_idx").on(table.action),
        index("audit_logs_resource_idx").on(table.resource),
        index("audit_logs_timestamp_idx").on(table.timestamp)
      ]
    );
    insertUserSchema = createInsertSchema(users).pick({
      username: true,
      password: true,
      email: true,
      isAdmin: true
    }).extend({
      email: z.string().email().optional(),
      isAdmin: z.boolean().optional()
    });
    insertPasswordResetTokenSchema = createInsertSchema(
      passwordResetTokens
    ).omit({
      id: true,
      createdAt: true
    });
    insertSessionSchema = createInsertSchema(sessions).omit({
      createdAt: true
    });
    insertAdminSettingSchema = createInsertSchema(adminSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAuditLogSchema = createInsertSchema(auditLogs).omit({
      id: true,
      timestamp: true
    });
  }
});

// shared/schema/trading.ts
import { sql as sql2 } from "drizzle-orm";
import {
  pgTable as pgTable2,
  text as text2,
  varchar as varchar2,
  timestamp as timestamp2,
  numeric,
  boolean as boolean2,
  index as index2,
  jsonb as jsonb2
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
import { z as z2 } from "zod";
var strategyStatuses, tradingModes, strategies, trades, positions, strategyStatusSchema, tradingModeSchema, performanceSummarySchema, strategyConfigSchema, insertStrategySchema, updateStrategySchema, deployStrategySchema, insertTradeSchema, insertPositionSchema;
var init_trading = __esm({
  "shared/schema/trading.ts"() {
    "use strict";
    init_auth();
    strategyStatuses = [
      "draft",
      // Initial state, under development
      "backtesting",
      // Currently running backtest
      "backtested",
      // Backtest completed, ready for deployment
      "paper",
      // Deployed to paper trading
      "live",
      // Deployed to live trading
      "paused",
      // Temporarily paused (paper or live)
      "stopped"
      // Fully stopped, can return to draft
    ];
    tradingModes = ["paper", "live"];
    strategies = pgTable2(
      "strategies",
      {
        id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
        name: text2("name").notNull(),
        type: text2("type").notNull(),
        description: text2("description"),
        // Legacy field - kept for backward compatibility, use status instead
        isActive: boolean2("is_active").default(false).notNull(),
        // NEW: Strategy lifecycle status
        status: text2("status").$type().default("draft").notNull(),
        // NEW: Trading mode (paper/live) - set when deployed
        mode: text2("mode").$type(),
        // NEW: Reference to algorithm template
        templateId: text2("template_id").default("custom").notNull(),
        // NEW: Configuration object (replaces parameters)
        config: jsonb2("config").$type().default({}),
        // NEW: Reference to last successful backtest
        lastBacktestId: varchar2("last_backtest_id"),
        // NEW: Cached performance metrics
        performanceSummary: jsonb2(
          "performance_summary"
        ).$type(),
        // Asset universe
        assets: text2("assets").array(),
        // Legacy field - use config instead
        parameters: text2("parameters"),
        createdAt: timestamp2("created_at").defaultNow().notNull(),
        updatedAt: timestamp2("updated_at").defaultNow().notNull()
      },
      (table) => [
        index2("strategies_status_idx").on(table.status),
        index2("strategies_mode_idx").on(table.mode),
        index2("strategies_template_id_idx").on(table.templateId)
      ]
    );
    trades = pgTable2(
      "trades",
      {
        id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
        userId: varchar2("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        strategyId: varchar2("strategy_id").references(() => strategies.id, {
          onDelete: "set null"
        }),
        // Note: orderId references orders table but defined without .references() to avoid circular type dependency
        // The foreign key constraint exists at database level via migration
        orderId: varchar2("order_id"),
        symbol: text2("symbol").notNull(),
        side: text2("side").notNull(),
        quantity: numeric("quantity").notNull(),
        price: numeric("price").notNull(),
        executedAt: timestamp2("executed_at").defaultNow().notNull(),
        pnl: numeric("pnl"),
        status: text2("status").default("completed").notNull(),
        notes: text2("notes"),
        traceId: text2("trace_id")
      },
      (table) => ({
        userIdIdx: index2("trades_user_id_idx").on(table.userId)
      })
    );
    positions = pgTable2(
      "positions",
      {
        id: varchar2("id").primaryKey().default(sql2`gen_random_uuid()`),
        userId: varchar2("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        symbol: text2("symbol").notNull(),
        quantity: numeric("quantity").notNull(),
        entryPrice: numeric("entry_price").notNull(),
        currentPrice: numeric("current_price"),
        unrealizedPnl: numeric("unrealized_pnl"),
        side: text2("side").notNull(),
        openedAt: timestamp2("opened_at").defaultNow().notNull(),
        // NEW: Entry time for tracking holding period (used by exit rule enforcer)
        entryTime: timestamp2("entry_time").defaultNow().notNull(),
        strategyId: varchar2("strategy_id").references(() => strategies.id, {
          onDelete: "set null"
        })
      },
      (table) => ({
        userIdIdx: index2("positions_user_id_idx").on(table.userId)
      })
    );
    strategyStatusSchema = z2.enum([
      "draft",
      "backtesting",
      "backtested",
      "paper",
      "live",
      "paused",
      "stopped"
    ]);
    tradingModeSchema = z2.enum(["paper", "live"]);
    performanceSummarySchema = z2.object({
      totalReturn: z2.number().optional(),
      winRate: z2.number().optional(),
      sharpeRatio: z2.number().optional(),
      maxDrawdown: z2.number().optional(),
      totalTrades: z2.number().optional(),
      lastUpdated: z2.string().optional()
    }).optional();
    strategyConfigSchema = z2.object({
      entryRules: z2.object({
        minConfidence: z2.number().min(0).max(1).optional(),
        maxPositions: z2.number().positive().optional(),
        excludeSymbols: z2.array(z2.string()).optional(),
        includeSymbols: z2.array(z2.string()).optional()
      }).optional(),
      positionSizing: z2.object({
        type: z2.enum(["percent", "fixed", "risk_based"]),
        value: z2.number().positive(),
        maxNotional: z2.number().positive().optional(),
        minNotional: z2.number().positive().optional()
      }).optional(),
      bracketOrders: z2.object({
        enabled: z2.boolean().optional(),
        takeProfitPercent: z2.number().positive().optional(),
        stopLossPercent: z2.number().positive().optional(),
        trailingStopPercent: z2.number().positive().optional(),
        useTrailingStop: z2.boolean().optional()
      }).optional(),
      orderExecution: z2.object({
        timeInForce: z2.enum(["day", "gtc", "ioc", "fok"]).optional(),
        orderType: z2.enum(["market", "limit"]).optional(),
        limitOffsetPercent: z2.number().optional(),
        extendedHours: z2.boolean().optional()
      }).optional(),
      exitRules: z2.object({
        maxHoldingPeriodHours: z2.number().positive().optional(),
        profitTargetPercent: z2.number().optional(),
        lossLimitPercent: z2.number().optional()
      }).optional()
    }).passthrough().optional();
    insertStrategySchema = createInsertSchema2(strategies).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      // Omit deprecated fields from validation
      isActive: true,
      parameters: true
    }).extend({
      // Make assets optional and allow empty arrays
      assets: z2.array(z2.string()).optional().default([]),
      // Add new field validations
      status: strategyStatusSchema.optional().default("draft"),
      mode: tradingModeSchema.optional().nullable(),
      templateId: z2.string().min(1).optional().default("custom"),
      config: strategyConfigSchema.default({}),
      performanceSummary: performanceSummarySchema
    });
    updateStrategySchema = insertStrategySchema.partial();
    deployStrategySchema = z2.object({
      mode: tradingModeSchema
    });
    insertTradeSchema = createInsertSchema2(trades).omit({
      id: true,
      executedAt: true
    });
    insertPositionSchema = createInsertSchema2(positions).omit({
      id: true,
      openedAt: true
    });
  }
});

// shared/schema/ai-decisions.ts
import { sql as sql3 } from "drizzle-orm";
import {
  pgTable as pgTable3,
  varchar as varchar3,
  text as text3,
  timestamp as timestamp3,
  numeric as numeric2,
  integer as integer2,
  boolean as boolean3,
  index as index3
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema3 } from "drizzle-zod";
var aiDecisions, aiDecisionFeatures, aiTradeOutcomes, aiCalibrationLog, insertAiDecisionSchema, insertAiDecisionFeaturesSchema, insertAiTradeOutcomesSchema, insertAiCalibrationLogSchema;
var init_ai_decisions = __esm({
  "shared/schema/ai-decisions.ts"() {
    "use strict";
    init_auth();
    init_trading();
    aiDecisions = pgTable3(
      "ai_decisions",
      {
        id: varchar3("id").primaryKey().default(sql3`gen_random_uuid()`),
        userId: varchar3("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        strategyId: varchar3("strategy_id").references(() => strategies.id, {
          onDelete: "set null"
        }),
        symbol: text3("symbol").notNull(),
        action: text3("action").notNull(),
        confidence: numeric2("confidence"),
        reasoning: text3("reasoning"),
        marketContext: text3("market_context"),
        createdAt: timestamp3("created_at").defaultNow().notNull(),
        // Note: executedTradeId references trades table - foreign key defined at database level
        executedTradeId: varchar3("executed_trade_id"),
        status: text3("status").default("pending").notNull(),
        stopLoss: numeric2("stop_loss"),
        takeProfit: numeric2("take_profit"),
        entryPrice: numeric2("entry_price"),
        filledPrice: numeric2("filled_price"),
        filledAt: timestamp3("filled_at"),
        skipReason: text3("skip_reason"),
        traceId: text3("trace_id"),
        metadata: text3("metadata")
      },
      (table) => ({
        userIdIdx: index3("ai_decisions_user_id_idx").on(table.userId)
      })
    );
    aiDecisionFeatures = pgTable3("ai_decision_features", {
      id: varchar3("id").primaryKey().default(sql3`gen_random_uuid()`),
      decisionId: varchar3("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
      symbol: text3("symbol").notNull(),
      volatility: numeric2("volatility"),
      trendStrength: numeric2("trend_strength"),
      signalAgreement: numeric2("signal_agreement"),
      sentimentScore: numeric2("sentiment_score"),
      peRatio: numeric2("pe_ratio"),
      pbRatio: numeric2("pb_ratio"),
      rsi: numeric2("rsi"),
      macdSignal: text3("macd_signal"),
      volumeRatio: numeric2("volume_ratio"),
      priceChangePercent: numeric2("price_change_percent"),
      marketCondition: text3("market_condition"),
      dataQuality: numeric2("data_quality"),
      activeSources: integer2("active_sources"),
      featureVector: text3("feature_vector"),
      createdAt: timestamp3("created_at").defaultNow().notNull()
    });
    aiTradeOutcomes = pgTable3("ai_trade_outcomes", {
      id: varchar3("id").primaryKey().default(sql3`gen_random_uuid()`),
      decisionId: varchar3("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
      tradeId: varchar3("trade_id").references(() => trades.id, {
        onDelete: "set null"
      }),
      symbol: text3("symbol").notNull(),
      action: text3("action").notNull(),
      predictionConfidence: numeric2("prediction_confidence"),
      entryPrice: numeric2("entry_price"),
      exitPrice: numeric2("exit_price"),
      quantity: numeric2("quantity"),
      realizedPnl: numeric2("realized_pnl"),
      realizedPnlPercent: numeric2("realized_pnl_percent"),
      holdingTimeMs: integer2("holding_time_ms"),
      isWin: boolean3("is_win"),
      slippagePercent: numeric2("slippage_percent"),
      targetPriceHit: boolean3("target_price_hit"),
      stopLossHit: boolean3("stop_loss_hit"),
      maxDrawdown: numeric2("max_drawdown"),
      maxGain: numeric2("max_gain"),
      marketSessionAtEntry: text3("market_session_at_entry"),
      marketSessionAtExit: text3("market_session_at_exit"),
      strategyId: varchar3("strategy_id").references(() => strategies.id, {
        onDelete: "set null"
      }),
      exitReason: text3("exit_reason"),
      createdAt: timestamp3("created_at").defaultNow().notNull(),
      closedAt: timestamp3("closed_at")
    });
    aiCalibrationLog = pgTable3("ai_calibration_log", {
      id: varchar3("id").primaryKey().default(sql3`gen_random_uuid()`),
      calibrationType: text3("calibration_type").notNull(),
      dataWindowDays: integer2("data_window_days").default(30),
      totalDecisions: integer2("total_decisions"),
      winCount: integer2("win_count"),
      lossCount: integer2("loss_count"),
      avgConfidenceOnWins: numeric2("avg_confidence_on_wins"),
      avgConfidenceOnLosses: numeric2("avg_confidence_on_losses"),
      avgHoldingTimeWins: integer2("avg_holding_time_wins"),
      avgHoldingTimeLosses: integer2("avg_holding_time_losses"),
      topWinningSymbols: text3("top_winning_symbols"),
      topLosingSymbols: text3("top_losing_symbols"),
      recommendedAdjustments: text3("recommended_adjustments"),
      modelVersion: text3("model_version"),
      createdAt: timestamp3("created_at").defaultNow().notNull()
    });
    insertAiDecisionSchema = createInsertSchema3(aiDecisions).omit({
      id: true,
      createdAt: true
    });
    insertAiDecisionFeaturesSchema = createInsertSchema3(
      aiDecisionFeatures
    ).omit({
      id: true,
      createdAt: true
    });
    insertAiTradeOutcomesSchema = createInsertSchema3(
      aiTradeOutcomes
    ).omit({
      id: true,
      createdAt: true
    });
    insertAiCalibrationLogSchema = createInsertSchema3(
      aiCalibrationLog
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/orchestration.ts
import { sql as sql4 } from "drizzle-orm";
import {
  pgTable as pgTable4,
  varchar as varchar4,
  text as text4,
  timestamp as timestamp4,
  numeric as numeric3,
  boolean as boolean4,
  integer as integer3,
  index as index4
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema4 } from "drizzle-zod";
var workItemTypes, workItemStatuses, agentStatus, workItems, insertWorkItemSchema, workItemRuns, insertWorkItemRunSchema, aiArenaRuns, insertAiArenaRunSchema, aiArenaAgentDecisions, insertAiArenaAgentDecisionSchema;
var init_orchestration = __esm({
  "shared/schema/orchestration.ts"() {
    "use strict";
    init_ai_decisions();
    workItemTypes = [
      "ORDER_SUBMIT",
      "ORDER_CANCEL",
      "ORDER_SYNC",
      "POSITION_CLOSE",
      "KILL_SWITCH",
      "DECISION_EVALUATION",
      "ASSET_UNIVERSE_SYNC"
    ];
    workItemStatuses = [
      "PENDING",
      "RUNNING",
      "SUCCEEDED",
      "FAILED",
      "DEAD_LETTER"
    ];
    agentStatus = pgTable4("agent_status", {
      id: varchar4("id").primaryKey().default(sql4`gen_random_uuid()`),
      isRunning: boolean4("is_running").default(false).notNull(),
      lastHeartbeat: timestamp4("last_heartbeat"),
      totalTrades: integer3("total_trades").default(0),
      totalPnl: numeric3("total_pnl").default("0"),
      winRate: numeric3("win_rate"),
      cashBalance: numeric3("cash_balance").default("100000"),
      updatedAt: timestamp4("updated_at").defaultNow().notNull(),
      killSwitchActive: boolean4("kill_switch_active").default(false).notNull(),
      maxPositionSizePercent: numeric3("max_position_size_percent").default("10"),
      maxTotalExposurePercent: numeric3("max_total_exposure_percent").default("50"),
      maxPositionsCount: integer3("max_positions_count").default(10),
      dailyLossLimitPercent: numeric3("daily_loss_limit_percent").default("5"),
      dynamicOrderLimit: integer3("dynamic_order_limit").default(10),
      minOrderLimit: integer3("min_order_limit").default(10),
      maxOrderLimit: integer3("max_order_limit").default(50),
      marketCondition: text4("market_condition").default("neutral"),
      aiConfidenceScore: numeric3("ai_confidence_score").default("0.5"),
      autoStartEnabled: boolean4("auto_start_enabled").default(true).notNull(),
      lastMarketAnalysis: timestamp4("last_market_analysis"),
      autoExecuteTrades: boolean4("auto_execute_trades").default(false).notNull(),
      conservativeMode: boolean4("conservative_mode").default(false).notNull()
    });
    workItems = pgTable4("work_items", {
      id: varchar4("id").primaryKey().default(sql4`gen_random_uuid()`),
      type: text4("type").notNull(),
      status: text4("status").default("PENDING").notNull(),
      attempts: integer3("attempts").default(0).notNull(),
      maxAttempts: integer3("max_attempts").default(3).notNull(),
      nextRunAt: timestamp4("next_run_at").defaultNow().notNull(),
      lastError: text4("last_error"),
      payload: text4("payload"),
      idempotencyKey: text4("idempotency_key").unique(),
      decisionId: varchar4("decision_id").references(() => aiDecisions.id, {
        onDelete: "set null"
      }),
      brokerOrderId: text4("broker_order_id"),
      symbol: text4("symbol"),
      result: text4("result"),
      createdAt: timestamp4("created_at").defaultNow().notNull(),
      updatedAt: timestamp4("updated_at").defaultNow().notNull()
    });
    insertWorkItemSchema = createInsertSchema4(workItems).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      attempts: true
    });
    workItemRuns = pgTable4("work_item_runs", {
      id: varchar4("id").primaryKey().default(sql4`gen_random_uuid()`),
      workItemId: varchar4("work_item_id").references(() => workItems.id, { onDelete: "cascade" }).notNull(),
      attemptNumber: integer3("attempt_number").notNull(),
      startedAt: timestamp4("started_at").defaultNow().notNull(),
      completedAt: timestamp4("completed_at"),
      status: text4("status").default("RUNNING").notNull(),
      error: text4("error"),
      durationMs: integer3("duration_ms"),
      createdAt: timestamp4("created_at").defaultNow().notNull()
    });
    insertWorkItemRunSchema = createInsertSchema4(workItemRuns).omit({
      id: true,
      createdAt: true
    });
    aiArenaRuns = pgTable4(
      "ai_arena_runs",
      {
        id: varchar4("id").primaryKey().default(sql4`gen_random_uuid()`),
        traceId: text4("trace_id").notNull(),
        mode: text4("mode").$type().default("debate").notNull(),
        symbols: text4("symbols").array().notNull(),
        agentProfileIds: text4("agent_profile_ids").array().notNull(),
        marketSnapshotHash: text4("market_snapshot_hash"),
        portfolioSnapshotHash: text4("portfolio_snapshot_hash"),
        // Note: strategyVersionId references strategy_versions table but defined without .references() to avoid circular type dependency
        // The foreign key constraint exists at database level via migration
        strategyVersionId: varchar4("strategy_version_id"),
        status: text4("status").$type().default("pending").notNull(),
        startedAt: timestamp4("started_at"),
        completedAt: timestamp4("completed_at"),
        durationMs: integer3("duration_ms"),
        totalTokensUsed: integer3("total_tokens_used").default(0),
        totalCostUsd: numeric3("total_cost_usd").default("0"),
        escalationTriggered: boolean4("escalation_triggered").default(false),
        escalationReason: text4("escalation_reason"),
        consensusReached: boolean4("consensus_reached"),
        finalDecision: text4("final_decision"),
        disagreementRate: numeric3("disagreement_rate"),
        avgConfidence: numeric3("avg_confidence"),
        triggeredBy: text4("triggered_by"),
        outcomeLinked: boolean4("outcome_linked").default(false),
        notes: text4("notes"),
        createdAt: timestamp4("created_at").defaultNow().notNull()
      },
      (table) => [
        index4("ai_arena_runs_trace_id_idx").on(table.traceId),
        index4("ai_arena_runs_status_idx").on(table.status),
        index4("ai_arena_runs_mode_idx").on(table.mode),
        index4("ai_arena_runs_created_at_idx").on(table.createdAt)
      ]
    );
    insertAiArenaRunSchema = createInsertSchema4(aiArenaRuns).omit({
      id: true,
      createdAt: true
    });
    aiArenaAgentDecisions = pgTable4(
      "ai_arena_agent_decisions",
      {
        id: varchar4("id").primaryKey().default(sql4`gen_random_uuid()`),
        arenaRunId: varchar4("arena_run_id").references(() => aiArenaRuns.id, { onDelete: "cascade" }).notNull(),
        // Note: agentProfileId references ai_agent_profiles table but defined without .references() to avoid circular type dependency
        // The foreign key constraint exists at database level via migration
        agentProfileId: varchar4("agent_profile_id"),
        role: text4("role").$type().notNull(),
        action: text4("action").notNull(),
        symbols: text4("symbols").array(),
        confidence: numeric3("confidence"),
        stance: text4("stance"),
        rationale: text4("rationale"),
        keySignals: text4("key_signals"),
        risks: text4("risks"),
        proposedOrder: text4("proposed_order"),
        tokensUsed: integer3("tokens_used"),
        costUsd: numeric3("cost_usd"),
        latencyMs: integer3("latency_ms"),
        modelUsed: text4("model_used"),
        wasEscalation: boolean4("was_escalation").default(false),
        rawOutput: text4("raw_output"),
        toolCallsCount: integer3("tool_calls_count").default(0),
        errorMessage: text4("error_message"),
        createdAt: timestamp4("created_at").defaultNow().notNull()
      },
      (table) => [
        index4("ai_arena_agent_decisions_run_id_idx").on(table.arenaRunId),
        index4("ai_arena_agent_decisions_agent_profile_id_idx").on(
          table.agentProfileId
        ),
        index4("ai_arena_agent_decisions_role_idx").on(table.role)
      ]
    );
    insertAiArenaAgentDecisionSchema = createInsertSchema4(
      aiArenaAgentDecisions
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/orders.ts
import { sql as sql5 } from "drizzle-orm";
import {
  pgTable as pgTable5,
  varchar as varchar5,
  text as text5,
  numeric as numeric4,
  boolean as boolean5,
  timestamp as timestamp5,
  jsonb as jsonb3,
  index as index5
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema5 } from "drizzle-zod";
var orderStatuses, orderTypes, timeInForceValues, assetClasses, brokerAssets, orders, fills, insertBrokerAssetSchema, insertOrderSchema, insertFillSchema;
var init_orders = __esm({
  "shared/schema/orders.ts"() {
    "use strict";
    init_auth();
    init_ai_decisions();
    init_trading();
    init_orchestration();
    orderStatuses = [
      "new",
      "accepted",
      "pending_new",
      "partially_filled",
      "filled",
      "canceled",
      "rejected",
      "expired",
      "replaced",
      "pending_cancel",
      "pending_replace",
      "stopped",
      "suspended",
      "calculated",
      "done_for_day"
    ];
    orderTypes = ["market", "limit", "stop", "stop_limit"];
    timeInForceValues = [
      "day",
      "gtc",
      "opg",
      "cls",
      "ioc",
      "fok"
    ];
    assetClasses = ["us_equity", "crypto"];
    brokerAssets = pgTable5("broker_assets", {
      id: varchar5("id").primaryKey().default(sql5`gen_random_uuid()`),
      alpacaId: text5("alpaca_id").notNull().unique(),
      symbol: text5("symbol").notNull().unique(),
      name: text5("name").notNull(),
      assetClass: text5("asset_class").notNull(),
      exchange: text5("exchange").notNull(),
      status: text5("status").notNull(),
      tradable: boolean5("tradable").default(false).notNull(),
      marginable: boolean5("marginable").default(false).notNull(),
      shortable: boolean5("shortable").default(false).notNull(),
      easyToBorrow: boolean5("easy_to_borrow").default(false).notNull(),
      fractionable: boolean5("fractionable").default(false).notNull(),
      minOrderSize: numeric4("min_order_size"),
      minTradeIncrement: numeric4("min_trade_increment"),
      priceIncrement: numeric4("price_increment"),
      lastSyncedAt: timestamp5("last_synced_at").defaultNow().notNull(),
      createdAt: timestamp5("created_at").defaultNow().notNull(),
      updatedAt: timestamp5("updated_at").defaultNow().notNull()
    });
    orders = pgTable5(
      "orders",
      {
        id: varchar5("id").primaryKey().default(sql5`gen_random_uuid()`),
        userId: varchar5("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        broker: text5("broker").notNull(),
        brokerOrderId: text5("broker_order_id").notNull().unique(),
        clientOrderId: text5("client_order_id").unique(),
        symbol: text5("symbol").notNull(),
        side: text5("side").notNull(),
        type: text5("type").notNull(),
        timeInForce: text5("time_in_force"),
        qty: numeric4("qty"),
        notional: numeric4("notional"),
        limitPrice: numeric4("limit_price"),
        stopPrice: numeric4("stop_price"),
        status: text5("status").notNull(),
        // ADDED: Missing Alpaca order fields for complete tracking
        extendedHours: boolean5("extended_hours").default(false),
        orderClass: text5("order_class"),
        // simple, bracket, oco, oto
        submittedAt: timestamp5("submitted_at").notNull(),
        updatedAt: timestamp5("updated_at").notNull(),
        filledAt: timestamp5("filled_at"),
        expiredAt: timestamp5("expired_at"),
        canceledAt: timestamp5("canceled_at"),
        failedAt: timestamp5("failed_at"),
        filledQty: numeric4("filled_qty"),
        filledAvgPrice: numeric4("filled_avg_price"),
        traceId: text5("trace_id"),
        decisionId: varchar5("decision_id").references(() => aiDecisions.id, {
          onDelete: "set null"
        }),
        tradeIntentId: varchar5("trade_intent_id").references(() => trades.id, {
          onDelete: "set null"
        }),
        workItemId: varchar5("work_item_id").references(() => workItems.id, {
          onDelete: "set null"
        }),
        rawJson: jsonb3("raw_json"),
        createdAt: timestamp5("created_at").defaultNow().notNull()
      },
      (table) => [
        index5("orders_user_id_idx").on(table.userId),
        index5("orders_broker_order_id_idx").on(table.brokerOrderId),
        index5("orders_client_order_id_idx").on(table.clientOrderId),
        index5("orders_symbol_idx").on(table.symbol),
        index5("orders_status_idx").on(table.status),
        index5("orders_trace_id_idx").on(table.traceId),
        index5("orders_decision_id_idx").on(table.decisionId)
      ]
    );
    fills = pgTable5(
      "fills",
      {
        id: varchar5("id").primaryKey().default(sql5`gen_random_uuid()`),
        broker: text5("broker").notNull(),
        brokerOrderId: text5("broker_order_id").notNull(),
        brokerFillId: text5("broker_fill_id").unique(),
        orderId: varchar5("order_id").references(() => orders.id, {
          onDelete: "cascade"
        }),
        symbol: text5("symbol").notNull(),
        side: text5("side").notNull(),
        qty: numeric4("qty").notNull(),
        price: numeric4("price").notNull(),
        occurredAt: timestamp5("occurred_at").notNull(),
        traceId: text5("trace_id"),
        rawJson: jsonb3("raw_json"),
        createdAt: timestamp5("created_at").defaultNow().notNull()
      },
      (table) => [
        index5("fills_broker_order_id_idx").on(table.brokerOrderId),
        index5("fills_order_id_idx").on(table.orderId),
        index5("fills_symbol_idx").on(table.symbol),
        index5("fills_trace_id_idx").on(table.traceId)
      ]
    );
    insertBrokerAssetSchema = createInsertSchema5(brokerAssets).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertOrderSchema = createInsertSchema5(orders).omit({
      id: true,
      createdAt: true
    });
    insertFillSchema = createInsertSchema5(fills).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/debate-arena.ts
import { sql as sql6 } from "drizzle-orm";
import {
  pgTable as pgTable6,
  text as text6,
  varchar as varchar6,
  timestamp as timestamp6,
  numeric as numeric5,
  integer as integer4,
  jsonb as jsonb4,
  index as index6
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema6 } from "drizzle-zod";
var debateSessions, debateMessages, debateConsensus, aiAgentProfiles, aiOutcomeLinks, insertDebateSessionSchema, insertDebateMessageSchema, insertDebateConsensusSchema, insertAiAgentProfileSchema, insertAiOutcomeLinkSchema;
var init_debate_arena = __esm({
  "shared/schema/debate-arena.ts"() {
    "use strict";
    init_ai_decisions();
    debateSessions = pgTable6(
      "debate_sessions",
      {
        id: varchar6("id").primaryKey().default(sql6`gen_random_uuid()`),
        traceId: text6("trace_id").notNull(),
        strategyVersionId: varchar6("strategy_version_id"),
        symbols: text6("symbols").array().notNull(),
        status: text6("status").$type().default("pending").notNull(),
        triggeredBy: text6("triggered_by"),
        marketContext: jsonb4("market_context"),
        config: jsonb4("config"),
        startedAt: timestamp6("started_at"),
        completedAt: timestamp6("completed_at"),
        durationMs: integer4("duration_ms"),
        totalCost: numeric5("total_cost"),
        createdAt: timestamp6("created_at").defaultNow().notNull()
      },
      (table) => [
        index6("debate_sessions_trace_id_idx").on(table.traceId),
        index6("debate_sessions_status_idx").on(table.status),
        index6("debate_sessions_created_at_idx").on(table.createdAt)
      ]
    );
    debateMessages = pgTable6(
      "debate_messages",
      {
        id: varchar6("id").primaryKey().default(sql6`gen_random_uuid()`),
        sessionId: varchar6("session_id").references(() => debateSessions.id, { onDelete: "cascade" }).notNull(),
        role: text6("role").$type().notNull(),
        stance: text6("stance"),
        confidence: numeric5("confidence"),
        keySignals: jsonb4("key_signals"),
        risks: jsonb4("risks"),
        invalidationPoints: jsonb4("invalidation_points"),
        proposedAction: text6("proposed_action"),
        proposedOrder: jsonb4("proposed_order"),
        evidenceRefs: jsonb4("evidence_refs"),
        rawOutput: text6("raw_output"),
        provider: text6("provider"),
        model: text6("model"),
        tokensUsed: integer4("tokens_used"),
        estimatedCost: numeric5("estimated_cost"),
        latencyMs: integer4("latency_ms"),
        createdAt: timestamp6("created_at").defaultNow().notNull()
      },
      (table) => [
        index6("debate_messages_session_id_idx").on(table.sessionId),
        index6("debate_messages_role_idx").on(table.role)
      ]
    );
    debateConsensus = pgTable6(
      "debate_consensus",
      {
        id: varchar6("id").primaryKey().default(sql6`gen_random_uuid()`),
        sessionId: varchar6("session_id").references(() => debateSessions.id, { onDelete: "cascade" }).notNull().unique(),
        decision: text6("decision").notNull(),
        orderIntent: jsonb4("order_intent"),
        reasonsSummary: text6("reasons_summary"),
        riskChecks: jsonb4("risk_checks"),
        confidence: numeric5("confidence"),
        dissent: jsonb4("dissent"),
        // Note: workItemId references workItems table - foreign key defined at database level to avoid circular dependency
        workItemId: varchar6("work_item_id"),
        brokerOrderId: text6("broker_order_id"),
        createdAt: timestamp6("created_at").defaultNow().notNull()
      },
      (table) => [
        index6("debate_consensus_session_id_idx").on(table.sessionId),
        index6("debate_consensus_work_item_id_idx").on(table.workItemId)
      ]
    );
    aiAgentProfiles = pgTable6(
      "ai_agent_profiles",
      {
        id: varchar6("id").primaryKey().default(sql6`gen_random_uuid()`),
        name: text6("name").notNull().unique(),
        description: text6("description"),
        provider: text6("provider").$type().notNull(),
        model: text6("model").notNull(),
        role: text6("role").$type().notNull(),
        mode: text6("mode").$type().default("cheap_first").notNull(),
        temperature: numeric5("temperature").default("0.7"),
        maxTokens: integer4("max_tokens").default(2e3),
        promptTemplateId: varchar6("prompt_template_id"),
        toolPolicy: jsonb4("tool_policy"),
        budgetLimitPerDay: numeric5("budget_limit_per_day"),
        budgetLimitPerRun: numeric5("budget_limit_per_run"),
        priority: integer4("priority").default(0),
        status: text6("status").$type().default("active").notNull(),
        totalCalls: integer4("total_calls").default(0).notNull(),
        totalTokens: integer4("total_tokens").default(0).notNull(),
        totalCostUsd: numeric5("total_cost_usd").default("0").notNull(),
        avgLatencyMs: numeric5("avg_latency_ms"),
        successRate: numeric5("success_rate"),
        createdAt: timestamp6("created_at").defaultNow().notNull(),
        updatedAt: timestamp6("updated_at").defaultNow().notNull()
      },
      (table) => [
        index6("ai_agent_profiles_status_idx").on(table.status),
        index6("ai_agent_profiles_role_idx").on(table.role),
        index6("ai_agent_profiles_mode_idx").on(table.mode)
      ]
    );
    aiOutcomeLinks = pgTable6(
      "ai_outcome_links",
      {
        id: varchar6("id").primaryKey().default(sql6`gen_random_uuid()`),
        consensusId: varchar6("consensus_id").references(() => debateConsensus.id, {
          onDelete: "set null"
        }),
        debateSessionId: varchar6("debate_session_id").references(
          () => debateSessions.id,
          { onDelete: "set null" }
        ),
        decisionId: varchar6("decision_id").references(() => aiDecisions.id, {
          onDelete: "set null"
        }),
        // Note: workItemId references workItems table - foreign key defined at database level to avoid circular dependency
        workItemId: varchar6("work_item_id"),
        brokerOrderId: varchar6("broker_order_id"),
        symbol: text6("symbol").notNull(),
        side: text6("side").notNull(),
        intendedQty: numeric5("intended_qty"),
        intendedNotional: numeric5("intended_notional"),
        filledQty: numeric5("filled_qty"),
        filledAvgPrice: numeric5("filled_avg_price"),
        fillCount: integer4("fill_count").default(0),
        status: text6("status").$type().default("pending").notNull(),
        pnlRealized: numeric5("pnl_realized"),
        pnlUnrealized: numeric5("pnl_unrealized"),
        entryPrice: numeric5("entry_price"),
        exitPrice: numeric5("exit_price"),
        holdDurationMs: integer4("hold_duration_ms"),
        outcome: text6("outcome").$type().default("unknown"),
        llmCostUsd: numeric5("llm_cost_usd"),
        traceId: text6("trace_id"),
        createdAt: timestamp6("created_at").defaultNow().notNull(),
        closedAt: timestamp6("closed_at")
      },
      (table) => [
        index6("ai_outcome_links_consensus_id_idx").on(table.consensusId),
        index6("ai_outcome_links_debate_session_id_idx").on(table.debateSessionId),
        index6("ai_outcome_links_work_item_id_idx").on(table.workItemId),
        index6("ai_outcome_links_symbol_idx").on(table.symbol),
        index6("ai_outcome_links_status_idx").on(table.status),
        index6("ai_outcome_links_outcome_idx").on(table.outcome),
        index6("ai_outcome_links_created_at_idx").on(table.createdAt)
      ]
    );
    insertDebateSessionSchema = createInsertSchema6(
      debateSessions
    ).omit({
      id: true,
      createdAt: true
    });
    insertDebateMessageSchema = createInsertSchema6(
      debateMessages
    ).omit({
      id: true,
      createdAt: true
    });
    insertDebateConsensusSchema = createInsertSchema6(
      debateConsensus
    ).omit({
      id: true,
      createdAt: true
    });
    insertAiAgentProfileSchema = createInsertSchema6(
      aiAgentProfiles
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      totalCalls: true,
      totalTokens: true,
      totalCostUsd: true
    });
    insertAiOutcomeLinkSchema = createInsertSchema6(
      aiOutcomeLinks
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/market-data.ts
import { sql as sql7 } from "drizzle-orm";
import {
  pgTable as pgTable7,
  varchar as varchar7,
  text as text7,
  timestamp as timestamp7,
  numeric as numeric6,
  integer as integer5,
  jsonb as jsonb5,
  index as index7
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema7 } from "drizzle-zod";
var macroIndicators, externalApiCacheEntries, externalApiUsageCounters, valyuRetrievalCounters, insertMacroIndicatorsSchema, insertExternalApiCacheEntrySchema, insertExternalApiUsageCounterSchema, insertValyuRetrievalCounterSchema;
var init_market_data = __esm({
  "shared/schema/market-data.ts"() {
    "use strict";
    macroIndicators = pgTable7(
      "macro_indicators",
      {
        id: varchar7("id").primaryKey().default(sql7`gen_random_uuid()`),
        indicatorId: text7("indicator_id").notNull().unique(),
        name: text7("name").notNull(),
        category: text7("category").notNull(),
        latestValue: numeric6("latest_value"),
        previousValue: numeric6("previous_value"),
        changePercent: numeric6("change_percent"),
        frequency: text7("frequency"),
        lastUpdatedAt: timestamp7("last_updated_at").defaultNow().notNull(),
        source: text7("source").notNull().default("FRED"),
        rawJson: jsonb5("raw_json")
      },
      (table) => [
        index7("macro_indicators_category_idx").on(table.category),
        index7("macro_indicators_indicator_id_idx").on(table.indicatorId)
      ]
    );
    externalApiCacheEntries = pgTable7("external_api_cache_entries", {
      id: varchar7("id").primaryKey().default(sql7`gen_random_uuid()`),
      provider: text7("provider").notNull(),
      cacheKey: text7("cache_key").notNull(),
      responseJson: text7("response_json").notNull(),
      expiresAt: timestamp7("expires_at").notNull(),
      staleUntilAt: timestamp7("stale_until_at").notNull(),
      createdAt: timestamp7("created_at").defaultNow().notNull(),
      updatedAt: timestamp7("updated_at").defaultNow().notNull(),
      hitCount: integer5("hit_count").default(0).notNull(),
      lastAccessedAt: timestamp7("last_accessed_at").defaultNow().notNull()
    });
    externalApiUsageCounters = pgTable7("external_api_usage_counters", {
      id: varchar7("id").primaryKey().default(sql7`gen_random_uuid()`),
      provider: text7("provider").notNull(),
      windowType: text7("window_type").notNull(),
      windowStart: timestamp7("window_start").notNull(),
      windowEnd: timestamp7("window_end").notNull(),
      requestCount: integer5("request_count").default(0).notNull(),
      tokenCount: integer5("token_count").default(0),
      errorCount: integer5("error_count").default(0).notNull(),
      rateLimitHits: integer5("rate_limit_hits").default(0).notNull(),
      cacheHits: integer5("cache_hits").default(0).notNull(),
      cacheMisses: integer5("cache_misses").default(0).notNull(),
      avgLatencyMs: numeric6("avg_latency_ms"),
      createdAt: timestamp7("created_at").defaultNow().notNull(),
      updatedAt: timestamp7("updated_at").defaultNow().notNull()
    });
    valyuRetrievalCounters = pgTable7("valyu_retrieval_counters", {
      id: varchar7("id").primaryKey().default(sql7`gen_random_uuid()`),
      sourceTier: text7("source_tier").notNull(),
      monthKey: text7("month_key").notNull(),
      retrievalCount: integer5("retrieval_count").default(0).notNull(),
      lastUpdated: timestamp7("last_updated").defaultNow().notNull()
    });
    insertMacroIndicatorsSchema = createInsertSchema7(
      macroIndicators
    ).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertExternalApiCacheEntrySchema = createInsertSchema7(
      externalApiCacheEntries
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      hitCount: true,
      lastAccessedAt: true
    });
    insertExternalApiUsageCounterSchema = createInsertSchema7(
      externalApiUsageCounters
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertValyuRetrievalCounterSchema = createInsertSchema7(
      valyuRetrievalCounters
    ).omit({
      id: true,
      lastUpdated: true
    });
  }
});

// shared/schema/analysis.ts
import { sql as sql8 } from "drizzle-orm";
import {
  pgTable as pgTable8,
  varchar as varchar8,
  text as text8,
  timestamp as timestamp8,
  numeric as numeric7,
  jsonb as jsonb6,
  integer as integer6,
  boolean as boolean7,
  index as index8,
  unique as unique3
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema8 } from "drizzle-zod";
var dataSourceAnalysis, shortInterestAnalysis, insiderActivityAnalysis, macroAnalysis, analysisFeedback, insertDataSourceAnalysisSchema, insertShortInterestAnalysisSchema, insertInsiderActivityAnalysisSchema, insertMacroAnalysisSchema, insertAnalysisFeedbackSchema;
var init_analysis = __esm({
  "shared/schema/analysis.ts"() {
    "use strict";
    init_ai_decisions();
    init_ai_decisions();
    dataSourceAnalysis = pgTable8(
      "data_source_analysis",
      {
        id: varchar8("id").primaryKey().default(sql8`gen_random_uuid()`),
        decisionId: varchar8("decision_id").references(() => aiDecisions.id, {
          onDelete: "cascade"
        }),
        symbol: text8("symbol").notNull(),
        source: text8("source").notNull(),
        // finra, sec-edgar, finnhub, fred, frankfurter, etc.
        analysisType: text8("analysis_type").notNull(),
        // short_interest, insider_activity, fundamentals, macro, forex
        dataJson: jsonb6("data_json").notNull(),
        // Raw analysis data
        score: numeric7("score"),
        // Normalized score (-1 to 1 or 0 to 100)
        signal: text8("signal"),
        // bullish, bearish, neutral
        confidence: numeric7("confidence"),
        // 0 to 1
        reliability: numeric7("reliability"),
        // Source reliability weight
        createdAt: timestamp8("created_at").defaultNow().notNull()
      },
      (table) => [
        index8("data_source_analysis_decision_id_idx").on(table.decisionId),
        index8("data_source_analysis_symbol_idx").on(table.symbol),
        index8("data_source_analysis_source_idx").on(table.source),
        index8("data_source_analysis_created_at_idx").on(table.createdAt)
      ]
    );
    shortInterestAnalysis = pgTable8(
      "short_interest_analysis",
      {
        id: varchar8("id").primaryKey().default(sql8`gen_random_uuid()`),
        symbol: text8("symbol").notNull(),
        shortRatio: numeric7("short_ratio").notNull(),
        // Short volume / Total volume
        shortVolume: numeric7("short_volume"),
        totalVolume: numeric7("total_volume"),
        daysToCover: numeric7("days_to_cover"),
        shortRatioTrend: text8("short_ratio_trend"),
        // increasing, decreasing, stable
        squeezePotential: text8("squeeze_potential"),
        // high, medium, low
        averageShortRatio: numeric7("average_short_ratio"),
        // 20-day average
        analysisDate: timestamp8("analysis_date").notNull(),
        createdAt: timestamp8("created_at").defaultNow().notNull()
      },
      (table) => [
        index8("short_interest_symbol_idx").on(table.symbol),
        index8("short_interest_date_idx").on(table.analysisDate),
        unique3("short_interest_symbol_date_unique").on(
          table.symbol,
          table.analysisDate
        )
      ]
    );
    insiderActivityAnalysis = pgTable8(
      "insider_activity_analysis",
      {
        id: varchar8("id").primaryKey().default(sql8`gen_random_uuid()`),
        symbol: text8("symbol").notNull(),
        totalBuys: numeric7("total_buys").default("0"),
        totalSells: numeric7("total_sells").default("0"),
        netActivity: numeric7("net_activity").default("0"),
        // Buys - Sells (shares)
        netValue: numeric7("net_value").default("0"),
        // Dollar value
        buyToSellRatio: numeric7("buy_to_sell_ratio"),
        sentiment: text8("sentiment"),
        // bullish, bearish, neutral
        recentTransactionsJson: jsonb6("recent_transactions_json"),
        // Last 10 transactions
        analysisWindowDays: integer6("analysis_window_days").default(90),
        analysisDate: timestamp8("analysis_date").notNull(),
        createdAt: timestamp8("created_at").defaultNow().notNull()
      },
      (table) => [
        index8("insider_activity_symbol_idx").on(table.symbol),
        index8("insider_activity_date_idx").on(table.analysisDate),
        unique3("insider_activity_symbol_date_unique").on(
          table.symbol,
          table.analysisDate
        )
      ]
    );
    macroAnalysis = pgTable8(
      "macro_analysis",
      {
        id: varchar8("id").primaryKey().default(sql8`gen_random_uuid()`),
        vix: numeric7("vix"),
        fedFundsRate: numeric7("fed_funds_rate"),
        yieldCurve: numeric7("yield_curve"),
        // 10Y-2Y spread
        inflation: numeric7("inflation"),
        // CPI
        unemployment: numeric7("unemployment"),
        marketRegime: text8("market_regime"),
        // risk_on, risk_off, neutral
        indicatorsJson: jsonb6("indicators_json"),
        // All FRED indicators
        analysisDate: timestamp8("analysis_date").notNull(),
        createdAt: timestamp8("created_at").defaultNow().notNull()
      },
      (table) => [
        index8("macro_analysis_date_idx").on(table.analysisDate),
        unique3("macro_analysis_date_unique").on(table.analysisDate)
      ]
    );
    analysisFeedback = pgTable8(
      "analysis_feedback",
      {
        id: varchar8("id").primaryKey().default(sql8`gen_random_uuid()`),
        dataSourceAnalysisId: varchar8("data_source_analysis_id").references(
          () => dataSourceAnalysis.id,
          { onDelete: "cascade" }
        ),
        tradeOutcomeId: varchar8("trade_outcome_id").references(
          () => aiTradeOutcomes.id,
          { onDelete: "cascade" }
        ),
        symbol: text8("symbol").notNull(),
        source: text8("source").notNull(),
        signalAtEntry: text8("signal_at_entry"),
        // The signal when trade was entered
        confidenceAtEntry: numeric7("confidence_at_entry"),
        tradeResult: text8("trade_result"),
        // win, loss
        pnlPercent: numeric7("pnl_percent"),
        signalAccuracy: boolean7("signal_accuracy"),
        // Did signal predict correctly?
        holdingTimeMs: integer6("holding_time_ms"),
        createdAt: timestamp8("created_at").defaultNow().notNull()
      },
      (table) => [
        index8("analysis_feedback_source_idx").on(table.source),
        index8("analysis_feedback_symbol_idx").on(table.symbol),
        index8("analysis_feedback_created_at_idx").on(table.createdAt)
      ]
    );
    insertDataSourceAnalysisSchema = createInsertSchema8(
      dataSourceAnalysis
    ).omit({
      id: true,
      createdAt: true
    });
    insertShortInterestAnalysisSchema = createInsertSchema8(
      shortInterestAnalysis
    ).omit({
      id: true,
      createdAt: true
    });
    insertInsiderActivityAnalysisSchema = createInsertSchema8(
      insiderActivityAnalysis
    ).omit({
      id: true,
      createdAt: true
    });
    insertMacroAnalysisSchema = createInsertSchema8(macroAnalysis).omit(
      {
        id: true,
        createdAt: true
      }
    );
    insertAnalysisFeedbackSchema = createInsertSchema8(
      analysisFeedback
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/universe.ts
import { sql as sql9 } from "drizzle-orm";
import {
  pgTable as pgTable9,
  varchar as varchar9,
  text as text9,
  timestamp as timestamp9,
  numeric as numeric8,
  boolean as boolean8,
  integer as integer7,
  jsonb as jsonb7,
  index as index9,
  unique as unique4
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema9 } from "drizzle-zod";
var universeAssets, universeLiquidityMetrics, universeFundamentals, universeTechnicals, assetClassifications, universeCandidates, insertUniverseAssetSchema, insertUniverseLiquiditySchema, insertUniverseFundamentalsSchema, insertUniverseTechnicalsSchema, insertAssetClassificationSchema, insertUniverseCandidateSchema;
var init_universe = __esm({
  "shared/schema/universe.ts"() {
    "use strict";
    init_auth();
    universeAssets = pgTable9(
      "universe_assets",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull().unique(),
        name: text9("name").notNull(),
        exchange: text9("exchange").notNull(),
        assetClass: text9("asset_class").notNull(),
        status: text9("status").notNull(),
        tradable: boolean8("tradable").default(false).notNull(),
        marginable: boolean8("marginable").default(false).notNull(),
        shortable: boolean8("shortable").default(false).notNull(),
        fractionable: boolean8("fractionable").default(false).notNull(),
        easyToBorrow: boolean8("easy_to_borrow").default(false).notNull(),
        isOtc: boolean8("is_otc").default(false).notNull(),
        isSpac: boolean8("is_spac").default(false).notNull(),
        isPennyStock: boolean8("is_penny_stock").default(false).notNull(),
        excluded: boolean8("excluded").default(false).notNull(),
        excludeReason: text9("exclude_reason"),
        lastRefreshedAt: timestamp9("last_refreshed_at").defaultNow().notNull(),
        rawJson: jsonb7("raw_json")
      },
      (table) => [
        index9("universe_assets_symbol_idx").on(table.symbol),
        index9("universe_assets_tradable_idx").on(table.tradable),
        index9("universe_assets_exchange_idx").on(table.exchange)
      ]
    );
    universeLiquidityMetrics = pgTable9(
      "universe_liquidity_metrics",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull().unique(),
        avgDailyVolumeShares: numeric8("avg_daily_volume_shares"),
        avgDailyTradedValueUsd: numeric8("avg_daily_traded_value_usd"),
        avgBidAskSpreadPct: numeric8("avg_bid_ask_spread_pct"),
        latestPrice: numeric8("latest_price"),
        priceDataDays: integer7("price_data_days").default(30),
        liquidityTier: text9("liquidity_tier"),
        source: text9("source").notNull(),
        lastUpdatedAt: timestamp9("last_updated_at").defaultNow().notNull(),
        rawJson: jsonb7("raw_json")
      },
      (table) => [
        index9("universe_liquidity_symbol_idx").on(table.symbol),
        index9("universe_liquidity_tier_idx").on(table.liquidityTier)
      ]
    );
    universeFundamentals = pgTable9(
      "universe_fundamentals",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull().unique(),
        marketCap: numeric8("market_cap"),
        revenueTtm: numeric8("revenue_ttm"),
        revenueCagr3y: numeric8("revenue_cagr_3y"),
        grossMargin: numeric8("gross_margin"),
        operatingMargin: numeric8("operating_margin"),
        netMargin: numeric8("net_margin"),
        freeCashFlowMargin: numeric8("free_cash_flow_margin"),
        debtToEquity: numeric8("debt_to_equity"),
        sharesDilution1y: numeric8("shares_dilution_1y"),
        peRatio: numeric8("pe_ratio"),
        priceToBook: numeric8("price_to_book"),
        beta: numeric8("beta"),
        week52High: numeric8("week_52_high"),
        week52Low: numeric8("week_52_low"),
        dividendYield: numeric8("dividend_yield"),
        sector: text9("sector"),
        industry: text9("industry"),
        source: text9("source").notNull(),
        lastUpdatedAt: timestamp9("last_updated_at").defaultNow().notNull(),
        rawJson: jsonb7("raw_json")
      },
      (table) => [
        index9("universe_fundamentals_symbol_idx").on(table.symbol),
        index9("universe_fundamentals_sector_idx").on(table.sector)
      ]
    );
    universeTechnicals = pgTable9(
      "universe_technicals",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull(),
        date: timestamp9("date").notNull(),
        open: numeric8("open"),
        high: numeric8("high"),
        low: numeric8("low"),
        close: numeric8("close"),
        volume: numeric8("volume"),
        vwap: numeric8("vwap"),
        sma20: numeric8("sma_20"),
        sma50: numeric8("sma_50"),
        sma200: numeric8("sma_200"),
        ema12: numeric8("ema_12"),
        ema26: numeric8("ema_26"),
        rsi14: numeric8("rsi_14"),
        macd: numeric8("macd"),
        macdSignal: numeric8("macd_signal"),
        macdHistogram: numeric8("macd_histogram"),
        atr14: numeric8("atr_14"),
        bollingerUpper: numeric8("bollinger_upper"),
        bollingerLower: numeric8("bollinger_lower"),
        adx14: numeric8("adx_14"),
        plusDi: numeric8("plus_di"),
        minusDi: numeric8("minus_di"),
        pivotPoint: numeric8("pivot_point"),
        resistance1: numeric8("resistance_1"),
        support1: numeric8("support_1"),
        source: text9("source").notNull(),
        lastUpdatedAt: timestamp9("last_updated_at").defaultNow().notNull()
      },
      (table) => [
        index9("universe_technicals_symbol_idx").on(table.symbol),
        index9("universe_technicals_date_idx").on(table.date),
        unique4("universe_technicals_symbol_date_unique").on(
          table.symbol,
          table.date
        )
      ]
    );
    assetClassifications = pgTable9(
      "asset_classifications",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull().unique(),
        assetClass: text9("asset_class"),
        marketCapTier: text9("market_cap_tier"),
        liquidityTier: text9("liquidity_tier"),
        volatilityTier: text9("volatility_tier"),
        trendStrength: text9("trend_strength"),
        momentumScore: numeric8("momentum_score"),
        valueScore: numeric8("value_score"),
        qualityScore: numeric8("quality_score"),
        lastUpdatedAt: timestamp9("last_updated_at").defaultNow().notNull(),
        source: text9("source").notNull(),
        rawJson: jsonb7("raw_json")
      },
      (table) => [
        index9("asset_classifications_symbol_idx").on(table.symbol),
        index9("asset_classifications_asset_class_idx").on(table.assetClass),
        index9("asset_classifications_market_cap_tier_idx").on(table.marketCapTier)
      ]
    );
    universeCandidates = pgTable9(
      "universe_candidates",
      {
        id: varchar9("id").primaryKey().default(sql9`gen_random_uuid()`),
        symbol: text9("symbol").notNull().unique(),
        tier: text9("tier").notNull(),
        liquidityScore: numeric8("liquidity_score"),
        growthScore: numeric8("growth_score"),
        qualityScore: numeric8("quality_score"),
        finalScore: numeric8("final_score"),
        themeTags: jsonb7("theme_tags"),
        rationale: text9("rationale"),
        status: text9("status").notNull().default("NEW"),
        approvedBy: varchar9("approved_by").references(() => users.id, {
          onDelete: "set null"
        }),
        approvedAt: timestamp9("approved_at"),
        traceId: text9("trace_id"),
        createdAt: timestamp9("created_at").defaultNow().notNull(),
        updatedAt: timestamp9("updated_at").defaultNow().notNull()
      },
      (table) => [
        index9("universe_candidates_symbol_idx").on(table.symbol),
        index9("universe_candidates_status_idx").on(table.status),
        index9("universe_candidates_tier_idx").on(table.tier),
        index9("universe_candidates_final_score_idx").on(table.finalScore)
      ]
    );
    insertUniverseAssetSchema = createInsertSchema9(
      universeAssets
    ).omit({
      id: true,
      lastRefreshedAt: true
    });
    insertUniverseLiquiditySchema = createInsertSchema9(
      universeLiquidityMetrics
    ).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseFundamentalsSchema = createInsertSchema9(
      universeFundamentals
    ).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseTechnicalsSchema = createInsertSchema9(
      universeTechnicals
    ).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertAssetClassificationSchema = createInsertSchema9(
      assetClassifications
    ).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseCandidateSchema = createInsertSchema9(
      universeCandidates
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
  }
});

// shared/schema/allocation.ts
import { sql as sql10 } from "drizzle-orm";
import {
  pgTable as pgTable10,
  varchar as varchar10,
  text as text10,
  timestamp as timestamp10,
  numeric as numeric9,
  boolean as boolean9,
  integer as integer8,
  jsonb as jsonb8,
  index as index10
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema10 } from "drizzle-zod";
var allocationPolicies, rebalanceRuns, insertAllocationPolicySchema, insertRebalanceRunSchema;
var init_allocation = __esm({
  "shared/schema/allocation.ts"() {
    "use strict";
    init_auth();
    allocationPolicies = pgTable10(
      "allocation_policies",
      {
        id: varchar10("id").primaryKey().default(sql10`gen_random_uuid()`),
        name: text10("name").notNull().unique(),
        description: text10("description"),
        isActive: boolean9("is_active").default(false).notNull(),
        maxPositionWeightPct: numeric9("max_position_weight_pct").default("8"),
        maxSectorWeightPct: numeric9("max_sector_weight_pct").default("25"),
        minLiquidityTier: text10("min_liquidity_tier").default("B"),
        profitTakingThresholdPct: numeric9("profit_taking_threshold_pct").default(
          "20"
        ),
        overweightThresholdPct: numeric9("overweight_threshold_pct").default("50"),
        rotationTopN: integer8("rotation_top_n").default(10),
        rebalanceFrequency: text10("rebalance_frequency").default("daily"),
        createdBy: varchar10("created_by").references(() => users.id, {
          onDelete: "set null"
        }),
        createdAt: timestamp10("created_at").defaultNow().notNull(),
        updatedAt: timestamp10("updated_at").defaultNow().notNull()
      },
      (table) => [index10("allocation_policies_active_idx").on(table.isActive)]
    );
    rebalanceRuns = pgTable10(
      "rebalance_runs",
      {
        id: varchar10("id").primaryKey().default(sql10`gen_random_uuid()`),
        policyId: varchar10("policy_id").references(() => allocationPolicies.id, {
          onDelete: "set null"
        }),
        traceId: text10("trace_id").notNull(),
        status: text10("status").notNull().default("pending"),
        triggerType: text10("trigger_type").notNull(),
        inputSnapshot: jsonb8("input_snapshot"),
        orderIntents: jsonb8("order_intents"),
        executedOrders: jsonb8("executed_orders"),
        rationale: text10("rationale"),
        startedAt: timestamp10("started_at").defaultNow().notNull(),
        completedAt: timestamp10("completed_at")
      },
      (table) => [
        index10("rebalance_runs_trace_id_idx").on(table.traceId),
        index10("rebalance_runs_status_idx").on(table.status)
      ]
    );
    insertAllocationPolicySchema = createInsertSchema10(
      allocationPolicies
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRebalanceRunSchema = createInsertSchema10(rebalanceRuns).omit({
      id: true,
      startedAt: true
    });
  }
});

// shared/schema/backtest.ts
import { sql as sql11 } from "drizzle-orm";
import {
  pgTable as pgTable11,
  text as text11,
  varchar as varchar11,
  timestamp as timestamp11,
  numeric as numeric10,
  integer as integer9,
  jsonb as jsonb9,
  index as index11
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema11 } from "drizzle-zod";
var backtestStatuses, executionPriceRules, backtestRuns, backtestTradeEvents, backtestEquityCurve, insertBacktestRunSchema, insertBacktestTradeEventSchema, insertBacktestEquityCurveSchema;
var init_backtest = __esm({
  "shared/schema/backtest.ts"() {
    "use strict";
    init_trading();
    backtestStatuses = [
      "QUEUED",
      "RUNNING",
      "DONE",
      "FAILED"
    ];
    executionPriceRules = ["NEXT_OPEN", "NEXT_CLOSE"];
    backtestRuns = pgTable11(
      "backtest_runs",
      {
        id: varchar11("id").primaryKey().default(sql11`gen_random_uuid()`),
        createdAt: timestamp11("created_at").defaultNow().notNull(),
        updatedAt: timestamp11("updated_at").defaultNow().notNull(),
        status: text11("status").default("QUEUED").notNull(),
        strategyId: varchar11("strategy_id").references(() => strategies.id, {
          onDelete: "set null"
        }),
        strategyConfigHash: text11("strategy_config_hash").notNull(),
        strategyConfig: jsonb9("strategy_config").notNull(),
        universe: text11("universe").array().notNull(),
        broker: text11("broker").notNull(),
        timeframe: text11("timeframe").notNull(),
        startDate: text11("start_date").notNull(),
        endDate: text11("end_date").notNull(),
        initialCash: numeric10("initial_cash").notNull(),
        feesModel: jsonb9("fees_model").notNull(),
        slippageModel: jsonb9("slippage_model").notNull(),
        executionPriceRule: text11("execution_price_rule").notNull(),
        dataSource: text11("data_source").notNull(),
        provenance: jsonb9("provenance"),
        resultsSummary: jsonb9("results_summary"),
        errorMessage: text11("error_message"),
        runtimeMs: integer9("runtime_ms")
      },
      (table) => [
        index11("backtest_runs_status_idx").on(table.status),
        index11("backtest_runs_strategy_id_idx").on(table.strategyId),
        index11("backtest_runs_created_at_idx").on(table.createdAt)
      ]
    );
    backtestTradeEvents = pgTable11(
      "backtest_trade_events",
      {
        id: varchar11("id").primaryKey().default(sql11`gen_random_uuid()`),
        runId: varchar11("run_id").references(() => backtestRuns.id, { onDelete: "cascade" }).notNull(),
        ts: timestamp11("ts").notNull(),
        symbol: text11("symbol").notNull(),
        side: text11("side").notNull(),
        qty: numeric10("qty").notNull(),
        price: numeric10("price").notNull(),
        reason: text11("reason").notNull(),
        orderType: text11("order_type").notNull(),
        fees: numeric10("fees").notNull(),
        slippage: numeric10("slippage").notNull(),
        positionAfter: numeric10("position_after").notNull(),
        cashAfter: numeric10("cash_after").notNull()
      },
      (table) => [
        index11("backtest_trade_events_run_id_idx").on(table.runId),
        index11("backtest_trade_events_ts_idx").on(table.ts),
        index11("backtest_trade_events_symbol_idx").on(table.symbol)
      ]
    );
    backtestEquityCurve = pgTable11(
      "backtest_equity_curve",
      {
        id: varchar11("id").primaryKey().default(sql11`gen_random_uuid()`),
        runId: varchar11("run_id").references(() => backtestRuns.id, { onDelete: "cascade" }).notNull(),
        ts: timestamp11("ts").notNull(),
        equity: numeric10("equity").notNull(),
        cash: numeric10("cash").notNull(),
        exposure: numeric10("exposure").notNull()
      },
      (table) => [
        index11("backtest_equity_curve_run_id_idx").on(table.runId),
        index11("backtest_equity_curve_ts_idx").on(table.ts)
      ]
    );
    insertBacktestRunSchema = createInsertSchema11(backtestRuns).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBacktestTradeEventSchema = createInsertSchema11(
      backtestTradeEvents
    ).omit({
      id: true
    });
    insertBacktestEquityCurveSchema = createInsertSchema11(
      backtestEquityCurve
    ).omit({
      id: true
    });
  }
});

// shared/schema/competition.ts
import { sql as sql12 } from "drizzle-orm";
import {
  pgTable as pgTable12,
  varchar as varchar12,
  text as text12,
  timestamp as timestamp12,
  numeric as numeric11,
  boolean as boolean10,
  integer as integer10,
  jsonb as jsonb10,
  index as index12
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema12 } from "drizzle-zod";
var traderProfiles, competitionRuns, competitionScores, insertTraderProfileSchema, insertCompetitionRunSchema, insertCompetitionScoreSchema;
var init_competition = __esm({
  "shared/schema/competition.ts"() {
    "use strict";
    traderProfiles = pgTable12(
      "trader_profiles",
      {
        id: varchar12("id").primaryKey().default(sql12`gen_random_uuid()`),
        name: text12("name").notNull().unique(),
        description: text12("description"),
        strategyVersionId: varchar12("strategy_version_id"),
        modelProfile: jsonb10("model_profile"),
        riskPreset: jsonb10("risk_preset"),
        universeFilter: jsonb10("universe_filter"),
        isPromoted: boolean10("is_promoted").default(false).notNull(),
        status: text12("status").$type().default("active").notNull(),
        createdAt: timestamp12("created_at").defaultNow().notNull(),
        updatedAt: timestamp12("updated_at").defaultNow().notNull()
      },
      (table) => [
        index12("trader_profiles_status_idx").on(table.status),
        index12("trader_profiles_promoted_idx").on(table.isPromoted)
      ]
    );
    competitionRuns = pgTable12(
      "competition_runs",
      {
        id: varchar12("id").primaryKey().default(sql12`gen_random_uuid()`),
        name: text12("name").notNull(),
        traceId: text12("trace_id").notNull(),
        mode: text12("mode").$type().notNull(),
        traderIds: text12("trader_ids").array().notNull(),
        universeSymbols: text12("universe_symbols").array(),
        startedAt: timestamp12("started_at").defaultNow().notNull(),
        endedAt: timestamp12("ended_at"),
        durationMinutes: integer10("duration_minutes"),
        status: text12("status").$type().default("pending").notNull(),
        config: jsonb10("config"),
        createdAt: timestamp12("created_at").defaultNow().notNull()
      },
      (table) => [
        index12("competition_runs_trace_id_idx").on(table.traceId),
        index12("competition_runs_status_idx").on(table.status)
      ]
    );
    competitionScores = pgTable12(
      "competition_scores",
      {
        id: varchar12("id").primaryKey().default(sql12`gen_random_uuid()`),
        runId: varchar12("run_id").references(() => competitionRuns.id, { onDelete: "cascade" }).notNull(),
        traderProfileId: varchar12("trader_profile_id").references(() => traderProfiles.id, { onDelete: "cascade" }).notNull(),
        totalPnl: numeric11("total_pnl").default("0").notNull(),
        roi: numeric11("roi").default("0").notNull(),
        maxDrawdown: numeric11("max_drawdown").default("0").notNull(),
        winRate: numeric11("win_rate").default("0").notNull(),
        avgHoldTime: integer10("avg_hold_time"),
        tradeCount: integer10("trade_count").default(0).notNull(),
        errorCount: integer10("error_count").default(0).notNull(),
        costPerDecision: numeric11("cost_per_decision"),
        slippageProxy: numeric11("slippage_proxy"),
        rank: integer10("rank"),
        snapshotAt: timestamp12("snapshot_at").defaultNow().notNull(),
        details: jsonb10("details")
      },
      (table) => [
        index12("competition_scores_run_id_idx").on(table.runId),
        index12("competition_scores_trader_id_idx").on(table.traderProfileId),
        index12("competition_scores_rank_idx").on(table.rank)
      ]
    );
    insertTraderProfileSchema = createInsertSchema12(
      traderProfiles
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCompetitionRunSchema = createInsertSchema12(
      competitionRuns
    ).omit({
      id: true,
      createdAt: true
    });
    insertCompetitionScoreSchema = createInsertSchema12(
      competitionScores
    ).omit({
      id: true,
      snapshotAt: true
    });
  }
});

// shared/schema/strategy-versioning.ts
import { sql as sql13 } from "drizzle-orm";
import {
  pgTable as pgTable13,
  varchar as varchar13,
  text as text13,
  timestamp as timestamp13,
  integer as integer11,
  jsonb as jsonb11,
  index as index13,
  unique as unique5
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema13 } from "drizzle-zod";
var strategyVersions, insertStrategyVersionSchema;
var init_strategy_versioning = __esm({
  "shared/schema/strategy-versioning.ts"() {
    "use strict";
    init_trading();
    strategyVersions = pgTable13(
      "strategy_versions",
      {
        id: varchar13("id").primaryKey().default(sql13`gen_random_uuid()`),
        strategyId: varchar13("strategy_id").references(() => strategies.id, { onDelete: "cascade" }).notNull(),
        version: integer11("version").notNull(),
        name: text13("name").notNull(),
        spec: jsonb11("spec").notNull(),
        universeConfig: jsonb11("universe_config"),
        signalsConfig: jsonb11("signals_config"),
        riskConfig: jsonb11("risk_config"),
        llmPolicy: jsonb11("llm_policy"),
        promptTemplate: text13("prompt_template"),
        status: text13("status").$type().default("draft").notNull(),
        dryRunResult: jsonb11("dry_run_result"),
        changeNotes: text13("change_notes"),
        createdBy: varchar13("created_by"),
        createdAt: timestamp13("created_at").defaultNow().notNull(),
        activatedAt: timestamp13("activated_at")
      },
      (table) => [
        index13("strategy_versions_strategy_id_idx").on(table.strategyId),
        index13("strategy_versions_status_idx").on(table.status),
        unique5("strategy_versions_unique").on(table.strategyId, table.version)
      ]
    );
    insertStrategyVersionSchema = createInsertSchema13(
      strategyVersions
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/monitoring.ts
import { sql as sql14 } from "drizzle-orm";
import {
  pgTable as pgTable14,
  text as text14,
  varchar as varchar14,
  timestamp as timestamp14,
  numeric as numeric12,
  boolean as boolean11,
  integer as integer12,
  jsonb as jsonb12,
  index as index14,
  unique as unique6
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema14 } from "drizzle-zod";
var llmRoles, llmRoleConfigs, llmCalls, connectorMetrics, alertRules, alertEvents, toolInvocations, insertLlmRoleConfigSchema, insertLlmCallSchema, insertConnectorMetricsSchema, insertAlertRuleSchema, insertAlertEventSchema, insertToolInvocationSchema;
var init_monitoring = __esm({
  "shared/schema/monitoring.ts"() {
    "use strict";
    llmRoles = [
      "market_news_summarizer",
      "technical_analyst",
      "risk_manager",
      "execution_planner",
      "post_trade_reporter",
      // New roles added for enhanced trading capabilities
      "position_sizer",
      // Optimal position sizing based on risk and market conditions
      "sentiment_analyst",
      // Dedicated sentiment analysis from news and social sources
      "post_trade_analyzer",
      // Detailed trade performance analysis and learning
      "futures_analyst"
      // Specialized futures market analysis
    ];
    llmRoleConfigs = pgTable14("llm_role_configs", {
      id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
      role: text14("role").notNull().unique(),
      description: text14("description"),
      fallbackChain: text14("fallback_chain").notNull(),
      maxTokens: integer12("max_tokens").default(1e3),
      temperature: numeric12("temperature").default("0.3"),
      enableCitations: boolean11("enable_citations").default(false).notNull(),
      isActive: boolean11("is_active").default(true).notNull(),
      createdAt: timestamp14("created_at").defaultNow().notNull(),
      updatedAt: timestamp14("updated_at").defaultNow().notNull()
    });
    llmCalls = pgTable14("llm_calls", {
      id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
      role: text14("role").notNull(),
      provider: text14("provider").notNull(),
      model: text14("model").notNull(),
      promptTokens: integer12("prompt_tokens"),
      completionTokens: integer12("completion_tokens"),
      totalTokens: integer12("total_tokens"),
      estimatedCost: numeric12("estimated_cost"),
      latencyMs: integer12("latency_ms"),
      status: text14("status").default("success").notNull(),
      errorMessage: text14("error_message"),
      systemPrompt: text14("system_prompt"),
      userPrompt: text14("user_prompt"),
      response: text14("response"),
      cacheHit: boolean11("cache_hit").default(false).notNull(),
      fallbackUsed: boolean11("fallback_used").default(false).notNull(),
      fallbackReason: text14("fallback_reason"),
      traceId: text14("trace_id"),
      criticality: text14("criticality"),
      purpose: text14("purpose"),
      metadata: text14("metadata"),
      createdAt: timestamp14("created_at").defaultNow().notNull()
    });
    connectorMetrics = pgTable14(
      "connector_metrics",
      {
        id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
        connector: text14("connector").notNull(),
        endpoint: text14("endpoint").notNull(),
        date: timestamp14("date").notNull().defaultNow(),
        totalRequests: integer12("total_requests").default(0).notNull(),
        successCount: integer12("success_count").default(0).notNull(),
        failureCount: integer12("failure_count").default(0).notNull(),
        cacheHits: integer12("cache_hits").default(0).notNull(),
        cacheMisses: integer12("cache_misses").default(0).notNull(),
        rateLimitHits: integer12("rate_limit_hits").default(0).notNull(),
        fallbackUsed: integer12("fallback_used").default(0).notNull(),
        avgLatencyMs: numeric12("avg_latency_ms"),
        p50LatencyMs: numeric12("p50_latency_ms"),
        p95LatencyMs: numeric12("p95_latency_ms"),
        p99LatencyMs: numeric12("p99_latency_ms"),
        lastError: text14("last_error"),
        lastErrorAt: timestamp14("last_error_at"),
        createdAt: timestamp14("created_at").defaultNow().notNull(),
        updatedAt: timestamp14("updated_at").defaultNow().notNull()
      },
      (table) => [
        index14("connector_metrics_connector_idx").on(table.connector),
        index14("connector_metrics_date_idx").on(table.date),
        unique6("connector_metrics_connector_endpoint_date_unique").on(
          table.connector,
          table.endpoint,
          table.date
        )
      ]
    );
    alertRules = pgTable14(
      "alert_rules",
      {
        id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
        name: text14("name").notNull().unique(),
        description: text14("description"),
        ruleType: text14("rule_type").notNull(),
        condition: jsonb12("condition").notNull(),
        threshold: numeric12("threshold").notNull(),
        enabled: boolean11("enabled").default(true).notNull(),
        webhookUrl: text14("webhook_url"),
        lastTriggeredAt: timestamp14("last_triggered_at"),
        lastCheckedAt: timestamp14("last_checked_at"),
        createdAt: timestamp14("created_at").defaultNow().notNull(),
        updatedAt: timestamp14("updated_at").defaultNow().notNull()
      },
      (table) => [
        index14("alert_rules_enabled_idx").on(table.enabled),
        index14("alert_rules_type_idx").on(table.ruleType)
      ]
    );
    alertEvents = pgTable14(
      "alert_events",
      {
        id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
        ruleId: varchar14("rule_id").references(() => alertRules.id, { onDelete: "cascade" }).notNull(),
        ruleName: text14("rule_name").notNull(),
        ruleType: text14("rule_type").notNull(),
        triggeredValue: numeric12("triggered_value").notNull(),
        threshold: numeric12("threshold").notNull(),
        status: text14("status").default("triggered").notNull(),
        webhookSent: boolean11("webhook_sent").default(false),
        webhookResponse: text14("webhook_response"),
        createdAt: timestamp14("created_at").defaultNow().notNull()
      },
      (table) => [
        index14("alert_events_rule_id_idx").on(table.ruleId),
        index14("alert_events_created_at_idx").on(table.createdAt)
      ]
    );
    toolInvocations = pgTable14(
      "tool_invocations",
      {
        id: varchar14("id").primaryKey().default(sql14`gen_random_uuid()`),
        traceId: text14("trace_id").notNull(),
        toolName: text14("tool_name").notNull(),
        category: text14("category").$type().notNull(),
        inputParams: jsonb12("input_params"),
        outputResult: jsonb12("output_result"),
        status: text14("status").$type().default("pending").notNull(),
        errorMessage: text14("error_message"),
        cacheHit: boolean11("cache_hit").default(false).notNull(),
        latencyMs: integer12("latency_ms"),
        callerRole: text14("caller_role"),
        // Note: debateSessionId references debateSessions.id from debate-arena module
        // Foreign key constraint will be resolved in main schema index
        debateSessionId: varchar14("debate_session_id"),
        createdAt: timestamp14("created_at").defaultNow().notNull()
      },
      (table) => [
        index14("tool_invocations_trace_id_idx").on(table.traceId),
        index14("tool_invocations_tool_name_idx").on(table.toolName),
        index14("tool_invocations_created_at_idx").on(table.createdAt),
        index14("tool_invocations_session_id_idx").on(table.debateSessionId)
      ]
    );
    insertLlmRoleConfigSchema = createInsertSchema14(
      llmRoleConfigs
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertLlmCallSchema = createInsertSchema14(llmCalls).omit({
      id: true,
      createdAt: true
    });
    insertConnectorMetricsSchema = createInsertSchema14(
      connectorMetrics
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAlertRuleSchema = createInsertSchema14(alertRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAlertEventSchema = createInsertSchema14(alertEvents).omit({
      id: true,
      createdAt: true
    });
    insertToolInvocationSchema = createInsertSchema14(
      toolInvocations
    ).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema/watchlist.ts
import { sql as sql15 } from "drizzle-orm";
import {
  pgTable as pgTable15,
  text as text15,
  varchar as varchar15,
  timestamp as timestamp15,
  boolean as boolean12,
  integer as integer13,
  index as index15
} from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema15 } from "drizzle-zod";
import { z as z3 } from "zod";
var watchlists, watchlistSymbols, insertWatchlistSchema, insertWatchlistSymbolSchema, createWatchlistSchema, updateWatchlistSchema, addWatchlistSymbolSchema, updateWatchlistSymbolSchema;
var init_watchlist = __esm({
  "shared/schema/watchlist.ts"() {
    "use strict";
    init_auth();
    watchlists = pgTable15(
      "watchlists",
      {
        id: varchar15("id").primaryKey().default(sql15`gen_random_uuid()`),
        userId: varchar15("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
        name: text15("name").notNull(),
        description: text15("description"),
        isDefault: boolean12("is_default").default(false).notNull(),
        sortOrder: integer13("sort_order").default(0).notNull(),
        createdAt: timestamp15("created_at").defaultNow().notNull(),
        updatedAt: timestamp15("updated_at").defaultNow().notNull()
      },
      (table) => [
        index15("watchlists_user_id_idx").on(table.userId),
        index15("watchlists_is_default_idx").on(table.isDefault)
      ]
    );
    watchlistSymbols = pgTable15(
      "watchlist_symbols",
      {
        id: varchar15("id").primaryKey().default(sql15`gen_random_uuid()`),
        watchlistId: varchar15("watchlist_id").references(() => watchlists.id, { onDelete: "cascade" }).notNull(),
        symbol: text15("symbol").notNull(),
        notes: text15("notes"),
        tags: text15("tags"),
        sortOrder: integer13("sort_order").default(0).notNull(),
        addedAt: timestamp15("added_at").defaultNow().notNull()
      },
      (table) => [
        index15("watchlist_symbols_watchlist_id_idx").on(table.watchlistId),
        index15("watchlist_symbols_symbol_idx").on(table.symbol)
      ]
    );
    insertWatchlistSchema = createInsertSchema15(watchlists).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWatchlistSymbolSchema = createInsertSchema15(
      watchlistSymbols
    ).omit({
      id: true,
      addedAt: true
    });
    createWatchlistSchema = z3.object({
      name: z3.string().min(1).max(100),
      description: z3.string().max(500).optional(),
      isDefault: z3.boolean().optional()
    });
    updateWatchlistSchema = z3.object({
      name: z3.string().min(1).max(100).optional(),
      description: z3.string().max(500).optional(),
      isDefault: z3.boolean().optional(),
      sortOrder: z3.number().int().min(0).optional()
    });
    addWatchlistSymbolSchema = z3.object({
      symbol: z3.string().min(1).max(20).toUpperCase(),
      notes: z3.string().max(500).optional(),
      tags: z3.string().max(200).optional()
    });
    updateWatchlistSymbolSchema = z3.object({
      notes: z3.string().max(500).optional(),
      tags: z3.string().max(200).optional(),
      sortOrder: z3.number().int().min(0).optional()
    });
  }
});

// shared/schema/user-preferences.ts
import {
  pgTable as pgTable16,
  varchar as varchar16,
  timestamp as timestamp16,
  jsonb as jsonb13,
  index as index16,
  unique as unique7
} from "drizzle-orm/pg-core";
import { sql as sql16 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema16, createSelectSchema } from "drizzle-zod";
import { z as z4 } from "zod";
var themeValues, animationLevelValues, chartStyleValues, userPreferences, insertUserPreferencesSchema, selectUserPreferencesSchema, updateUserPreferencesSchema, defaultUserPreferences;
var init_user_preferences = __esm({
  "shared/schema/user-preferences.ts"() {
    "use strict";
    init_auth();
    themeValues = ["dark", "light", "system"];
    animationLevelValues = ["full", "reduced", "none"];
    chartStyleValues = ["area", "candle", "line"];
    userPreferences = pgTable16(
      "user_preferences",
      {
        id: varchar16("id", { length: 36 }).primaryKey().default(sql16`gen_random_uuid()`),
        userId: varchar16("user_id", { length: 36 }).notNull().references(() => users.id, { onDelete: "cascade" }),
        theme: varchar16("theme", { length: 10 }).default("dark").notNull(),
        accentColor: varchar16("accent_color", { length: 7 }).default("#00C805").notNull(),
        animationLevel: varchar16("animation_level", { length: 10 }).default("full").notNull(),
        chartStyle: varchar16("chart_style", { length: 10 }).default("area").notNull(),
        // Extensible JSON column for future preferences
        extras: jsonb13("extras").default({}).notNull(),
        createdAt: timestamp16("created_at").defaultNow().notNull(),
        updatedAt: timestamp16("updated_at").defaultNow().notNull()
      },
      (table) => [
        // Ensure one preferences record per user
        unique7("user_preferences_user_id_unique").on(table.userId),
        // Index for fast user lookup
        index16("user_preferences_user_id_idx").on(table.userId)
      ]
    );
    insertUserPreferencesSchema = createInsertSchema16(userPreferences, {
      theme: z4.enum(themeValues).default("dark"),
      accentColor: z4.string().regex(/^#[0-9A-Fa-f]{6}$/, "Must be a valid hex color (e.g., #00C805)").default("#00C805"),
      animationLevel: z4.enum(animationLevelValues).default("full"),
      chartStyle: z4.enum(chartStyleValues).default("area"),
      extras: z4.record(z4.unknown()).default({})
    }).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    selectUserPreferencesSchema = createSelectSchema(userPreferences);
    updateUserPreferencesSchema = insertUserPreferencesSchema.partial().omit({
      userId: true
    });
    defaultUserPreferences = {
      theme: "dark",
      accentColor: "#00C805",
      animationLevel: "full",
      chartStyle: "area",
      extras: {}
    };
  }
});

// shared/schema/notification-preferences.ts
import {
  pgTable as pgTable17,
  varchar as varchar17,
  boolean as boolean13,
  timestamp as timestamp17,
  index as index17,
  unique as unique8
} from "drizzle-orm/pg-core";
import { sql as sql17 } from "drizzle-orm";
import { createInsertSchema as createInsertSchema17, createSelectSchema as createSelectSchema2 } from "drizzle-zod";
import { z as z5 } from "zod";
var notificationPreferences, insertNotificationPreferencesSchema, selectNotificationPreferencesSchema, updateNotificationPreferencesSchema, defaultNotificationPreferences;
var init_notification_preferences = __esm({
  "shared/schema/notification-preferences.ts"() {
    "use strict";
    init_auth();
    notificationPreferences = pgTable17(
      "notification_preferences",
      {
        id: varchar17("id", { length: 36 }).primaryKey().default(sql17`gen_random_uuid()`),
        userId: varchar17("user_id", { length: 36 }).notNull().references(() => users.id, { onDelete: "cascade" }),
        emailOrderFills: boolean13("email_order_fills").default(true).notNull(),
        emailLargeLosses: boolean13("email_large_losses").default(true).notNull(),
        emailCircuitBreaker: boolean13("email_circuit_breaker").default(true).notNull(),
        emailDailySummary: boolean13("email_daily_summary").default(false).notNull(),
        emailWeeklyReport: boolean13("email_weekly_report").default(true).notNull(),
        createdAt: timestamp17("created_at").defaultNow().notNull(),
        updatedAt: timestamp17("updated_at").defaultNow().notNull()
      },
      (table) => [
        // Ensure one preferences record per user
        unique8("notification_preferences_user_id_unique").on(table.userId),
        // Index for fast user lookup
        index17("notification_preferences_user_id_idx").on(table.userId)
      ]
    );
    insertNotificationPreferencesSchema = createInsertSchema17(
      notificationPreferences,
      {
        emailOrderFills: z5.boolean().default(true),
        emailLargeLosses: z5.boolean().default(true),
        emailCircuitBreaker: z5.boolean().default(true),
        emailDailySummary: z5.boolean().default(false),
        emailWeeklyReport: z5.boolean().default(true)
      }
    ).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    selectNotificationPreferencesSchema = createSelectSchema2(
      notificationPreferences
    );
    updateNotificationPreferencesSchema = insertNotificationPreferencesSchema.partial().omit({
      userId: true
    });
    defaultNotificationPreferences = {
      emailOrderFills: true,
      emailLargeLosses: true,
      emailCircuitBreaker: true,
      emailDailySummary: false,
      emailWeeklyReport: true
    };
  }
});

// shared/schema/index.ts
var init_schema = __esm({
  "shared/schema/index.ts"() {
    "use strict";
    init_auth();
    init_trading();
    init_orders();
    init_ai_decisions();
    init_orchestration();
    init_debate_arena();
    init_market_data();
    init_analysis();
    init_universe();
    init_allocation();
    init_backtest();
    init_competition();
    init_strategy_versioning();
    init_monitoring();
    init_watchlist();
    init_user_preferences();
    init_notification_preferences();
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  addWatchlistSymbolSchema: () => addWatchlistSymbolSchema,
  adminSettings: () => adminSettings,
  agentStatus: () => agentStatus,
  aiAgentProfiles: () => aiAgentProfiles,
  aiArenaAgentDecisions: () => aiArenaAgentDecisions,
  aiArenaRuns: () => aiArenaRuns,
  aiCalibrationLog: () => aiCalibrationLog,
  aiDecisionFeatures: () => aiDecisionFeatures,
  aiDecisions: () => aiDecisions,
  aiOutcomeLinks: () => aiOutcomeLinks,
  aiTradeOutcomes: () => aiTradeOutcomes,
  alertEvents: () => alertEvents,
  alertRules: () => alertRules,
  allocationPolicies: () => allocationPolicies,
  analysisFeedback: () => analysisFeedback,
  animationLevelValues: () => animationLevelValues,
  assetClasses: () => assetClasses,
  assetClassifications: () => assetClassifications,
  auditLogs: () => auditLogs,
  backtestEquityCurve: () => backtestEquityCurve,
  backtestRuns: () => backtestRuns,
  backtestStatuses: () => backtestStatuses,
  backtestTradeEvents: () => backtestTradeEvents,
  brokerAssets: () => brokerAssets,
  chartStyleValues: () => chartStyleValues,
  competitionRuns: () => competitionRuns,
  competitionScores: () => competitionScores,
  connectorMetrics: () => connectorMetrics,
  createWatchlistSchema: () => createWatchlistSchema,
  dataSourceAnalysis: () => dataSourceAnalysis,
  debateConsensus: () => debateConsensus,
  debateMessages: () => debateMessages,
  debateSessions: () => debateSessions,
  defaultNotificationPreferences: () => defaultNotificationPreferences,
  defaultUserPreferences: () => defaultUserPreferences,
  deployStrategySchema: () => deployStrategySchema,
  executionPriceRules: () => executionPriceRules,
  externalApiCacheEntries: () => externalApiCacheEntries,
  externalApiUsageCounters: () => externalApiUsageCounters,
  fills: () => fills,
  insertAdminSettingSchema: () => insertAdminSettingSchema,
  insertAiAgentProfileSchema: () => insertAiAgentProfileSchema,
  insertAiArenaAgentDecisionSchema: () => insertAiArenaAgentDecisionSchema,
  insertAiArenaRunSchema: () => insertAiArenaRunSchema,
  insertAiCalibrationLogSchema: () => insertAiCalibrationLogSchema,
  insertAiDecisionFeaturesSchema: () => insertAiDecisionFeaturesSchema,
  insertAiDecisionSchema: () => insertAiDecisionSchema,
  insertAiOutcomeLinkSchema: () => insertAiOutcomeLinkSchema,
  insertAiTradeOutcomesSchema: () => insertAiTradeOutcomesSchema,
  insertAlertEventSchema: () => insertAlertEventSchema,
  insertAlertRuleSchema: () => insertAlertRuleSchema,
  insertAllocationPolicySchema: () => insertAllocationPolicySchema,
  insertAnalysisFeedbackSchema: () => insertAnalysisFeedbackSchema,
  insertAssetClassificationSchema: () => insertAssetClassificationSchema,
  insertAuditLogSchema: () => insertAuditLogSchema,
  insertBacktestEquityCurveSchema: () => insertBacktestEquityCurveSchema,
  insertBacktestRunSchema: () => insertBacktestRunSchema,
  insertBacktestTradeEventSchema: () => insertBacktestTradeEventSchema,
  insertBrokerAssetSchema: () => insertBrokerAssetSchema,
  insertCompetitionRunSchema: () => insertCompetitionRunSchema,
  insertCompetitionScoreSchema: () => insertCompetitionScoreSchema,
  insertConnectorMetricsSchema: () => insertConnectorMetricsSchema,
  insertDataSourceAnalysisSchema: () => insertDataSourceAnalysisSchema,
  insertDebateConsensusSchema: () => insertDebateConsensusSchema,
  insertDebateMessageSchema: () => insertDebateMessageSchema,
  insertDebateSessionSchema: () => insertDebateSessionSchema,
  insertExternalApiCacheEntrySchema: () => insertExternalApiCacheEntrySchema,
  insertExternalApiUsageCounterSchema: () => insertExternalApiUsageCounterSchema,
  insertFillSchema: () => insertFillSchema,
  insertInsiderActivityAnalysisSchema: () => insertInsiderActivityAnalysisSchema,
  insertLlmCallSchema: () => insertLlmCallSchema,
  insertLlmRoleConfigSchema: () => insertLlmRoleConfigSchema,
  insertMacroAnalysisSchema: () => insertMacroAnalysisSchema,
  insertMacroIndicatorsSchema: () => insertMacroIndicatorsSchema,
  insertNotificationPreferencesSchema: () => insertNotificationPreferencesSchema,
  insertOrderSchema: () => insertOrderSchema,
  insertPasswordResetTokenSchema: () => insertPasswordResetTokenSchema,
  insertPositionSchema: () => insertPositionSchema,
  insertRebalanceRunSchema: () => insertRebalanceRunSchema,
  insertSessionSchema: () => insertSessionSchema,
  insertShortInterestAnalysisSchema: () => insertShortInterestAnalysisSchema,
  insertStrategySchema: () => insertStrategySchema,
  insertStrategyVersionSchema: () => insertStrategyVersionSchema,
  insertToolInvocationSchema: () => insertToolInvocationSchema,
  insertTradeSchema: () => insertTradeSchema,
  insertTraderProfileSchema: () => insertTraderProfileSchema,
  insertUniverseAssetSchema: () => insertUniverseAssetSchema,
  insertUniverseCandidateSchema: () => insertUniverseCandidateSchema,
  insertUniverseFundamentalsSchema: () => insertUniverseFundamentalsSchema,
  insertUniverseLiquiditySchema: () => insertUniverseLiquiditySchema,
  insertUniverseTechnicalsSchema: () => insertUniverseTechnicalsSchema,
  insertUserPreferencesSchema: () => insertUserPreferencesSchema,
  insertUserSchema: () => insertUserSchema,
  insertValyuRetrievalCounterSchema: () => insertValyuRetrievalCounterSchema,
  insertWatchlistSchema: () => insertWatchlistSchema,
  insertWatchlistSymbolSchema: () => insertWatchlistSymbolSchema,
  insertWorkItemRunSchema: () => insertWorkItemRunSchema,
  insertWorkItemSchema: () => insertWorkItemSchema,
  insiderActivityAnalysis: () => insiderActivityAnalysis,
  llmCalls: () => llmCalls,
  llmRoleConfigs: () => llmRoleConfigs,
  llmRoles: () => llmRoles,
  macroAnalysis: () => macroAnalysis,
  macroIndicators: () => macroIndicators,
  notificationPreferences: () => notificationPreferences,
  orderStatuses: () => orderStatuses,
  orderTypes: () => orderTypes,
  orders: () => orders,
  passwordResetTokens: () => passwordResetTokens,
  performanceSummarySchema: () => performanceSummarySchema,
  positions: () => positions,
  rebalanceRuns: () => rebalanceRuns,
  selectNotificationPreferencesSchema: () => selectNotificationPreferencesSchema,
  selectUserPreferencesSchema: () => selectUserPreferencesSchema,
  sessions: () => sessions,
  shortInterestAnalysis: () => shortInterestAnalysis,
  strategies: () => strategies,
  strategyConfigSchema: () => strategyConfigSchema,
  strategyStatusSchema: () => strategyStatusSchema,
  strategyStatuses: () => strategyStatuses,
  strategyVersions: () => strategyVersions,
  themeValues: () => themeValues,
  timeInForceValues: () => timeInForceValues,
  toolInvocations: () => toolInvocations,
  traderProfiles: () => traderProfiles,
  trades: () => trades,
  tradingModeSchema: () => tradingModeSchema,
  tradingModes: () => tradingModes,
  universeAssets: () => universeAssets,
  universeCandidates: () => universeCandidates,
  universeFundamentals: () => universeFundamentals,
  universeLiquidityMetrics: () => universeLiquidityMetrics,
  universeTechnicals: () => universeTechnicals,
  updateNotificationPreferencesSchema: () => updateNotificationPreferencesSchema,
  updateStrategySchema: () => updateStrategySchema,
  updateUserPreferencesSchema: () => updateUserPreferencesSchema,
  updateWatchlistSchema: () => updateWatchlistSchema,
  updateWatchlistSymbolSchema: () => updateWatchlistSymbolSchema,
  userPreferences: () => userPreferences,
  users: () => users,
  valyuRetrievalCounters: () => valyuRetrievalCounters,
  watchlistSymbols: () => watchlistSymbols,
  watchlists: () => watchlists,
  workItemRuns: () => workItemRuns,
  workItemStatuses: () => workItemStatuses,
  workItemTypes: () => workItemTypes,
  workItems: () => workItems
});
var init_schema2 = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_schema();
  }
});

// server/utils/logger.ts
import pino from "pino";
function generateId() {
  return Math.random().toString(36).substring(2, 10);
}
var REDACT_PATHS, isProduction, getLogLevel, createPinoLogger, pinoLogger, Logger, log, tradingLogger, autonomousLogger, aiLogger, apiLogger, connectorLogger;
var init_logger = __esm({
  "server/utils/logger.ts"() {
    "use strict";
    REDACT_PATHS = [
      // API credentials
      "alpacaApiKey",
      "alpacaSecretKey",
      "ALPACA_API_KEY",
      "ALPACA_SECRET_KEY",
      "apiKey",
      "secretKey",
      "api_key",
      "secret_key",
      // Authentication
      "password",
      "token",
      "accessToken",
      "refreshToken",
      "authorization",
      "cookie",
      "session",
      "jwt",
      // Nested patterns
      "*.apiKey",
      "*.secretKey",
      "*.password",
      "*.token",
      "*.accessToken",
      "*.refreshToken",
      // Request headers
      "req.headers.authorization",
      "req.headers.cookie",
      'req.headers["x-api-key"]',
      // Request body
      "body.password",
      "body.apiKey",
      "body.secretKey",
      "body.token"
    ];
    isProduction = process.env.NODE_ENV === "production";
    getLogLevel = () => {
      if (process.env.LOG_LEVEL) {
        return process.env.LOG_LEVEL;
      }
      return isProduction ? "info" : "debug";
    };
    createPinoLogger = () => {
      const baseConfig = {
        level: getLogLevel(),
        redact: {
          paths: REDACT_PATHS,
          censor: "[REDACTED]"
        },
        formatters: {
          level: (label) => ({ level: label })
        },
        timestamp: pino.stdTimeFunctions.isoTime,
        base: {
          service: "alphaflow",
          env: process.env.NODE_ENV || "development"
        }
      };
      if (!isProduction) {
        return pino({
          ...baseConfig,
          transport: {
            target: "pino-pretty",
            options: {
              colorize: true,
              translateTime: "SYS:standard",
              ignore: "pid,hostname,service,env"
            }
          }
        });
      }
      return pino(baseConfig);
    };
    pinoLogger = createPinoLogger();
    Logger = class {
      currentRequestId;
      currentCycleId;
      /**
       * Set minimum log level
       */
      setLevel(level) {
        pinoLogger.level = level;
      }
      /**
       * Set current request ID for correlation
       */
      setRequestId(requestId) {
        this.currentRequestId = requestId;
      }
      /**
       * Set current cycle ID for correlation
       */
      setCycleId(cycleId) {
        this.currentCycleId = cycleId;
      }
      /**
       * Generate a new request ID
       */
      generateRequestId() {
        return `req-${generateId()}`;
      }
      /**
       * Generate a new cycle ID
       */
      generateCycleId() {
        return `cyc-${generateId()}`;
      }
      /**
       * Build log metadata with correlation IDs
       */
      buildMeta(context, meta) {
        return {
          context,
          requestId: meta?.requestId || this.currentRequestId,
          cycleId: meta?.cycleId || this.currentCycleId,
          ...meta
        };
      }
      /**
       * Log debug message
       */
      debug(context, message, meta) {
        pinoLogger.debug(this.buildMeta(context, meta), message);
      }
      /**
       * Log info message
       */
      info(context, message, meta) {
        pinoLogger.info(this.buildMeta(context, meta), message);
      }
      /**
       * Log warning message
       */
      warn(context, message, meta) {
        pinoLogger.warn(this.buildMeta(context, meta), message);
      }
      /**
       * Log error message
       */
      error(context, message, meta) {
        const { error, err, ...restMeta } = meta || {};
        const errorObj = error || err;
        if (errorObj instanceof Error) {
          pinoLogger.error(
            { err: errorObj, ...this.buildMeta(context, restMeta) },
            message
          );
        } else if (errorObj) {
          pinoLogger.error(
            { error: errorObj, ...this.buildMeta(context, restMeta) },
            message
          );
        } else {
          pinoLogger.error(this.buildMeta(context, meta), message);
        }
      }
      // ============================================================================
      // Convenience methods for specific modules
      // ============================================================================
      /**
       * Log API-related message
       */
      api(message, meta) {
        this.info("API", message, meta);
      }
      /**
       * Log orchestrator-related message
       */
      orchestrator(message, meta) {
        this.info("Orchestrator", message, meta);
      }
      /**
       * Log Alpaca-related message
       */
      alpaca(message, meta) {
        this.info("Alpaca", message, meta);
      }
      /**
       * Log AI-related message
       */
      ai(message, meta) {
        this.info("AI", message, meta);
      }
      /**
       * Log connector-related message
       */
      connector(name, message, meta) {
        this.info(name, message, meta);
      }
      /**
       * Log trade-related message
       */
      trade(action, meta) {
        this.info("Trade", action, meta);
      }
      /**
       * Log order-related message
       */
      order(action, meta) {
        this.info("Order", action, meta);
      }
      /**
       * Log position-related message
       */
      position(action, meta) {
        this.info("Position", action, meta);
      }
      /**
       * Log strategy-related message
       */
      strategy(action, meta) {
        this.info("Strategy", action, meta);
      }
      /**
       * Log backtest-related message
       */
      backtest(action, meta) {
        this.info("Backtest", action, meta);
      }
    };
    log = new Logger();
    tradingLogger = pinoLogger.child({ module: "trading" });
    autonomousLogger = pinoLogger.child({ module: "autonomous" });
    aiLogger = pinoLogger.child({ module: "ai" });
    apiLogger = pinoLogger.child({ module: "api" });
    connectorLogger = pinoLogger.child({ module: "connector" });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  getPoolStats: () => getPoolStats,
  pool: () => pool
});
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
function getPoolStats() {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount
  };
}
var Pool, poolConfig, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema2();
    init_logger();
    ({ Pool } = pg);
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    poolConfig = {
      connectionString: process.env.DATABASE_URL,
      max: 20,
      min: 5,
      idleTimeoutMillis: 3e4,
      connectionTimeoutMillis: 5e3,
      allowExitOnIdle: false
    };
    pool = new Pool(poolConfig);
    pool.on("error", (err) => {
      log.error("DB Pool", "Unexpected error on idle client", {
        error: err.message
      });
    });
    pool.on("connect", () => {
      log.debug("DB Pool", "New client connected");
    });
    db = drizzle(pool, { schema: schema_exports });
  }
});

// server/lib/sanitization.ts
import DOMPurify from "isomorphic-dompurify";
function sanitizeInput(input) {
  if (typeof input !== "string") {
    return input;
  }
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    // Strip ALL HTML tags
    ALLOWED_ATTR: [],
    // Strip ALL attributes
    KEEP_CONTENT: true
    // Keep text content, just remove tags
  });
}
function sanitizeArray(arr) {
  if (!Array.isArray(arr)) {
    return arr;
  }
  return arr.map(
    (item) => typeof item === "string" ? sanitizeInput(item) : item
  );
}
function sanitizeUserInput(user) {
  const sanitized = { ...user };
  if (sanitized.username) {
    sanitized.username = sanitizeInput(sanitized.username);
  }
  if (sanitized.email) {
    sanitized.email = sanitizeInput(sanitized.email);
  }
  if (sanitized.displayName) {
    sanitized.displayName = sanitizeInput(sanitized.displayName);
  }
  if (sanitized.bio) {
    sanitized.bio = sanitizeInput(sanitized.bio);
  }
  return sanitized;
}
function sanitizeStrategyInput(strategy) {
  const sanitized = { ...strategy };
  if (sanitized.name) {
    sanitized.name = sanitizeInput(sanitized.name);
  }
  if (sanitized.description) {
    sanitized.description = sanitizeInput(sanitized.description);
  }
  if (sanitized.notes) {
    sanitized.notes = sanitizeInput(sanitized.notes);
  }
  return sanitized;
}
var init_sanitization = __esm({
  "server/lib/sanitization.ts"() {
    "use strict";
  }
});

// server/storage.ts
import {
  eq as eq2,
  desc,
  and,
  gte,
  lte,
  sql as sql18,
  like,
  or,
  inArray
} from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_db();
    init_sanitization();
    init_logger();
    init_schema2();
    DatabaseStorage = class {
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user;
      }
      async getUserByUsername(username) {
        const [user] = await db.select().from(users).where(eq2(users.username, username));
        return user;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(eq2(users.email, email));
        return user;
      }
      async getAdminUser() {
        const [adminUser] = await db.select().from(users).where(eq2(users.isAdmin, true)).limit(1);
        return adminUser;
      }
      async getAllUsers() {
        return db.select().from(users).orderBy(desc(users.id));
      }
      async createUser(insertUser) {
        const sanitizedUser = sanitizeUserInput(insertUser);
        const [user] = await db.insert(users).values(sanitizedUser).returning();
        return user;
      }
      async updateUser(id, updates) {
        const sanitizedUpdates = sanitizeUserInput(updates);
        const [user] = await db.update(users).set(sanitizedUpdates).where(eq2(users.id, id)).returning();
        return user;
      }
      async deleteUser(id) {
        const result = await db.delete(users).where(eq2(users.id, id)).returning();
        return result.length > 0;
      }
      // Password reset token methods
      async createPasswordResetToken(userId, token, expiresAt) {
        await db.insert(passwordResetTokens).values({
          userId,
          token,
          expiresAt,
          used: false
        });
      }
      async getPasswordResetToken(token) {
        const [result] = await db.select({
          userId: passwordResetTokens.userId,
          expiresAt: passwordResetTokens.expiresAt,
          used: passwordResetTokens.used
        }).from(passwordResetTokens).where(eq2(passwordResetTokens.token, token));
        return result;
      }
      async markPasswordResetTokenUsed(token) {
        await db.update(passwordResetTokens).set({ used: true }).where(eq2(passwordResetTokens.token, token));
      }
      async deleteExpiredPasswordResetTokens() {
        const result = await db.delete(passwordResetTokens).where(lte(passwordResetTokens.expiresAt, /* @__PURE__ */ new Date())).returning();
        return result.length;
      }
      async getStrategies() {
        return db.select().from(strategies).orderBy(desc(strategies.createdAt));
      }
      async getActiveStrategies() {
        return db.select().from(strategies).where(inArray(strategies.status, ["paper", "live"])).orderBy(desc(strategies.createdAt));
      }
      async getStrategy(id) {
        const [strategy] = await db.select().from(strategies).where(eq2(strategies.id, id));
        return strategy;
      }
      async createStrategy(insertStrategy) {
        const sanitizedStrategy = sanitizeStrategyInput(
          insertStrategy
        );
        const [strategy] = await db.insert(strategies).values(sanitizedStrategy).returning();
        return strategy;
      }
      async updateStrategy(id, updates) {
        const sanitizedUpdates = sanitizeStrategyInput(
          updates
        );
        const [strategy] = await db.update(strategies).set({ ...sanitizedUpdates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(strategies.id, id)).returning();
        return strategy;
      }
      async updateStrategyStatus(id, status, mode) {
        const updates = {
          status
        };
        if (mode) {
          updates.mode = mode;
        }
        return this.updateStrategy(id, updates);
      }
      async toggleStrategy(id, isActive) {
        return this.updateStrategy(id, { isActive });
      }
      async deleteStrategy(id) {
        const result = await db.delete(strategies).where(eq2(strategies.id, id)).returning();
        return result.length > 0;
      }
      async updateStrategyPerformance(id, performanceSummary) {
        const [strategy] = await db.update(strategies).set({ performanceSummary, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(strategies.id, id)).returning();
        return strategy;
      }
      async getTrades(userId, limit4 = 50) {
        if (userId) {
          return db.select().from(trades).where(eq2(trades.userId, userId)).orderBy(desc(trades.executedAt)).limit(limit4);
        }
        return db.select().from(trades).orderBy(desc(trades.executedAt)).limit(limit4);
      }
      async getTradesFiltered(userId, filters) {
        const conditions = [eq2(trades.userId, userId)];
        if (filters.symbol) {
          conditions.push(eq2(trades.symbol, filters.symbol));
        }
        if (filters.strategyId) {
          conditions.push(eq2(trades.strategyId, filters.strategyId));
        }
        if (filters.startDate) {
          conditions.push(gte(trades.executedAt, filters.startDate));
        }
        if (filters.endDate) {
          conditions.push(lte(trades.executedAt, filters.endDate));
        }
        if (filters.pnlDirection === "profit") {
          conditions.push(sql18`CAST(${trades.pnl} AS numeric) >= 0`);
        } else if (filters.pnlDirection === "loss") {
          conditions.push(sql18`CAST(${trades.pnl} AS numeric) < 0`);
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql18`count(*)` }).from(trades).where(whereClause);
        const total = Number(countResult[0]?.count ?? 0);
        const limit4 = filters.limit ?? 50;
        const offset = filters.offset ?? 0;
        const result = await db.select({
          trade: trades,
          strategy: strategies,
          aiDecision: aiDecisions
        }).from(trades).leftJoin(strategies, eq2(trades.strategyId, strategies.id)).leftJoin(aiDecisions, eq2(aiDecisions.executedTradeId, trades.id)).where(whereClause).orderBy(desc(trades.executedAt)).limit(limit4).offset(offset);
        const enrichedTrades = result.map((row) => ({
          ...row.trade,
          aiDecision: row.aiDecision ?? null,
          strategyName: row.strategy?.name ?? null
        }));
        return { trades: enrichedTrades, total };
      }
      async getTrade(id) {
        const [trade] = await db.select().from(trades).where(eq2(trades.id, id));
        return trade;
      }
      async getEnrichedTrade(id) {
        const [trade] = await db.select().from(trades).where(eq2(trades.id, id));
        if (!trade) return void 0;
        const [aiDecision] = await db.select().from(aiDecisions).where(eq2(aiDecisions.executedTradeId, trade.id)).limit(1);
        let strategyName = null;
        if (trade.strategyId) {
          const [strategy] = await db.select().from(strategies).where(eq2(strategies.id, trade.strategyId));
          strategyName = strategy?.name ?? null;
        }
        return {
          ...trade,
          aiDecision: aiDecision ?? null,
          strategyName
        };
      }
      async createTrade(insertTrade) {
        let tradeData = insertTrade;
        if (!insertTrade.userId) {
          const adminUser = await this.getAdminUser();
          tradeData = { ...insertTrade, userId: adminUser?.id || "system" };
        }
        const [trade] = await db.insert(trades).values(tradeData).returning();
        return trade;
      }
      async updateTrade(id, updates) {
        const [trade] = await db.update(trades).set(updates).where(eq2(trades.id, id)).returning();
        return trade;
      }
      async getDistinctSymbols() {
        const result = await db.selectDistinct({ symbol: trades.symbol }).from(trades).orderBy(trades.symbol);
        return result.map((r) => r.symbol);
      }
      async getTradesByStrategy(strategyId, limit4 = 1e3) {
        return db.select().from(trades).where(eq2(trades.strategyId, strategyId)).orderBy(desc(trades.executedAt)).limit(limit4);
      }
      async getPositions(userId) {
        if (userId) {
          return db.select().from(positions).where(eq2(positions.userId, userId)).orderBy(desc(positions.openedAt));
        }
        return db.select().from(positions).orderBy(desc(positions.openedAt));
      }
      async getPosition(id) {
        const [position] = await db.select().from(positions).where(eq2(positions.id, id));
        return position;
      }
      async createPosition(insertPosition) {
        const [position] = await db.insert(positions).values(insertPosition).returning();
        return position;
      }
      async updatePosition(id, updates) {
        const [position] = await db.update(positions).set(updates).where(eq2(positions.id, id)).returning();
        return position;
      }
      async deletePosition(id) {
        const result = await db.delete(positions).where(eq2(positions.id, id)).returning();
        return result.length > 0;
      }
      async getPositionsByStrategy(strategyId) {
        return db.select().from(positions).where(eq2(positions.strategyId, strategyId)).orderBy(desc(positions.openedAt));
      }
      async deleteAllPositions() {
        const result = await db.delete(positions).returning();
        return result.length;
      }
      async syncPositionsFromAlpaca(userId, alpacaPositions) {
        return await db.transaction(async (tx) => {
          await tx.delete(positions).where(eq2(positions.userId, userId));
          if (alpacaPositions.length === 0) {
            return [];
          }
          const positionsToInsert = alpacaPositions.map((pos) => ({
            userId,
            symbol: pos.symbol,
            quantity: pos.qty,
            entryPrice: pos.avg_entry_price,
            currentPrice: pos.current_price,
            unrealizedPnl: pos.unrealized_pl,
            side: pos.side === "long" ? "long" : "short"
          }));
          const insertedPositions = await tx.insert(positions).values(positionsToInsert).returning();
          return insertedPositions;
        });
      }
      async getAiDecisions(userId, limit4 = 20) {
        if (userId) {
          return db.select().from(aiDecisions).where(eq2(aiDecisions.userId, userId)).orderBy(desc(aiDecisions.createdAt)).limit(limit4);
        }
        return db.select().from(aiDecisions).orderBy(desc(aiDecisions.createdAt)).limit(limit4);
      }
      async createAiDecision(insertDecision) {
        let decisionData = insertDecision;
        if (!insertDecision.userId) {
          const adminUser = await this.getAdminUser();
          decisionData = { ...insertDecision, userId: adminUser?.id || "system" };
        }
        const [decision] = await db.insert(aiDecisions).values(decisionData).returning();
        return decision;
      }
      async updateAiDecision(id, updates) {
        const [decision] = await db.update(aiDecisions).set(updates).where(eq2(aiDecisions.id, id)).returning();
        return decision;
      }
      async getLatestAiDecisionForSymbol(symbol, strategyId) {
        const conditions = [eq2(aiDecisions.symbol, symbol.toUpperCase())];
        if (strategyId) {
          conditions.push(eq2(aiDecisions.strategyId, strategyId));
        }
        const [decision] = await db.select().from(aiDecisions).where(and(...conditions)).orderBy(desc(aiDecisions.createdAt)).limit(1);
        return decision;
      }
      async getOrdersByDecisionId(decisionId) {
        return db.select().from(orders).where(eq2(orders.decisionId, decisionId)).orderBy(desc(orders.submittedAt));
      }
      async getAiDecisionsByStatus(userId, status, limit4 = 100) {
        return db.select().from(aiDecisions).where(
          and(eq2(aiDecisions.userId, userId), eq2(aiDecisions.status, status))
        ).orderBy(desc(aiDecisions.createdAt)).limit(limit4);
      }
      async getPendingAiDecisions(userId, limit4 = 50) {
        return this.getAiDecisionsByStatus(userId, "pending", limit4);
      }
      async getAgentStatus() {
        const [status] = await db.select().from(agentStatus).limit(1);
        return status;
      }
      async updateAgentStatus(updates) {
        const existing = await this.getAgentStatus();
        if (existing) {
          const [status] = await db.update(agentStatus).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentStatus.id, existing.id)).returning();
          return status;
        } else {
          const [status] = await db.insert(agentStatus).values({
            isRunning: updates.isRunning ?? false,
            ...updates
          }).returning();
          return status;
        }
      }
      async createWorkItem(item) {
        const [workItem] = await db.insert(workItems).values(item).returning();
        return workItem;
      }
      async getWorkItem(id) {
        const [item] = await db.select().from(workItems).where(eq2(workItems.id, id));
        return item;
      }
      async getWorkItemByIdempotencyKey(key) {
        const [item] = await db.select().from(workItems).where(eq2(workItems.idempotencyKey, key));
        return item || null;
      }
      async updateWorkItem(id, updates) {
        const [item] = await db.update(workItems).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(workItems.id, id)).returning();
        return item;
      }
      async claimNextWorkItem(types) {
        const now = /* @__PURE__ */ new Date();
        const conditions = [
          eq2(workItems.status, "PENDING"),
          lte(workItems.nextRunAt, now)
        ];
        const query = db.select().from(workItems).where(and(...conditions)).orderBy(workItems.nextRunAt).limit(1);
        const [item] = await query;
        if (!item) return null;
        if (types && types.length > 0 && !types.includes(item.type)) {
          return null;
        }
        const [claimed] = await db.update(workItems).set({ status: "RUNNING", updatedAt: /* @__PURE__ */ new Date() }).where(and(eq2(workItems.id, item.id), eq2(workItems.status, "PENDING"))).returning();
        return claimed || null;
      }
      async getWorkItemCount(status, type) {
        const conditions = [];
        if (status) conditions.push(eq2(workItems.status, status));
        if (type) conditions.push(eq2(workItems.type, type));
        const result = await db.select({ count: sql18`count(*)` }).from(workItems).where(conditions.length > 0 ? and(...conditions) : void 0);
        return Number(result[0]?.count || 0);
      }
      async getWorkItems(limit4 = 50, status) {
        const conditions = status ? [eq2(workItems.status, status)] : [];
        return db.select().from(workItems).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(workItems.createdAt)).limit(limit4);
      }
      async createWorkItemRun(run) {
        const [itemRun] = await db.insert(workItemRuns).values(run).returning();
        return itemRun;
      }
      async getWorkItemRuns(workItemId) {
        return db.select().from(workItemRuns).where(eq2(workItemRuns.workItemId, workItemId)).orderBy(desc(workItemRuns.createdAt));
      }
      async getBrokerAsset(symbol) {
        const [asset] = await db.select().from(brokerAssets).where(eq2(brokerAssets.symbol, symbol.toUpperCase()));
        return asset;
      }
      async getBrokerAssets(assetClass, tradableOnly = false, limit4 = 1e3) {
        const conditions = [];
        if (assetClass) conditions.push(eq2(brokerAssets.assetClass, assetClass));
        if (tradableOnly) conditions.push(eq2(brokerAssets.tradable, true));
        return db.select().from(brokerAssets).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(brokerAssets.symbol).limit(limit4);
      }
      async upsertBrokerAsset(asset) {
        const [existing] = await db.select().from(brokerAssets).where(eq2(brokerAssets.symbol, asset.symbol.toUpperCase()));
        if (existing) {
          const [updated] = await db.update(brokerAssets).set({ ...asset, updatedAt: /* @__PURE__ */ new Date(), lastSyncedAt: /* @__PURE__ */ new Date() }).where(eq2(brokerAssets.id, existing.id)).returning();
          return updated;
        }
        const [created] = await db.insert(brokerAssets).values({ ...asset, symbol: asset.symbol.toUpperCase() }).returning();
        return created;
      }
      async bulkUpsertBrokerAssets(assets) {
        let count3 = 0;
        const batchSize = 100;
        for (let i = 0; i < assets.length; i += batchSize) {
          const batch = assets.slice(i, i + batchSize);
          for (const asset of batch) {
            await this.upsertBrokerAsset(asset);
            count3++;
          }
        }
        return count3;
      }
      async getBrokerAssetCount(assetClass) {
        const conditions = assetClass ? [eq2(brokerAssets.assetClass, assetClass)] : [];
        const result = await db.select({ count: sql18`count(*)` }).from(brokerAssets).where(conditions.length > 0 ? and(...conditions) : void 0);
        return Number(result[0]?.count || 0);
      }
      async getLastAssetSyncTime() {
        const [result] = await db.select({ lastSynced: sql18`MAX(last_synced_at)` }).from(brokerAssets);
        return result?.lastSynced || null;
      }
      async searchBrokerAssets(query, limit4 = 20) {
        const searchPattern = `%${query.toUpperCase()}%`;
        return db.select().from(brokerAssets).where(
          and(
            eq2(brokerAssets.tradable, true),
            or(
              like(brokerAssets.symbol, searchPattern),
              like(sql18`UPPER(${brokerAssets.name})`, searchPattern)
            )
          )
        ).orderBy(brokerAssets.symbol).limit(limit4);
      }
      async createOrder(order) {
        const [result] = await db.insert(orders).values(order).returning();
        return result;
      }
      async upsertOrderByBrokerOrderId(brokerOrderId, data) {
        const existing = await this.getOrderByBrokerOrderId(brokerOrderId);
        if (existing) {
          const [updated] = await db.update(orders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(orders.brokerOrderId, brokerOrderId)).returning();
          return updated;
        }
        try {
          const [created] = await db.insert(orders).values({ ...data, brokerOrderId }).returning();
          return created;
        } catch (error) {
          if (error.code === "23505" || error.message?.includes("duplicate")) {
            const [updated] = await db.update(orders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(orders.brokerOrderId, brokerOrderId)).returning();
            return updated;
          }
          throw error;
        }
      }
      async getOrderByBrokerOrderId(brokerOrderId) {
        const [result] = await db.select().from(orders).where(eq2(orders.brokerOrderId, brokerOrderId)).limit(1);
        return result;
      }
      async getOrderByClientOrderId(clientOrderId) {
        const [result] = await db.select().from(orders).where(eq2(orders.clientOrderId, clientOrderId)).limit(1);
        return result;
      }
      async getOrderById(id) {
        const [result] = await db.select().from(orders).where(eq2(orders.id, id)).limit(1);
        return result;
      }
      async getOrdersByStatus(userId, status, limit4 = 100) {
        return db.select().from(orders).where(and(eq2(orders.userId, userId), eq2(orders.status, status))).limit(limit4).orderBy(desc(orders.createdAt));
      }
      async getRecentOrders(userId, limit4 = 50) {
        if (userId) {
          return db.select().from(orders).where(eq2(orders.userId, userId)).orderBy(desc(orders.createdAt)).limit(limit4);
        }
        return db.select().from(orders).orderBy(desc(orders.createdAt)).limit(limit4);
      }
      /**
       * Get orders by strategy ID
       * NOTE: This is a stub implementation - orders table doesn't have strategyId column yet.
       * TODO: Add strategyId column to orders schema and implement proper query
       */
      async getOrdersByStrategy(_strategyId, _limit = 50) {
        return [];
      }
      async createFill(fill) {
        const [result] = await db.insert(fills).values(fill).returning();
        return result;
      }
      async getFillsByOrderId(orderId) {
        return db.select().from(fills).where(eq2(fills.orderId, orderId)).orderBy(desc(fills.occurredAt));
      }
      async getFillsByOrderIds(orderIds) {
        if (orderIds.length === 0) return [];
        return db.select().from(fills).where(inArray(fills.orderId, orderIds)).orderBy(desc(fills.occurredAt));
      }
      async getFillsByBrokerOrderId(brokerOrderId) {
        return db.select().from(fills).where(eq2(fills.brokerOrderId, brokerOrderId)).orderBy(desc(fills.occurredAt));
      }
      // ============================================================================
      // DEBATE ARENA
      // ============================================================================
      async createDebateSession(session) {
        const [result] = await db.insert(debateSessions).values(session).returning();
        return result;
      }
      async getDebateSession(id) {
        const [result] = await db.select().from(debateSessions).where(eq2(debateSessions.id, id));
        return result;
      }
      async getDebateSessions(limit4 = 50) {
        return db.select().from(debateSessions).orderBy(desc(debateSessions.createdAt)).limit(limit4);
      }
      async updateDebateSession(id, updates) {
        const [result] = await db.update(debateSessions).set(updates).where(eq2(debateSessions.id, id)).returning();
        return result;
      }
      async createDebateMessage(message) {
        const [result] = await db.insert(debateMessages).values(message).returning();
        return result;
      }
      async getDebateMessagesBySession(sessionId) {
        return db.select().from(debateMessages).where(eq2(debateMessages.sessionId, sessionId)).orderBy(debateMessages.createdAt);
      }
      async createDebateConsensus(consensus) {
        const [result] = await db.insert(debateConsensus).values(consensus).returning();
        return result;
      }
      async getDebateConsensusBySession(sessionId) {
        const [result] = await db.select().from(debateConsensus).where(eq2(debateConsensus.sessionId, sessionId));
        return result;
      }
      async updateDebateConsensus(id, updates) {
        const [result] = await db.update(debateConsensus).set(updates).where(eq2(debateConsensus.id, id)).returning();
        return result;
      }
      // ============================================================================
      // TRADER PROFILES & COMPETITION
      // ============================================================================
      async createTraderProfile(profile) {
        const [result] = await db.insert(traderProfiles).values(profile).returning();
        return result;
      }
      async getTraderProfile(id) {
        const [result] = await db.select().from(traderProfiles).where(eq2(traderProfiles.id, id));
        return result;
      }
      async getTraderProfiles() {
        return db.select().from(traderProfiles).orderBy(desc(traderProfiles.createdAt));
      }
      async updateTraderProfile(id, updates) {
        const [result] = await db.update(traderProfiles).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(traderProfiles.id, id)).returning();
        return result;
      }
      async createCompetitionRun(run) {
        const [result] = await db.insert(competitionRuns).values(run).returning();
        return result;
      }
      async getCompetitionRun(id) {
        const [result] = await db.select().from(competitionRuns).where(eq2(competitionRuns.id, id));
        return result;
      }
      async getCompetitionRuns(limit4 = 20) {
        return db.select().from(competitionRuns).orderBy(desc(competitionRuns.createdAt)).limit(limit4);
      }
      async updateCompetitionRun(id, updates) {
        const [result] = await db.update(competitionRuns).set(updates).where(eq2(competitionRuns.id, id)).returning();
        return result;
      }
      async createCompetitionScore(score) {
        const [result] = await db.insert(competitionScores).values(score).returning();
        return result;
      }
      async getCompetitionScoresByRun(runId) {
        return db.select().from(competitionScores).where(eq2(competitionScores.runId, runId)).orderBy(competitionScores.rank);
      }
      async updateCompetitionScore(id, updates) {
        const [result] = await db.update(competitionScores).set(updates).where(eq2(competitionScores.id, id)).returning();
        return result;
      }
      // ============================================================================
      // STRATEGY VERSIONS
      // ============================================================================
      async createStrategyVersion(version) {
        const [result] = await db.insert(strategyVersions).values(version).returning();
        return result;
      }
      async getStrategyVersion(id) {
        const [result] = await db.select().from(strategyVersions).where(eq2(strategyVersions.id, id));
        return result;
      }
      async getStrategyVersionsByStrategy(strategyId) {
        return db.select().from(strategyVersions).where(eq2(strategyVersions.strategyId, strategyId)).orderBy(desc(strategyVersions.version));
      }
      async getLatestStrategyVersion(strategyId) {
        const [result] = await db.select().from(strategyVersions).where(eq2(strategyVersions.strategyId, strategyId)).orderBy(desc(strategyVersions.version)).limit(1);
        return result;
      }
      async getNextVersionNumber(strategyId) {
        const latest = await this.getLatestStrategyVersion(strategyId);
        return (latest?.version || 0) + 1;
      }
      async updateStrategyVersion(id, updates) {
        const [result] = await db.update(strategyVersions).set(updates).where(eq2(strategyVersions.id, id)).returning();
        return result;
      }
      async getActiveStrategyVersions() {
        return db.select().from(strategyVersions).where(eq2(strategyVersions.status, "active")).orderBy(strategyVersions.createdAt);
      }
      // ============================================================================
      // TOOL INVOCATIONS
      // ============================================================================
      async createToolInvocation(invocation) {
        const [result] = await db.insert(toolInvocations).values(invocation).returning();
        return result;
      }
      async updateToolInvocation(id, updates) {
        const [result] = await db.update(toolInvocations).set(updates).where(eq2(toolInvocations.id, id)).returning();
        return result;
      }
      async getToolInvocationsByTrace(traceId) {
        return db.select().from(toolInvocations).where(eq2(toolInvocations.traceId, traceId)).orderBy(toolInvocations.createdAt);
      }
      async getToolInvocationsBySession(sessionId) {
        return db.select().from(toolInvocations).where(eq2(toolInvocations.debateSessionId, sessionId)).orderBy(toolInvocations.createdAt);
      }
      async getRecentToolInvocations(limit4 = 100) {
        return db.select().from(toolInvocations).orderBy(desc(toolInvocations.createdAt)).limit(limit4);
      }
      // ============================================================================
      // AUDIT LOGGING
      // ============================================================================
      async createAuditLog(logEntry) {
        try {
          const [result] = await db.insert(auditLogs).values(logEntry).returning();
          return result;
        } catch (error) {
          log.error("Storage", "Failed to create audit log", { error });
          throw error;
        }
      }
      async getUserAuditLogs(userId, limit4 = 100, offset = 0) {
        try {
          return db.select().from(auditLogs).where(eq2(auditLogs.userId, userId)).orderBy(desc(auditLogs.timestamp)).limit(limit4).offset(offset);
        } catch (error) {
          log.error("Storage", "Failed to get user audit logs", { error, userId });
          return [];
        }
      }
      async getResourceAuditLogs(resource, resourceId, limit4 = 50) {
        try {
          return db.select().from(auditLogs).where(
            and(
              eq2(auditLogs.resource, resource),
              eq2(auditLogs.resourceId, resourceId)
            )
          ).orderBy(desc(auditLogs.timestamp)).limit(limit4);
        } catch (error) {
          log.error("Storage", "Failed to get resource audit logs", {
            error,
            resource,
            resourceId
          });
          return [];
        }
      }
      async getRecentAuditLogs(limit4 = 100, offset = 0) {
        try {
          return db.select().from(auditLogs).orderBy(desc(auditLogs.timestamp)).limit(limit4).offset(offset);
        } catch (error) {
          log.error("Storage", "Failed to get recent audit logs", { error });
          return [];
        }
      }
      // ========================================
      // User Preferences Methods
      // ========================================
      async getUserPreferences(userId) {
        try {
          const [prefs] = await db.select().from(userPreferences).where(eq2(userPreferences.userId, userId));
          return prefs || null;
        } catch (error) {
          log.error("Storage", "Failed to get user preferences", { error, userId });
          return null;
        }
      }
      async createUserPreferences(userId, prefs) {
        const [created] = await db.insert(userPreferences).values({
          userId,
          ...defaultUserPreferences,
          ...prefs
        }).returning();
        return created;
      }
      async updateUserPreferences(userId, updates) {
        try {
          const [updated] = await db.update(userPreferences).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(userPreferences.userId, userId)).returning();
          return updated || null;
        } catch (error) {
          log.error("Storage", "Failed to update user preferences", {
            error,
            userId
          });
          return null;
        }
      }
      async getOrCreateUserPreferences(userId) {
        const existing = await this.getUserPreferences(userId);
        if (existing) return existing;
        return this.createUserPreferences(userId);
      }
      async deleteUserPreferences(userId) {
        try {
          const result = await db.delete(userPreferences).where(eq2(userPreferences.userId, userId)).returning();
          return result.length > 0;
        } catch (error) {
          log.error("Storage", "Failed to delete user preferences", {
            error,
            userId
          });
          return false;
        }
      }
      // ========================================
      // Notification Preferences Methods
      // ========================================
      async getNotificationPreferences(userId) {
        try {
          const [prefs] = await db.select().from(notificationPreferences).where(eq2(notificationPreferences.userId, userId));
          return prefs || null;
        } catch (error) {
          log.error("Storage", "Failed to get notification preferences", {
            error,
            userId
          });
          return null;
        }
      }
      async createDefaultNotificationPreferences(userId, prefs) {
        const [created] = await db.insert(notificationPreferences).values({
          userId,
          ...defaultNotificationPreferences,
          ...prefs
        }).returning();
        return created;
      }
      async updateNotificationPreferences(userId, updates) {
        try {
          const [updated] = await db.update(notificationPreferences).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(notificationPreferences.userId, userId)).returning();
          return updated || null;
        } catch (error) {
          log.error("Storage", "Failed to update notification preferences", {
            error,
            userId
          });
          return null;
        }
      }
      async getOrCreateNotificationPreferences(userId) {
        const existing = await this.getNotificationPreferences(userId);
        if (existing) return existing;
        return this.createDefaultNotificationPreferences(userId);
      }
      async deleteNotificationPreferences(userId) {
        try {
          const result = await db.delete(notificationPreferences).where(eq2(notificationPreferences.userId, userId)).returning();
          return result.length > 0;
        } catch (error) {
          log.error("Storage", "Failed to delete notification preferences", {
            error,
            userId
          });
          return false;
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/config/env-helpers.ts
function getEnvString(key, defaultValue) {
  const value = process.env[key];
  if (value === void 0 || value === "") {
    if (defaultValue !== void 0) {
      return defaultValue;
    }
    throw new Error(`Missing required environment variable: ${key}`);
  }
  return value;
}
function getEnvFloat(key, defaultValue) {
  const value = process.env[key];
  if (value === void 0 || value === "") {
    if (defaultValue !== void 0) return defaultValue;
    throw new Error(`Missing required environment variable: ${key}`);
  }
  const parsed = parseFloat(value);
  if (isNaN(parsed)) {
    throw new Error(
      `Environment variable ${key} must be a number, got: ${value}`
    );
  }
  return parsed;
}
var init_env_helpers = __esm({
  "server/config/env-helpers.ts"() {
    "use strict";
  }
});

// server/config/trading-config.ts
var trading_config_exports = {};
__export(trading_config_exports, {
  alpacaConfig: () => alpacaConfig,
  default: () => trading_config_default,
  getAlpacaBaseUrl: () => getAlpacaBaseUrl,
  getConfigSummary: () => getConfigSummary,
  orderExecutionConfig: () => orderExecutionConfig,
  orderRetryConfig: () => orderRetryConfig,
  queueConfig: () => queueConfig,
  riskManagementConfig: () => riskManagementConfig,
  tradingConfig: () => tradingConfig,
  universeConfig: () => universeConfig,
  validateTradingConfig: () => validateTradingConfig
});
function getAlpacaBaseUrl() {
  return tradingConfig.alpaca.tradingMode === "live" ? tradingConfig.alpaca.liveUrl : tradingConfig.alpaca.paperUrl;
}
function getConfigSummary() {
  return {
    tradingMode: tradingConfig.alpaca.tradingMode,
    alpacaUrl: getAlpacaBaseUrl(),
    riskProfile: {
      maxPositionSize: `${tradingConfig.riskManagement.defaultMaxPositionSizePercent}%`,
      maxExposure: `${tradingConfig.riskManagement.defaultMaxExposurePercent}%`,
      stopLoss: `${tradingConfig.riskManagement.defaultHardStopLossPercent}%`,
      takeProfit: `${tradingConfig.riskManagement.defaultTakeProfitPercent}%`
    },
    universe: {
      maxStocks: tradingConfig.universe.maxStockSymbolsPerCycle,
      maxCrypto: tradingConfig.universe.maxCryptoSymbolsPerCycle,
      minConfidence: tradingConfig.universe.minConfidenceForUniverse
    },
    orderRetry: {
      maxRetries: tradingConfig.orderRetry.maxRetriesPerOrder,
      backoffBaseMs: tradingConfig.orderRetry.retryBackoffBaseMs,
      circuitBreakerThreshold: tradingConfig.orderRetry.circuitBreakerThreshold
    }
  };
}
function validateTradingConfig() {
  const errors = [];
  if (!["paper", "live"].includes(tradingConfig.alpaca.tradingMode)) {
    errors.push(
      `Invalid trading mode: ${tradingConfig.alpaca.tradingMode}. Must be 'paper' or 'live'.`
    );
  }
  if (!tradingConfig.alpaca.paperUrl.startsWith("http")) {
    errors.push(`Invalid paper URL: ${tradingConfig.alpaca.paperUrl}`);
  }
  if (!tradingConfig.alpaca.liveUrl.startsWith("http")) {
    errors.push(`Invalid live URL: ${tradingConfig.alpaca.liveUrl}`);
  }
  if (tradingConfig.orderRetry.maxRetriesPerOrder < 0 || tradingConfig.orderRetry.maxRetriesPerOrder > 10) {
    errors.push(
      `Max retries must be between 0 and 10, got: ${tradingConfig.orderRetry.maxRetriesPerOrder}`
    );
  }
  if (tradingConfig.orderRetry.retryBackoffBaseMs < 100 || tradingConfig.orderRetry.retryBackoffBaseMs > 3e4) {
    errors.push(
      `Retry backoff base must be between 100ms and 30000ms, got: ${tradingConfig.orderRetry.retryBackoffBaseMs}`
    );
  }
  if (tradingConfig.orderExecution.orderFillPollIntervalMs < 100 || tradingConfig.orderExecution.orderFillPollIntervalMs > 5e3) {
    errors.push(
      `Poll interval must be between 100ms and 5000ms, got: ${tradingConfig.orderExecution.orderFillPollIntervalMs}`
    );
  }
  if (tradingConfig.riskManagement.defaultHardStopLossPercent <= 0 || tradingConfig.riskManagement.defaultHardStopLossPercent > 50) {
    errors.push(
      `Stop loss percent must be between 0 and 50, got: ${tradingConfig.riskManagement.defaultHardStopLossPercent}`
    );
  }
  if (tradingConfig.riskManagement.defaultTakeProfitPercent <= 0 || tradingConfig.riskManagement.defaultTakeProfitPercent > 100) {
    errors.push(
      `Take profit percent must be between 0 and 100, got: ${tradingConfig.riskManagement.defaultTakeProfitPercent}`
    );
  }
  if (tradingConfig.riskManagement.defaultMaxPositionSizePercent <= 0 || tradingConfig.riskManagement.defaultMaxPositionSizePercent > 100) {
    errors.push(
      `Max position size must be between 0 and 100, got: ${tradingConfig.riskManagement.defaultMaxPositionSizePercent}`
    );
  }
  if (tradingConfig.universe.maxStockSymbolsPerCycle < 1 || tradingConfig.universe.maxStockSymbolsPerCycle > 1e4) {
    errors.push(
      `Max stock symbols must be between 1 and 10000, got: ${tradingConfig.universe.maxStockSymbolsPerCycle}`
    );
  }
  if (tradingConfig.universe.minConfidenceForUniverse < 0 || tradingConfig.universe.minConfidenceForUniverse > 1) {
    errors.push(
      `Min confidence must be between 0 and 1, got: ${tradingConfig.universe.minConfidenceForUniverse}`
    );
  }
  if (tradingConfig.universe.alpacaSnapshotChunkSize < 1 || tradingConfig.universe.alpacaSnapshotChunkSize > 100) {
    errors.push(
      `Snapshot chunk size must be between 1 and 100, got: ${tradingConfig.universe.alpacaSnapshotChunkSize}`
    );
  }
  if (errors.length > 0) {
    throw new Error(
      `Trading configuration validation failed:
${errors.join("\n")}`
    );
  }
}
var alpacaConfig, orderRetryConfig, orderExecutionConfig, riskManagementConfig, universeConfig, queueConfig, tradingConfig, trading_config_default;
var init_trading_config = __esm({
  "server/config/trading-config.ts"() {
    "use strict";
    init_env_helpers();
    alpacaConfig = Object.freeze({
      // Trading mode: 'paper' or 'live'
      tradingMode: getEnvString("ALPACA_TRADING_MODE", "paper"),
      // Paper trading URL (default for testing)
      paperUrl: getEnvString(
        "ALPACA_PAPER_URL",
        "https://paper-api.alpaca.markets"
      ),
      // Live trading URL (use with caution!)
      liveUrl: getEnvString("ALPACA_LIVE_URL", "https://api.alpaca.markets"),
      // Market data URL (same for both paper and live)
      dataUrl: getEnvString("ALPACA_DATA_URL", "https://data.alpaca.markets"),
      // WebSocket streaming URL (same for both paper and live)
      streamUrl: getEnvString(
        "ALPACA_STREAM_URL",
        "wss://stream.data.alpaca.markets"
      )
    });
    orderRetryConfig = Object.freeze({
      // Maximum number of retry attempts per order before giving up
      maxRetriesPerOrder: getEnvFloat("MAX_RETRIES_PER_ORDER", 3),
      // Base delay in milliseconds for exponential backoff (doubles each retry)
      // Formula: delay = retryBackoffBaseMs * 2^(attemptNumber - 1)
      // Example: 2000ms, 4000ms, 8000ms for 3 attempts
      retryBackoffBaseMs: getEnvFloat("RETRY_BACKOFF_BASE_MS", 2e3),
      // Circuit breaker: number of failures before opening circuit
      circuitBreakerThreshold: getEnvFloat("CIRCUIT_BREAKER_THRESHOLD", 10),
      // Circuit breaker: time window in ms to count failures (1 minute default)
      circuitBreakerWindowMs: getEnvFloat("CIRCUIT_BREAKER_WINDOW_MS", 6e4),
      // Circuit breaker: cooldown period before auto-reset (5 minutes default)
      circuitBreakerResetMs: getEnvFloat("CIRCUIT_BREAKER_RESET_MS", 3e5)
    });
    orderExecutionConfig = Object.freeze({
      // Polling interval in ms to check if order is filled (500ms default)
      orderFillPollIntervalMs: getEnvFloat("ORDER_FILL_POLL_INTERVAL_MS", 500),
      // Maximum time in ms to wait for order fill before timing out (30 seconds default)
      orderFillTimeoutMs: getEnvFloat("ORDER_FILL_TIMEOUT_MS", 3e4),
      // Maximum age in ms for unfilled orders before auto-cancellation (5 minutes default)
      staleOrderTimeoutMs: getEnvFloat("STALE_ORDER_TIMEOUT_MS", 3e5)
    });
    riskManagementConfig = Object.freeze({
      // Default hard stop loss percentage (exit when position loses this much)
      defaultHardStopLossPercent: getEnvFloat("DEFAULT_HARD_STOP_LOSS_PERCENT", 3),
      // Default take profit percentage (exit when position gains this much)
      defaultTakeProfitPercent: getEnvFloat("DEFAULT_TAKE_PROFIT_PERCENT", 6),
      // Maximum position size as percentage of portfolio (10% = conservative, 15% = aggressive)
      defaultMaxPositionSizePercent: getEnvFloat(
        "DEFAULT_MAX_POSITION_SIZE_PERCENT",
        15
      ),
      // Maximum total exposure as percentage of portfolio
      // 100% = fully invested, 200% = 2x leverage (margin account)
      defaultMaxExposurePercent: getEnvFloat("DEFAULT_MAX_EXPOSURE_PERCENT", 200)
    });
    universeConfig = Object.freeze({
      // Maximum number of stock symbols to analyze per cycle
      // Conservative: 120, Moderate: 300, Aggressive: 500
      maxStockSymbolsPerCycle: getEnvFloat("MAX_STOCK_SYMBOLS_PER_CYCLE", 500),
      // Maximum number of crypto symbols to analyze per cycle
      // Conservative: 20, Moderate: 50, Aggressive: 100
      maxCryptoSymbolsPerCycle: getEnvFloat("MAX_CRYPTO_SYMBOLS_PER_CYCLE", 100),
      // Minimum AI confidence score (0-1) to include symbol in universe
      // Conservative: 0.70, Moderate: 0.60, Aggressive: 0.50
      minConfidenceForUniverse: getEnvFloat("MIN_CONFIDENCE_FOR_UNIVERSE", 0.5),
      // Number of symbols to fetch per Alpaca snapshot API request
      // Max supported: 100, Recommended: 50 for reliability
      alpacaSnapshotChunkSize: getEnvFloat("ALPACA_SNAPSHOT_CHUNK_SIZE", 50)
    });
    queueConfig = Object.freeze({
      // Interval in ms to poll work queue for pending tasks (2 seconds default)
      queuePollIntervalMs: getEnvFloat("QUEUE_POLL_INTERVAL_MS", 2e3),
      // Maximum time in ms for a work item to complete before timing out (1 minute default)
      queuePollTimeoutMs: getEnvFloat("QUEUE_POLL_TIMEOUT_MS", 6e4),
      // Interval in ms to send heartbeat signals (30 seconds default)
      heartbeatIntervalMs: getEnvFloat("HEARTBEAT_INTERVAL_MS", 3e4)
    });
    tradingConfig = Object.freeze({
      alpaca: alpacaConfig,
      orderRetry: orderRetryConfig,
      orderExecution: orderExecutionConfig,
      riskManagement: riskManagementConfig,
      universe: universeConfig,
      queue: queueConfig
    });
    trading_config_default = tradingConfig;
  }
});

// server/lib/rateLimiter.ts
var rateLimiter_exports = {};
__export(rateLimiter_exports, {
  addProviderLimits: () => addProviderLimits,
  getAllProviderStatus: () => getAllProviderStatus,
  getLimiter: () => getLimiter,
  getProviderLimits: () => getProviderLimits,
  getProviderStatus: () => getProviderStatus,
  isProviderConfigured: () => isProviderConfigured,
  wrapWithLimiter: () => wrapWithLimiter
});
import Bottleneck from "bottleneck";
function getLimiter(provider) {
  if (limiters.has(provider)) {
    return limiters.get(provider);
  }
  const limits = PROVIDER_LIMITS[provider] || {
    maxPerMinute: 60,
    maxConcurrent: 5
  };
  const limiter = new Bottleneck({
    maxConcurrent: limits.maxConcurrent || 5,
    minTime: limits.minTime || 0,
    reservoir: limits.maxPerMinute,
    reservoirRefreshAmount: limits.maxPerMinute,
    reservoirRefreshInterval: 60 * 1e3
  });
  if (limits.maxPerSecond) {
    const secondLimiter = new Bottleneck({
      reservoir: limits.maxPerSecond,
      reservoirRefreshAmount: limits.maxPerSecond,
      reservoirRefreshInterval: 1e3
    });
    secondLimiters.set(provider, secondLimiter);
    limiter.chain(secondLimiter);
    log.debug(
      "RateLimiter",
      `[${provider}] Per-second limiter: ${limits.maxPerSecond}/s`
    );
  }
  if (limits.maxPerHour) {
    const hourlyLimiter = new Bottleneck({
      reservoir: limits.maxPerHour,
      reservoirRefreshAmount: limits.maxPerHour,
      reservoirRefreshInterval: 60 * 60 * 1e3
    });
    hourlyLimiters.set(provider, hourlyLimiter);
    limiter.chain(hourlyLimiter);
    log.debug(
      "RateLimiter",
      `[${provider}] Per-hour limiter: ${limits.maxPerHour}/h`
    );
  }
  if (limits.maxPerDay) {
    const dailyLimiter = new Bottleneck({
      reservoir: limits.maxPerDay,
      reservoirRefreshAmount: limits.maxPerDay,
      reservoirRefreshInterval: 24 * 60 * 60 * 1e3
    });
    dailyLimiters.set(provider, dailyLimiter);
    limiter.chain(dailyLimiter);
    log.debug(
      "RateLimiter",
      `[${provider}] Per-day limiter: ${limits.maxPerDay}/d`
    );
  }
  limiter.on("failed", (error, jobInfo) => {
    log.warn(
      "RateLimiter",
      `[${provider}] Job failed: ${error.message}`
    );
    if (jobInfo.retryCount < 3) {
      return 1e3 * Math.pow(2, jobInfo.retryCount);
    }
    return void 0;
  });
  limiter.on("depleted", () => {
    log.debug(
      "RateLimiter",
      `[${provider}] Rate limit depleted, requests queued`
    );
  });
  limiters.set(provider, limiter);
  return limiter;
}
function wrapWithLimiter(provider, fn) {
  return getLimiter(provider).schedule(fn);
}
async function getProviderStatus(provider) {
  const limiter = limiters.get(provider);
  const secondLimiter = secondLimiters.get(provider);
  const hourlyLimiter = hourlyLimiters.get(provider);
  const dailyLimiter = dailyLimiters.get(provider);
  if (!limiter) {
    return {
      running: 0,
      queued: 0,
      reservoir: null,
      secondReservoir: null,
      hourlyReservoir: null,
      dailyReservoir: null
    };
  }
  const counts = limiter.counts();
  const [reservoir, secondReservoir, hourlyReservoir, dailyReservoir] = await Promise.all([
    limiter.currentReservoir(),
    secondLimiter?.currentReservoir() ?? Promise.resolve(null),
    hourlyLimiter?.currentReservoir() ?? Promise.resolve(null),
    dailyLimiter?.currentReservoir() ?? Promise.resolve(null)
  ]);
  return {
    running: counts.RUNNING,
    queued: counts.QUEUED,
    reservoir,
    secondReservoir,
    hourlyReservoir,
    dailyReservoir
  };
}
async function getAllProviderStatus() {
  const status = {};
  const providers3 = Object.keys(PROVIDER_LIMITS);
  const results = await Promise.all(providers3.map((p) => getProviderStatus(p)));
  providers3.forEach((p, i) => {
    status[p] = results[i];
  });
  return status;
}
function getProviderLimits(provider) {
  return PROVIDER_LIMITS[provider];
}
function isProviderConfigured(provider) {
  return provider in PROVIDER_LIMITS;
}
function addProviderLimits(provider, limits) {
  PROVIDER_LIMITS[provider] = limits;
  limiters.delete(provider);
  secondLimiters.delete(provider);
  hourlyLimiters.delete(provider);
  dailyLimiters.delete(provider);
}
var PROVIDER_LIMITS, limiters, secondLimiters, hourlyLimiters, dailyLimiters;
var init_rateLimiter = __esm({
  "server/lib/rateLimiter.ts"() {
    "use strict";
    init_logger();
    PROVIDER_LIMITS = {
      "sec-edgar": { maxPerSecond: 10, maxConcurrent: 5, minTime: 100 },
      "alpha-vantage": {
        maxPerDay: 25,
        maxPerMinute: 5,
        maxConcurrent: 1,
        minTime: 12e3
      },
      yfinance: { maxPerHour: 2e3, maxPerMinute: 60, maxConcurrent: 3 },
      "polygon-free": { maxPerMinute: 5, maxConcurrent: 1, minTime: 12e3 },
      binance: { maxPerMinute: 1200, maxConcurrent: 10 },
      defillama: { maxPerMinute: 60, maxConcurrent: 5 },
      cryptocompare: { maxPerSecond: 50, maxPerDay: 2e5, maxConcurrent: 10 },
      fred: { maxPerMinute: 120, maxConcurrent: 5 },
      reddit: { maxPerMinute: 100, maxConcurrent: 2 },
      stocktwits: { maxPerMinute: 200, maxConcurrent: 3 },
      "yahoo-scrape": { maxPerMinute: 60, maxConcurrent: 2, minTime: 1e3 },
      "huggingface-inference": { maxPerMinute: 30, maxConcurrent: 2 },
      alpaca: { maxPerMinute: 180, maxConcurrent: 5, minTime: 333 },
      finnhub: { maxPerMinute: 50, maxConcurrent: 3, minTime: 1200 },
      coingecko: {
        maxPerMinute: 10,
        maxPerDay: 500,
        maxConcurrent: 2,
        minTime: 2100
      },
      newsapi: { maxPerDay: 80, maxConcurrent: 1, minTime: 3e3 },
      twelvedata: {
        maxPerMinute: 6,
        maxPerDay: 700,
        maxConcurrent: 2,
        minTime: 1e4
      },
      valyu: { maxPerDay: 100, maxConcurrent: 1, minTime: 5e3 },
      jina: { maxPerMinute: 30, maxConcurrent: 3, minTime: 2e3 },
      gdelt: { maxPerMinute: 60, maxConcurrent: 3 },
      openai: { maxPerMinute: 60, maxConcurrent: 5 },
      claude: { maxPerMinute: 50, maxConcurrent: 3 },
      openrouter: { maxPerMinute: 100, maxConcurrent: 5 },
      groq: { maxPerMinute: 30, maxConcurrent: 3 },
      together: { maxPerMinute: 60, maxConcurrent: 5 },
      deepseek: { maxPerMinute: 60, maxConcurrent: 3 }
    };
    limiters = /* @__PURE__ */ new Map();
    secondLimiters = /* @__PURE__ */ new Map();
    hourlyLimiters = /* @__PURE__ */ new Map();
    dailyLimiters = /* @__PURE__ */ new Map();
  }
});

// server/utils/money.ts
import Decimal from "decimal.js";
function toDecimal(value, defaultValue = 0) {
  if (value === null || value === void 0 || value === "") {
    return new Decimal(defaultValue ?? 0);
  }
  try {
    const d = new Decimal(value);
    if (!d.isFinite()) {
      return new Decimal(defaultValue ?? 0);
    }
    return d;
  } catch {
    return new Decimal(defaultValue ?? 0);
  }
}
function toNumber(value) {
  if (value instanceof Decimal) {
    return value.toNumber();
  }
  return toDecimal(value).toNumber();
}
function priceWithBuffer(price, bufferPercent, direction = 1) {
  const p = toDecimal(price);
  const buffer = p.times(toDecimal(bufferPercent));
  return direction === 1 ? p.plus(buffer) : p.minus(buffer);
}
function roundPrice(price, decimals = 2) {
  return toDecimal(price).toDecimalPlaces(decimals, Decimal.ROUND_HALF_UP);
}
function formatPrice(price, decimals = 2) {
  const d = toDecimal(price);
  if (!d.isFinite()) return "0.00";
  return d.toFixed(decimals);
}
function calculateQuantity(notional, price) {
  const p = toDecimal(price);
  if (p.isZero()) return new Decimal(0);
  return toDecimal(notional).dividedBy(p);
}
function calculateWholeShares(notional, price) {
  return calculateQuantity(notional, price).floor();
}
function partialQuantity(quantity, percent) {
  return toDecimal(quantity).times(toDecimal(percent)).dividedBy(100);
}
function calculatePnL(entryPrice, exitPrice, quantity, side = "long") {
  const entry = toDecimal(entryPrice);
  const exit = toDecimal(exitPrice);
  const qty = toDecimal(quantity);
  if (!entry.isFinite() || !exit.isFinite() || !qty.isFinite()) {
    return new Decimal(0);
  }
  if (side === "long") {
    return exit.minus(entry).times(qty);
  } else {
    return entry.minus(exit).times(qty);
  }
}
function percentChange(current, previous) {
  const prev = toDecimal(previous);
  if (prev.isZero()) return new Decimal(0);
  const curr = toDecimal(current);
  return curr.minus(prev).dividedBy(prev).times(100);
}
function percentOf(value, percent) {
  return toDecimal(value).times(toDecimal(percent)).dividedBy(100);
}
function positionValue(quantity, price) {
  return toDecimal(quantity).times(toDecimal(price));
}
function calculateSlippage(price, slippageBps, side) {
  const p = toDecimal(price);
  const slippage = p.times(toDecimal(slippageBps)).dividedBy(1e4);
  return side === "buy" ? slippage : slippage.negated();
}
function calculateFeePercent(notional, feePercent) {
  return toDecimal(notional).times(toDecimal(feePercent)).dividedBy(100);
}
function trailingStopPrice(highWaterMark, trailPercent) {
  const hwm = toDecimal(highWaterMark);
  const trail = percentOf(hwm, trailPercent);
  return hwm.minus(trail);
}
function kellyFraction(winRate, avgWin, avgLoss) {
  const w = toDecimal(winRate);
  const win = toDecimal(avgWin);
  const loss = toDecimal(avgLoss).abs();
  if (win.isZero() || loss.isZero()) return new Decimal(0);
  const lossRate = new Decimal(1).minus(w);
  const winLossRatio = win.dividedBy(loss);
  const kelly = winLossRatio.times(w).minus(lossRate).dividedBy(winLossRatio);
  return Decimal.max(kelly, 0);
}
function kellySuggestedSize(portfolioValue, kellyFrac, fraction = 0.25, maxPercent = 10) {
  const adjustedKelly = toDecimal(kellyFrac).times(toDecimal(fraction));
  const kellyPercent = adjustedKelly.times(100);
  const cappedPercent = Decimal.min(kellyPercent, toDecimal(maxPercent));
  return percentOf(portfolioValue, cappedPercent);
}
function mean(values) {
  if (values.length === 0) return new Decimal(0);
  const sum = values.reduce(
    (acc, v) => acc.plus(toDecimal(v)),
    new Decimal(0)
  );
  return sum.dividedBy(values.length);
}
function variance(values) {
  if (values.length < 2) return new Decimal(0);
  const avg = mean(values);
  const squaredDiffs = values.map((v) => toDecimal(v).minus(avg).pow(2));
  return mean(squaredDiffs);
}
function stdDev(values) {
  return variance(values).sqrt();
}
function sharpeRatio(returns, riskFreeRate = 0, periodsPerYear = 252) {
  if (returns.length === 0) return new Decimal(0);
  const avgReturn = mean(returns);
  const std = stdDev(returns);
  if (std.isZero()) return new Decimal(0);
  const rf = toDecimal(riskFreeRate).dividedBy(periodsPerYear);
  const excessReturn = avgReturn.minus(rf);
  const annualizationFactor = new Decimal(periodsPerYear).sqrt();
  return excessReturn.dividedBy(std).times(annualizationFactor);
}
function zScore(value, avg, std) {
  const s = toDecimal(std);
  if (s.isZero()) return new Decimal(0);
  return toDecimal(value).minus(toDecimal(avg)).dividedBy(s);
}
var init_money = __esm({
  "server/utils/money.ts"() {
    "use strict";
    Decimal.set({
      precision: 20,
      // High precision for intermediate calculations
      rounding: Decimal.ROUND_HALF_UP,
      // Standard financial rounding
      toExpNeg: -9,
      // Don't use exponential notation for small numbers
      toExpPos: 21
      // Don't use exponential notation for large numbers
    });
  }
});

// server/utils/numeric.ts
function safeParseFloat(value, defaultValue = 0) {
  if (value === null || value === void 0 || value === "") {
    return defaultValue;
  }
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : defaultValue;
  }
  const trimmed = value.trim();
  if (trimmed === "") {
    return defaultValue;
  }
  return toNumber(toDecimal(trimmed, defaultValue));
}
var init_numeric = __esm({
  "server/utils/numeric.ts"() {
    "use strict";
    init_money();
  }
});

// server/lib/performance-metrics.ts
var performance_metrics_exports = {};
__export(performance_metrics_exports, {
  performanceTracker: () => performanceTracker
});
function createEmptyMetric() {
  return {
    count: 0,
    totalMs: 0,
    minMs: Infinity,
    maxMs: 0,
    p50Ms: 0,
    p95Ms: 0,
    p99Ms: 0,
    samples: []
  };
}
function calculatePercentile(samples, percentile) {
  if (samples.length === 0) return 0;
  const sorted = [...samples].sort((a, b) => a - b);
  const index18 = Math.ceil(percentile / 100 * sorted.length) - 1;
  return sorted[Math.max(0, index18)];
}
function updateMetric(metric, durationMs) {
  metric.count++;
  metric.totalMs += durationMs;
  metric.minMs = Math.min(metric.minMs, durationMs);
  metric.maxMs = Math.max(metric.maxMs, durationMs);
  metric.samples.push(durationMs);
  if (metric.samples.length > MAX_SAMPLES) {
    metric.samples.shift();
  }
  metric.p50Ms = calculatePercentile(metric.samples, 50);
  metric.p95Ms = calculatePercentile(metric.samples, 95);
  metric.p99Ms = calculatePercentile(metric.samples, 99);
}
var MAX_SAMPLES, PerformanceTracker, performanceTracker;
var init_performance_metrics = __esm({
  "server/lib/performance-metrics.ts"() {
    "use strict";
    MAX_SAMPLES = 1e3;
    PerformanceTracker = class {
      metrics = {
        orderExecution: createEmptyMetric(),
        quoteRetrieval: createEmptyMetric(),
        aiDecision: createEmptyMetric(),
        databaseQuery: createEmptyMetric(),
        apiCall: createEmptyMetric()
      };
      startTimes = /* @__PURE__ */ new Map();
      startTimer(operationId) {
        this.startTimes.set(operationId, Date.now());
      }
      endTimer(operationId, metricType) {
        const startTime = this.startTimes.get(operationId);
        if (!startTime) return 0;
        const durationMs = Date.now() - startTime;
        this.startTimes.delete(operationId);
        updateMetric(this.metrics[metricType], durationMs);
        return durationMs;
      }
      recordLatency(metricType, durationMs) {
        updateMetric(this.metrics[metricType], durationMs);
      }
      async measure(metricType, operation) {
        const start = Date.now();
        const result = await operation();
        const durationMs = Date.now() - start;
        updateMetric(this.metrics[metricType], durationMs);
        return { result, durationMs };
      }
      getMetrics() {
        return { ...this.metrics };
      }
      getMetricSummary(metricType) {
        const metric = this.metrics[metricType];
        return {
          avgMs: metric.count > 0 ? metric.totalMs / metric.count : 0,
          minMs: metric.minMs === Infinity ? 0 : metric.minMs,
          maxMs: metric.maxMs,
          p50Ms: metric.p50Ms,
          p95Ms: metric.p95Ms,
          p99Ms: metric.p99Ms,
          count: metric.count
        };
      }
      getSLOStatus() {
        return {
          orderExecutionP99Under50ms: this.metrics.orderExecution.p99Ms < 50,
          quoteRetrievalP99Under10ms: this.metrics.quoteRetrieval.p99Ms < 10,
          aiDecisionP99Under5s: this.metrics.aiDecision.p99Ms < 5e3
        };
      }
      reset() {
        this.metrics = {
          orderExecution: createEmptyMetric(),
          quoteRetrieval: createEmptyMetric(),
          aiDecision: createEmptyMetric(),
          databaseQuery: createEmptyMetric(),
          apiCall: createEmptyMetric()
        };
        this.startTimes.clear();
      }
    };
    performanceTracker = new PerformanceTracker();
  }
});

// server/lib/api-cache.ts
var DEFAULT_FRESH_DURATION, DEFAULT_STALE_DURATION, DEFAULT_MAX_ENTRIES, ApiCache, marketDataCache, stockQuoteCache, cryptoPriceCache, newsCache, assetListCache, portfolioCache;
var init_api_cache = __esm({
  "server/lib/api-cache.ts"() {
    "use strict";
    init_logger();
    DEFAULT_FRESH_DURATION = 60 * 1e3;
    DEFAULT_STALE_DURATION = 30 * 60 * 1e3;
    DEFAULT_MAX_ENTRIES = 1e3;
    ApiCache = class {
      cache = /* @__PURE__ */ new Map();
      config;
      constructor(config2 = {}) {
        this.config = {
          freshDuration: config2.freshDuration ?? DEFAULT_FRESH_DURATION,
          staleDuration: config2.staleDuration ?? DEFAULT_STALE_DURATION,
          maxEntries: config2.maxEntries ?? DEFAULT_MAX_ENTRIES
        };
      }
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        const now = Date.now();
        if (now - entry.timestamp < this.config.freshDuration) {
          return { data: entry.data, isFresh: true };
        }
        if (now - entry.timestamp < this.config.staleDuration) {
          return { data: entry.data, isFresh: false };
        }
        this.cache.delete(key);
        return null;
      }
      getFresh(key) {
        const result = this.get(key);
        return result?.isFresh ? result.data : null;
      }
      getStale(key) {
        const result = this.get(key);
        return result?.data ?? null;
      }
      set(key, data) {
        if (this.cache.size >= this.config.maxEntries) {
          this.evictOldest();
        }
        const now = Date.now();
        this.cache.set(key, {
          data,
          timestamp: now,
          staleTimestamp: now + this.config.staleDuration
        });
      }
      evictOldest() {
        let oldestKey = null;
        let oldestTime = Infinity;
        for (const [key, entry] of this.cache.entries()) {
          if (entry.timestamp < oldestTime) {
            oldestTime = entry.timestamp;
            oldestKey = key;
          }
        }
        if (oldestKey) {
          this.cache.delete(oldestKey);
        }
      }
      has(key) {
        return this.get(key) !== null;
      }
      clear() {
        this.cache.clear();
      }
      size() {
        return this.cache.size;
      }
      getStats() {
        const now = Date.now();
        let freshCount = 0;
        let staleCount = 0;
        for (const entry of this.cache.values()) {
          if (now - entry.timestamp < this.config.freshDuration) {
            freshCount++;
          } else if (now - entry.timestamp < this.config.staleDuration) {
            staleCount++;
          }
        }
        return { size: this.cache.size, freshCount, staleCount };
      }
    };
    marketDataCache = new ApiCache({
      freshDuration: 30 * 1e3,
      staleDuration: 60 * 60 * 1e3
    });
    stockQuoteCache = new ApiCache({
      freshDuration: 60 * 1e3,
      staleDuration: 30 * 60 * 1e3
    });
    cryptoPriceCache = new ApiCache({
      freshDuration: 60 * 1e3,
      staleDuration: 30 * 60 * 1e3
    });
    newsCache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 60 * 60 * 1e3
    });
    assetListCache = new ApiCache({
      freshDuration: 15 * 60 * 1e3,
      staleDuration: 24 * 60 * 60 * 1e3
    });
    portfolioCache = new ApiCache({
      freshDuration: 30 * 1e3,
      staleDuration: 10 * 60 * 1e3
    });
  }
});

// server/lib/order-execution-cache.ts
var order_execution_cache_exports = {};
__export(order_execution_cache_exports, {
  cacheAccountSnapshot: () => cacheAccountSnapshot,
  cacheQuickQuote: () => cacheQuickQuote,
  cacheTradability: () => cacheTradability,
  clearOrderCaches: () => clearOrderCaches,
  getAccountSnapshot: () => getAccountSnapshot,
  getCachedBuyingPower: () => getCachedBuyingPower,
  getCachedPrice: () => getCachedPrice,
  getOrderCacheStats: () => getOrderCacheStats,
  getQuickQuote: () => getQuickQuote,
  getTradability: () => getTradability,
  isTradable: () => isTradable,
  preloadOrderValidationData: () => preloadOrderValidationData
});
function cacheQuickQuote(quote) {
  quickQuoteCache.set(quote.symbol, quote);
}
function getQuickQuote(symbol) {
  const result = quickQuoteCache.get(symbol);
  return result?.data ?? null;
}
function getCachedPrice(symbol) {
  const quote = getQuickQuote(symbol);
  return quote?.price ?? null;
}
function cacheTradability(asset) {
  tradabilityCache.set(asset.symbol, asset);
}
function getTradability(symbol) {
  const result = tradabilityCache.get(symbol);
  return result?.data ?? null;
}
function isTradable(symbol) {
  const asset = getTradability(symbol);
  return asset?.tradable ?? null;
}
function cacheAccountSnapshot(snapshot) {
  accountSnapshotCache.set("account", snapshot);
}
function getAccountSnapshot() {
  const result = accountSnapshotCache.get("account");
  return result?.data ?? null;
}
function getCachedBuyingPower() {
  const snapshot = getAccountSnapshot();
  return snapshot?.buyingPower ?? null;
}
function preloadOrderValidationData(symbols, getQuote, getAsset, getAccount) {
  const now = Date.now();
  const quotePromises = symbols.map(async (symbol) => {
    const cached = getQuickQuote(symbol);
    if (cached) return;
    try {
      const quote = await getQuote(symbol);
      cacheQuickQuote({
        symbol,
        price: quote.price,
        bid: quote.bid,
        ask: quote.ask,
        spread: quote.ask - quote.bid,
        timestamp: now
      });
    } catch {
    }
  });
  const assetPromises = symbols.map(async (symbol) => {
    const cached = getTradability(symbol);
    if (cached) return;
    try {
      const asset = await getAsset(symbol);
      cacheTradability({
        symbol,
        tradable: asset.tradable,
        fractionable: asset.fractionable,
        shortable: asset.shortable,
        marginable: asset.marginable,
        timestamp: now
      });
    } catch {
    }
  });
  const accountPromise = (async () => {
    const cached = getAccountSnapshot();
    if (cached) return;
    try {
      const account = await getAccount();
      cacheAccountSnapshot({
        buyingPower: parseFloat(account.buying_power),
        cash: parseFloat(account.cash),
        equity: parseFloat(account.equity),
        timestamp: now
      });
    } catch {
    }
  })();
  return Promise.all([...quotePromises, ...assetPromises, accountPromise]).then(
    () => {
    }
  );
}
function clearOrderCaches() {
  quickQuoteCache.clear();
  tradabilityCache.clear();
  accountSnapshotCache.clear();
}
function getOrderCacheStats() {
  return {
    quotes: quickQuoteCache.size(),
    tradability: tradabilityCache.size(),
    hasAccountSnapshot: accountSnapshotCache.has("account")
  };
}
var quickQuoteCache, tradabilityCache, accountSnapshotCache;
var init_order_execution_cache = __esm({
  "server/lib/order-execution-cache.ts"() {
    "use strict";
    init_api_cache();
    quickQuoteCache = new ApiCache({
      freshDuration: 5 * 1e3,
      staleDuration: 30 * 1e3,
      maxEntries: 500
    });
    tradabilityCache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 60 * 60 * 1e3,
      maxEntries: 1e3
    });
    accountSnapshotCache = new ApiCache({
      freshDuration: 10 * 1e3,
      staleDuration: 60 * 1e3,
      maxEntries: 1
    });
  }
});

// server/lib/webhook-emitter.ts
import pLimit from "p-limit";
function registerWebhook(config2) {
  webhooks.set(config2.id, config2);
  log.info("Webhook", "Registered", {
    name: config2.name,
    id: config2.id,
    url: config2.url
  });
}
function unregisterWebhook(id) {
  const result = webhooks.delete(id);
  if (result) {
    log.info("Webhook", "Unregistered", { id });
  }
  return result;
}
function getWebhooks() {
  return Array.from(webhooks.values());
}
function getWebhook(id) {
  return webhooks.get(id);
}
function updateWebhook(id, updates) {
  const existing = webhooks.get(id);
  if (!existing) return void 0;
  const updated = { ...existing, ...updates };
  webhooks.set(id, updated);
  return updated;
}
async function deliverWebhook(webhook, event) {
  const startTime = Date.now();
  const attempt = {
    webhookId: webhook.id,
    eventId: event.id,
    eventType: event.type,
    status: "pending",
    timestamp: /* @__PURE__ */ new Date(),
    durationMs: 0
  };
  try {
    const headers = {
      "Content-Type": "application/json",
      "X-Webhook-Event": event.type,
      "X-Webhook-Id": event.id,
      "X-Webhook-Timestamp": event.timestamp,
      ...webhook.headers
    };
    if (webhook.secret) {
      const crypto5 = await import("crypto");
      const signature = crypto5.createHmac("sha256", webhook.secret).update(JSON.stringify(event)).digest("hex");
      headers["X-Webhook-Signature"] = `sha256=${signature}`;
    }
    const response = await fetch(webhook.url, {
      method: "POST",
      headers,
      body: JSON.stringify(event),
      signal: AbortSignal.timeout(1e4)
    });
    attempt.durationMs = Date.now() - startTime;
    attempt.statusCode = response.status;
    if (response.ok) {
      attempt.status = "success";
    } else {
      attempt.status = "failed";
      attempt.error = `HTTP ${response.status}: ${response.statusText}`;
    }
  } catch (error) {
    attempt.durationMs = Date.now() - startTime;
    attempt.status = "failed";
    attempt.error = error instanceof Error ? error.message : "Unknown error";
  }
  deliveryHistory.push(attempt);
  if (deliveryHistory.length > MAX_HISTORY) {
    deliveryHistory.shift();
  }
  return attempt;
}
async function emitEvent(type, payload) {
  const event = {
    id: `evt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
    type,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    source: "ai-active-trader",
    payload
  };
  const matchingWebhooks = Array.from(webhooks.values()).filter(
    (w) => w.enabled && (w.eventTypes.includes(type) || w.eventTypes.includes("*"))
  );
  if (matchingWebhooks.length === 0) {
    return [];
  }
  log.info("Webhook", "Emitting event", {
    type,
    webhookCount: matchingWebhooks.length
  });
  const results = await Promise.all(
    matchingWebhooks.map(
      (webhook) => limit(() => deliverWebhook(webhook, event))
    )
  );
  const successes = results.filter((r) => r.status === "success").length;
  const failures = results.filter((r) => r.status === "failed").length;
  if (failures > 0) {
    log.warn("Webhook", "Some deliveries failed", {
      type,
      successes,
      failures
    });
  }
  return results;
}
function getDeliveryHistory(limit4) {
  const count3 = limit4 || MAX_HISTORY;
  return deliveryHistory.slice(-count3);
}
function getWebhookStats() {
  const recent = deliveryHistory.slice(-50);
  const successes = recent.filter((d) => d.status === "success").length;
  return {
    totalWebhooks: webhooks.size,
    enabledWebhooks: Array.from(webhooks.values()).filter((w) => w.enabled).length,
    recentDeliveries: recent.length,
    successRate: recent.length > 0 ? successes / recent.length : 1
  };
}
var webhooks, deliveryHistory, MAX_HISTORY, limit, SUPPORTED_EVENTS;
var init_webhook_emitter = __esm({
  "server/lib/webhook-emitter.ts"() {
    "use strict";
    init_logger();
    webhooks = /* @__PURE__ */ new Map();
    deliveryHistory = [];
    MAX_HISTORY = 100;
    limit = pLimit(5);
    SUPPORTED_EVENTS = [
      "trade.order.submitted",
      "trade.order.filled",
      "trade.order.canceled",
      "trade.order.rejected",
      "trade.position.opened",
      "trade.position.closed",
      "trade.position.updated",
      "ai.decision.generated",
      "ai.decision.executed",
      "market.data.update",
      "market.news.alert",
      "analytics.pnl.daily",
      "analytics.metrics.update",
      "system.error",
      "system.health.changed"
    ];
  }
});

// server/lib/email-providers/sendgrid.ts
import sgMail from "@sendgrid/mail";
var apiKey, sendgridProvider;
var init_sendgrid = __esm({
  "server/lib/email-providers/sendgrid.ts"() {
    "use strict";
    init_logger();
    apiKey = process.env.SENDGRID_API_KEY;
    if (apiKey) {
      sgMail.setApiKey(apiKey);
    }
    sendgridProvider = {
      name: "sendgrid",
      priority: 1,
      isConfigured: () => !!process.env.SENDGRID_API_KEY,
      async send(options) {
        if (!this.isConfigured()) {
          return {
            success: false,
            error: "SendGrid API key not configured",
            provider: "sendgrid"
          };
        }
        try {
          const [response] = await sgMail.send({
            to: options.to,
            from: options.from,
            subject: options.subject,
            text: options.text,
            html: options.html || `<p>${options.text}</p>`,
            replyTo: options.replyTo
          });
          log.info("Email", "Email sent via SendGrid", {
            to: Array.isArray(options.to) ? options.to.length : 1,
            subject: options.subject.substring(0, 50),
            statusCode: response.statusCode
          });
          return {
            success: true,
            messageId: response.headers["x-message-id"],
            provider: "sendgrid"
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          log.error("Email", "SendGrid send failed", { error: errorMessage });
          return {
            success: false,
            error: errorMessage,
            provider: "sendgrid"
          };
        }
      }
    };
  }
});

// server/lib/email-providers/brevo.ts
var BREVO_API_URL, brevoProvider;
var init_brevo = __esm({
  "server/lib/email-providers/brevo.ts"() {
    "use strict";
    init_logger();
    BREVO_API_URL = "https://api.brevo.com/v3/smtp/email";
    brevoProvider = {
      name: "brevo",
      priority: 2,
      isConfigured: () => !!process.env.BREVO_API_KEY,
      async send(options) {
        const apiKey2 = process.env.BREVO_API_KEY;
        if (!apiKey2) {
          return {
            success: false,
            error: "Brevo API not configured",
            provider: "brevo"
          };
        }
        try {
          const toAddresses = Array.isArray(options.to) ? options.to : [options.to];
          let sender;
          const fromMatch = options.from.match(/^(.+?)\s*<(.+)>$/);
          if (fromMatch) {
            sender = { name: fromMatch[1].trim(), email: fromMatch[2].trim() };
          } else {
            sender = { email: options.from };
          }
          const requestBody = {
            sender,
            to: toAddresses.map((email) => ({ email })),
            subject: options.subject,
            textContent: options.text,
            htmlContent: options.html || `<p>${options.text}</p>`
          };
          if (options.replyTo) {
            requestBody.replyTo = { email: options.replyTo };
          }
          const response = await fetch(BREVO_API_URL, {
            method: "POST",
            headers: {
              accept: "application/json",
              "api-key": apiKey2,
              "content-type": "application/json"
            },
            body: JSON.stringify(requestBody)
          });
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(
              errorData.message || `HTTP ${response.status}: ${response.statusText}`
            );
          }
          const data = await response.json();
          log.info("Email", "Email sent via Brevo", {
            to: toAddresses.length,
            subject: options.subject.substring(0, 50),
            messageId: data.messageId
          });
          return {
            success: true,
            messageId: data.messageId,
            provider: "brevo"
          };
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          log.error("Email", "Brevo send failed", { error: errorMessage });
          return {
            success: false,
            error: errorMessage,
            provider: "brevo"
          };
        }
      }
    };
  }
});

// server/lib/email-providers/index.ts
function getActiveProvider() {
  for (const provider of providers) {
    if (provider.isConfigured()) {
      return provider;
    }
  }
  return null;
}
function getConfiguredProviders() {
  return providers.filter((p) => p.isConfigured());
}
function isEmailConfigured() {
  return providers.some((p) => p.isConfigured());
}
async function sendEmailWithFallback(options) {
  const configuredProviders = getConfiguredProviders();
  if (configuredProviders.length === 0) {
    log.warn("Email", "No email provider configured");
    return {
      success: false,
      error: "No email provider configured"
    };
  }
  for (const provider of configuredProviders) {
    log.debug("Email", `Attempting to send via ${provider.name}`);
    const result = await provider.send(options);
    if (result.success) {
      return result;
    }
    log.warn("Email", `${provider.name} failed, trying next provider`, {
      error: result.error
    });
  }
  return {
    success: false,
    error: `All email providers failed (tried: ${configuredProviders.map((p) => p.name).join(", ")})`
  };
}
var providers, activeProvider;
var init_email_providers = __esm({
  "server/lib/email-providers/index.ts"() {
    "use strict";
    init_logger();
    init_sendgrid();
    init_brevo();
    providers = [sendgridProvider, brevoProvider].sort(
      (a, b) => a.priority - b.priority
    );
    activeProvider = getActiveProvider();
    if (activeProvider) {
      log.info("Email", `Email service initialized with ${activeProvider.name}`);
    } else {
      log.warn(
        "Email",
        "No email provider configured - email notifications disabled"
      );
    }
  }
});

// server/lib/email-service.ts
function isEmailConfigured2() {
  return isEmailConfigured();
}
async function sendEmail(options) {
  if (!isEmailConfigured2()) {
    return {
      success: false,
      error: "No email provider configured"
    };
  }
  return sendEmailWithFallback(options);
}
async function sendPasswordResetEmail(options) {
  const subject = "AlphaFlow - Password Reset Request";
  const text17 = `
Hello ${options.username},

You requested a password reset for your AlphaFlow account.

Click the link below to reset your password (valid for 1 hour):
${options.resetUrl}?token=${options.resetToken}

If you did not request this reset, please ignore this email.

Best regards,
The AlphaFlow Team
`;
  const html = `
<div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px;">
  <h2 style="color: #3b82f6;">Password Reset Request</h2>
  <p>Hello <strong>${options.username}</strong>,</p>
  <p>You requested a password reset for your AlphaFlow account.</p>
  <p style="margin: 20px 0;">
    <a href="${options.resetUrl}?token=${options.resetToken}"
       style="background-color: #3b82f6; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; display: inline-block;">
      Reset Password
    </a>
  </p>
  <p style="color: #6b7280; font-size: 14px;">This link is valid for 1 hour.</p>
  <p style="color: #6b7280; font-size: 14px;">If you did not request this reset, please ignore this email.</p>
  <hr style="border: none; border-top: 1px solid #e5e7eb; margin: 20px 0;">
  <p style="color: #9ca3af; font-size: 12px;">Best regards,<br>The AlphaFlow Team</p>
</div>
`;
  return sendEmail({
    to: options.to,
    from: options.from,
    subject,
    text: text17,
    html
  });
}
var init_email_service = __esm({
  "server/lib/email-service.ts"() {
    "use strict";
    init_email_providers();
  }
});

// server/lib/email-templates.ts
function getOrderFilledTemplate(params) {
  const { symbol, side, qty, price, totalValue, timestamp: timestamp18 } = params;
  const sideColor = side === "buy" ? ALPHAFLOW_GREEN : ALPHAFLOW_RED;
  const sideText = side === "buy" ? "BUY" : "SELL";
  const sideIcon = side === "buy" ? "\u{1F4C8}" : "\u{1F4C9}";
  const formattedDate = timestamp18.toLocaleDateString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  });
  const formattedTime = timestamp18.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short"
  });
  const subject = `Order Filled: ${sideText} ${qty} ${symbol} @ $${price.toFixed(2)}`;
  const text17 = `
AlphaFlow Trade Confirmation

Your order has been successfully filled!

ORDER DETAILS
Symbol: ${symbol}
Action: ${sideText}
Quantity: ${qty} shares
Price: $${price.toFixed(2)}
Total Value: $${totalValue.toFixed(2)}

EXECUTION TIME
${formattedDate}
${formattedTime}

NEXT STEPS
\u2022 View your updated portfolio at: https://alphaflow.app/portfolio
\u2022 Check position performance at: https://alphaflow.app/positions
\u2022 Review order history at: https://alphaflow.app/orders

Questions? Contact support@alphaflow.app

---
AlphaFlow Trading Platform
  `.trim();
  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Order Filled - ${symbol}</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f3f4f6;">
  <div style="${BASE_STYLES}">
    <!-- Header -->
    <div style="background: linear-gradient(135deg, ${sideColor} 0%, ${side === "buy" ? "#16a34a" : "#dc2626"} 100%); padding: 32px 24px; border-radius: 8px 8px 0 0; text-align: center; color: white;">
      <div style="font-size: 48px; margin-bottom: 8px;">${sideIcon}</div>
      <h1 style="margin: 0; font-size: 28px; font-weight: bold;">Order Filled!</h1>
      <p style="margin: 8px 0 0 0; font-size: 16px; opacity: 0.95;">${sideText} ${qty} shares of ${symbol}</p>
    </div>

    <!-- Content -->
    <div style="background-color: white; padding: 24px; border-left: 1px solid #e5e7eb; border-right: 1px solid #e5e7eb;">
      <p style="color: #4b5563; font-size: 16px; margin-top: 0;">
        Your order has been successfully executed. Below are the details of your trade:
      </p>

      <!-- Order Details Table -->
      <div style="background-color: #f9fafb; border-radius: 8px; padding: 16px; margin: 24px 0;">
        <h2 style="color: #1f2937; font-size: 18px; margin-top: 0; margin-bottom: 16px; border-bottom: 2px solid ${sideColor}; padding-bottom: 8px;">
          Order Details
        </h2>
        <table style="width: 100%; border-collapse: collapse;">
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Symbol</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: bold; font-size: 16px; color: #1f2937;">${symbol}</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Action</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: bold; color: ${sideColor};">${sideText}</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Quantity</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #1f2937;">${qty} shares</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Fill Price</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: bold; font-size: 18px; color: #1f2937;">$${price.toFixed(2)}</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; color: #6b7280; font-weight: 600;">Total Value</td>
            <td style="padding: 12px 8px; text-align: right; font-weight: bold; font-size: 20px; color: ${sideColor};">$${totalValue.toFixed(2)}</td>
          </tr>
        </table>
      </div>

      <!-- Execution Time -->
      <div style="background-color: #eff6ff; border-left: 4px solid ${ALPHAFLOW_BLUE}; padding: 16px; margin: 24px 0; border-radius: 4px;">
        <p style="margin: 0; color: #1e40af; font-size: 14px;">
          <strong>Executed:</strong> ${formattedDate} at ${formattedTime}
        </p>
      </div>

      <!-- Call to Action -->
      <div style="text-align: center; margin: 32px 0;">
        <a href="https://alphaflow.app/portfolio" style="display: inline-block; background-color: ${ALPHAFLOW_GREEN}; color: white; padding: 14px 32px; text-decoration: none; border-radius: 6px; font-weight: bold; font-size: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          View Portfolio
        </a>
      </div>

      <!-- Quick Links -->
      <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid #e5e7eb;">
        <p style="color: #6b7280; font-size: 14px; margin-bottom: 12px;"><strong>Quick Links:</strong></p>
        <ul style="margin: 0; padding-left: 20px; color: #4b5563; font-size: 14px; line-height: 1.8;">
          <li><a href="https://alphaflow.app/positions" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">View Position Performance</a></li>
          <li><a href="https://alphaflow.app/orders" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">Order History</a></li>
          <li><a href="https://alphaflow.app/analytics" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">Portfolio Analytics</a></li>
        </ul>
      </div>
    </div>

    <!-- Footer -->
    <div style="background-color: #f9fafb; padding: 20px 24px; border-radius: 0 0 8px 8px; border: 1px solid #e5e7eb; border-top: none; text-align: center;">
      <p style="margin: 0; color: #9ca3af; font-size: 12px;">
        \xA9 2026 AlphaFlow Trading Platform. All rights reserved.
      </p>
      <p style="margin: 8px 0 0 0; color: #9ca3af; font-size: 12px;">
        Questions? Contact <a href="mailto:support@alphaflow.app" style="color: ${ALPHAFLOW_BLUE};">support@alphaflow.app</a>
      </p>
    </div>
  </div>
</body>
</html>
  `.trim();
  return { subject, html, text: text17 };
}
function getLargeLossAlertTemplate(params) {
  const { symbol, unrealizedPL, percentLoss, currentPrice, avgEntryPrice } = params;
  const priceChange = currentPrice - avgEntryPrice;
  const priceChangePercent = priceChange / avgEntryPrice * 100;
  const subject = `\u26A0\uFE0F Large Loss Alert: ${symbol} down ${Math.abs(percentLoss).toFixed(2)}%`;
  const text17 = `
LARGE LOSS ALERT

Your position in ${symbol} has exceeded the loss threshold!

POSITION DETAILS
Symbol: ${symbol}
Unrealized P&L: -$${Math.abs(unrealizedPL).toFixed(2)}
Loss Percentage: ${percentLoss.toFixed(2)}%
Entry Price: $${avgEntryPrice.toFixed(2)}
Current Price: $${currentPrice.toFixed(2)}
Price Change: -$${Math.abs(priceChange).toFixed(2)} (${priceChangePercent.toFixed(2)}%)

SUGGESTED ACTIONS
1. Review your position strategy and risk tolerance
2. Consider setting a stop-loss order to limit further losses
3. Evaluate whether to hold, reduce, or close the position
4. Check market news and fundamentals for ${symbol}
5. Consult with a financial advisor if needed

RISK MANAGEMENT REMINDER
\u2022 Never invest more than you can afford to lose
\u2022 Diversification helps manage portfolio risk
\u2022 Emotional decisions can lead to poor outcomes
\u2022 Review your overall portfolio allocation

View Position: https://alphaflow.app/positions/${symbol}

---
AlphaFlow Trading Platform
  `.trim();
  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Large Loss Alert - ${symbol}</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f3f4f6;">
  <div style="${BASE_STYLES}">
    <!-- Alert Header -->
    <div style="background-color: #fef2f2; padding: 24px; border-left: 6px solid ${ALPHAFLOW_RED}; border-radius: 8px 8px 0 0;">
      <div style="display: flex; align-items: center; margin-bottom: 12px;">
        <div style="font-size: 40px; margin-right: 16px;">\u26A0\uFE0F</div>
        <div>
          <h1 style="margin: 0; color: #991b1b; font-size: 24px; font-weight: bold;">Large Loss Alert</h1>
          <p style="margin: 4px 0 0 0; color: #b91c1c; font-size: 16px;">Position: ${symbol}</p>
        </div>
      </div>
      <p style="margin: 12px 0 0 0; color: #7f1d1d; font-size: 14px; background-color: #fee2e2; padding: 12px; border-radius: 4px;">
        <strong>\u26A1 Immediate Attention Required:</strong> Your position has exceeded the loss threshold.
      </p>
    </div>

    <!-- Content -->
    <div style="background-color: white; padding: 24px; border-left: 1px solid #e5e7eb; border-right: 1px solid #e5e7eb;">
      <!-- Loss Summary -->
      <div style="background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); border-radius: 8px; padding: 20px; margin-bottom: 24px; text-align: center;">
        <p style="margin: 0 0 8px 0; color: #991b1b; font-size: 14px; font-weight: 600; text-transform: uppercase;">Unrealized Loss</p>
        <p style="margin: 0; color: #dc2626; font-size: 36px; font-weight: bold;">-$${Math.abs(unrealizedPL).toFixed(2)}</p>
        <p style="margin: 8px 0 0 0; color: #b91c1c; font-size: 20px; font-weight: 600;">${percentLoss.toFixed(2)}%</p>
      </div>

      <!-- Position Details -->
      <div style="background-color: #f9fafb; border-radius: 8px; padding: 16px; margin: 24px 0;">
        <h2 style="color: #1f2937; font-size: 18px; margin-top: 0; margin-bottom: 16px;">Position Details</h2>
        <table style="width: 100%; border-collapse: collapse;">
          <tr>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Symbol</td>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: bold; color: #1f2937;">${symbol}</td>
          </tr>
          <tr>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Entry Price</td>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #1f2937;">$${avgEntryPrice.toFixed(2)}</td>
          </tr>
          <tr>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Current Price</td>
            <td style="padding: 10px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; color: ${ALPHAFLOW_RED}; font-weight: bold;">$${currentPrice.toFixed(2)}</td>
          </tr>
          <tr>
            <td style="padding: 10px 8px; color: #6b7280; font-weight: 600;">Price Change</td>
            <td style="padding: 10px 8px; text-align: right; color: ${ALPHAFLOW_RED}; font-weight: bold;">-$${Math.abs(priceChange).toFixed(2)} (${priceChangePercent.toFixed(2)}%)</td>
          </tr>
        </table>
      </div>

      <!-- Suggested Actions -->
      <div style="background-color: #fffbeb; border-left: 4px solid ${ALPHAFLOW_ORANGE}; padding: 20px; margin: 24px 0; border-radius: 4px;">
        <h3 style="margin-top: 0; color: #92400e; font-size: 16px;">\u{1F3AF} Suggested Actions</h3>
        <ol style="margin: 12px 0 0 0; padding-left: 24px; color: #78350f; font-size: 14px; line-height: 1.8;">
          <li>Review your position strategy and risk tolerance</li>
          <li>Consider setting a stop-loss order to limit further losses</li>
          <li>Evaluate whether to hold, reduce, or close the position</li>
          <li>Check market news and fundamentals for ${symbol}</li>
          <li>Consult with a financial advisor if needed</li>
        </ol>
      </div>

      <!-- Risk Management Reminder -->
      <div style="background-color: #f0f9ff; border: 1px solid #bfdbfe; padding: 16px; margin: 24px 0; border-radius: 6px;">
        <h3 style="margin-top: 0; color: #1e40af; font-size: 14px; font-weight: bold;">\u{1F4A1} Risk Management Reminder</h3>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #1e3a8a; font-size: 13px; line-height: 1.7;">
          <li>Never invest more than you can afford to lose</li>
          <li>Diversification helps manage portfolio risk</li>
          <li>Emotional decisions can lead to poor outcomes</li>
          <li>Review your overall portfolio allocation</li>
        </ul>
      </div>

      <!-- Call to Action -->
      <div style="text-align: center; margin: 32px 0 16px 0;">
        <a href="https://alphaflow.app/positions/${symbol}" style="display: inline-block; background-color: ${ALPHAFLOW_RED}; color: white; padding: 14px 32px; text-decoration: none; border-radius: 6px; font-weight: bold; font-size: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
          Review Position
        </a>
      </div>
    </div>

    <!-- Footer -->
    <div style="background-color: #f9fafb; padding: 20px 24px; border-radius: 0 0 8px 8px; border: 1px solid #e5e7eb; border-top: none; text-align: center;">
      <p style="margin: 0; color: #9ca3af; font-size: 12px;">
        \xA9 2026 AlphaFlow Trading Platform. All rights reserved.
      </p>
      <p style="margin: 8px 0 0 0; color: #9ca3af; font-size: 11px;">
        <em>This is an automated alert. Trading involves risk. Past performance does not guarantee future results.</em>
      </p>
    </div>
  </div>
</body>
</html>
  `.trim();
  return { subject, html, text: text17 };
}
function getCircuitBreakerTemplate(params) {
  const { reason, triggeredAt, estimatedRecovery } = params;
  const formattedTriggerTime = triggeredAt.toLocaleString("en-US", {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    timeZoneName: "short"
  });
  const recoveryText = estimatedRecovery ? estimatedRecovery.toLocaleString("en-US", {
    weekday: "long",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
    timeZoneName: "short"
  }) : "Manual review required - no automatic resume scheduled";
  const subject = `\u{1F6A8} Circuit Breaker Triggered - Trading Halted`;
  const text17 = `
CIRCUIT BREAKER ALERT

Automated trading has been halted to protect your portfolio.

STATUS: TRADING SUSPENDED

DETAILS
Reason: ${reason}
Triggered: ${formattedTriggerTime}
Estimated Recovery: ${recoveryText}

WHAT THIS MEANS
\u2022 All automated trading strategies have been paused
\u2022 Open orders remain active (unless cancelled by system)
\u2022 Your portfolio remains safe and accessible
\u2022 Manual trading may still be available

WHAT HAPPENS NEXT
1. System will monitor market conditions continuously
2. Trading will resume automatically when conditions normalize
   OR after manual review confirms safety
3. You will receive a notification when trading resumes
4. All strategies will be evaluated before reactivation

WHAT YOU CAN DO
\u2022 Review your current positions at: https://alphaflow.app/positions
\u2022 Check system status at: https://alphaflow.app/status
\u2022 Contact support if you have concerns: support@alphaflow.app

WHY WE DO THIS
Circuit breakers protect your portfolio during:
\u2022 Extreme market volatility
\u2022 Rapid portfolio losses
\u2022 System anomalies
\u2022 Exchange-wide trading halts

Your safety is our priority. Thank you for your patience.

---
AlphaFlow Trading Platform
  `.trim();
  const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circuit Breaker Alert</title>
</head>
<body style="margin: 0; padding: 0; background-color: #f3f4f6;">
  <div style="${BASE_STYLES}">
    <!-- Alert Header -->
    <div style="background: linear-gradient(135deg, #ea580c 0%, #c2410c 100%); padding: 32px 24px; text-align: center; color: white; border-radius: 8px 8px 0 0;">
      <div style="font-size: 56px; margin-bottom: 12px;">\u{1F6A8}</div>
      <h1 style="margin: 0; font-size: 28px; font-weight: bold;">Circuit Breaker Triggered</h1>
      <p style="margin: 12px 0 0 0; font-size: 16px; opacity: 0.95; background-color: rgba(0,0,0,0.2); padding: 8px 16px; border-radius: 4px; display: inline-block;">
        <strong>STATUS:</strong> Trading Suspended
      </p>
    </div>

    <!-- Content -->
    <div style="background-color: white; padding: 24px; border-left: 1px solid #e5e7eb; border-right: 1px solid #e5e7eb;">
      <!-- Alert Banner -->
      <div style="background-color: #fffbeb; border: 2px solid #f59e0b; padding: 20px; margin-bottom: 24px; border-radius: 8px; text-align: center;">
        <p style="margin: 0; color: #92400e; font-size: 16px; font-weight: bold;">
          \u26A1 Automated trading has been halted to protect your portfolio
        </p>
      </div>

      <!-- Details -->
      <div style="background-color: #f9fafb; border-radius: 8px; padding: 16px; margin: 24px 0;">
        <h2 style="color: #1f2937; font-size: 18px; margin-top: 0; margin-bottom: 16px;">Circuit Breaker Details</h2>
        <table style="width: 100%; border-collapse: collapse;">
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600; width: 40%;">Status</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; font-weight: bold; color: #ea580c;">TRADING HALTED</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Reason</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #1f2937;">${reason}</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; color: #6b7280; font-weight: 600;">Triggered</td>
            <td style="padding: 12px 8px; border-bottom: 1px solid #e5e7eb; text-align: right; color: #1f2937; font-size: 14px;">${formattedTriggerTime}</td>
          </tr>
          <tr>
            <td style="padding: 12px 8px; color: #6b7280; font-weight: 600;">Estimated Recovery</td>
            <td style="padding: 12px 8px; text-align: right; color: ${estimatedRecovery ? ALPHAFLOW_GREEN : ALPHAFLOW_ORANGE}; font-weight: 600; font-size: 14px;">${recoveryText}</td>
          </tr>
        </table>
      </div>

      <!-- What This Means -->
      <div style="margin: 24px 0;">
        <h3 style="color: #1f2937; font-size: 16px; margin-bottom: 12px; border-left: 4px solid ${ALPHAFLOW_BLUE}; padding-left: 12px;">What This Means</h3>
        <ul style="margin: 0; padding-left: 24px; color: #4b5563; font-size: 14px; line-height: 1.8;">
          <li>All automated trading strategies have been paused</li>
          <li>Open orders remain active (unless cancelled by system)</li>
          <li>Your portfolio remains safe and accessible</li>
          <li>Manual trading may still be available</li>
        </ul>
      </div>

      <!-- What Happens Next -->
      <div style="margin: 24px 0;">
        <h3 style="color: #1f2937; font-size: 16px; margin-bottom: 12px; border-left: 4px solid ${ALPHAFLOW_GREEN}; padding-left: 12px;">What Happens Next</h3>
        <ol style="margin: 0; padding-left: 24px; color: #4b5563; font-size: 14px; line-height: 1.8;">
          <li>System will monitor market conditions continuously</li>
          <li>Trading will resume automatically when conditions normalize OR after manual review confirms safety</li>
          <li>You will receive a notification when trading resumes</li>
          <li>All strategies will be evaluated before reactivation</li>
        </ol>
      </div>

      <!-- What You Can Do -->
      <div style="background-color: #f0f9ff; border-left: 4px solid ${ALPHAFLOW_BLUE}; padding: 20px; margin: 24px 0; border-radius: 4px;">
        <h3 style="margin-top: 0; color: #1e40af; font-size: 16px;">What You Can Do</h3>
        <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #1e3a8a; font-size: 14px; line-height: 1.7;">
          <li><a href="https://alphaflow.app/positions" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">Review your current positions</a></li>
          <li><a href="https://alphaflow.app/status" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">Check system status</a></li>
          <li><a href="mailto:support@alphaflow.app" style="color: ${ALPHAFLOW_BLUE}; text-decoration: none;">Contact support if you have concerns</a></li>
        </ul>
      </div>

      <!-- Why We Do This -->
      <div style="background-color: #fefce8; border: 1px solid #fde047; padding: 16px; margin: 24px 0; border-radius: 6px;">
        <h3 style="margin-top: 0; color: #713f12; font-size: 14px; font-weight: bold;">\u{1F6E1}\uFE0F Why We Do This</h3>
        <p style="margin: 8px 0 12px 0; color: #854d0e; font-size: 13px;">
          Circuit breakers protect your portfolio during:
        </p>
        <ul style="margin: 0; padding-left: 20px; color: #854d0e; font-size: 13px; line-height: 1.7;">
          <li>Extreme market volatility</li>
          <li>Rapid portfolio losses</li>
          <li>System anomalies</li>
          <li>Exchange-wide trading halts</li>
        </ul>
      </div>

      <p style="text-align: center; color: #6b7280; font-size: 14px; margin: 24px 0 8px 0; font-style: italic;">
        Your safety is our priority. Thank you for your patience.
      </p>
    </div>

    <!-- Footer -->
    <div style="background-color: #f9fafb; padding: 20px 24px; border-radius: 0 0 8px 8px; border: 1px solid #e5e7eb; border-top: none; text-align: center;">
      <p style="margin: 0; color: #9ca3af; font-size: 12px;">
        \xA9 2026 AlphaFlow Trading Platform. All rights reserved.
      </p>
      <p style="margin: 8px 0 0 0; color: #9ca3af; font-size: 11px;">
        <em>This is an automated safety alert. You will be notified when trading resumes.</em>
      </p>
    </div>
  </div>
</body>
</html>
  `.trim();
  return { subject, html, text: text17 };
}
var ALPHAFLOW_GREEN, ALPHAFLOW_RED, ALPHAFLOW_BLUE, ALPHAFLOW_ORANGE, BASE_STYLES;
var init_email_templates = __esm({
  "server/lib/email-templates.ts"() {
    "use strict";
    ALPHAFLOW_GREEN = "#22c55e";
    ALPHAFLOW_RED = "#ef4444";
    ALPHAFLOW_BLUE = "#3b82f6";
    ALPHAFLOW_ORANGE = "#f97316";
    BASE_STYLES = `
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  max-width: 600px;
  margin: 0 auto;
  padding: 20px;
`;
  }
});

// server/lib/notification-service.ts
var notification_service_exports = {};
__export(notification_service_exports, {
  createDefaultTemplates: () => createDefaultTemplates,
  deleteChannel: () => deleteChannel,
  deleteTemplate: () => deleteTemplate,
  getChannel: () => getChannel,
  getChannels: () => getChannels,
  getNotificationHistory: () => getNotificationHistory,
  getNotificationStats: () => getNotificationStats,
  getTemplates: () => getTemplates,
  registerChannel: () => registerChannel,
  registerTemplate: () => registerTemplate,
  sendCircuitBreakerEmail: () => sendCircuitBreakerEmail,
  sendDirectNotification: () => sendDirectNotification,
  sendLossAlertEmail: () => sendLossAlertEmail,
  sendNotification: () => sendNotification,
  sendOrderFilledEmail: () => sendOrderFilledEmail,
  updateChannel: () => updateChannel,
  updateTemplate: () => updateTemplate
});
function registerChannel(channel) {
  channels.set(channel.id, channel);
}
function getChannel(id) {
  return channels.get(id);
}
function getChannels() {
  return Array.from(channels.values());
}
function updateChannel(id, updates) {
  const channel = channels.get(id);
  if (!channel) return null;
  const updated = { ...channel, ...updates, id: channel.id };
  channels.set(id, updated);
  return updated;
}
function deleteChannel(id) {
  return channels.delete(id);
}
function registerTemplate(template) {
  templates.set(template.id, template);
}
function getTemplates() {
  return Array.from(templates.values());
}
function updateTemplate(id, updates) {
  const template = templates.get(id);
  if (!template) return null;
  const updated = { ...template, ...updates, id: template.id };
  templates.set(id, updated);
  return updated;
}
function deleteTemplate(id) {
  return templates.delete(id);
}
function formatMessage(template, data) {
  let message = template;
  for (const [key, value] of Object.entries(data)) {
    const regex = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, "g");
    message = message.replace(regex, String(value ?? ""));
  }
  message = message.replace(/\{\{[^}]+\}\}/g, "");
  return message;
}
async function sendTelegram(config2, message) {
  const url = `https://api.telegram.org/bot${config2.botToken}/sendMessage`;
  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: config2.chatId,
      text: message,
      parse_mode: "HTML"
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Telegram API error: ${response.status} - ${error}`);
  }
}
async function sendSlack(config2, message) {
  const response = await fetch(config2.webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: message,
      channel: config2.channel
    })
  });
  if (!response.ok) {
    throw new Error(`Slack webhook error: ${response.status}`);
  }
}
async function sendDiscord(config2, message) {
  const response = await fetch(config2.webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ content: message })
  });
  if (!response.ok) {
    throw new Error(`Discord webhook error: ${response.status}`);
  }
}
async function sendToChannel(channel, message) {
  const result = {
    channelId: channel.id,
    channelType: channel.type,
    success: false,
    timestamp: /* @__PURE__ */ new Date()
  };
  try {
    switch (channel.type) {
      case "telegram":
        await sendTelegram(channel.config, message);
        result.success = true;
        break;
      case "slack":
        await sendSlack(channel.config, message);
        result.success = true;
        break;
      case "discord":
        await sendDiscord(channel.config, message);
        result.success = true;
        break;
      case "email": {
        if (!isEmailConfigured2()) {
          result.error = "No email provider configured";
          log.warn("Notification", "Email skipped - no provider configured", {
            channelId: channel.id
          });
          break;
        }
        const emailConfig = channel.config;
        const emailResult = await sendEmail({
          to: emailConfig.to,
          from: emailConfig.from,
          subject: message.substring(0, 100).replace(/<[^>]*>/g, ""),
          text: message.replace(/<[^>]*>/g, ""),
          html: message.replace(/\n/g, "<br>"),
          replyTo: emailConfig.replyTo
        });
        if (emailResult.success) {
          result.success = true;
          log.info("Notification", "Email sent successfully", {
            channelId: channel.id,
            to: emailConfig.to.length
          });
        } else {
          result.error = emailResult.error;
        }
        break;
      }
      default:
        result.error = `Unsupported channel type: ${channel.type}`;
    }
  } catch (error) {
    result.error = error instanceof Error ? error.message : String(error);
  }
  notificationHistory.unshift(result);
  if (notificationHistory.length > MAX_HISTORY2) {
    notificationHistory.pop();
  }
  return result;
}
async function sendNotification(eventType, data) {
  const results = [];
  for (const template of templates.values()) {
    if (!template.enabled) continue;
    if (template.eventType !== eventType && template.eventType !== "*")
      continue;
    const message = formatMessage(template.messageTemplate, {
      ...data,
      eventType
    });
    for (const channelId of template.channels) {
      const channel = channels.get(channelId);
      if (!channel || !channel.enabled) continue;
      const result = await sendToChannel(channel, message);
      results.push(result);
    }
  }
  return results;
}
async function sendDirectNotification(channelId, message) {
  const channel = channels.get(channelId);
  if (!channel) return null;
  return sendToChannel(channel, message);
}
function getNotificationHistory(limit4 = 50) {
  return notificationHistory.slice(0, limit4);
}
function getNotificationStats() {
  const total = notificationHistory.length;
  const successful = notificationHistory.filter((n) => n.success).length;
  return {
    totalChannels: channels.size,
    enabledChannels: Array.from(channels.values()).filter((c) => c.enabled).length,
    totalTemplates: templates.size,
    recentNotifications: total,
    successRate: total > 0 ? successful / total : 1
  };
}
function createDefaultTemplates() {
  const defaultTemplates = [
    {
      id: "trade-order-submitted",
      name: "Trade Order Submitted",
      eventType: "trade.order.submitted",
      channels: [],
      messageTemplate: "\u{1F4CA} <b>Order Submitted</b>\n{{side}} {{qty}} {{symbol}} @ ${{price}}\nOrder ID: {{orderId}}",
      enabled: true
    },
    {
      id: "trade-order-filled",
      name: "Trade Order Filled",
      eventType: "trade.order.filled",
      channels: [],
      messageTemplate: "\u2705 <b>Order Filled</b>\n{{side}} {{qty}} {{symbol}} @ ${{price}}\nOrder ID: {{orderId}}",
      enabled: true
    },
    {
      id: "trade-order-rejected",
      name: "Trade Order Rejected",
      eventType: "trade.order.rejected",
      channels: [],
      messageTemplate: "\u274C <b>Order Rejected</b>\n{{side}} {{qty}} {{symbol}}\nReason: {{reason}}",
      enabled: true
    },
    {
      id: "ai-decision",
      name: "AI Decision Generated",
      eventType: "ai.decision.generated",
      channels: [],
      messageTemplate: "\u{1F916} <b>AI Decision</b>\nSymbol: {{symbol}}\nAction: {{action}}\nConfidence: {{confidence}}%\nReason: {{reasoning}}",
      enabled: true
    },
    {
      id: "position-opened",
      name: "Position Opened",
      eventType: "trade.position.opened",
      channels: [],
      messageTemplate: "\u{1F4C8} <b>Position Opened</b>\n{{side}} {{qty}} {{symbol}} @ ${{entryPrice}}",
      enabled: true
    },
    {
      id: "position-closed",
      name: "Position Closed",
      eventType: "trade.position.closed",
      channels: [],
      messageTemplate: "\u{1F4C9} <b>Position Closed</b>\n{{symbol}} closed\nP/L: ${{pnl}} ({{pnlPercent}}%)",
      enabled: true
    }
  ];
  for (const template of defaultTemplates) {
    if (!templates.has(template.id)) {
      templates.set(template.id, template);
    }
  }
}
async function sendOrderFilledEmail(to, params) {
  if (!isEmailConfigured2()) {
    log.warn(
      "Notification",
      "Email not configured - skipping order filled email",
      {
        symbol: params.symbol
      }
    );
    return;
  }
  try {
    const template = getOrderFilledTemplate(params);
    const result = await sendEmail({
      to,
      from: "noreply@alphaflow.app",
      subject: template.subject,
      text: template.text,
      html: template.html
    });
    if (result.success) {
      log.info("Notification", "Order filled email sent", {
        symbol: params.symbol,
        side: params.side,
        qty: params.qty
      });
    } else {
      log.error("Notification", "Order filled email failed", {
        error: result.error,
        symbol: params.symbol
      });
    }
  } catch (error) {
    log.error("Notification", "Error sending order filled email", {
      error: error.message,
      symbol: params.symbol
    });
  }
}
async function sendLossAlertEmail(to, params) {
  if (!isEmailConfigured2()) {
    log.warn(
      "Notification",
      "Email not configured - skipping loss alert email",
      {
        symbol: params.symbol
      }
    );
    return;
  }
  try {
    const template = getLargeLossAlertTemplate(params);
    const result = await sendEmail({
      to,
      from: "noreply@alphaflow.app",
      subject: template.subject,
      text: template.text,
      html: template.html
    });
    if (result.success) {
      log.info("Notification", "Loss alert email sent", {
        symbol: params.symbol,
        percentLoss: params.percentLoss
      });
    } else {
      log.error("Notification", "Loss alert email failed", {
        error: result.error,
        symbol: params.symbol
      });
    }
  } catch (error) {
    log.error("Notification", "Error sending loss alert email", {
      error: error.message,
      symbol: params.symbol
    });
  }
}
async function sendCircuitBreakerEmail(to, params) {
  if (!isEmailConfigured2()) {
    log.warn(
      "Notification",
      "Email not configured - skipping circuit breaker email",
      {
        reason: params.reason
      }
    );
    return;
  }
  try {
    const template = getCircuitBreakerTemplate(params);
    const result = await sendEmail({
      to,
      from: "noreply@alphaflow.app",
      subject: template.subject,
      text: template.text,
      html: template.html
    });
    if (result.success) {
      log.info("Notification", "Circuit breaker email sent", {
        reason: params.reason
      });
    } else {
      log.error("Notification", "Circuit breaker email failed", {
        error: result.error,
        reason: params.reason
      });
    }
  } catch (error) {
    log.error("Notification", "Error sending circuit breaker email", {
      error: error.message,
      reason: params.reason
    });
  }
}
var channels, templates, notificationHistory, MAX_HISTORY2;
var init_notification_service = __esm({
  "server/lib/notification-service.ts"() {
    "use strict";
    init_logger();
    init_email_service();
    init_email_templates();
    channels = /* @__PURE__ */ new Map();
    templates = /* @__PURE__ */ new Map();
    notificationHistory = [];
    MAX_HISTORY2 = 200;
    createDefaultTemplates();
  }
});

// server/services/tradability-service.ts
function mapAlpacaAssetToInsert(asset) {
  return {
    alpacaId: asset.id,
    symbol: asset.symbol.toUpperCase(),
    name: asset.name,
    assetClass: asset.class === "crypto" ? "crypto" : "us_equity",
    exchange: asset.exchange,
    status: asset.status,
    tradable: asset.tradable,
    marginable: asset.marginable,
    shortable: asset.shortable,
    easyToBorrow: asset.easy_to_borrow,
    fractionable: asset.fractionable,
    lastSyncedAt: /* @__PURE__ */ new Date()
  };
}
function brokerAssetToTradabilityCheck(asset) {
  return {
    symbol: asset.symbol,
    tradable: asset.tradable,
    assetClass: asset.assetClass,
    exchange: asset.exchange,
    fractionable: asset.fractionable,
    marginable: asset.marginable,
    shortable: asset.shortable,
    lastSyncedAt: asset.lastSyncedAt,
    reason: asset.tradable ? void 0 : `Asset status: ${asset.status}`
  };
}
var SYNC_STALE_THRESHOLD_MS, CACHE_TTL_MS, memoryCache, TradabilityService, tradabilityService;
var init_tradability_service = __esm({
  "server/services/tradability-service.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_logger();
    SYNC_STALE_THRESHOLD_MS = 24 * 60 * 60 * 1e3;
    CACHE_TTL_MS = 5 * 60 * 1e3;
    memoryCache = /* @__PURE__ */ new Map();
    TradabilityService = class {
      async validateSymbolTradable(symbol) {
        const normalizedSymbol = symbol.toUpperCase();
        const cached = memoryCache.get(normalizedSymbol);
        if (cached && Date.now() - cached.cachedAt < CACHE_TTL_MS) {
          return cached.check;
        }
        const dbAsset = await storage.getBrokerAsset(normalizedSymbol);
        if (dbAsset) {
          const check = brokerAssetToTradabilityCheck(dbAsset);
          memoryCache.set(normalizedSymbol, { check, cachedAt: Date.now() });
          return check;
        }
        try {
          const alpacaAsset = await alpaca.getAsset(normalizedSymbol);
          if (alpacaAsset) {
            const insertAsset = mapAlpacaAssetToInsert(alpacaAsset);
            const savedAsset = await storage.upsertBrokerAsset(insertAsset);
            const check = brokerAssetToTradabilityCheck(savedAsset);
            memoryCache.set(normalizedSymbol, { check, cachedAt: Date.now() });
            return check;
          }
        } catch (error) {
          log.warn(
            "tradability",
            `Failed to fetch asset ${normalizedSymbol} from Alpaca`,
            { error: error.message }
          );
        }
        const notFoundCheck = {
          symbol: normalizedSymbol,
          tradable: false,
          reason: "Symbol not found in broker asset universe"
        };
        memoryCache.set(normalizedSymbol, {
          check: notFoundCheck,
          cachedAt: Date.now()
        });
        return notFoundCheck;
      }
      async validateSymbolsTradable(symbols) {
        const results = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          const check = await this.validateSymbolTradable(symbol);
          results.set(symbol.toUpperCase(), check);
        }
        return results;
      }
      async syncAssetUniverse(assetClass = "us_equity") {
        const errors = [];
        let synced = 0;
        let tradable = 0;
        try {
          log.info("tradability", `Starting universe sync for ${assetClass}`);
          const assets = await alpaca.getAssets("active", assetClass);
          log.info(
            "tradability",
            `Fetched ${assets.length} ${assetClass} assets from Alpaca`
          );
          const insertAssets = assets.map(mapAlpacaAssetToInsert);
          synced = await storage.bulkUpsertBrokerAssets(insertAssets);
          tradable = assets.filter((a) => a.tradable).length;
          log.info(
            "tradability",
            `Universe sync complete: ${synced} synced, ${tradable} tradable`
          );
        } catch (error) {
          errors.push(`Sync failed for ${assetClass}: ${error.message}`);
          log.error("tradability", `Universe sync error: ${error.message}`);
        }
        return { synced, tradable, errors };
      }
      async getUniverseStats() {
        const equityCount = await storage.getBrokerAssetCount("us_equity");
        const cryptoCount = await storage.getBrokerAssetCount("crypto");
        const lastSyncedAt = await storage.getLastAssetSyncTime();
        const tradableEquities = (await storage.getBrokerAssets("us_equity", true)).length;
        const tradableCrypto = (await storage.getBrokerAssets("crypto", true)).length;
        const isStale = !lastSyncedAt || Date.now() - lastSyncedAt.getTime() > SYNC_STALE_THRESHOLD_MS;
        return {
          totalAssets: equityCount + cryptoCount,
          tradableEquities,
          tradableCrypto,
          lastSyncedAt,
          isStale
        };
      }
      async searchSymbols(query, limit4 = 20) {
        return storage.searchBrokerAssets(query, limit4);
      }
      clearMemoryCache() {
        memoryCache.clear();
        log.info("tradability", "Memory cache cleared");
      }
    };
    tradabilityService = new TradabilityService();
  }
});

// server/trading/order-types-matrix.ts
import { z as z6 } from "zod";
function isTerminalStatus(status) {
  return TERMINAL_STATUSES.includes(status);
}
function isActiveStatus(status) {
  return ACTIVE_STATUSES.includes(status);
}
function isFailedStatus(status) {
  return FAILED_STATUSES.includes(status);
}
function validateOrderTypeCombination(orderType, timeInForce, extendedHours = false) {
  const result = { valid: true, errors: [], warnings: [] };
  const typeConfig = ORDER_TYPE_MATRIX.find((t) => t.orderType === orderType);
  if (!typeConfig) {
    result.valid = false;
    result.errors.push(`Invalid order type: ${orderType}`);
    return result;
  }
  if (!typeConfig.validTimeInForce.includes(timeInForce)) {
    result.valid = false;
    result.errors.push(
      `Invalid time_in_force '${timeInForce}' for ${orderType} order. Valid options: ${typeConfig.validTimeInForce.join(", ")}`
    );
  }
  if (extendedHours && !typeConfig.supportsExtendedHours) {
    result.valid = false;
    result.errors.push(
      `Extended hours trading not supported for ${orderType} orders. Use limit or stop_limit orders for extended hours.`
    );
  }
  return result;
}
function validateStopPrice(side, currentPrice, stopPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy" && stopPrice <= currentPrice) {
    result.warnings.push(
      `Buy stop at $${stopPrice} is below current price $${currentPrice}. This order will trigger immediately as a market order.`
    );
  }
  if (side === "sell" && stopPrice >= currentPrice) {
    result.warnings.push(
      `Sell stop at $${stopPrice} is above current price $${currentPrice}. This order will trigger immediately as a market order.`
    );
  }
  return result;
}
function validateLimitPrice(side, currentPrice, limitPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy" && limitPrice > currentPrice * 1.1) {
    result.warnings.push(
      `Buy limit at $${limitPrice} is significantly above current price $${currentPrice}. This order will likely fill immediately at a worse price.`
    );
  }
  if (side === "sell" && limitPrice < currentPrice * 0.9) {
    result.warnings.push(
      `Sell limit at $${limitPrice} is significantly below current price $${currentPrice}. This order will likely fill immediately at a worse price.`
    );
  }
  return result;
}
function validateBracketOrder(side, entryPrice, takeProfitPrice, stopLossPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy") {
    if (takeProfitPrice <= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Take profit price ($${takeProfitPrice}) must be above entry price ($${entryPrice}) for buy orders`
      );
    }
    if (stopLossPrice >= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Stop loss price ($${stopLossPrice}) must be below entry price ($${entryPrice}) for buy orders`
      );
    }
  } else {
    if (takeProfitPrice >= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Take profit price ($${takeProfitPrice}) must be below entry price ($${entryPrice}) for sell orders`
      );
    }
    if (stopLossPrice <= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Stop loss price ($${stopLossPrice}) must be above entry price ($${entryPrice}) for sell orders`
      );
    }
  }
  return result;
}
function validateTrailingStop(trailPercent, trailPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (trailPercent !== void 0 && trailPrice !== void 0) {
    result.valid = false;
    result.errors.push(
      "Cannot specify both trail_percent and trail_price. Choose one."
    );
  }
  if (trailPercent === void 0 && trailPrice === void 0) {
    result.valid = false;
    result.errors.push(
      "Must specify either trail_percent or trail_price for trailing stop orders."
    );
  }
  if (trailPercent !== void 0) {
    if (trailPercent <= 0 || trailPercent > 100) {
      result.valid = false;
      result.errors.push(
        `Trail percent must be between 0 and 100, got ${trailPercent}`
      );
    }
    if (trailPercent < 0.5) {
      result.warnings.push(
        "Trail percent below 0.5% may trigger too frequently"
      );
    }
    if (trailPercent > 10) {
      result.warnings.push(
        "Trail percent above 10% may not provide adequate protection"
      );
    }
  }
  if (trailPrice !== void 0 && trailPrice <= 0) {
    result.valid = false;
    result.errors.push(`Trail price must be positive, got ${trailPrice}`);
  }
  return result;
}
var OrderTypeEnum, OrderClassEnum, TimeInForceEnum, OrderSideEnum, ORDER_TYPE_MATRIX, BaseOrderSchema, QuantitySchema, MarketOrderSchema, LimitOrderSchema, StopOrderSchema, StopLimitOrderSchema, TrailingStopOrderSchema, BracketOrderSchema, OCOOrderSchema, OTOOrderSchema, SimpleOrderSchema, ComplexOrderSchema, CreateOrderSchema, OrderStatusEnum, TERMINAL_STATUSES, ACTIVE_STATUSES, FAILED_STATUSES;
var init_order_types_matrix = __esm({
  "server/trading/order-types-matrix.ts"() {
    "use strict";
    OrderTypeEnum = z6.enum([
      "market",
      "limit",
      "stop",
      "stop_limit",
      "trailing_stop"
    ]);
    OrderClassEnum = z6.enum(["simple", "bracket", "oco", "oto"]);
    TimeInForceEnum = z6.enum([
      "day",
      "gtc",
      "opg",
      "cls",
      "ioc",
      "fok"
    ]);
    OrderSideEnum = z6.enum(["buy", "sell"]);
    ORDER_TYPE_MATRIX = [
      {
        orderType: "market",
        validTimeInForce: ["day", "opg", "cls", "ioc", "fok"],
        supportsExtendedHours: false,
        requiredFields: ["symbol", "side", "qty|notional"],
        optionalFields: ["client_order_id"],
        description: "Execute immediately at best available price"
      },
      {
        orderType: "limit",
        validTimeInForce: ["day", "gtc", "opg", "cls", "ioc", "fok"],
        supportsExtendedHours: true,
        requiredFields: ["symbol", "side", "qty|notional", "limit_price"],
        optionalFields: ["client_order_id", "extended_hours"],
        description: "Execute at specified price or better"
      },
      {
        orderType: "stop",
        validTimeInForce: ["day", "gtc"],
        supportsExtendedHours: false,
        requiredFields: ["symbol", "side", "qty", "stop_price"],
        optionalFields: ["client_order_id"],
        description: "Trigger market order when stop price is reached"
      },
      {
        orderType: "stop_limit",
        validTimeInForce: ["day", "gtc"],
        supportsExtendedHours: true,
        requiredFields: ["symbol", "side", "qty", "stop_price", "limit_price"],
        optionalFields: ["client_order_id", "extended_hours"],
        description: "Trigger limit order when stop price is reached"
      },
      {
        orderType: "trailing_stop",
        validTimeInForce: ["day", "gtc"],
        supportsExtendedHours: false,
        requiredFields: ["symbol", "side", "qty", "trail_percent|trail_price"],
        optionalFields: ["client_order_id"],
        description: "Dynamic stop that follows price movement"
      }
    ];
    BaseOrderSchema = z6.object({
      symbol: z6.string().min(1).max(10).toUpperCase(),
      side: OrderSideEnum,
      client_order_id: z6.string().uuid().optional()
    });
    QuantitySchema = z6.union([
      z6.object({
        qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number")
      }),
      z6.object({
        notional: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive dollar amount")
      })
    ]);
    MarketOrderSchema = BaseOrderSchema.extend({
      type: z6.literal("market"),
      time_in_force: z6.enum(["day", "opg", "cls", "ioc", "fok"]),
      extended_hours: z6.literal(false).optional()
    }).and(QuantitySchema);
    LimitOrderSchema = BaseOrderSchema.extend({
      type: z6.literal("limit"),
      time_in_force: TimeInForceEnum,
      limit_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
      extended_hours: z6.boolean().optional()
    }).and(QuantitySchema);
    StopOrderSchema = BaseOrderSchema.extend({
      type: z6.literal("stop"),
      time_in_force: z6.enum(["day", "gtc"]),
      stop_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      extended_hours: z6.literal(false).optional()
    });
    StopLimitOrderSchema = BaseOrderSchema.extend({
      type: z6.literal("stop_limit"),
      time_in_force: z6.enum(["day", "gtc"]),
      stop_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
      limit_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      extended_hours: z6.boolean().optional()
    });
    TrailingStopOrderSchema = BaseOrderSchema.extend({
      type: z6.literal("trailing_stop"),
      time_in_force: z6.enum(["day", "gtc"]),
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      extended_hours: z6.literal(false).optional()
    }).and(
      z6.union([
        z6.object({
          trail_percent: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive percent")
        }),
        z6.object({
          trail_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive dollar amount")
        })
      ])
    );
    BracketOrderSchema = BaseOrderSchema.extend({
      order_class: z6.literal("bracket"),
      type: z6.enum(["market", "limit"]),
      time_in_force: z6.literal("day"),
      // FIXED: Must be "day" only - "gtc" causes 422 rejection
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      limit_price: z6.string().regex(/^\d+(\.\d+)?$/).optional(),
      take_profit: z6.object({
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
      }),
      stop_loss: z6.object({
        stop_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/).optional()
      })
    });
    OCOOrderSchema = BaseOrderSchema.extend({
      order_class: z6.literal("oco"),
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      time_in_force: z6.enum(["day", "gtc"]),
      take_profit: z6.object({
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
      }),
      stop_loss: z6.object({
        stop_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/).optional()
      })
    });
    OTOOrderSchema = BaseOrderSchema.extend({
      order_class: z6.literal("oto"),
      type: z6.enum(["market", "limit"]),
      time_in_force: z6.enum(["day", "gtc"]),
      qty: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
      limit_price: z6.string().regex(/^\d+(\.\d+)?$/).optional(),
      stop_loss: z6.object({
        stop_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/).optional()
      }).optional(),
      take_profit: z6.object({
        limit_price: z6.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
      }).optional()
    });
    SimpleOrderSchema = z6.union([
      MarketOrderSchema,
      LimitOrderSchema,
      StopOrderSchema,
      StopLimitOrderSchema,
      TrailingStopOrderSchema
    ]);
    ComplexOrderSchema = z6.union([
      BracketOrderSchema,
      OCOOrderSchema,
      OTOOrderSchema
    ]);
    CreateOrderSchema = z6.union([
      SimpleOrderSchema,
      ComplexOrderSchema
    ]);
    OrderStatusEnum = z6.enum([
      "new",
      // Order has been received but not yet accepted
      "pending_new",
      // Order is being processed
      "accepted",
      // Order is accepted and live in the market
      "partially_filled",
      // Order has been partially filled
      "filled",
      // Order has been completely filled
      "done_for_day",
      // Order is done for the day
      "canceled",
      // Order has been canceled
      "expired",
      // Order has expired
      "replaced",
      // Order has been replaced
      "pending_cancel",
      // Order cancel request is pending
      "pending_replace",
      // Order replace request is pending
      "stopped",
      // Order has been stopped
      "rejected",
      // Order has been rejected
      "suspended",
      // Order has been suspended
      "calculated"
      // Order is being calculated
    ]);
    TERMINAL_STATUSES = [
      "filled",
      "canceled",
      "expired",
      "replaced",
      "rejected"
    ];
    ACTIVE_STATUSES = [
      "new",
      "pending_new",
      "accepted",
      "partially_filled",
      "pending_cancel",
      "pending_replace"
    ];
    FAILED_STATUSES = ["canceled", "expired", "rejected"];
  }
});

// server/trading/order-execution-flow.ts
import { randomUUID } from "crypto";
function classifyError(error, context) {
  const message = error.message.toLowerCase();
  if (message.includes("insufficient") || message.includes("buying power")) {
    return {
      type: "INSUFFICIENT_FUNDS" /* INSUFFICIENT_FUNDS */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */
    };
  }
  if (message.includes("symbol") && (message.includes("not found") || message.includes("invalid"))) {
    return {
      type: "INVALID_SYMBOL" /* INVALID_SYMBOL */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "MANUAL_INTERVENTION" /* MANUAL_INTERVENTION */
    };
  }
  if (message.includes("market") && (message.includes("closed") || message.includes("not open"))) {
    return {
      type: "MARKET_CLOSED" /* MARKET_CLOSED */,
      message: error.message,
      retryable: true,
      suggestedDelay: 6e4,
      recoveryStrategy: "WAIT_FOR_MARKET_OPEN" /* WAIT_FOR_MARKET_OPEN */
    };
  }
  if (message.includes("429") || message.includes("rate limit")) {
    return {
      type: "RATE_LIMITED" /* RATE_LIMITED */,
      message: error.message,
      retryable: true,
      suggestedDelay: 5e3,
      recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */
    };
  }
  if (message.includes("network") || message.includes("fetch") || message.includes("econnrefused")) {
    return {
      type: "NETWORK_ERROR" /* NETWORK_ERROR */,
      message: error.message,
      retryable: true,
      suggestedDelay: 2e3,
      recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */
    };
  }
  if (message.includes("timeout")) {
    return {
      type: "TIMEOUT" /* TIMEOUT */,
      message: error.message,
      retryable: true,
      suggestedDelay: 1e3,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  if (message.includes("rejected") || message.includes("refused")) {
    return {
      type: "BROKER_REJECTION" /* BROKER_REJECTION */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */
    };
  }
  if (message.includes("position") && message.includes("not found")) {
    return {
      type: "POSITION_NOT_FOUND" /* POSITION_NOT_FOUND */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  if (message.includes("order") && message.includes("not found")) {
    return {
      type: "ORDER_NOT_FOUND" /* ORDER_NOT_FOUND */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  return {
    type: "UNKNOWN" /* UNKNOWN */,
    message: error.message,
    retryable: true,
    suggestedDelay: 3e3,
    recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */,
    originalError: error
  };
}
async function identifyUnrealOrders() {
  const unrealOrders = [];
  try {
    const allOrders = await alpaca.getOrders("all", 500);
    const staleThresholdMs = 24 * 60 * 60 * 1e3;
    const now = Date.now();
    for (const order of allOrders) {
      let isUnreal = false;
      let reason = "";
      const filledQty = safeParseFloat(order.filled_qty, 0);
      const notionalValue = order.notional ? safeParseFloat(order.notional, 0) : 0;
      const orderCreatedAt = new Date(order.created_at).getTime();
      const orderAgeMs = now - orderCreatedAt;
      if (order.status === "rejected") {
        isUnreal = true;
        reason = "Order was rejected by broker";
      } else if (order.status === "canceled" && filledQty === 0) {
        isUnreal = true;
        reason = "Order was canceled with no fills";
      } else if (order.status === "expired" && filledQty === 0) {
        isUnreal = true;
        reason = "Order expired with no fills";
      } else if (filledQty === 0 && notionalValue === 0 && order.qty === "0") {
        isUnreal = true;
        reason = "Order has zero quantity and zero notional";
      } else if (isActiveStatus(order.status) && orderAgeMs >= staleThresholdMs && filledQty === 0) {
        isUnreal = true;
        reason = "Stale active order with no fills (>24 hours old)";
      }
      if (isUnreal) {
        unrealOrders.push({
          orderId: order.id,
          symbol: order.symbol,
          status: order.status,
          reason,
          createdAt: order.created_at,
          filledQty: order.filled_qty,
          qty: order.qty,
          notional: order.notional
        });
      }
    }
  } catch (error) {
    log.error("OrderCleanup", "Failed to identify unreal orders", {
      error: error.message
    });
  }
  return unrealOrders;
}
async function cleanupUnrealOrders() {
  const result = {
    identified: 0,
    canceled: 0,
    errors: []
  };
  try {
    const unrealOrders = await identifyUnrealOrders();
    result.identified = unrealOrders.length;
    for (const order of unrealOrders) {
      if (isActiveStatus(order.status)) {
        try {
          await alpaca.cancelOrder(order.orderId);
          log.info("OrderCleanup", "Canceled unreal order", {
            orderId: order.orderId,
            reason: order.reason
          });
          result.canceled++;
        } catch (error) {
          const errorMsg = `Failed to cancel ${order.orderId}: ${error.message}`;
          result.errors.push(errorMsg);
          log.warn("OrderCleanup", "Failed to cancel order", {
            orderId: order.orderId,
            error: error.message
          });
        }
      }
    }
    log.info("OrderCleanup", "Unreal order cleanup complete", {
      identified: result.identified,
      canceled: result.canceled
    });
  } catch (error) {
    result.errors.push(`Cleanup failed: ${error.message}`);
  }
  return result;
}
async function reconcileOrderBook() {
  const result = {
    alpacaOrders: 0,
    localTrades: 0,
    missingLocal: [],
    orphanedLocal: [],
    synced: 0
  };
  try {
    const alpacaOrders = await alpaca.getOrders("all", 100);
    result.alpacaOrders = alpacaOrders.length;
    const localTrades = await storage.getTrades(void 0, 100);
    result.localTrades = localTrades.length;
    const alpacaOrderIds = new Set(alpacaOrders.map((o) => o.id));
    const alpacaClientIds = new Set(alpacaOrders.map((o) => o.client_order_id));
    for (const order of alpacaOrders) {
      if (order.status === "filled") {
        const hasLocal = localTrades.some(
          (t) => t.notes?.includes(order.id) || t.notes?.includes(order.client_order_id)
        );
        if (!hasLocal) {
          result.missingLocal.push(order.id);
          await storage.createTrade({
            symbol: order.symbol,
            side: order.side,
            quantity: order.filled_qty,
            price: order.filled_avg_price || "0",
            status: "completed",
            notes: `Synced from Alpaca: ${order.id}`,
            pnl: null,
            strategyId: null
          });
          result.synced++;
        }
      }
    }
    log.info("Reconciliation", "Order book reconciliation complete", {
      alpacaOrders: result.alpacaOrders,
      localTrades: result.localTrades,
      synced: result.synced
    });
  } catch (error) {
    log.error("Reconciliation", "Order book reconciliation failed", {
      error: error.message
    });
  }
  return result;
}
async function waitForAlpacaOrderFill(orderId, timeoutMs = ORDER_FILL_TIMEOUT_MS) {
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    try {
      const order = await alpaca.getOrder(orderId);
      const filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      const hasFillData = filledPrice > 0 && filledQty > 0;
      if (order.status === "filled" && hasFillData) {
        return {
          order,
          timedOut: false,
          hasFillData: true,
          isFullyFilled: true
        };
      }
      if (isTerminalStatus(order.status)) {
        log.info("OrderFlow", "Order ended with status", {
          orderId,
          status: order.status
        });
        return { order, timedOut: false, hasFillData, isFullyFilled: false };
      }
      await new Promise(
        (resolve2) => setTimeout(resolve2, ORDER_FILL_POLL_INTERVAL_MS)
      );
    } catch (error) {
      log.error("OrderFlow", "Error polling order", {
        orderId,
        error: error.message
      });
      await new Promise(
        (resolve2) => setTimeout(resolve2, ORDER_FILL_POLL_INTERVAL_MS)
      );
    }
  }
  log.warn("OrderFlow", "Order fill timeout", { orderId, timeoutMs });
  try {
    const finalOrder = await alpaca.getOrder(orderId);
    const filledPrice = safeParseFloat(finalOrder.filled_avg_price, 0);
    const filledQty = safeParseFloat(finalOrder.filled_qty, 0);
    const hasFillData = filledPrice > 0 && filledQty > 0;
    const isFullyFilled = finalOrder.status === "filled" && hasFillData;
    return { order: finalOrder, timedOut: true, hasFillData, isFullyFilled };
  } catch {
    return {
      order: null,
      timedOut: true,
      hasFillData: false,
      isFullyFilled: false
    };
  }
}
async function cancelExpiredOrders(maxAgeMs = STALE_ORDER_TIMEOUT_MS) {
  let canceledCount = 0;
  try {
    const openOrders = await alpaca.getOrders("open", 100);
    const now = Date.now();
    for (const order of openOrders) {
      const createdAt = new Date(order.created_at).getTime();
      const orderAge = now - createdAt;
      if (orderAge > maxAgeMs) {
        try {
          await alpaca.cancelOrder(order.id);
          canceledCount++;
          log.info("OrderFlow", "Canceled expired order", {
            orderId: order.id,
            symbol: order.symbol,
            ageSec: Math.floor(orderAge / 1e3)
          });
        } catch (error) {
          log.warn("OrderFlow", "Failed to cancel expired order", {
            orderId: order.id,
            error: error.message
          });
        }
      }
    }
    if (canceledCount > 0) {
      log.info("OrderFlow", "Expired order cancellation complete", {
        canceledCount
      });
    }
  } catch (error) {
    log.error("OrderFlow", "Error checking for expired orders", {
      error: error.message
    });
  }
  return canceledCount;
}
async function getUserEmailForNotifications() {
  return null;
}
async function checkPositionForLargeLoss(symbol, currentPrice) {
  try {
    const positions2 = await alpaca.getPositions();
    const position = positions2.find((p) => p.symbol === symbol);
    if (!position) {
      return;
    }
    const unrealizedPL = parseFloat(position.unrealized_pl || "0");
    const avgEntryPrice = parseFloat(position.avg_entry_price);
    const marketValue = parseFloat(position.market_value || "0");
    const percentLoss = marketValue > 0 ? percentChange(unrealizedPL, Math.abs(marketValue)).toNumber() : 0;
    if (percentLoss < -5) {
      const userEmail = await getUserEmailForNotifications();
      if (userEmail) {
        sendLossAlertEmail(userEmail, {
          symbol,
          unrealizedPL,
          percentLoss,
          currentPrice,
          avgEntryPrice
        }).catch(
          (err) => log.error("Notification", "Loss alert email failed", {
            error: err.message,
            symbol
          })
        );
      }
    }
  } catch (error) {
    log.error("OrderExecution", "Error checking position for large loss", {
      error: error.message,
      symbol
    });
  }
}
async function notifyCircuitBreakerTriggered(reason, estimatedRecovery) {
  try {
    const userEmail = await getUserEmailForNotifications();
    if (userEmail) {
      sendCircuitBreakerEmail(userEmail, {
        reason,
        triggeredAt: /* @__PURE__ */ new Date(),
        estimatedRecovery
      }).catch(
        (err) => log.error("Notification", "Circuit breaker email failed", {
          error: err.message,
          reason
        })
      );
    }
  } catch (error) {
    log.error("OrderExecution", "Error sending circuit breaker notification", {
      error: error.message,
      reason
    });
  }
}
var DEFAULT_OPTIONS, OrderExecutionEngine, orderExecutionEngine, ORDER_FILL_POLL_INTERVAL_MS, ORDER_FILL_TIMEOUT_MS, STALE_ORDER_TIMEOUT_MS;
var init_order_execution_flow = __esm({
  "server/trading/order-execution-flow.ts"() {
    "use strict";
    init_alpaca();
    init_storage();
    init_numeric();
    init_money();
    init_performance_metrics();
    init_order_execution_cache();
    init_webhook_emitter();
    init_notification_service();
    init_tradability_service();
    init_logger();
    init_order_types_matrix();
    init_trading_config();
    DEFAULT_OPTIONS = {
      maxRetries: 3,
      retryDelayMs: 1e3,
      timeoutMs: 3e4,
      validateBeforeSubmit: true,
      trackExpectedOutcome: true,
      autoRecover: true
    };
    OrderExecutionEngine = class {
      activeExecutions = /* @__PURE__ */ new Map();
      /**
       * Execute order with full validation, retry, and recovery
       */
      async executeOrder(params, options = {}) {
        const opts = { ...DEFAULT_OPTIONS, ...options };
        const clientOrderId = params.client_order_id || randomUUID();
        const state = {
          orderId: null,
          clientOrderId,
          status: "pending",
          symbol: params.symbol,
          side: params.side,
          orderType: params.type,
          requestedQty: params.qty || params.notional || "0",
          filledQty: "0",
          requestedPrice: params.limit_price || params.stop_price || null,
          filledPrice: null,
          attempts: 0,
          maxAttempts: opts.maxRetries,
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          errors: [],
          validationResult: null,
          expectedOutcome: null,
          actualOutcome: null
        };
        this.activeExecutions.set(clientOrderId, state);
        const warnings = [];
        try {
          state.status = "validating";
          state.updatedAt = /* @__PURE__ */ new Date();
          if (opts.validateBeforeSubmit) {
            const validation = await this.validateOrderParams(params);
            state.validationResult = validation;
            if (!validation.valid) {
              const error = classifyError(new Error(validation.errors.join("; ")));
              error.type = "VALIDATION_ERROR" /* VALIDATION_ERROR */;
              state.errors.push(error);
              state.status = "failed";
              return {
                success: false,
                state,
                error,
                validationWarnings: validation.warnings
              };
            }
            warnings.push(...validation.warnings);
          }
          if (opts.trackExpectedOutcome) {
            state.expectedOutcome = await this.calculateExpectedOutcome(params);
          }
          state.status = "submitting";
          let order = null;
          while (state.attempts < opts.maxRetries) {
            state.attempts++;
            state.updatedAt = /* @__PURE__ */ new Date();
            try {
              const orderWithClientId = {
                ...params,
                client_order_id: clientOrderId
              };
              order = await this.submitOrderWithTimeout(
                orderWithClientId,
                opts.timeoutMs
              );
              state.orderId = order.id;
              state.status = "submitted";
              emitEvent("trade.order.submitted", {
                orderId: order.id,
                clientOrderId,
                symbol: params.symbol,
                side: params.side,
                type: params.type,
                qty: params.qty,
                limitPrice: params.limit_price,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              }).catch(
                (err) => log.error("Webhook", "Order submitted event failed", {
                  error: err.message
                })
              );
              sendNotification("trade.order.submitted", {
                orderId: order.id,
                symbol: params.symbol,
                side: params.side,
                qty: params.qty,
                price: params.limit_price || "market"
              }).catch(
                (err) => log.error("Notification", "Order submitted notification failed", {
                  error: err.message
                })
              );
              break;
            } catch (error) {
              const classifiedError = classifyError(
                error,
                `Attempt ${state.attempts}`
              );
              state.errors.push(classifiedError);
              if (!classifiedError.retryable || state.attempts >= opts.maxRetries) {
                if (opts.autoRecover && classifiedError.recoveryStrategy !== "NONE" /* NONE */) {
                  const recovered = await this.attemptRecovery(
                    state,
                    classifiedError,
                    params
                  );
                  if (recovered) {
                    order = recovered;
                    break;
                  }
                }
                state.status = "failed";
                sendNotification("trade.order.rejected", {
                  symbol: params.symbol,
                  side: params.side,
                  qty: params.qty,
                  reason: classifiedError.message
                }).catch(
                  (err) => log.error("Notification", "Order rejected notification failed", {
                    error: err.message
                  })
                );
                return {
                  success: false,
                  state,
                  error: classifiedError,
                  validationWarnings: warnings
                };
              }
              const delay = classifiedError.suggestedDelay * Math.pow(2, state.attempts - 1);
              await this.sleep(delay);
            }
          }
          if (!order) {
            state.status = "failed";
            return {
              success: false,
              state,
              error: state.errors[state.errors.length - 1],
              validationWarnings: warnings
            };
          }
          state.status = "monitoring";
          const monitoredOrder = await this.monitorOrderUntilTerminal(
            order.id,
            opts.timeoutMs
          );
          state.actualOutcome = this.recordActualOutcome(monitoredOrder, state);
          if (isFailedStatus(monitoredOrder.status)) {
            state.status = monitoredOrder.status === "canceled" ? "canceled" : "failed";
            return {
              success: false,
              state,
              order: monitoredOrder,
              validationWarnings: warnings,
              outcomeAnalysis: this.analyzeOutcome(state)
            };
          }
          state.status = "filled";
          state.filledQty = monitoredOrder.filled_qty;
          state.filledPrice = monitoredOrder.filled_avg_price;
          emitEvent("trade.order.filled", {
            orderId: monitoredOrder.id,
            clientOrderId,
            symbol: monitoredOrder.symbol,
            side: monitoredOrder.side,
            filledQty: monitoredOrder.filled_qty,
            filledPrice: monitoredOrder.filled_avg_price,
            status: monitoredOrder.status,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }).catch(
            (err) => log.error("Webhook", "Order filled event failed", {
              error: err.message
            })
          );
          sendNotification("trade.order.filled", {
            orderId: monitoredOrder.id,
            symbol: monitoredOrder.symbol,
            side: monitoredOrder.side,
            qty: monitoredOrder.filled_qty,
            price: monitoredOrder.filled_avg_price
          }).catch(
            (err) => log.error("Notification", "Order filled notification failed", {
              error: err.message
            })
          );
          const userEmail = await getUserEmailForNotifications();
          if (userEmail) {
            const filledPrice = parseFloat(monitoredOrder.filled_avg_price || "0");
            const filledQty = parseFloat(monitoredOrder.filled_qty);
            sendOrderFilledEmail(userEmail, {
              symbol: monitoredOrder.symbol,
              side: monitoredOrder.side,
              qty: filledQty,
              price: filledPrice,
              totalValue: filledPrice * filledQty,
              timestamp: /* @__PURE__ */ new Date()
            }).catch(
              (err) => log.error("Notification", "Order filled email failed", {
                error: err.message
              })
            );
          }
          return {
            success: true,
            state,
            order: monitoredOrder,
            validationWarnings: warnings,
            outcomeAnalysis: this.analyzeOutcome(state)
          };
        } finally {
          this.activeExecutions.delete(clientOrderId);
        }
      }
      /**
       * Validate order parameters before submission
       */
      async validateOrderParams(params) {
        const result = { valid: true, errors: [], warnings: [] };
        try {
          CreateOrderSchema.parse(params);
        } catch (e) {
          result.valid = false;
          const errorMessage = e instanceof Error ? e.message : String(e);
          result.errors.push(`Schema validation failed: ${errorMessage}`);
          return result;
        }
        const tradabilityCheck = await tradabilityService.validateSymbolTradable(
          params.symbol
        );
        if (!tradabilityCheck.tradable) {
          result.valid = false;
          result.errors.push(
            `Symbol ${params.symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}`
          );
          return result;
        }
        if (!tradabilityCheck.fractionable && params.notional) {
          result.warnings.push(
            `${params.symbol} does not support fractional trading; use qty instead of notional`
          );
        }
        if (!tradabilityCheck.marginable) {
          result.warnings.push(`${params.symbol} is not marginable`);
        }
        const typeTifValidation = validateOrderTypeCombination(
          params.type,
          params.time_in_force,
          params.extended_hours
        );
        result.errors.push(...typeTifValidation.errors);
        result.warnings.push(...typeTifValidation.warnings);
        if (!typeTifValidation.valid) result.valid = false;
        let currentPrice = null;
        const cachedQuote = getQuickQuote(params.symbol);
        if (cachedQuote) {
          currentPrice = cachedQuote.price;
        } else {
          try {
            const operationId = `quote_${params.symbol}_${Date.now()}`;
            performanceTracker.startTimer(operationId);
            const snapshots = await alpaca.getSnapshots([params.symbol]);
            const latency = performanceTracker.endTimer(
              operationId,
              "quoteRetrieval"
            );
            currentPrice = snapshots[params.symbol]?.latestTrade?.p || null;
            if (currentPrice) {
              const trade = snapshots[params.symbol]?.latestTrade;
              cacheQuickQuote({
                symbol: params.symbol,
                price: currentPrice,
                bid: snapshots[params.symbol]?.latestQuote?.bp || currentPrice,
                ask: snapshots[params.symbol]?.latestQuote?.ap || currentPrice,
                spread: 0,
                timestamp: Date.now()
              });
            }
            if (latency > 10) {
              log.debug("OrderExecution", "Slow quote retrieval", {
                latencyMs: latency,
                symbol: params.symbol
              });
            }
          } catch {
            result.warnings.push(
              `Could not fetch current price for ${params.symbol}`
            );
          }
        }
        if (currentPrice) {
          if (params.stop_price) {
            const stopValidation = validateStopPrice(
              params.side,
              currentPrice,
              parseFloat(params.stop_price)
            );
            result.errors.push(...stopValidation.errors);
            result.warnings.push(...stopValidation.warnings);
            if (!stopValidation.valid) result.valid = false;
          }
          if (params.limit_price) {
            const limitValidation = validateLimitPrice(
              params.side,
              currentPrice,
              parseFloat(params.limit_price)
            );
            result.errors.push(...limitValidation.errors);
            result.warnings.push(...limitValidation.warnings);
            if (!limitValidation.valid) result.valid = false;
          }
          if (params.order_class === "bracket" && params.take_profit && params.stop_loss) {
            const entryPrice = params.limit_price ? parseFloat(params.limit_price) : currentPrice;
            const bracketValidation = validateBracketOrder(
              params.side,
              entryPrice,
              parseFloat(params.take_profit.limit_price),
              parseFloat(params.stop_loss.stop_price)
            );
            result.errors.push(...bracketValidation.errors);
            result.warnings.push(...bracketValidation.warnings);
            if (!bracketValidation.valid) result.valid = false;
          }
        }
        if (params.type === "trailing_stop") {
          const trailValidation = validateTrailingStop(
            params.trail_percent ? parseFloat(params.trail_percent) : void 0,
            params.trail_price ? parseFloat(params.trail_price) : void 0
          );
          result.errors.push(...trailValidation.errors);
          result.warnings.push(...trailValidation.warnings);
          if (!trailValidation.valid) result.valid = false;
        }
        if (!params.extended_hours) {
          try {
            const marketStatus = await alpaca.getMarketStatus();
            if (!marketStatus.isOpen && params.time_in_force === "day") {
              result.warnings.push(
                `Market is currently ${marketStatus.session}. Day orders will queue until market open.`
              );
            }
          } catch {
            result.warnings.push("Could not verify market status");
          }
        }
        return result;
      }
      /**
       * Calculate expected outcome based on order parameters
       */
      async calculateExpectedOutcome(params) {
        const qty = parseFloat(params.qty || "0");
        const notional = parseFloat(params.notional || "0");
        let currentPrice = 0;
        try {
          const snapshots = await alpaca.getSnapshots([params.symbol]);
          currentPrice = snapshots[params.symbol]?.latestTrade?.p || 0;
        } catch {
          currentPrice = params.limit_price ? parseFloat(params.limit_price) : 0;
        }
        const expectedQty = qty > 0 ? qty : calculateQuantity(notional, currentPrice).toNumber();
        const risks = [];
        let fillPriceMin = currentPrice;
        let fillPriceMax = currentPrice;
        let shouldFillImmediately = false;
        let fillTimeEstimate = 0;
        switch (params.type) {
          case "market":
            fillPriceMin = priceWithBuffer(currentPrice, 5e-3, -1).toNumber();
            fillPriceMax = priceWithBuffer(currentPrice, 5e-3, 1).toNumber();
            shouldFillImmediately = true;
            fillTimeEstimate = 500;
            risks.push("Slippage possible in fast-moving markets");
            break;
          case "limit":
            const limitPrice = parseFloat(params.limit_price || "0");
            fillPriceMin = limitPrice;
            fillPriceMax = limitPrice;
            shouldFillImmediately = params.side === "buy" ? limitPrice >= currentPrice : limitPrice <= currentPrice;
            fillTimeEstimate = shouldFillImmediately ? 1e3 : 3e5;
            if (!shouldFillImmediately) {
              risks.push("Order may not fill if price doesn't reach limit");
            }
            break;
          case "stop":
            const stopPrice = parseFloat(params.stop_price || "0");
            fillPriceMin = priceWithBuffer(stopPrice, 0.01, -1).toNumber();
            fillPriceMax = priceWithBuffer(stopPrice, 0.01, 1).toNumber();
            shouldFillImmediately = false;
            fillTimeEstimate = 6e5;
            risks.push("Stop orders trigger as market orders - slippage possible");
            break;
          case "stop_limit":
            fillPriceMin = parseFloat(params.limit_price || "0");
            fillPriceMax = parseFloat(params.limit_price || "0");
            shouldFillImmediately = false;
            fillTimeEstimate = 6e5;
            risks.push("Order may not fill if gap occurs past limit price");
            break;
          case "trailing_stop":
            fillPriceMin = priceWithBuffer(currentPrice, 0.1, -1).toNumber();
            fillPriceMax = priceWithBuffer(currentPrice, 0.1, 1).toNumber();
            shouldFillImmediately = false;
            fillTimeEstimate = 36e5;
            risks.push("Trailing stop may trigger during normal volatility");
            break;
        }
        const avgFillPrice = toDecimal(fillPriceMin).plus(fillPriceMax).dividedBy(2);
        const estimatedCost = positionValue(expectedQty, avgFillPrice).toNumber();
        return {
          fillPrice: { min: fillPriceMin, max: fillPriceMax },
          fillQty: expectedQty,
          estimatedCost,
          shouldFillImmediately,
          fillTimeEstimateMs: fillTimeEstimate,
          risksIdentified: risks
        };
      }
      /**
       * Submit order with timeout and performance tracking
       */
      async submitOrderWithTimeout(params, timeoutMs) {
        const operationId = `order_${params.symbol}_${Date.now()}`;
        performanceTracker.startTimer(operationId);
        return new Promise((resolve2, reject) => {
          const timeout = setTimeout(() => {
            performanceTracker.endTimer(operationId, "orderExecution");
            reject(new Error(`Order submission timed out after ${timeoutMs}ms`));
          }, timeoutMs);
          alpaca.createOrder(params).then((order) => {
            clearTimeout(timeout);
            const latency = performanceTracker.endTimer(
              operationId,
              "orderExecution"
            );
            if (latency > 50) {
              log.debug("OrderExecution", "Slow order submission", {
                latencyMs: latency,
                symbol: params.symbol
              });
            }
            resolve2(order);
          }).catch((error) => {
            clearTimeout(timeout);
            performanceTracker.endTimer(operationId, "orderExecution");
            reject(error);
          });
        });
      }
      /**
       * Monitor order until it reaches a terminal state
       */
      async monitorOrderUntilTerminal(orderId, timeoutMs) {
        const startTime = Date.now();
        const pollInterval = 1e3;
        while (Date.now() - startTime < timeoutMs) {
          try {
            const order = await alpaca.getOrder(orderId);
            if (isTerminalStatus(order.status)) {
              return order;
            }
            await this.sleep(pollInterval);
          } catch (error) {
            log.error("OrderExecution", "Error polling order", {
              orderId,
              error: error.message
            });
            await this.sleep(pollInterval);
          }
        }
        return await alpaca.getOrder(orderId);
      }
      /**
       * Record actual outcome from filled order
       */
      recordActualOutcome(order, state) {
        const fillPrice = safeParseFloat(order.filled_avg_price, 0);
        const fillQty = safeParseFloat(order.filled_qty, 0);
        const fillTimeMs = order.filled_at ? new Date(order.filled_at).getTime() - state.createdAt.getTime() : Date.now() - state.createdAt.getTime();
        const requestedPrice = state.requestedPrice ? parseFloat(state.requestedPrice) : null;
        const slippage = requestedPrice && fillPrice ? percentChange(fillPrice, requestedPrice).toNumber() : null;
        const unexpectedEvents = [];
        if (order.status === "partially_filled") {
          unexpectedEvents.push(
            `Only partially filled: ${fillQty} of ${order.qty}`
          );
        }
        if (slippage !== null && Math.abs(slippage) > 1) {
          unexpectedEvents.push(
            `Significant slippage: ${formatPrice(slippage, 2)}%`
          );
        }
        const totalCost = positionValue(fillQty, fillPrice).toNumber();
        return {
          filled: order.status === "filled",
          fillPrice,
          fillQty,
          totalCost,
          fillTimeMs,
          slippage,
          status: order.status,
          unexpectedEvents
        };
      }
      /**
       * Analyze outcome vs expected
       */
      analyzeOutcome(state) {
        const expected = state.expectedOutcome;
        const actual = state.actualOutcome;
        if (!expected || !actual) {
          return {
            matchesExpected: true,
            slippagePercent: null,
            fillTimeDeviation: null,
            unexpectedIssues: [],
            recommendations: []
          };
        }
        const issues = [];
        const recommendations = [];
        let matchesExpected = true;
        if (actual.fillPrice !== null) {
          if (actual.fillPrice < expected.fillPrice.min || actual.fillPrice > expected.fillPrice.max) {
            matchesExpected = false;
            issues.push(
              `Fill price $${actual.fillPrice.toFixed(2)} outside expected range $${expected.fillPrice.min.toFixed(2)}-$${expected.fillPrice.max.toFixed(2)}`
            );
            recommendations.push(
              "Consider using limit orders for better price control"
            );
          }
        }
        if (actual.fillQty < expected.fillQty * 0.99) {
          matchesExpected = false;
          issues.push(
            `Partial fill: ${actual.fillQty} of ${expected.fillQty} requested`
          );
          recommendations.push("Check liquidity before placing large orders");
        }
        const fillTimeDeviation = actual.fillTimeMs - expected.fillTimeEstimateMs;
        if (expected.shouldFillImmediately && actual.fillTimeMs > 5e3) {
          issues.push(`Expected immediate fill but took ${actual.fillTimeMs}ms`);
        }
        issues.push(...actual.unexpectedEvents);
        return {
          matchesExpected,
          slippagePercent: actual.slippage,
          fillTimeDeviation,
          unexpectedIssues: issues,
          recommendations
        };
      }
      /**
       * Attempt recovery based on error type
       */
      async attemptRecovery(state, error, originalParams) {
        state.status = "recovering";
        log.info("OrderExecution", "Attempting recovery", {
          recoveryStrategy: error.recoveryStrategy
        });
        switch (error.recoveryStrategy) {
          case "CHECK_AND_SYNC" /* CHECK_AND_SYNC */:
            try {
              const orders2 = await alpaca.getOrders("all", 10);
              const existingOrder = orders2.find(
                (o) => o.client_order_id === state.clientOrderId
              );
              if (existingOrder) {
                log.info("OrderExecution", "Found existing order via sync", {
                  orderId: existingOrder.id
                });
                return existingOrder;
              }
            } catch {
              log.error("OrderExecution", "Sync check failed");
            }
            return null;
          case "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */:
            if (error.type === "INSUFFICIENT_FUNDS" /* INSUFFICIENT_FUNDS */) {
              const reducedParams = { ...originalParams };
              if (reducedParams.qty) {
                reducedParams.qty = toDecimal(reducedParams.qty).times(0.5).toString();
              } else if (reducedParams.notional) {
                reducedParams.notional = toDecimal(reducedParams.notional).times(0.5).toString();
              }
              try {
                return await alpaca.createOrder(reducedParams);
              } catch {
                return null;
              }
            }
            return null;
          case "WAIT_FOR_MARKET_OPEN" /* WAIT_FOR_MARKET_OPEN */:
            const marketStatus = await alpaca.getMarketStatus();
            if (marketStatus.isOpen || marketStatus.isExtendedHours) {
              try {
                return await alpaca.createOrder(originalParams);
              } catch {
                return null;
              }
            }
            return null;
          default:
            return null;
        }
      }
      sleep(ms) {
        return new Promise((resolve2) => setTimeout(resolve2, ms));
      }
      /**
       * Get active execution states for monitoring
       */
      getActiveExecutions() {
        return new Map(this.activeExecutions);
      }
    };
    orderExecutionEngine = new OrderExecutionEngine();
    ORDER_FILL_POLL_INTERVAL_MS = tradingConfig.orderExecution.orderFillPollIntervalMs;
    ORDER_FILL_TIMEOUT_MS = tradingConfig.orderExecution.orderFillTimeoutMs;
    STALE_ORDER_TIMEOUT_MS = tradingConfig.orderExecution.staleOrderTimeoutMs;
  }
});

// server/lib/circuitBreaker.ts
var circuitBreaker_exports = {};
__export(circuitBreaker_exports, {
  getAllBreakerStats: () => getAllBreakerStats,
  getBreaker: () => getBreaker,
  getBreakerStats: () => getBreakerStats,
  isCircuitOpen: () => isCircuitOpen,
  removeBreaker: () => removeBreaker,
  resetAllBreakers: () => resetAllBreakers,
  resetBreaker: () => resetBreaker,
  withCircuitBreaker: () => withCircuitBreaker
});
import CircuitBreaker from "opossum";
function getBreaker(name, fn, options, fallback) {
  const key = name;
  if (breakers.has(key)) {
    return breakers.get(key);
  }
  const breaker = new CircuitBreaker(fn, {
    ...DEFAULT_OPTIONS2,
    ...options,
    name
  });
  if (fallback) {
    breaker.fallback(fallback);
  }
  breaker.on("open", () => {
    log.warn("CircuitBreaker", `[${name}] OPEN - failing fast`);
    const estimatedRecovery = new Date(
      Date.now() + (options?.resetTimeout || DEFAULT_OPTIONS2.resetTimeout || 3e4)
    );
    notifyCircuitBreakerTriggered(
      `Circuit breaker ${name} opened - service experiencing errors`,
      estimatedRecovery
    ).catch(
      (err) => log.error("CircuitBreaker", "Failed to send circuit breaker email", {
        error: err.message,
        breakerName: name
      })
    );
  });
  breaker.on("halfOpen", () => {
    log.info("CircuitBreaker", `[${name}] HALF-OPEN - testing`);
  });
  breaker.on("close", () => {
    log.info("CircuitBreaker", `[${name}] CLOSED - recovered`);
  });
  breaker.on("fallback", () => {
    log.debug("CircuitBreaker", `[${name}] Using fallback`);
  });
  breaker.on("timeout", () => {
    log.warn("CircuitBreaker", `[${name}] Request timed out`);
  });
  breakers.set(key, breaker);
  return breaker;
}
function getBreakerStats(name) {
  const breaker = breakers.get(name);
  if (!breaker) return null;
  const stats = breaker.stats;
  let state = "closed";
  if (breaker.opened) {
    state = "open";
  } else if (breaker.halfOpen) {
    state = "halfOpen";
  }
  return {
    name,
    state,
    failures: stats.failures,
    successes: stats.successes,
    fallbacks: stats.fallbacks,
    rejects: stats.rejects,
    timeouts: stats.timeouts,
    cacheHits: stats.cacheHits,
    cacheMisses: stats.cacheMisses,
    latencyMean: stats.latencyMean,
    percentiles: stats.percentiles
  };
}
function getAllBreakerStats() {
  const stats = {};
  for (const name of breakers.keys()) {
    stats[name] = getBreakerStats(name);
  }
  return stats;
}
function resetBreaker(name) {
  const breaker = breakers.get(name);
  if (breaker) {
    breaker.close();
    return true;
  }
  return false;
}
function resetAllBreakers() {
  for (const breaker of breakers.values()) {
    breaker.close();
  }
}
function isCircuitOpen(name) {
  const breaker = breakers.get(name);
  if (!breaker) return false;
  return breaker.opened;
}
function removeBreaker(name) {
  const breaker = breakers.get(name);
  if (breaker) {
    breaker.shutdown();
    breakers.delete(name);
    return true;
  }
  return false;
}
function withCircuitBreaker(name, fn, options, fallback) {
  const breaker = getBreaker(name, fn, options, fallback);
  return (...args) => breaker.fire(...args);
}
var DEFAULT_OPTIONS2, breakers;
var init_circuitBreaker = __esm({
  "server/lib/circuitBreaker.ts"() {
    "use strict";
    init_logger();
    init_order_execution_flow();
    DEFAULT_OPTIONS2 = {
      timeout: 1e4,
      errorThresholdPercentage: 50,
      resetTimeout: 3e4,
      volumeThreshold: 5
    };
    breakers = /* @__PURE__ */ new Map();
  }
});

// server/connectors/alpaca.ts
var alpaca_exports = {};
__export(alpaca_exports, {
  alpaca: () => alpaca,
  alpacaClient: () => alpacaClient
});
var ALPACA_BASE_URL, ALPACA_DATA_URL, ALPACA_STREAM_URL, AlpacaConnector, alpaca, alpacaClient;
var init_alpaca = __esm({
  "server/connectors/alpaca.ts"() {
    "use strict";
    init_logger();
    init_trading_config();
    init_rateLimiter();
    init_circuitBreaker();
    ALPACA_BASE_URL = getAlpacaBaseUrl();
    ALPACA_DATA_URL = tradingConfig.alpaca.dataUrl;
    ALPACA_STREAM_URL = tradingConfig.alpaca.streamUrl;
    AlpacaConnector = class {
      cache = /* @__PURE__ */ new Map();
      // Tiered cache TTLs for different data types (trading accuracy vs performance)
      cacheTTL = {
        account: 5 * 1e3,
        // 5 seconds - critical for trading decisions
        positions: 5 * 1e3,
        // 5 seconds - positions change with fills
        orders: 2 * 1e3,
        // 2 seconds - order status is time-sensitive
        assets: 15 * 60 * 1e3,
        // 15 minutes - asset list rarely changes
        clock: 10 * 1e3,
        // 10 seconds - market hours check
        marketData: 30 * 1e3,
        // 30 seconds - general quotes/bars
        default: 30 * 1e3
        // 30 seconds - fallback for other data
      };
      providerName = "alpaca";
      failureCount = 0;
      maxConsecutiveFailures = 5;
      lastFailureReset = Date.now();
      circuitBreakerOpenedAt = null;
      // Auto-reset circuit breaker after 60 seconds (half-open state)
      circuitBreakerCooldownMs = 60 * 1e3;
      getCredentials() {
        const apiKey2 = process.env.ALPACA_API_KEY;
        const secretKey = process.env.ALPACA_SECRET_KEY;
        if (!apiKey2 || !secretKey) return null;
        return { apiKey: apiKey2, secretKey };
      }
      recordSuccess() {
        if (this.failureCount > 0) {
          log.info(
            "Alpaca",
            `Circuit breaker recovered after ${this.failureCount} failures`
          );
        }
        this.failureCount = 0;
        this.circuitBreakerOpenedAt = null;
        this.lastFailureReset = Date.now();
      }
      recordFailure() {
        this.failureCount++;
        this.lastFailureReset = Date.now();
        if (this.failureCount >= this.maxConsecutiveFailures) {
          if (!this.circuitBreakerOpenedAt) {
            this.circuitBreakerOpenedAt = Date.now();
          }
          log.error(
            "Alpaca",
            `Circuit breaker threshold reached: ${this.failureCount} consecutive failures`
          );
        }
      }
      shouldRejectRequest() {
        if (this.failureCount < this.maxConsecutiveFailures) {
          return false;
        }
        if (this.circuitBreakerOpenedAt) {
          const elapsed = Date.now() - this.circuitBreakerOpenedAt;
          if (elapsed >= this.circuitBreakerCooldownMs) {
            log.info(
              "Alpaca",
              `Circuit breaker entering half-open state after ${Math.round(elapsed / 1e3)}s cooldown`
            );
            return false;
          }
        }
        return true;
      }
      getCacheTTL(key) {
        if (key === "account") return this.cacheTTL.account;
        if (key === "positions") return this.cacheTTL.positions;
        if (key.startsWith("order")) return this.cacheTTL.orders;
        if (key === "assets" || key.startsWith("asset-"))
          return this.cacheTTL.assets;
        if (key === "clock") return this.cacheTTL.clock;
        if (key.startsWith("bars-") || key.startsWith("quote-"))
          return this.cacheTTL.marketData;
        return this.cacheTTL.default;
      }
      getCached(key) {
        const entry = this.cache.get(key);
        const ttl = this.getCacheTTL(key);
        if (entry && Date.now() - entry.timestamp < ttl) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async fetchWithRetry(url, options = {}, retries = 3) {
        if (this.shouldRejectRequest()) {
          const error = new Error(
            "Circuit breaker is open - too many consecutive failures"
          );
          log.error("Alpaca", error.message);
          throw error;
        }
        const credentials2 = this.getCredentials();
        if (!credentials2) {
          throw new Error("Alpaca API credentials not configured");
        }
        const headers = {
          "APCA-API-KEY-ID": credentials2.apiKey,
          "APCA-API-SECRET-KEY": credentials2.secretKey,
          "Content-Type": "application/json",
          Accept: "application/json",
          ...options.headers
        };
        const breakerKey = `alpaca-api-${url.replace(/[^a-zA-Z0-9]/g, "-")}`;
        const breaker = getBreaker(
          breakerKey,
          async () => {
            return wrapWithLimiter(this.providerName, async () => {
              for (let i = 0; i < retries; i++) {
                try {
                  const response = await fetch(url, {
                    ...options,
                    headers
                  });
                  if (response.status === 429) {
                    const retryAfter = response.headers.get("Retry-After");
                    const waitTime = retryAfter ? parseInt(retryAfter) * 1e3 : Math.min(Math.pow(2, i + 1) * 1e3, 16e3);
                    log.warn(
                      "Alpaca",
                      `Rate limited (429), waiting ${waitTime}ms (attempt ${i + 1}/${retries})`
                    );
                    if (i < retries - 1) {
                      await new Promise((resolve2) => setTimeout(resolve2, waitTime));
                      continue;
                    } else {
                      throw new Error(
                        `Rate limit exceeded after ${retries} retries`
                      );
                    }
                  }
                  if (!response.ok) {
                    const errorBody = await response.text();
                    const error = new Error(
                      `Alpaca API error: ${response.status} - ${errorBody}`
                    );
                    if (response.status >= 400 && response.status < 500 && response.status !== 429) {
                      throw error;
                    }
                    if (i < retries - 1) {
                      const waitTime = Math.min(1e3 * Math.pow(2, i), 8e3);
                      log.warn(
                        "Alpaca",
                        `Server error ${response.status}, retrying in ${waitTime}ms`
                      );
                      await new Promise((resolve2) => setTimeout(resolve2, waitTime));
                      continue;
                    }
                    throw error;
                  }
                  const text17 = await response.text();
                  if (process.env.NODE_ENV === "development" && process.env.ALPACA_DEBUG === "true") {
                    log.debug(
                      "Alpaca",
                      `Response for ${url}: ${text17.substring(0, 150)}`
                    );
                  }
                  if (!text17 || text17.trim() === "") {
                    if (url.includes("/positions") || url.includes("/orders") || url.includes("/assets")) {
                      return [];
                    }
                    return {};
                  }
                  const parsed = JSON.parse(text17);
                  return parsed;
                } catch (error) {
                  if (i === retries - 1) throw error;
                  const waitTime = Math.min(1e3 * Math.pow(2, i), 8e3);
                  log.warn(
                    "Alpaca",
                    `Request failed: ${error.message}, retrying in ${waitTime}ms`
                  );
                  await new Promise((resolve2) => setTimeout(resolve2, waitTime));
                }
              }
              throw new Error("Failed to fetch from Alpaca after retries");
            });
          },
          {
            timeout: 3e4,
            // 30 second timeout
            errorThresholdPercentage: 50,
            // Open circuit at 50% error rate
            resetTimeout: 6e4,
            // Try again after 1 minute
            volumeThreshold: 5
            // Need at least 5 requests before calculating error rate
          }
        );
        try {
          const result = await breaker.fire();
          this.recordSuccess();
          return result;
        } catch (error) {
          this.recordFailure();
          log.error("Alpaca", `Request failed: ${error.message}`);
          throw error;
        }
      }
      async getAccount() {
        const cacheKey = "account";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/account`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getPositions() {
        const cacheKey = "positions";
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("Alpaca", "getPositions() returning cached data", {
            type: Array.isArray(cached) ? "array" : typeof cached
          });
          return cached;
        }
        log.debug("Alpaca", "getPositions() fetching fresh data from API");
        const url = `${ALPACA_BASE_URL}/v2/positions`;
        log.debug("Alpaca", "Positions request", { url });
        const data = await this.fetchWithRetry(url);
        log.debug("Alpaca", "getPositions() received data", {
          type: Array.isArray(data) ? "array" : typeof data,
          length: data?.length
        });
        if (!Array.isArray(data)) {
          log.warn(
            "Alpaca",
            "positions endpoint returned non-array, returning empty array",
            {
              receivedType: typeof data
            }
          );
          const emptyArray = [];
          this.setCache(cacheKey, emptyArray);
          return emptyArray;
        }
        this.setCache(cacheKey, data);
        return data;
      }
      async getPosition(symbol) {
        try {
          const url = `${ALPACA_BASE_URL}/v2/positions/${symbol.toUpperCase()}`;
          return await this.fetchWithRetry(url);
        } catch {
          return null;
        }
      }
      async closePosition(symbol) {
        const url = `${ALPACA_BASE_URL}/v2/positions/${symbol.toUpperCase()}`;
        return await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async closeAllPositions() {
        const url = `${ALPACA_BASE_URL}/v2/positions`;
        return await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async createOrder(params) {
        const url = `${ALPACA_BASE_URL}/v2/orders`;
        return await this.fetchWithRetry(url, {
          method: "POST",
          body: JSON.stringify(params)
        });
      }
      async createBracketOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: params.type || "market",
          time_in_force: "day",
          // MUST be "day" for bracket orders per Alpaca API requirements
          order_class: "bracket",
          take_profit: {
            limit_price: params.take_profit_price
          },
          stop_loss: {
            stop_price: params.stop_loss_price,
            limit_price: params.stop_loss_limit_price
          }
        };
        if (params.limit_price) {
          orderParams.limit_price = params.limit_price;
        }
        log.info(
          "Alpaca",
          `Creating bracket order for ${params.symbol}: TP=${params.take_profit_price}, SL=${params.stop_loss_price}, TIF=day`
        );
        try {
          const order = await this.createOrder(orderParams);
          log.info(
            "Alpaca",
            `Bracket order created successfully for ${params.symbol}`,
            { orderId: order.id, status: order.status }
          );
          return order;
        } catch (error) {
          log.error(
            "Alpaca",
            `Bracket order FAILED for ${params.symbol}: ${error.message}`
          );
          throw error;
        }
      }
      async createTrailingStopOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: "trailing_stop",
          time_in_force: params.time_in_force || "gtc"
        };
        if (params.trail_percent !== void 0) {
          orderParams.trail_percent = params.trail_percent.toString();
        } else if (params.trail_price !== void 0) {
          orderParams.trail_price = params.trail_price.toString();
        } else {
          orderParams.trail_percent = "2";
        }
        log.debug(
          "Alpaca",
          `Creating trailing stop order for ${params.symbol}: trail=${params.trail_percent || params.trail_price}`
        );
        return this.createOrder(orderParams);
      }
      async createStopLossOrder(symbol, qty, stopPrice, limitPrice) {
        const orderParams = {
          symbol,
          qty,
          side: "sell",
          type: limitPrice ? "stop_limit" : "stop",
          time_in_force: "gtc",
          stop_price: stopPrice
        };
        if (limitPrice) {
          orderParams.limit_price = limitPrice;
        }
        log.debug(
          "Alpaca",
          `Creating stop loss order for ${symbol} at $${stopPrice}`
        );
        return this.createOrder(orderParams);
      }
      async createTakeProfitOrder(symbol, qty, limitPrice) {
        const orderParams = {
          symbol,
          qty,
          side: "sell",
          type: "limit",
          time_in_force: "gtc",
          limit_price: limitPrice
        };
        log.debug(
          "Alpaca",
          `Creating take profit order for ${symbol} at $${limitPrice}`
        );
        return this.createOrder(orderParams);
      }
      /**
       * Create an OCO (One-Cancels-Other) order
       * Two orders where filling one automatically cancels the other
       * Use case: Set both take-profit and stop-loss on an existing position
       *
       * @param symbol The trading symbol
       * @param qty Quantity to trade
       * @param takeProfitPrice Limit price for take-profit leg
       * @param stopLossPrice Stop price for stop-loss leg
       * @param stopLossLimitPrice Optional limit price for stop-loss (creates stop-limit)
       */
      async createOCOOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: "limit",
          time_in_force: params.timeInForce || "day",
          // OCO orders should typically be day orders
          limit_price: params.takeProfitPrice,
          order_class: "oco",
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        log.info(
          "Alpaca",
          `Creating OCO order for ${params.symbol}: TP=$${params.takeProfitPrice}, SL=$${params.stopLossPrice}`
        );
        try {
          const order = await this.createOrder(orderParams);
          log.info(
            "Alpaca",
            `OCO order created successfully for ${params.symbol}`,
            { orderId: order.id, status: order.status }
          );
          return order;
        } catch (error) {
          log.error(
            "Alpaca",
            `OCO order FAILED for ${params.symbol}: ${error.message}`
          );
          throw error;
        }
      }
      /**
       * Create an OTO (One-Triggers-Other) order
       * First order triggers the second order upon fill
       * Use case: Buy then immediately set a protective stop-loss
       *
       * @param primaryOrder The primary order that triggers the secondary
       * @param secondaryOrder The order triggered when primary fills
       */
      async createOTOOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.primarySide,
          type: params.primaryType,
          time_in_force: params.timeInForce || "day",
          order_class: "oto",
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        if (params.primaryLimitPrice && params.primaryType === "limit") {
          orderParams.limit_price = params.primaryLimitPrice;
        }
        log.info(
          "Alpaca",
          `Creating OTO order for ${params.symbol}: Primary=${params.primaryType}, SL=$${params.stopLossPrice}`
        );
        try {
          const order = await this.createOrder(orderParams);
          log.info(
            "Alpaca",
            `OTO order created successfully for ${params.symbol}`,
            { orderId: order.id, status: order.status }
          );
          return order;
        } catch (error) {
          log.error(
            "Alpaca",
            `OTO order FAILED for ${params.symbol}: ${error.message}`
          );
          throw error;
        }
      }
      /**
       * Create an OTO order with take-profit
       * Primary order triggers both stop-loss and take-profit upon fill
       *
       * @param params Order parameters including both TP and SL legs
       */
      async createOTOWithTPOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.primarySide,
          type: params.primaryType,
          time_in_force: params.timeInForce || "day",
          order_class: "oto",
          take_profit: {
            limit_price: params.takeProfitPrice
          },
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        if (params.primaryLimitPrice && params.primaryType === "limit") {
          orderParams.limit_price = params.primaryLimitPrice;
        }
        log.info(
          "Alpaca",
          `Creating OTO+TP order for ${params.symbol}: Primary=${params.primaryType}, TP=$${params.takeProfitPrice}, SL=$${params.stopLossPrice}`
        );
        try {
          const order = await this.createOrder(orderParams);
          log.info(
            "Alpaca",
            `OTO+TP order created successfully for ${params.symbol}`,
            { orderId: order.id, status: order.status }
          );
          return order;
        } catch (error) {
          log.error(
            "Alpaca",
            `OTO+TP order FAILED for ${params.symbol}: ${error.message}`
          );
          throw error;
        }
      }
      async getOrders(status = "all", limit4 = 50) {
        const cacheKey = `orders_${status}_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/orders?status=${status}&limit=${limit4}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getOrder(orderId) {
        const url = `${ALPACA_BASE_URL}/v2/orders/${orderId}`;
        return await this.fetchWithRetry(url);
      }
      async cancelOrder(orderId) {
        const url = `${ALPACA_BASE_URL}/v2/orders/${orderId}`;
        await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async cancelAllOrders() {
        const url = `${ALPACA_BASE_URL}/v2/orders`;
        await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async getAssets(status = "active", assetClass = "us_equity") {
        const cacheKey = `assets_${status}_${assetClass}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/assets?status=${status}&asset_class=${assetClass}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getAsset(symbol) {
        const cacheKey = `asset_${symbol}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/assets/${symbol.toUpperCase()}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getBars(symbols, timeframe = "1Day", start, end, limit4 = 100, pageToken) {
        const symbolsParam = symbols.join(",");
        if (!pageToken) {
          const cacheKey = `bars_${symbolsParam}_${timeframe}_${start}_${end}`;
          const cached = this.getCached(cacheKey);
          if (cached) return cached;
        }
        let url = `${ALPACA_DATA_URL}/v2/stocks/bars?symbols=${symbolsParam}&timeframe=${timeframe}&limit=${limit4}&feed=iex`;
        if (start) url += `&start=${start}`;
        if (end) url += `&end=${end}`;
        if (pageToken) url += `&page_token=${pageToken}`;
        const data = await this.fetchWithRetry(url);
        if (!pageToken) {
          const cacheKey = `bars_${symbolsParam}_${timeframe}_${start}_${end}`;
          this.setCache(cacheKey, data);
        }
        return data;
      }
      async getSnapshots(symbols) {
        const symbolsParam = symbols.join(",");
        const cacheKey = `snapshots_${symbolsParam}`;
        const cached = this.getCached(
          cacheKey
        );
        if (cached) return cached;
        const url = `${ALPACA_DATA_URL}/v2/stocks/snapshots?symbols=${symbolsParam}&feed=iex`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getCryptoSnapshots(symbols) {
        const symbolsParam = symbols.join(",");
        const cacheKey = `crypto_snapshots_${symbolsParam}`;
        const cached = this.getCached(
          cacheKey
        );
        if (cached) return cached;
        const url = `${ALPACA_DATA_URL}/v1beta3/crypto/us/snapshots?symbols=${symbolsParam}`;
        const response = await this.fetchWithRetry(url);
        const result = {};
        for (const [symbol, snapshot] of Object.entries(response.snapshots || {})) {
          result[symbol] = {
            latestTrade: {
              t: snapshot.latestTrade?.t || "",
              x: "CBSE",
              p: snapshot.latestTrade?.p || 0,
              s: snapshot.latestTrade?.s || 0,
              c: [],
              i: 0,
              z: ""
            },
            latestQuote: snapshot.latestQuote || {
              ap: 0,
              as: 0,
              bp: 0,
              bs: 0,
              t: ""
            },
            minuteBar: snapshot.minuteBar || {
              t: "",
              o: 0,
              h: 0,
              l: 0,
              c: 0,
              v: 0,
              n: 0,
              vw: 0
            },
            dailyBar: snapshot.dailyBar || {
              t: "",
              o: 0,
              h: 0,
              l: 0,
              c: 0,
              v: 0,
              n: 0,
              vw: 0
            },
            prevDailyBar: snapshot.prevDailyBar || {
              t: "",
              o: 0,
              h: 0,
              l: 0,
              c: 0,
              v: 0,
              n: 0,
              vw: 0
            }
          };
        }
        this.setCache(cacheKey, result);
        return result;
      }
      async searchAssets(query) {
        const assets = await this.getAssets("active", "us_equity");
        const lowerQuery = query.toLowerCase();
        return assets.filter(
          (asset) => asset.symbol.toLowerCase().includes(lowerQuery) || asset.name.toLowerCase().includes(lowerQuery)
        );
      }
      getConnectionStatus() {
        const credentials2 = this.getCredentials();
        return {
          connected: !!credentials2,
          hasCredentials: !!credentials2,
          cacheSize: this.cache.size,
          failureCount: this.failureCount,
          circuitBreakerOpen: this.shouldRejectRequest()
        };
      }
      async getRateLimitStatus() {
        const { getProviderStatus: getProviderStatus3 } = await Promise.resolve().then(() => (init_rateLimiter(), rateLimiter_exports));
        const { getBreakerStats: getBreakerStats2 } = await Promise.resolve().then(() => (init_circuitBreaker(), circuitBreaker_exports));
        const limiterStatus = await getProviderStatus3(this.providerName);
        const breakerStats = getBreakerStats2("alpaca-api");
        return {
          provider: this.providerName,
          running: limiterStatus.running,
          queued: limiterStatus.queued,
          reservoir: limiterStatus.reservoir,
          failureCount: this.failureCount,
          circuitBreakerOpen: breakerStats?.state === "open" || this.shouldRejectRequest()
        };
      }
      resetCircuitBreaker() {
        this.failureCount = 0;
        this.circuitBreakerOpenedAt = null;
        this.lastFailureReset = Date.now();
        log.info("Alpaca", "Circuit breaker manually reset");
      }
      clearCache() {
        this.cache.clear();
      }
      async getClock() {
        const cacheKey = "clock";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/clock`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getMarketStatus() {
        const clock = await this.getClock();
        const now = new Date(clock.timestamp);
        const nextOpen = new Date(clock.next_open);
        const nextClose = new Date(clock.next_close);
        const etHour = parseInt(
          now.toLocaleString("en-US", {
            timeZone: "America/New_York",
            hour: "2-digit",
            hour12: false
          })
        );
        const etMinute = parseInt(
          now.toLocaleString("en-US", {
            timeZone: "America/New_York",
            minute: "2-digit"
          })
        );
        const etTime = etHour * 60 + etMinute;
        const preMarketStart = 4 * 60;
        const marketOpen = 9 * 60 + 30;
        const marketClose = 16 * 60;
        const afterHoursEnd = 20 * 60;
        const isWeekday = now.getDay() >= 1 && now.getDay() <= 5;
        const isPreMarket = isWeekday && etTime >= preMarketStart && etTime < marketOpen;
        const isRegularHours = clock.is_open;
        const isAfterHours = isWeekday && etTime >= marketClose && etTime < afterHoursEnd;
        const isExtendedHours = isPreMarket || isAfterHours;
        let session;
        if (isRegularHours) {
          session = "regular";
        } else if (isPreMarket) {
          session = "pre-market";
        } else if (isAfterHours) {
          session = "after-hours";
        } else {
          session = "closed";
        }
        return {
          isOpen: clock.is_open,
          isPreMarket,
          isAfterHours,
          isExtendedHours,
          currentTime: clock.timestamp,
          nextOpen: clock.next_open,
          nextClose: clock.next_close,
          session
        };
      }
      async healthCheck() {
        const result = {
          overall: "unhealthy",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          endpoints: {
            account: { status: "unknown", latencyMs: 0 },
            positions: { status: "unknown", latencyMs: 0 },
            orders: { status: "unknown", latencyMs: 0 },
            marketData: { status: "unknown", latencyMs: 0 }
          },
          account: null
        };
        const credentials2 = this.getCredentials();
        if (!credentials2) {
          result.endpoints.account.status = "error";
          result.endpoints.account.error = "API credentials not configured";
          return result;
        }
        const checkEndpoint = async (name, fn) => {
          const start = Date.now();
          try {
            await fn();
            result.endpoints[name].status = "healthy";
            result.endpoints[name].latencyMs = Date.now() - start;
          } catch (error) {
            result.endpoints[name].status = "error";
            result.endpoints[name].latencyMs = Date.now() - start;
            result.endpoints[name].error = error instanceof Error ? error.message : "Unknown error";
          }
        };
        await checkEndpoint("account", async () => {
          const account = await this.getAccount();
          result.account = {
            id: account.id,
            status: account.status,
            currency: account.currency,
            buyingPower: account.buying_power,
            portfolioValue: account.portfolio_value,
            cash: account.cash,
            equity: account.equity,
            tradingBlocked: account.trading_blocked
          };
        });
        await Promise.all([
          checkEndpoint("positions", () => this.getPositions()),
          checkEndpoint("orders", () => this.getOrders("open", 1)),
          checkEndpoint("marketData", () => this.getSnapshots(["AAPL"]))
        ]);
        const healthyCount = Object.values(result.endpoints).filter(
          (e) => e.status === "healthy"
        ).length;
        const total = Object.keys(result.endpoints).length;
        if (healthyCount === total) {
          result.overall = "healthy";
        } else if (healthyCount > 0) {
          result.overall = "degraded";
        } else {
          result.overall = "unhealthy";
        }
        return result;
      }
      async getPortfolioHistory(period = "1M", timeframe = "1D") {
        const cacheKey = `portfolio_history_${period}_${timeframe}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/account/portfolio/history?period=${period}&timeframe=${timeframe}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getTopStocks(limit4 = 25) {
        const cacheKey = `top_stocks_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const assets = await this.getAssets("active", "us_equity");
        const tradableAssets = assets.filter((a) => a.tradable && a.fractionable).slice(0, 100);
        const symbols = tradableAssets.slice(0, 50).map((a) => a.symbol);
        let snapshots = {};
        try {
          snapshots = await this.getSnapshots(symbols);
        } catch {
          snapshots = {};
        }
        const result = tradableAssets.map((asset) => {
          const snapshot = snapshots[asset.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: asset.symbol,
            name: asset.name,
            price,
            change,
            volume,
            tradable: asset.tradable,
            fractionable: asset.fractionable,
            assetClass: "us_equity"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume).slice(0, limit4);
        this.setCache(cacheKey, result);
        return result;
      }
      async getTopCrypto(limit4 = 25) {
        const cacheKey = `top_crypto_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const assets = await this.getAssets("active", "crypto");
        const tradableAssets = assets.filter((a) => a.tradable).slice(0, limit4 * 2);
        const symbols = tradableAssets.map((a) => a.symbol);
        let cryptoSnapshots = {
          snapshots: {}
        };
        try {
          const url = `${ALPACA_DATA_URL}/v1beta3/crypto/us/snapshots?symbols=${symbols.join(",")}`;
          cryptoSnapshots = await this.fetchWithRetry(url);
        } catch {
          cryptoSnapshots = { snapshots: {} };
        }
        const result = tradableAssets.map((asset) => {
          const snapshot = cryptoSnapshots.snapshots?.[asset.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: asset.symbol,
            name: asset.name,
            price,
            change,
            volume,
            tradable: asset.tradable,
            fractionable: asset.fractionable,
            assetClass: "crypto"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume).slice(0, limit4);
        this.setCache(cacheKey, result);
        return result;
      }
      async getTopETFs(limit4 = 25) {
        const cacheKey = `top_etfs_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const popularETFs = [
          { symbol: "SPY", name: "S&P 500 ETF" },
          { symbol: "QQQ", name: "Nasdaq 100 ETF" },
          { symbol: "IWM", name: "Russell 2000 ETF" },
          { symbol: "DIA", name: "Dow Jones ETF" },
          { symbol: "VTI", name: "Total Stock Market" },
          { symbol: "VOO", name: "Vanguard S&P 500" },
          { symbol: "VEA", name: "Developed Markets" },
          { symbol: "VWO", name: "Emerging Markets" },
          { symbol: "EFA", name: "EAFE Index ETF" },
          { symbol: "EEM", name: "Emerging Mkts ETF" },
          { symbol: "GLD", name: "Gold Trust" },
          { symbol: "SLV", name: "Silver Trust" },
          { symbol: "USO", name: "US Oil Fund" },
          { symbol: "TLT", name: "20+ Year Treasury" },
          { symbol: "IEF", name: "7-10 Year Treasury" },
          { symbol: "LQD", name: "Investment Grade Corp" },
          { symbol: "HYG", name: "High Yield Corporate" },
          { symbol: "XLF", name: "Financial Sector" },
          { symbol: "XLK", name: "Technology Sector" },
          { symbol: "XLE", name: "Energy Sector" },
          { symbol: "XLV", name: "Healthcare Sector" },
          { symbol: "XLI", name: "Industrial Sector" },
          { symbol: "XLY", name: "Consumer Discretionary" },
          { symbol: "XLP", name: "Consumer Staples" },
          { symbol: "XLU", name: "Utilities Sector" }
        ];
        const etfList = popularETFs.slice(0, limit4);
        const symbols = etfList.map((e) => e.symbol);
        let snapshots = {};
        try {
          snapshots = await this.getSnapshots(symbols);
        } catch {
          snapshots = {};
        }
        const result = etfList.map((etf) => {
          const snapshot = snapshots[etf.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: etf.symbol,
            name: etf.name,
            price,
            change,
            volume,
            tradable: true,
            fractionable: true,
            assetClass: "us_equity"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume);
        this.setCache(cacheKey, result);
        return result;
      }
      validateOrder(params) {
        const errors = [];
        const warnings = [];
        const adjustments = [];
        if (!params.symbol || params.symbol.trim() === "") {
          errors.push("Symbol is required");
        }
        if (!params.qty && !params.notional) {
          errors.push("Either qty or notional is required");
        }
        if (params.qty && params.notional) {
          warnings.push("Both qty and notional provided - qty takes precedence");
        }
        if (params.qty) {
          const qty = parseFloat(params.qty);
          if (isNaN(qty) || qty <= 0) {
            errors.push("Quantity must be a positive number");
          }
        }
        if (params.notional) {
          const notional = parseFloat(params.notional);
          if (isNaN(notional) || notional <= 0) {
            errors.push("Notional value must be positive");
          }
          if (notional < 1) {
            errors.push("Minimum order value is $1");
          }
        }
        if (params.type === "limit" && !params.limit_price) {
          errors.push("Limit price required for limit orders");
        }
        if (params.type === "stop" && !params.stop_price) {
          errors.push("Stop price required for stop orders");
        }
        if (params.type === "stop_limit" && (!params.limit_price || !params.stop_price)) {
          errors.push("Both limit and stop prices required for stop-limit orders");
        }
        const normalizedParams = { ...params };
        normalizedParams.symbol = params.symbol?.toUpperCase().trim();
        if (params.type === "market" && params.time_in_force === "gtc") {
          adjustments.push({
            field: "time_in_force",
            from: "gtc",
            to: "day",
            reason: "Market orders cannot be GTC"
          });
          normalizedParams.time_in_force = "day";
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings,
          adjustments,
          normalizedParams
        };
      }
    };
    alpaca = new AlpacaConnector();
    alpacaClient = alpaca;
  }
});

// server/ai/llmClient.ts
function createLLMError(message, provider, opts = {}) {
  const error = new Error(message);
  error.provider = provider;
  error.isRateLimit = opts.isRateLimit ?? false;
  error.isAuthError = opts.isAuthError ?? false;
  error.isBudgetExhausted = opts.isBudgetExhausted ?? false;
  error.statusCode = opts.statusCode;
  return error;
}
var init_llmClient = __esm({
  "server/ai/llmClient.ts"() {
    "use strict";
  }
});

// server/ai/baseLLMClient.ts
var BaseLLMClient;
var init_baseLLMClient = __esm({
  "server/ai/baseLLMClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    BaseLLMClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      config;
      constructor(config2) {
        this.config = config2;
        this.apiKey = this.resolveApiKey(config2.apiKeyEnvVars);
        this.baseUrl = process.env[config2.baseUrlEnvVar || ""] || config2.defaultBaseUrl;
        this.defaultModel = process.env[config2.modelEnvVar || ""] || config2.defaultModel;
      }
      resolveApiKey(envVars) {
        for (const envVar of envVars) {
          const value = process.env[envVar];
          if (value) return value;
        }
        return "";
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return this.config.providerName;
      }
      async measureLatency(fn) {
        const startTime = Date.now();
        const result = await fn();
        return { result, latencyMs: Date.now() - startTime };
      }
      handleHttpError(response, errorText) {
        const statusCode = response.status;
        const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
        const isAuthError = statusCode === 401 || statusCode === 403;
        log.error(this.config.providerName, "API request failed", {
          statusCode,
          isRateLimit,
          isAuthError
        });
        throw createLLMError(
          `${this.config.providerName} API error: ${statusCode}`,
          this.config.providerName,
          { isRateLimit, isAuthError, statusCode }
        );
      }
      createAuthError() {
        throw createLLMError(
          `${this.config.providerName} API key not configured`,
          this.config.providerName,
          { isAuthError: true }
        );
      }
    };
  }
});

// server/ai/openaiCompatibleClient.ts
var OpenAICompatibleClient;
var init_openaiCompatibleClient = __esm({
  "server/ai/openaiCompatibleClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    init_baseLLMClient();
    OpenAICompatibleClient = class extends BaseLLMClient {
      extraHeaders;
      constructor(config2) {
        super(config2);
        this.extraHeaders = config2.extraHeaders || {};
      }
      async call(req) {
        if (!this.isAvailable()) {
          this.createAuthError();
        }
        const model = req.model || this.defaultModel;
        const messages = this.buildMessages(req);
        const body = this.buildRequestBody(req, model, messages);
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`,
              ...this.extraHeaders
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            this.handleHttpError(response, errorText);
          }
          const data = await response.json();
          return this.parseResponse(data, latencyMs, model);
        } catch (error) {
          if (error.provider === this.config.providerName) {
            throw error;
          }
          log.error(this.config.providerName, "Request failed", {
            error: String(error)
          });
          throw createLLMError(
            `${this.config.providerName} request failed: ${String(error)}`,
            this.config.providerName
          );
        }
      }
      buildMessages(req) {
        const messages = [];
        if (req.system) {
          messages.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        return messages;
      }
      buildRequestBody(req, model, messages) {
        const body = {
          model,
          messages,
          max_tokens: req.maxTokens ?? this.config.defaultMaxTokens ?? 1e3,
          temperature: req.temperature ?? this.config.defaultTemperature ?? 0.3
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        if (req.responseFormat) {
          body.response_format = req.responseFormat;
        }
        return body;
      }
      parseResponse(data, latencyMs, model) {
        const choice = data.choices[0];
        if (!choice) {
          throw createLLMError(
            `${this.config.providerName} returned empty response`,
            this.config.providerName
          );
        }
        const message = choice.message;
        const toolCalls = this.parseToolCalls(message.tool_calls);
        log.ai(`${this.config.providerName} call complete`, {
          model: data.model || model,
          tokensUsed: data.usage?.total_tokens,
          latencyMs,
          hasToolCalls: toolCalls.length > 0
        });
        return {
          text: message.content ?? void 0,
          toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
          raw: data,
          model: data.model,
          tokensUsed: data.usage?.total_tokens
        };
      }
      parseToolCalls(toolCalls) {
        if (!toolCalls) return [];
        const parsed = [];
        for (const tc of toolCalls) {
          try {
            const args = JSON.parse(tc.function.arguments);
            parsed.push({
              id: tc.id,
              name: tc.function.name,
              arguments: args
            });
          } catch (parseError) {
            log.warn(
              this.config.providerName,
              "Failed to parse tool call arguments",
              {
                toolName: tc.function.name,
                error: String(parseError)
              }
            );
          }
        }
        return parsed;
      }
    };
  }
});

// server/ai/openaiClient.ts
var OpenAIClient, openaiClient;
var init_openaiClient = __esm({
  "server/ai/openaiClient.ts"() {
    "use strict";
    init_openaiCompatibleClient();
    OpenAIClient = class extends OpenAICompatibleClient {
      constructor() {
        super({
          providerName: "openai",
          apiKeyEnvVars: ["AI_INTEGRATIONS_OPENAI_API_KEY", "OPENAI_API_KEY"],
          baseUrlEnvVar: "AI_INTEGRATIONS_OPENAI_BASE_URL",
          defaultBaseUrl: "https://api.openai.com/v1",
          modelEnvVar: "OPENAI_MODEL",
          defaultModel: "gpt-4o-mini",
          defaultMaxTokens: 1e3,
          defaultTemperature: 0.3
        });
        if (!process.env.AI_INTEGRATIONS_OPENAI_BASE_URL && process.env.OPENAI_BASE_URL) {
          this.baseUrl = process.env.OPENAI_BASE_URL;
        }
      }
    };
    openaiClient = new OpenAIClient();
  }
});

// server/ai/openrouterClient.ts
var OpenRouterClient, openrouterClient;
var init_openrouterClient = __esm({
  "server/ai/openrouterClient.ts"() {
    "use strict";
    init_openaiCompatibleClient();
    OpenRouterClient = class extends OpenAICompatibleClient {
      constructor() {
        super({
          providerName: "openrouter",
          apiKeyEnvVars: ["OPENROUTER_API_KEY"],
          baseUrlEnvVar: "OPENROUTER_BASE_URL",
          defaultBaseUrl: "https://openrouter.ai/api/v1",
          modelEnvVar: "OPENROUTER_MODEL",
          defaultModel: "openai/gpt-4o-mini",
          defaultMaxTokens: 1e3,
          defaultTemperature: 0.3,
          extraHeaders: {
            "HTTP-Referer": process.env.REPLIT_DEV_DOMAIN || "https://replit.com",
            "X-Title": "AI Active Trader"
          }
        });
      }
    };
    openrouterClient = new OpenRouterClient();
  }
});

// server/ai/groqClient.ts
var GroqClient, groqClient;
var init_groqClient = __esm({
  "server/ai/groqClient.ts"() {
    "use strict";
    init_openaiCompatibleClient();
    GroqClient = class extends OpenAICompatibleClient {
      constructor() {
        super({
          providerName: "groq",
          apiKeyEnvVars: ["GROQ_API_KEY"],
          baseUrlEnvVar: "GROQ_BASE_URL",
          defaultBaseUrl: "https://api.groq.com/openai/v1",
          modelEnvVar: "GROQ_MODEL",
          defaultModel: "llama-3.1-8b-instant",
          defaultMaxTokens: 1e3,
          defaultTemperature: 0.3
        });
      }
    };
    groqClient = new GroqClient();
  }
});

// server/ai/togetherClient.ts
var TogetherClient, togetherClient;
var init_togetherClient = __esm({
  "server/ai/togetherClient.ts"() {
    "use strict";
    init_openaiCompatibleClient();
    TogetherClient = class extends OpenAICompatibleClient {
      constructor() {
        super({
          providerName: "together",
          apiKeyEnvVars: ["TOGETHER_API_KEY"],
          baseUrlEnvVar: "TOGETHER_BASE_URL",
          defaultBaseUrl: "https://api.together.xyz/v1",
          modelEnvVar: "TOGETHER_MODEL",
          defaultModel: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
          defaultMaxTokens: 1e3,
          defaultTemperature: 0.3
        });
      }
    };
    togetherClient = new TogetherClient();
  }
});

// server/ai/aimlClient.ts
var AIMLClient, aimlClient;
var init_aimlClient = __esm({
  "server/ai/aimlClient.ts"() {
    "use strict";
    init_openaiCompatibleClient();
    AIMLClient = class extends OpenAICompatibleClient {
      constructor() {
        super({
          providerName: "aimlapi",
          apiKeyEnvVars: ["AIMLAPI_KEY"],
          baseUrlEnvVar: "AIMLAPI_BASE_URL",
          defaultBaseUrl: "https://api.aimlapi.com/v1",
          modelEnvVar: "AIMLAPI_MODEL",
          defaultModel: "gpt-4o-mini",
          defaultMaxTokens: 1e3,
          defaultTemperature: 0.3
        });
      }
    };
    aimlClient = new AIMLClient();
  }
});

// server/ai/claudeClient.ts
var DEFAULT_MODEL, DEFAULT_MAX_TOKENS, ANTHROPIC_API_URL, ANTHROPIC_VERSION, ClaudeClient, claudeClient;
var init_claudeClient = __esm({
  "server/ai/claudeClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL = "claude-sonnet-4-20250514";
    DEFAULT_MAX_TOKENS = 4096;
    ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages";
    ANTHROPIC_VERSION = "2023-06-01";
    ClaudeClient = class {
      apiKey;
      defaultModel;
      constructor() {
        this.apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY || "";
        this.defaultModel = process.env.CLAUDE_MODEL || DEFAULT_MODEL;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "claude";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError(
            "Claude API key not configured. Set CLAUDE_API_KEY or ANTHROPIC_API_KEY environment variable.",
            "claude",
            { isAuthError: true }
          );
        }
        const model = req.model || this.defaultModel;
        const messages = [];
        for (const msg of req.messages) {
          if (msg.role === "system") {
            continue;
          }
          if (msg.role === "tool") {
            const toolResultBlock = {
              type: "tool_result",
              tool_use_id: msg.tool_call_id || "",
              content: [{ type: "text", text: msg.content }]
            };
            const lastMsg = messages[messages.length - 1];
            if (lastMsg && lastMsg.role === "user") {
              if (typeof lastMsg.content === "string") {
                lastMsg.content = [
                  { type: "text", text: lastMsg.content }
                ];
              }
              lastMsg.content.push(toolResultBlock);
            } else {
              messages.push({
                role: "user",
                content: [toolResultBlock]
              });
            }
          } else {
            messages.push({
              role: msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
        }
        const body = {
          model,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS,
          messages
        };
        if (req.system) {
          body.system = req.system;
        }
        if (req.temperature !== void 0) {
          body.temperature = req.temperature;
        }
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools.map(
            (tool) => ({
              name: tool.function.name,
              description: tool.function.description,
              input_schema: {
                type: "object",
                properties: tool.function.parameters.properties,
                required: tool.function.parameters.required
              }
            })
          );
          if (req.toolChoice) {
            if (req.toolChoice === "auto") {
              body.tool_choice = { type: "auto" };
            } else if (req.toolChoice === "none") {
              delete body.tools;
            } else if (typeof req.toolChoice === "object" && req.toolChoice.function) {
              body.tool_choice = {
                type: "tool",
                name: req.toolChoice.function.name
              };
            }
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(ANTHROPIC_API_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": this.apiKey,
              "anthropic-version": ANTHROPIC_VERSION
            },
            body: JSON.stringify(body)
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => "");
            if (response.status === 401) {
              throw createLLMError(
                `Claude authentication failed: ${errorText}`,
                "claude",
                {
                  isAuthError: true,
                  statusCode: response.status
                }
              );
            }
            if (response.status === 429) {
              throw createLLMError(
                `Claude rate limit exceeded: ${errorText}`,
                "claude",
                {
                  isRateLimit: true,
                  statusCode: response.status
                }
              );
            }
            throw createLLMError(
              `Claude API error ${response.status}: ${errorText.substring(0, 200)}`,
              "claude",
              { statusCode: response.status }
            );
          }
          const data = await response.json();
          const latencyMs = Date.now() - startTime;
          let text17;
          const toolCalls = [];
          for (const block of data.content) {
            if (block.type === "text") {
              text17 = (text17 || "") + block.text;
            } else if (block.type === "tool_use") {
              toolCalls.push({
                id: block.id,
                name: block.name,
                arguments: block.input
              });
            }
          }
          log.debug("ClaudeClient", `Call completed in ${latencyMs}ms`, {
            model: data.model,
            inputTokens: data.usage.input_tokens,
            outputTokens: data.usage.output_tokens,
            stopReason: data.stop_reason
          });
          return {
            text: text17,
            content: text17,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: {
              prompt: data.usage.input_tokens,
              completion: data.usage.output_tokens,
              total: data.usage.input_tokens + data.usage.output_tokens
            }
          };
        } catch (error) {
          if (error.provider === "claude") {
            throw error;
          }
          log.error("ClaudeClient", "API call failed", { error });
          throw createLLMError(
            `Claude API call failed: ${error instanceof Error ? error.message : "Unknown error"}`,
            "claude"
          );
        }
      }
    };
    claudeClient = new ClaudeClient();
  }
});

// server/ai/geminiClient.ts
var DEFAULT_TEMPERATURE, DEFAULT_MODEL2, GEMINI_BASE_URL, GeminiClient, geminiClient;
var init_geminiClient = __esm({
  "server/ai/geminiClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_TEMPERATURE = 0.3;
    DEFAULT_MODEL2 = "gemini-2.5-flash-lite";
    GEMINI_BASE_URL = "https://generativelanguage.googleapis.com/v1beta";
    GeminiClient = class {
      apiKey;
      model;
      constructor() {
        this.apiKey = process.env.GOOGLE_GEMINI_API_KEY || process.env.GEMINI_API_KEY || "";
        this.model = process.env.GEMINI_MODEL || DEFAULT_MODEL2;
        if (this.apiKey) {
          log.info("GeminiClient", `Initialized with model: ${this.model}`, {
            apiKeyConfigured: true,
            freeModel: this.model.includes("flash-lite") || this.model.includes("flash")
          });
        } else {
          log.warn(
            "GeminiClient",
            "No API key configured - Gemini provider will be unavailable"
          );
        }
      }
      async call(req) {
        if (!this.apiKey) {
          throw new Error("Gemini API key not configured");
        }
        const model = req.model || this.model;
        const url = `${GEMINI_BASE_URL}/models/${model}:generateContent?key=${this.apiKey}`;
        const userContent = req.messages.map((m) => m.content).join("\n");
        log.debug("GeminiClient", "Preparing request", {
          model,
          systemPromptLength: req.system?.length || 0,
          userPromptLength: userContent.length,
          temperature: req.temperature
        });
        const contents = [];
        if (req.system) {
          contents.push({
            parts: [{ text: `${req.system}

${userContent}` }],
            role: "user"
          });
        } else {
          contents.push({
            parts: [{ text: userContent }],
            role: "user"
          });
        }
        const geminiRequest = {
          contents,
          generationConfig: {
            temperature: req.temperature ?? DEFAULT_TEMPERATURE,
            maxOutputTokens: req.maxTokens ?? 2048,
            topP: 0.95
          },
          // Disable safety filters for trading/financial content
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_NONE"
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_NONE"
            }
          ]
        };
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(geminiRequest),
            signal: AbortSignal.timeout(6e4)
            // 60 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("GeminiClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            throw new Error(`Gemini API error ${response.status}: ${errorText}`);
          }
          const data = await response.json();
          if (!data.candidates || data.candidates.length === 0) {
            log.warn(
              "GeminiClient",
              "No candidates in response (possibly blocked)",
              {
                latency
              }
            );
            throw new Error("Gemini response blocked by safety filters");
          }
          const candidate = data.candidates[0];
          const content = candidate.content.parts.map((p) => p.text).join("");
          if (candidate.finishReason && candidate.finishReason !== "STOP") {
            log.warn(
              "GeminiClient",
              `Response finished with reason: ${candidate.finishReason}`,
              {
                finishReason: candidate.finishReason,
                contentLength: content.length
              }
            );
          }
          const usage = data.usageMetadata || {
            promptTokenCount: 0,
            candidatesTokenCount: 0,
            totalTokenCount: 0
          };
          log.info("GeminiClient", "Request successful", {
            model,
            latency,
            promptTokens: usage.promptTokenCount,
            completionTokens: usage.candidatesTokenCount,
            totalTokens: usage.totalTokenCount,
            finishReason: candidate.finishReason
          });
          return {
            text: content,
            content,
            model,
            raw: {
              provider: "gemini",
              finishReason: candidate.finishReason,
              latencyMs: latency
            },
            tokensUsed: {
              prompt: usage.promptTokenCount,
              completion: usage.candidatesTokenCount,
              total: usage.totalTokenCount
            }
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("GeminiClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "gemini";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get available Gemini models
       */
      getAvailableModels() {
        return [
          "gemini-2.5-flash-lite",
          // Free tier optimized
          "gemini-2.5-flash",
          // Balanced
          "gemini-2.5-pro",
          // Highest quality
          "gemini-3-flash-preview"
          // Latest preview
        ];
      }
      /**
       * Check Gemini API health
       */
      async healthCheck() {
        if (!this.apiKey) {
          return false;
        }
        try {
          const response = await this.call({
            system: "You are a helpful assistant. Respond with 'OK'.",
            messages: [{ role: "user", content: "Hello" }],
            temperature: 0,
            maxTokens: 10
          });
          return (response.content || response.text || "").toLowerCase().includes("ok");
        } catch (error) {
          log.error("GeminiClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    geminiClient = new GeminiClient();
  }
});

// server/ai/cloudflareClient.ts
var DEFAULT_MODEL3, DEFAULT_TEMPERATURE2, CloudflareClient, cloudflareClient;
var init_cloudflareClient = __esm({
  "server/ai/cloudflareClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_MODEL3 = "@cf/meta/llama-3.1-8b-instruct";
    DEFAULT_TEMPERATURE2 = 0.3;
    CloudflareClient = class {
      accountId;
      apiToken;
      model;
      constructor() {
        this.accountId = process.env.CLOUDFLARE_ACCOUNT_ID || "";
        this.apiToken = process.env.CLOUDFLARE_API_TOKEN || "";
        this.model = process.env.CLOUDFLARE_MODEL || DEFAULT_MODEL3;
        if (this.accountId && this.apiToken) {
          log.info("CloudflareClient", `Initialized with model: ${this.model}`, {
            accountConfigured: true,
            tokenConfigured: true
          });
        } else {
          log.warn(
            "CloudflareClient",
            "Cloudflare credentials not configured - provider will be unavailable",
            {
              hasAccountId: !!this.accountId,
              hasApiToken: !!this.apiToken
            }
          );
        }
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw new Error("Cloudflare Workers AI credentials not configured");
        }
        const model = req.model || this.model;
        const url = `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/ai/run/${model}`;
        log.debug("CloudflareClient", "Preparing request", {
          model,
          systemPresent: !!req.system,
          messageCount: req.messages?.length || 0
        });
        const messages = [];
        if (req.system) {
          messages.push({
            role: "system",
            content: req.system
          });
        }
        if (req.messages && req.messages.length > 0) {
          for (const msg of req.messages) {
            if (msg.role === "tool") {
              continue;
            }
            messages.push({
              role: msg.role === "system" ? "system" : msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
        }
        const cloudflareRequest = {
          messages,
          max_tokens: req.maxTokens ?? 2048,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE2,
          stream: false
        };
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${this.apiToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(cloudflareRequest),
            signal: AbortSignal.timeout(3e4)
            // 30 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("CloudflareClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            let errorMessage = `Cloudflare API error ${response.status}`;
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.errors && errorData.errors.length > 0) {
                errorMessage = errorData.errors[0].message;
              }
            } catch {
            }
            throw new Error(errorMessage);
          }
          const data = await response.json();
          if (!data.success) {
            const errorMsg = data.errors?.[0]?.message || "Unknown Cloudflare error";
            log.error("CloudflareClient", "API returned unsuccessful response", {
              error: errorMsg,
              latency
            });
            throw new Error(errorMsg);
          }
          const content = data.result.response;
          const estimatedTokens = Math.ceil((req.system || "").length / 4) + Math.ceil(req.messages.map((m) => m.content).join("").length / 4) + Math.ceil(content.length / 4);
          log.info("CloudflareClient", "Request successful", {
            model,
            latency,
            responseLength: content.length,
            estimatedTokens
          });
          return {
            text: content,
            content,
            model,
            raw: { provider: "cloudflare", latencyMs: latency },
            tokensUsed: {
              prompt: 0,
              // Cloudflare doesn't provide this
              completion: 0,
              total: estimatedTokens
              // Rough estimate
            }
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("CloudflareClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.accountId && !!this.apiToken;
      }
      getProviderName() {
        return "cloudflare";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get available Cloudflare AI models
       */
      getAvailableModels() {
        return [
          "@cf/meta/llama-3.1-8b-instruct",
          "@cf/meta/llama-3.2-1b-instruct",
          "@cf/meta/llama-3.2-3b-instruct",
          "@cf/mistral/mistral-7b-instruct-v0.2",
          "@cf/microsoft/phi-2",
          "@cf/qwen/qwen1.5-7b-chat-awq"
        ];
      }
      /**
       * Check Cloudflare Workers AI health
       */
      async healthCheck() {
        if (!this.isAvailable()) {
          return false;
        }
        try {
          const response = await this.call({
            system: "You are a helpful assistant. Respond with 'OK'.",
            messages: [{ role: "user", content: "Hello" }],
            temperature: 0,
            maxTokens: 10
          });
          return (response.content || response.text || "").toLowerCase().includes("ok");
        } catch (error) {
          log.error("CloudflareClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    cloudflareClient = new CloudflareClient();
  }
});

// server/ai/huggingfaceClient.ts
var DEFAULT_MODEL4, DEFAULT_TEMPERATURE3, HF_API_BASE, HuggingFaceClient, huggingfaceClient;
var init_huggingfaceClient = __esm({
  "server/ai/huggingfaceClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_MODEL4 = "meta-llama/Llama-3.2-3B-Instruct";
    DEFAULT_TEMPERATURE3 = 0.3;
    HF_API_BASE = "https://api-inference.huggingface.co/models";
    HuggingFaceClient = class {
      apiKey;
      model;
      constructor() {
        this.apiKey = process.env.HUGGINGFACE_API_KEY || process.env.HF_API_KEY || "";
        this.model = process.env.HUGGINGFACE_MODEL || DEFAULT_MODEL4;
        if (this.apiKey) {
          log.info("HuggingFaceClient", `Initialized with model: ${this.model}`, {
            apiKeyConfigured: true
          });
        } else {
          log.warn(
            "HuggingFaceClient",
            "No API key configured - HuggingFace provider will be unavailable"
          );
        }
      }
      async call(req) {
        if (!this.apiKey) {
          throw new Error("HuggingFace API key not configured");
        }
        const model = req.model || this.model;
        const url = `${HF_API_BASE}/${model}`;
        log.debug("HuggingFaceClient", "Preparing request", {
          model,
          messageCount: req.messages?.length || 0
        });
        const isChatModel = model.includes("chat") || model.includes("instruct") || model.includes("Instruct");
        let requestBody;
        if (isChatModel && req.messages) {
          const messages = [];
          if (req.system) {
            messages.push({ role: "system", content: req.system });
          }
          for (const msg of req.messages) {
            if (msg.role === "tool") continue;
            messages.push({
              role: msg.role === "system" ? "system" : msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
          requestBody = {
            messages,
            max_tokens: req.maxTokens ?? 2048,
            temperature: req.temperature ?? DEFAULT_TEMPERATURE3
          };
        } else {
          const prompt = req.system ? `${req.system}

${req.messages.map((m) => m.content).join("\n")}` : req.messages.map((m) => m.content).join("\n");
          requestBody = {
            inputs: prompt,
            parameters: {
              max_new_tokens: req.maxTokens ?? 512,
              temperature: req.temperature ?? DEFAULT_TEMPERATURE3,
              top_p: 0.95,
              return_full_text: false
            }
          };
        }
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody),
            signal: AbortSignal.timeout(6e4)
            // 60 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("HuggingFaceClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            if (response.status === 503) {
              throw new Error("Model is loading, please retry in a few seconds");
            } else if (response.status === 429) {
              throw new Error("Rate limit exceeded");
            } else {
              throw new Error(
                `HuggingFace API error ${response.status}: ${errorText}`
              );
            }
          }
          const data = await response.json();
          let content;
          let usage = { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
          if (isChatModel && data.choices) {
            const chatData = data;
            content = chatData.choices[0].message.content;
            if (chatData.usage) {
              usage = {
                promptTokens: chatData.usage.prompt_tokens,
                completionTokens: chatData.usage.completion_tokens,
                totalTokens: chatData.usage.total_tokens
              };
            }
          } else if (Array.isArray(data)) {
            const textGenData = data;
            content = textGenData[0].generated_text;
            const inputText = req.system ? `${req.system}

${req.messages.map((m) => m.content).join("\n")}` : req.messages.map((m) => m.content).join("\n");
            usage = {
              promptTokens: Math.ceil(inputText.length / 4),
              completionTokens: Math.ceil(content.length / 4),
              totalTokens: Math.ceil((inputText.length + content.length) / 4)
            };
          } else {
            throw new Error("Unexpected response format from HuggingFace");
          }
          log.info("HuggingFaceClient", "Request successful", {
            model,
            latency,
            responseLength: content.length,
            totalTokens: usage.totalTokens
          });
          return {
            text: content,
            content,
            model,
            raw: {
              provider: "huggingface",
              latencyMs: latency
            },
            tokensUsed: {
              prompt: usage.promptTokens,
              completion: usage.completionTokens,
              total: usage.totalTokens
            }
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("HuggingFaceClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "huggingface";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get popular Hugging Face models for different tasks
       */
      getAvailableModels() {
        return {
          textGeneration: [
            "meta-llama/Llama-3.2-3B-Instruct",
            "meta-llama/Llama-3.2-1B-Instruct",
            "mistralai/Mistral-7B-Instruct-v0.2",
            "microsoft/phi-2",
            "google/gemma-2b-it"
          ],
          sentiment: [
            "cardiffnlp/twitter-roberta-base-sentiment-latest",
            "finiteautomata/bertweet-base-sentiment-analysis",
            "ProsusAI/finbert"
          ],
          ner: ["dslim/bert-base-NER", "Jean-Baptiste/camembert-ner"],
          classification: [
            "facebook/bart-large-mnli",
            "cross-encoder/nli-deberta-v3-base"
          ]
        };
      }
      /**
       * Call specialized sentiment model
       */
      async analyzeSentiment(text17) {
        const sentimentModel = "cardiffnlp/twitter-roberta-base-sentiment-latest";
        const url = `${HF_API_BASE}/${sentimentModel}`;
        const response = await fetch(url, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ inputs: text17 })
        });
        if (!response.ok) {
          throw new Error(`Sentiment analysis failed: ${response.status}`);
        }
        const data = await response.json();
        const topResult = Array.isArray(data) && Array.isArray(data[0]) ? data[0][0] : data[0];
        return {
          label: topResult.label.toLowerCase(),
          score: topResult.score
        };
      }
      /**
       * Check HuggingFace API health
       */
      async healthCheck() {
        if (!this.isAvailable()) {
          return false;
        }
        try {
          const response = await this.call({
            system: "You are a helpful assistant.",
            messages: [{ role: "user", content: "Say 'OK'" }],
            temperature: 0,
            maxTokens: 10
          });
          return (response.content || response.text || "").toLowerCase().includes("ok");
        } catch (error) {
          log.error("HuggingFaceClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    huggingfaceClient = new HuggingFaceClient();
  }
});

// server/ai/llmGateway.ts
var llmGateway_exports = {};
__export(llmGateway_exports, {
  callLLM: () => callLLM,
  clearLLMCache: () => clearLLMCache,
  clearLLMCacheForRole: () => clearLLMCacheForRole,
  generateTraceId: () => generateTraceId,
  getLLMCacheStats: () => getLLMCacheStats,
  llmGateway: () => llmGateway,
  resetLLMCacheStats: () => resetLLMCacheStats
});
import { randomUUID as randomUUID2, createHash } from "crypto";
function estimateCost(tokens, costPer1kTokens) {
  return tokens / 1e3 * costPer1kTokens;
}
function getModelChain(role, criticality) {
  const roleChains = CRITICALITY_CHAINS[role];
  if (!roleChains) {
    return CRITICALITY_CHAINS.technical_analyst[criticality];
  }
  return roleChains[criticality] || roleChains.medium;
}
async function logCall(callData) {
  try {
    const metadata = JSON.stringify({
      traceId: callData.traceId,
      criticality: callData.criticality,
      purpose: callData.purpose
    });
    await db.insert(llmCalls).values({
      ...callData,
      metadata
    });
  } catch (error) {
    log.warn("LLMGateway", "Failed to log LLM call", { error: String(error) });
  }
}
function parseJsonFromText(text17) {
  try {
    return JSON.parse(text17);
  } catch {
    const jsonMatch = text17.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      try {
        return JSON.parse(jsonMatch[0]);
      } catch {
        return null;
      }
    }
    return null;
  }
}
function extractTokenCount(tokensUsed) {
  if (typeof tokensUsed === "number") {
    return tokensUsed;
  }
  if (tokensUsed && typeof tokensUsed === "object") {
    return tokensUsed.total || 0;
  }
  return 0;
}
async function callLLM(req) {
  const startTime = Date.now();
  const cachedEntry = llmResponseCache.get(req.role, req.system, req.messages);
  if (cachedEntry) {
    const cachedResponse = { ...cachedEntry.response, cached: true };
    if (llmResponseCache.needsRefresh(req.role, req.system, req.messages)) {
      callLLMUncached(req).then((freshResponse) => {
        llmResponseCache.set(
          req.role,
          req.system,
          req.messages,
          freshResponse
        );
      }).catch((err) => {
        log.warn("LLMGateway", "Background refresh failed", {
          role: req.role,
          error: String(err)
        });
      });
    }
    log.ai(`LLMGateway: Cache hit for ${req.role}/${req.criticality}`, {
      role: req.role,
      criticality: req.criticality,
      purpose: req.purpose,
      traceId: req.traceId,
      cacheKey: cachedEntry.cacheKey,
      cached: true
    });
    return cachedResponse;
  }
  const response = await callLLMUncached(req);
  llmResponseCache.set(req.role, req.system, req.messages, response);
  return response;
}
async function callLLMUncached(req) {
  const startTime = Date.now();
  const chain = getModelChain(req.role, req.criticality);
  let fallbackUsed = false;
  let fallbackReason;
  let lastError;
  for (let i = 0; i < chain.length; i++) {
    const modelConfig = chain[i];
    const providerEntry = PROVIDER_CLIENTS[modelConfig.provider];
    if (!providerEntry || !providerEntry.isAvailable()) {
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = `Primary provider ${modelConfig.provider} not available`;
      }
      continue;
    }
    try {
      const llmRequest = {
        model: modelConfig.model,
        system: req.system,
        messages: req.messages,
        tools: req.tools,
        toolChoice: req.toolChoice,
        maxTokens: req.maxTokens,
        temperature: req.temperature,
        responseFormat: req.responseFormat
      };
      const response = await providerEntry.client.call(llmRequest);
      const latencyMs2 = Date.now() - startTime;
      const tokensUsed = extractTokenCount(response.tokensUsed);
      const estimatedCost = estimateCost(
        tokensUsed,
        modelConfig.costPer1kTokens
      );
      let jsonResponse = null;
      if (req.responseFormat && response.text) {
        jsonResponse = parseJsonFromText(response.text);
      }
      await logCall({
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        promptTokens: null,
        completionTokens: null,
        totalTokens: tokensUsed || null,
        estimatedCost: estimatedCost.toFixed(6),
        latencyMs: latencyMs2,
        status: "success",
        systemPrompt: req.system || null,
        userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
        response: response.text?.slice(0, 2e3) || null,
        cacheHit: false,
        fallbackUsed,
        fallbackReason: fallbackReason || null,
        traceId: req.traceId,
        criticality: req.criticality,
        purpose: req.purpose
      });
      log.ai(`LLMGateway: ${req.role}/${req.criticality} succeeded`, {
        role: req.role,
        criticality: req.criticality,
        purpose: req.purpose,
        traceId: req.traceId,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed,
        estimatedCost,
        latencyMs: latencyMs2,
        fallbackUsed
      });
      return {
        text: response.text,
        json: jsonResponse,
        toolCalls: response.toolCalls,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed,
        latencyMs: latencyMs2,
        traceId: req.traceId,
        estimatedCost,
        fallbackUsed,
        fallbackReason
      };
    } catch (error) {
      lastError = error;
      const errorMsg = error.message || String(error);
      log.warn(
        "LLMGateway",
        `${modelConfig.provider}/${modelConfig.model} failed for ${req.role}`,
        {
          traceId: req.traceId,
          criticality: req.criticality,
          purpose: req.purpose,
          error: errorMsg
        }
      );
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = errorMsg.includes("rate") || errorMsg.includes("429") ? "Rate limit exceeded" : errorMsg.includes("401") || errorMsg.includes("403") ? "Auth error" : "Provider error";
      }
      if (errorMsg.includes("429") || errorMsg.includes("rate")) {
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
  }
  const latencyMs = Date.now() - startTime;
  await logCall({
    role: req.role,
    provider: "none",
    model: "none",
    status: "error",
    errorMessage: String(lastError),
    latencyMs,
    systemPrompt: req.system || null,
    userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
    fallbackUsed: true,
    fallbackReason: "All providers failed",
    traceId: req.traceId,
    criticality: req.criticality,
    purpose: req.purpose
  });
  log.error(
    "LLMGateway",
    `All providers failed for ${req.role}/${req.criticality}`,
    {
      traceId: req.traceId,
      purpose: req.purpose,
      triedProviders: chain.map((c) => c.provider),
      lastError: String(lastError)
    }
  );
  throw lastError || new Error(
    `All LLM providers failed for role: ${req.role}, criticality: ${req.criticality}`
  );
}
function generateTraceId() {
  return randomUUID2();
}
function getLLMCacheStats() {
  return llmResponseCache.getStats();
}
function clearLLMCacheForRole(role) {
  llmResponseCache.clearRole(role);
}
function clearLLMCache() {
  llmResponseCache.clear();
}
function resetLLMCacheStats() {
  llmResponseCache.resetStats();
}
var ROLE_CACHE_CONFIG, LLMResponseCache, llmResponseCache, getEnvModel, CRITICALITY_CHAINS, PROVIDER_CLIENTS, llmGateway;
var init_llmGateway = __esm({
  "server/ai/llmGateway.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema2();
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    init_claudeClient();
    init_geminiClient();
    init_cloudflareClient();
    init_huggingfaceClient();
    ROLE_CACHE_CONFIG = {
      technical_analyst: {
        freshTtlMs: 5 * 60 * 1e3,
        // 5 minutes fresh
        staleTtlMs: 30 * 60 * 1e3,
        // 30 minutes stale
        enabled: true
      },
      risk_manager: {
        freshTtlMs: 5 * 60 * 1e3,
        // 5 minutes fresh
        staleTtlMs: 15 * 60 * 1e3,
        // 15 minutes stale
        enabled: true
      },
      market_news_summarizer: {
        freshTtlMs: 30 * 60 * 1e3,
        // 30 minutes fresh
        staleTtlMs: 2 * 60 * 60 * 1e3,
        // 2 hours stale
        enabled: true
      },
      execution_planner: {
        freshTtlMs: 1 * 60 * 1e3,
        // 1 minute fresh
        staleTtlMs: 5 * 60 * 1e3,
        // 5 minutes stale (time-sensitive)
        enabled: true
      },
      post_trade_reporter: {
        freshTtlMs: 30 * 60 * 1e3,
        // 30 minutes fresh
        staleTtlMs: 2 * 60 * 60 * 1e3,
        // 2 hours stale
        enabled: true
      },
      position_sizer: {
        freshTtlMs: 5 * 60 * 1e3,
        staleTtlMs: 15 * 60 * 1e3,
        enabled: true
      },
      sentiment_analyst: {
        freshTtlMs: 15 * 60 * 1e3,
        staleTtlMs: 60 * 60 * 1e3,
        enabled: true
      },
      post_trade_analyzer: {
        freshTtlMs: 30 * 60 * 1e3,
        staleTtlMs: 2 * 60 * 60 * 1e3,
        enabled: true
      },
      futures_analyst: {
        freshTtlMs: 5 * 60 * 1e3,
        staleTtlMs: 30 * 60 * 1e3,
        enabled: true
      }
    };
    LLMResponseCache = class {
      cache = /* @__PURE__ */ new Map();
      hitsByRole = /* @__PURE__ */ new Map();
      missByRole = /* @__PURE__ */ new Map();
      tokensSaved = 0;
      costSaved = 0;
      /**
       * Generate a cache key from role, system prompt, and messages
       */
      generateCacheKey(role, system, messages) {
        const normalizeWhitespace = (text17) => text17.replace(/\s+/g, " ").trim();
        const systemNormalized = system ? normalizeWhitespace(system) : "";
        const messagesContent = messages.map((m) => {
          if (typeof m.content === "string") {
            return normalizeWhitespace(m.content);
          }
          return JSON.stringify(m.content);
        }).join("|");
        const combined = `${role}:${systemNormalized}:${messagesContent}`;
        return createHash("md5").update(combined).digest("hex");
      }
      /**
       * Get cached response if available
       * Returns fresh or stale data based on TTL configuration
       */
      get(role, system, messages) {
        const config2 = ROLE_CACHE_CONFIG[role];
        if (!config2.enabled) {
          return null;
        }
        const cacheKey = this.generateCacheKey(role, system, messages);
        const entry = this.cache.get(cacheKey);
        if (!entry) {
          this.recordMiss(role);
          return null;
        }
        const now = Date.now();
        if (now > entry.staleUntil) {
          this.cache.delete(cacheKey);
          this.recordMiss(role);
          return null;
        }
        this.recordHit(role);
        this.recordSavings(entry.response.tokensUsed, entry.response.estimatedCost);
        if (now <= entry.freshUntil) {
          log.ai(`LLMCache: Fresh hit for ${role}`, { cacheKey });
          return entry;
        }
        log.ai(`LLMCache: Stale hit for ${role} (will refresh in background)`, {
          cacheKey
        });
        return entry;
      }
      /**
       * Store response in cache with role-based TTL
       */
      set(role, system, messages, response) {
        const config2 = ROLE_CACHE_CONFIG[role];
        if (!config2.enabled) {
          return;
        }
        const cacheKey = this.generateCacheKey(role, system, messages);
        const now = Date.now();
        const entry = {
          response: { ...response, cached: false },
          // Store original response without cache flag
          cachedAt: now,
          freshUntil: now + config2.freshTtlMs,
          staleUntil: now + config2.staleTtlMs,
          cacheKey
        };
        this.cache.set(cacheKey, entry);
        if (this.cache.size > 1e3) {
          this.evictOldest();
        }
      }
      /**
       * Check if entry needs refresh (is in stale window)
       */
      needsRefresh(role, system, messages) {
        const config2 = ROLE_CACHE_CONFIG[role];
        if (!config2.enabled) {
          return false;
        }
        const cacheKey = this.generateCacheKey(role, system, messages);
        const entry = this.cache.get(cacheKey);
        if (!entry) {
          return false;
        }
        const now = Date.now();
        return now > entry.freshUntil && now <= entry.staleUntil;
      }
      /**
       * Clear cache for a specific role
       */
      clearRole(role) {
        const keysToDelete = [];
        this.cache.forEach((entry, key) => {
          if (key.startsWith(`${role}:`)) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => this.cache.delete(key));
      }
      /**
       * Clear all cache
       */
      clear() {
        this.cache.clear();
      }
      evictOldest() {
        let oldestKey = null;
        let oldestTime = Infinity;
        this.cache.forEach((entry, key) => {
          if (entry.cachedAt < oldestTime) {
            oldestTime = entry.cachedAt;
            oldestKey = key;
          }
        });
        if (oldestKey) {
          this.cache.delete(oldestKey);
        }
      }
      recordHit(role) {
        this.hitsByRole.set(role, (this.hitsByRole.get(role) || 0) + 1);
      }
      recordMiss(role) {
        this.missByRole.set(role, (this.missByRole.get(role) || 0) + 1);
      }
      recordSavings(tokens, cost) {
        this.tokensSaved += tokens;
        this.costSaved += cost;
      }
      /**
       * Get cache statistics by role
       */
      getStats() {
        let totalHits = 0;
        let totalMisses = 0;
        this.hitsByRole.forEach((hits) => totalHits += hits);
        this.missByRole.forEach((misses) => totalMisses += misses);
        const byRole = {};
        const hitRoles = Array.from(this.hitsByRole.keys());
        const missRoles = Array.from(this.missByRole.keys());
        const allRoles = /* @__PURE__ */ new Set([...hitRoles, ...missRoles]);
        allRoles.forEach((role) => {
          const hits = this.hitsByRole.get(role) || 0;
          const misses = this.missByRole.get(role) || 0;
          const total = hits + misses;
          byRole[role] = {
            hits,
            misses,
            hitRate: total > 0 ? hits / total : 0
          };
        });
        return {
          overall: {
            hitRate: totalHits + totalMisses > 0 ? totalHits / (totalHits + totalMisses) : 0,
            totalHits,
            totalMisses,
            tokensSaved: this.tokensSaved,
            costSaved: this.costSaved,
            cacheSize: this.cache.size
          },
          byRole
        };
      }
      /**
       * Reset statistics
       */
      resetStats() {
        this.hitsByRole.clear();
        this.missByRole.clear();
        this.tokensSaved = 0;
        this.costSaved = 0;
      }
    };
    llmResponseCache = new LLMResponseCache();
    getEnvModel = (key) => process.env[key];
    CRITICALITY_CHAINS = {
      technical_analyst: {
        high: [
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          },
          {
            provider: "openrouter",
            model: getEnvModel("TECH_ANALYST_HIGH_MODEL") || "deepseek/deepseek-r1",
            costPer1kTokens: 55e-5
          },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          },
          {
            provider: "openrouter",
            model: "deepseek/deepseek-r1",
            costPer1kTokens: 55e-5
          }
        ],
        low: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      },
      risk_manager: {
        high: [
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          },
          {
            provider: "openrouter",
            model: getEnvModel("RISK_MANAGER_HIGH_MODEL") || "anthropic/claude-3.5-sonnet",
            costPer1kTokens: 3e-3
          },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          }
        ],
        low: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      },
      execution_planner: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "openrouter",
            model: "anthropic/claude-3.5-sonnet",
            costPer1kTokens: 3e-3
          }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "cloudflare",
            model: "@cf/meta/llama-3.1-8b-instruct",
            costPer1kTokens: 1e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        low: [
          {
            provider: "cloudflare",
            model: "@cf/meta/llama-3.1-8b-instruct",
            costPer1kTokens: 1e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ]
      },
      market_news_summarizer: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.3-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        medium: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash",
            costPer1kTokens: 2e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          },
          {
            provider: "together",
            model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
            costPer1kTokens: 1e-4
          }
        ],
        low: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash-lite",
            costPer1kTokens: 1e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          },
          {
            provider: "cloudflare",
            model: "@cf/meta/llama-3.1-8b-instruct",
            costPer1kTokens: 1e-5
          }
        ]
      },
      post_trade_reporter: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ],
        medium: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash",
            costPer1kTokens: 2e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          },
          {
            provider: "together",
            model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
            costPer1kTokens: 1e-4
          }
        ],
        low: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash-lite",
            costPer1kTokens: 1e-5
          },
          {
            provider: "cloudflare",
            model: "@cf/meta/llama-3.1-8b-instruct",
            costPer1kTokens: 1e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          },
          {
            provider: "together",
            model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
            costPer1kTokens: 1e-4
          }
        ]
      },
      // NEW ROLE: Position sizing optimization based on risk and market conditions
      position_sizer: {
        high: [
          {
            provider: "openrouter",
            model: "anthropic/claude-3.5-sonnet",
            costPer1kTokens: 3e-3
          },
          {
            provider: "openrouter",
            model: "deepseek/deepseek-r1",
            costPer1kTokens: 55e-5
          }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.1-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        low: [
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      },
      // NEW ROLE: Dedicated sentiment analysis from news and social sources
      sentiment_analyst: {
        high: [
          {
            provider: "openrouter",
            model: "deepseek/deepseek-r1",
            costPer1kTokens: 55e-5
          },
          {
            provider: "groq",
            model: "llama-3.3-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        medium: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash",
            costPer1kTokens: 2e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-70b-versatile",
            costPer1kTokens: 59e-5
          },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        low: [
          {
            provider: "gemini",
            model: "gemini-2.5-flash",
            costPer1kTokens: 2e-5
          },
          {
            provider: "huggingface",
            model: "meta-llama/Llama-3.2-3B-Instruct",
            costPer1kTokens: 1e-5
          },
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      },
      // NEW ROLE: Detailed post-trade performance analysis and learning
      post_trade_analyzer: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          }
        ],
        medium: [
          {
            provider: "groq",
            model: "llama-3.1-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        low: [
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      },
      // NEW ROLE: Specialized futures market analysis
      futures_analyst: {
        high: [
          {
            provider: "openrouter",
            model: "deepseek/deepseek-r1",
            costPer1kTokens: 55e-5
          },
          {
            provider: "claude",
            model: "claude-sonnet-4-20250514",
            costPer1kTokens: 3e-3
          },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          {
            provider: "groq",
            model: "llama-3.1-70b-versatile",
            costPer1kTokens: 59e-5
          }
        ],
        low: [
          {
            provider: "groq",
            model: "llama-3.1-8b-instant",
            costPer1kTokens: 5e-5
          }
        ]
      }
    };
    PROVIDER_CLIENTS = {
      openai: {
        client: openaiClient,
        isAvailable: () => openaiClient.isAvailable()
      },
      groq: { client: groqClient, isAvailable: () => groqClient.isAvailable() },
      together: {
        client: togetherClient,
        isAvailable: () => togetherClient.isAvailable()
      },
      aimlapi: { client: aimlClient, isAvailable: () => aimlClient.isAvailable() },
      openrouter: {
        client: openrouterClient,
        isAvailable: () => openrouterClient.isAvailable()
      },
      claude: {
        client: claudeClient,
        isAvailable: () => claudeClient.isAvailable()
      },
      gemini: {
        client: geminiClient,
        isAvailable: () => geminiClient.isAvailable()
      },
      cloudflare: {
        client: cloudflareClient,
        isAvailable: () => cloudflareClient.isAvailable()
      },
      huggingface: {
        client: huggingfaceClient,
        isAvailable: () => huggingfaceClient.isAvailable()
      }
    };
    llmGateway = {
      call: callLLM,
      generateTraceId,
      getAvailableProviders: () => {
        return Object.entries(PROVIDER_CLIENTS).filter(([_, v]) => v.isAvailable()).map(([name]) => name);
      },
      cache: {
        getStats: getLLMCacheStats,
        clearRole: clearLLMCacheForRole,
        clear: clearLLMCache,
        resetStats: resetLLMCacheStats
      }
    };
  }
});

// server/orchestration/events.ts
import { EventEmitter } from "events";
var TradingEventBus, eventBus;
var init_events = __esm({
  "server/orchestration/events.ts"() {
    "use strict";
    TradingEventBus = class extends EventEmitter {
      eventHistory = [];
      maxHistorySize = 1e3;
      handlers = /* @__PURE__ */ new Map();
      constructor() {
        super();
        this.setMaxListeners(100);
      }
      emit(type, data, source, correlationId) {
        const event = {
          type,
          timestamp: /* @__PURE__ */ new Date(),
          source,
          data,
          correlationId
        };
        this.addToHistory(event);
        return super.emit(type, event);
      }
      subscribe(type, handler) {
        if (!this.handlers.has(type)) {
          this.handlers.set(type, /* @__PURE__ */ new Set());
        }
        this.handlers.get(type).add(handler);
        super.on(type, handler);
        return () => {
          this.unsubscribe(type, handler);
        };
      }
      unsubscribe(type, handler) {
        const typeHandlers = this.handlers.get(type);
        if (typeHandlers) {
          typeHandlers.delete(handler);
        }
        super.off(type, handler);
      }
      subscribeAll(handler) {
        const allTypes = [
          "market:data:update",
          "market:status:change",
          "strategy:started",
          "strategy:stopped",
          "strategy:signal",
          "strategy:error",
          "trade:executed",
          "trade:filled",
          "trade:cancelled",
          "trade:error",
          "position:opened",
          "position:closed",
          "position:updated",
          "ai:decision",
          "ai:analysis:complete",
          "portfolio:rebalanced",
          "system:heartbeat",
          "system:error",
          "system:warning",
          "connector:connected",
          "connector:disconnected",
          "connector:error"
        ];
        const unsubscribers = allTypes.map((type) => this.subscribe(type, handler));
        return () => {
          unsubscribers.forEach((unsub) => unsub());
        };
      }
      addToHistory(event) {
        this.eventHistory.push(event);
        if (this.eventHistory.length > this.maxHistorySize) {
          this.eventHistory = this.eventHistory.slice(-this.maxHistorySize);
        }
      }
      getEventHistory(filter) {
        let events = [...this.eventHistory];
        if (filter?.type) {
          events = events.filter((e) => e.type === filter.type);
        }
        if (filter?.source) {
          events = events.filter((e) => e.source === filter.source);
        }
        if (filter?.since) {
          events = events.filter((e) => e.timestamp >= filter.since);
        }
        if (filter?.limit) {
          events = events.slice(-filter.limit);
        }
        return events;
      }
      getRecentEvents(limit4 = 50) {
        return this.eventHistory.slice(-limit4);
      }
      clearHistory() {
        this.eventHistory = [];
      }
      getStats() {
        const eventsByType = {};
        for (const event of this.eventHistory) {
          eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;
        }
        return {
          totalEvents: this.eventHistory.length,
          eventsByType,
          oldestEvent: this.eventHistory.length > 0 ? this.eventHistory[0].timestamp : null,
          newestEvent: this.eventHistory.length > 0 ? this.eventHistory[this.eventHistory.length - 1].timestamp : null
        };
      }
    };
    eventBus = new TradingEventBus();
  }
});

// server/orchestration/logger.ts
var orchestrationLogger, TradingLogger, logger;
var init_logger2 = __esm({
  "server/orchestration/logger.ts"() {
    "use strict";
    init_events();
    init_logger();
    orchestrationLogger = pinoLogger.child({ module: "orchestration" });
    TradingLogger = class {
      logs = [];
      maxLogSize = 2e3;
      logLevel = "info";
      levelPriority = {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3,
        critical: 4
      };
      setLogLevel(level) {
        this.logLevel = level;
      }
      shouldLog(level) {
        return this.levelPriority[level] >= this.levelPriority[this.logLevel];
      }
      log(level, category, message, metadata, correlationId) {
        if (!this.shouldLog(level)) return;
        const entry = {
          timestamp: /* @__PURE__ */ new Date(),
          level,
          category,
          message,
          metadata,
          correlationId
        };
        this.logs.push(entry);
        if (this.logs.length > this.maxLogSize) {
          this.logs = this.logs.slice(-this.maxLogSize);
        }
        const logMeta = { category, correlationId, ...metadata };
        switch (level) {
          case "debug":
            orchestrationLogger.debug(logMeta, message);
            break;
          case "info":
            orchestrationLogger.info(logMeta, message);
            break;
          case "warn":
            orchestrationLogger.warn(logMeta, message);
            eventBus.emit(
              "system:warning",
              {
                level: "warning",
                message,
                details: metadata
              },
              category,
              correlationId
            );
            break;
          case "error":
          case "critical":
            orchestrationLogger.error(logMeta, message);
            eventBus.emit(
              "system:error",
              {
                level: level === "critical" ? "critical" : "error",
                message,
                details: metadata
              },
              category,
              correlationId
            );
            break;
        }
      }
      debug(category, message, metadata) {
        this.log("debug", category, message, metadata);
      }
      info(category, message, metadata) {
        this.log("info", category, message, metadata);
      }
      warn(category, message, metadata) {
        this.log("warn", category, message, metadata);
      }
      error(category, message, metadata) {
        this.log("error", category, message, metadata);
      }
      critical(category, message, metadata) {
        this.log("critical", category, message, metadata);
      }
      trade(action, details) {
        this.info("TRADE", action, details);
      }
      strategy(strategyName, action, details) {
        this.info("STRATEGY", `[${strategyName}] ${action}`, details);
      }
      market(symbol, action, details) {
        this.info("MARKET", `[${symbol}] ${action}`, details);
      }
      ai(action, details) {
        this.info("AI", action, details);
      }
      connector(connectorName, action, details) {
        this.info("CONNECTOR", `[${connectorName}] ${action}`, details);
      }
      getLogs(filter) {
        let entries = [...this.logs];
        if (filter?.level) {
          const minPriority = this.levelPriority[filter.level];
          entries = entries.filter(
            (e) => this.levelPriority[e.level] >= minPriority
          );
        }
        if (filter?.category) {
          entries = entries.filter((e) => e.category === filter.category);
        }
        if (filter?.since) {
          entries = entries.filter((e) => e.timestamp >= filter.since);
        }
        if (filter?.limit) {
          entries = entries.slice(-filter.limit);
        }
        return entries;
      }
      getRecentLogs(limit4 = 100) {
        return this.logs.slice(-limit4);
      }
      getErrorLogs(limit4 = 50) {
        return this.logs.filter((e) => e.level === "error" || e.level === "critical").slice(-limit4);
      }
      clearLogs() {
        this.logs = [];
      }
      getStats() {
        const logsByLevel = {
          debug: 0,
          info: 0,
          warn: 0,
          error: 0,
          critical: 0
        };
        const logsByCategory = {};
        for (const log2 of this.logs) {
          logsByLevel[log2.level]++;
          logsByCategory[log2.category] = (logsByCategory[log2.category] || 0) + 1;
        }
        return {
          totalLogs: this.logs.length,
          logsByLevel,
          logsByCategory
        };
      }
    };
    logger = new TradingLogger();
    eventBus.subscribe(
      "system:heartbeat",
      (event) => {
        logger.debug("SYSTEM", `Heartbeat from ${event.source}`, {
          status: event.data.status
        });
      }
    );
  }
});

// server/orchestration/coordinator.ts
var TradingCoordinator, coordinator;
var init_coordinator = __esm({
  "server/orchestration/coordinator.ts"() {
    "use strict";
    init_events();
    init_logger2();
    init_storage();
    TradingCoordinator = class {
      config;
      startTime;
      heartbeatInterval = null;
      reconcileInterval = null;
      isRunning = false;
      activeStrategies = /* @__PURE__ */ new Set();
      errorCount = 0;
      warningCount = 0;
      tradeCount24h = 0;
      constructor() {
        this.config = {
          heartbeatIntervalMs: 3e4,
          autoReconcileEnabled: true,
          reconcileIntervalMs: 3e5,
          maxConcurrentStrategies: 10,
          emergencyStopLossPercent: 10
        };
        this.startTime = /* @__PURE__ */ new Date();
        this.setupEventListeners();
      }
      setupEventListeners() {
        eventBus.subscribe("strategy:signal", (event) => {
          this.handleStrategySignal(event);
        });
        eventBus.subscribe("trade:executed", (event) => {
          this.handleTradeExecuted(event);
        });
        eventBus.subscribe(
          "trade:error",
          (event) => {
            this.handleTradeError(event);
          }
        );
        eventBus.subscribe("system:error", () => {
          this.errorCount++;
        });
        eventBus.subscribe("system:warning", () => {
          this.warningCount++;
        });
        eventBus.subscribe(
          "strategy:started",
          (event) => {
            this.activeStrategies.add(event.data.strategyId);
            logger.strategy(event.data.strategyId, "Started");
          }
        );
        eventBus.subscribe(
          "strategy:stopped",
          (event) => {
            this.activeStrategies.delete(event.data.strategyId);
            logger.strategy(event.data.strategyId, "Stopped");
          }
        );
      }
      handleStrategySignal(event) {
        const { strategyName, symbol, signal, confidence, reason } = event.data;
        logger.strategy(strategyName, `Signal: ${signal.toUpperCase()} ${symbol}`, {
          confidence,
          reason
        });
      }
      handleTradeExecuted(event) {
        const { symbol, side, quantity, price, status } = event.data;
        this.tradeCount24h++;
        logger.trade(`${side.toUpperCase()} ${quantity} ${symbol} @ $${price}`, {
          status,
          tradeId: event.data.tradeId,
          orderId: event.data.orderId
        });
      }
      handleTradeError(event) {
        this.errorCount++;
        logger.error("TRADE", event.data.message, event.data.details);
      }
      async start() {
        if (this.isRunning) {
          logger.warn("COORDINATOR", "Coordinator is already running");
          return;
        }
        logger.info("COORDINATOR", "Starting trading coordinator...");
        this.isRunning = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.heartbeatInterval = setInterval(() => {
          this.sendHeartbeat();
        }, this.config.heartbeatIntervalMs);
        if (this.config.autoReconcileEnabled) {
          this.reconcileInterval = setInterval(() => {
            this.reconcilePositions();
          }, this.config.reconcileIntervalMs);
        }
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        eventBus.emit("system:heartbeat", { status: "started" }, "coordinator");
        logger.info("COORDINATOR", "Trading coordinator started successfully");
      }
      async stop() {
        if (!this.isRunning) {
          logger.warn("COORDINATOR", "Coordinator is not running");
          return;
        }
        logger.info("COORDINATOR", "Stopping trading coordinator...");
        if (this.heartbeatInterval) {
          clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
        if (this.reconcileInterval) {
          clearInterval(this.reconcileInterval);
          this.reconcileInterval = null;
        }
        this.isRunning = false;
        await storage.updateAgentStatus({
          isRunning: false,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        eventBus.emit("system:heartbeat", { status: "stopped" }, "coordinator");
        logger.info("COORDINATOR", "Trading coordinator stopped");
      }
      sendHeartbeat() {
        eventBus.emit(
          "system:heartbeat",
          {
            status: "running",
            activeStrategies: this.activeStrategies.size,
            uptime: Date.now() - this.startTime.getTime()
          },
          "coordinator"
        );
        storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() }).catch((err) => {
          logger.error("COORDINATOR", "Failed to update heartbeat in database", {
            error: String(err)
          });
        });
      }
      async reconcilePositions() {
        logger.info("COORDINATOR", "Starting position reconciliation...");
        try {
          eventBus.emit(
            "system:heartbeat",
            { status: "reconciling" },
            "coordinator"
          );
          logger.info("COORDINATOR", "Position reconciliation completed");
        } catch (error) {
          logger.error("COORDINATOR", "Position reconciliation failed", {
            error: String(error)
          });
        }
      }
      emitMarketData(data) {
        eventBus.emit("market:data:update", data, "market-connector");
      }
      emitStrategySignal(signal) {
        eventBus.emit("strategy:signal", signal, signal.strategyName);
      }
      emitTradeExecuted(trade) {
        eventBus.emit("trade:executed", trade, "trading-engine");
      }
      emitPositionUpdate(position) {
        eventBus.emit("position:updated", position, "position-manager");
      }
      registerStrategy(strategyId) {
        if (this.activeStrategies.size >= this.config.maxConcurrentStrategies) {
          logger.warn(
            "COORDINATOR",
            `Max concurrent strategies (${this.config.maxConcurrentStrategies}) reached`
          );
          return false;
        }
        this.activeStrategies.add(strategyId);
        eventBus.emit("strategy:started", { strategyId }, "coordinator");
        return true;
      }
      unregisterStrategy(strategyId) {
        this.activeStrategies.delete(strategyId);
        eventBus.emit("strategy:stopped", { strategyId }, "coordinator");
      }
      getStatus() {
        return {
          isRunning: this.isRunning,
          activeStrategies: this.activeStrategies.size,
          openPositions: 0,
          totalTrades24h: this.tradeCount24h,
          lastHeartbeat: this.isRunning ? /* @__PURE__ */ new Date() : null,
          errors: this.errorCount,
          warnings: this.warningCount,
          uptime: Date.now() - this.startTime.getTime()
        };
      }
      updateConfig(updates) {
        this.config = { ...this.config, ...updates };
        logger.info("COORDINATOR", "Configuration updated", {
          config: this.config
        });
      }
      getConfig() {
        return { ...this.config };
      }
      resetStats() {
        this.errorCount = 0;
        this.warningCount = 0;
        this.tradeCount24h = 0;
        logger.info("COORDINATOR", "Statistics reset");
      }
      async triggerReconcileNow() {
        if (!this.isRunning) {
          return { success: false, message: "Coordinator is not running" };
        }
        logger.info("COORDINATOR", "Manual reconciliation triggered");
        await this.reconcilePositions();
        return { success: true, message: "Reconciliation triggered" };
      }
      getActiveStrategies() {
        return Array.from(this.activeStrategies);
      }
    };
    coordinator = new TradingCoordinator();
  }
});

// server/orchestration/index.ts
var init_orchestration2 = __esm({
  "server/orchestration/index.ts"() {
    "use strict";
    init_events();
    init_logger2();
    init_coordinator();
  }
});

// server/trading/symbol-normalizer.ts
function isCryptoSymbol(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const cryptoPairs = [
    "BTC/USD",
    "ETH/USD",
    "SOL/USD",
    "DOGE/USD",
    "SHIB/USD",
    "AVAX/USD",
    "DOT/USD",
    "LINK/USD",
    "UNI/USD",
    "AAVE/USD",
    "LTC/USD",
    "BCH/USD",
    "BTCUSD",
    "ETHUSD",
    "SOLUSD",
    "DOGEUSD",
    "SHIBUSD",
    "AVAXUSD",
    "DOTUSD",
    "LINKUSD",
    "UNIUSD",
    "AAVEUSD",
    "LTCUSD",
    "BCHUSD"
  ];
  return cryptoPairs.includes(upperSymbol) || symbol.includes("/") && upperSymbol.endsWith("USD");
}
function normalizeSymbolForAlpaca(symbol, forOrder = false) {
  if (forOrder && isCryptoSymbol(symbol)) {
    return normalizeCryptoSymbol(symbol);
  }
  return symbol.replace("/", "").toUpperCase();
}
function normalizeCryptoSymbol(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (upperSymbol.includes("/")) {
    return upperSymbol;
  }
  if (upperSymbol === "BTCUSD") return "BTC/USD";
  if (upperSymbol === "ETHUSD") return "ETH/USD";
  if (upperSymbol === "SOLUSD") return "SOL/USD";
  if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
    const base = upperSymbol.slice(0, -3);
    return `${base}/USD`;
  }
  return upperSymbol;
}
function getDefaultWatchlist() {
  return DEFAULT_WATCHLIST;
}
var DEFAULT_WATCHLIST;
var init_symbol_normalizer = __esm({
  "server/trading/symbol-normalizer.ts"() {
    "use strict";
    DEFAULT_WATCHLIST = [
      "AAPL",
      "GOOGL",
      "MSFT",
      "AMZN",
      "TSLA",
      "NVDA",
      "META",
      "JPM",
      "V",
      "UNH",
      "BTC/USD",
      "ETH/USD",
      "SOL/USD"
    ];
  }
});

// server/trading/broker-connection.ts
async function isAlpacaConnected() {
  try {
    const status = alpaca.getConnectionStatus();
    if (!status.hasCredentials) return false;
    await alpaca.getAccount();
    return true;
  } catch {
    return false;
  }
}
async function getAlpacaAccount() {
  return await alpaca.getAccount();
}
async function getAlpacaPositions() {
  return await alpaca.getPositions();
}
async function getMarketStatus() {
  return await alpaca.getMarketStatus();
}
async function getClock() {
  return await alpaca.getClock();
}
async function canTradeExtendedHours(symbol, isCryptoSymbol5) {
  if (isCryptoSymbol5(symbol)) {
    return {
      allowed: false,
      reason: "Extended hours trading is not available for crypto"
    };
  }
  const marketStatus = await getMarketStatus();
  if (marketStatus.session === "regular") {
    return { allowed: true };
  }
  if (marketStatus.isExtendedHours || marketStatus.session === "pre-market" || marketStatus.session === "after-hours") {
    return { allowed: true };
  }
  return {
    allowed: false,
    reason: "Market is closed and not in extended hours session (4AM-8PM ET on weekdays)"
  };
}
var init_broker_connection = __esm({
  "server/trading/broker-connection.ts"() {
    "use strict";
    init_alpaca();
  }
});

// server/trading/orchestrator-controller.ts
var OrchestratorController, orchestratorController;
var init_orchestrator_controller = __esm({
  "server/trading/orchestrator-controller.ts"() {
    "use strict";
    init_logger();
    OrchestratorController = class {
      orchestratorControlEnabled = false;
      /**
       * Enables orchestrator control mode
       *
       * When enabled, only trades with authorizedByOrchestrator=true can execute.
       * This effectively disables all autonomous trading strategies and requires
       * manual approval through the work queue system.
       *
       * SECURITY: Use this to prevent rogue AI trading or as an emergency stop mechanism.
       *
       * @example
       * ```typescript
       * // Emergency: stop all autonomous trading
       * orchestratorController.enableOrchestratorControl();
       * ```
       */
      enableOrchestratorControl() {
        this.orchestratorControlEnabled = true;
        log.info(
          "OrchestratorController",
          "Orchestrator control ENABLED - autonomous trading disabled"
        );
      }
      /**
       * Disables orchestrator control mode
       *
       * When disabled, autonomous trading strategies can execute trades without
       * explicit work queue authorization. The authorizedByOrchestrator flag
       * is not checked.
       *
       * @example
       * ```typescript
       * // Allow autonomous trading to resume
       * orchestratorController.disableOrchestratorControl();
       * ```
       */
      disableOrchestratorControl() {
        this.orchestratorControlEnabled = false;
        log.info(
          "OrchestratorController",
          "Orchestrator control DISABLED - autonomous trading allowed"
        );
      }
      /**
       * Checks whether orchestrator control is currently enabled
       *
       * @returns True if orchestrator control is enabled, false otherwise
       *
       * @example
       * ```typescript
       * if (orchestratorController.isOrchestratorControlEnabled()) {
       *   // Require authorization for trades
       *   validateTradeAuthorization(tradeRequest);
       * }
       * ```
       */
      isOrchestratorControlEnabled() {
        return this.orchestratorControlEnabled;
      }
    };
    orchestratorController = new OrchestratorController();
  }
});

// server/lib/apiPolicy.ts
function envInt(key, defaultVal) {
  const val = process.env[key];
  if (val !== void 0) {
    const parsed = parseInt(val, 10);
    if (!isNaN(parsed)) return parsed;
  }
  return defaultVal;
}
function envBool(key, defaultVal) {
  const val = process.env[key];
  if (val === "true" || val === "1") return true;
  if (val === "false" || val === "0") return false;
  return defaultVal;
}
function getProviderPolicy(provider) {
  const policy = providerPolicies[provider.toLowerCase()];
  if (policy) return policy;
  log.debug(
    "ApiPolicy",
    `No policy found for provider ${provider}, using defaults`
  );
  return { ...defaultPolicy, provider };
}
function getAllProviderPolicies() {
  return Object.values(providerPolicies);
}
function updateProviderPolicy(provider, updates) {
  const existing = providerPolicies[provider.toLowerCase()];
  if (existing) {
    providerPolicies[provider.toLowerCase()] = { ...existing, ...updates };
    log.info("ApiPolicy", `Updated policy for ${provider}`, updates);
  } else {
    providerPolicies[provider.toLowerCase()] = {
      ...defaultPolicy,
      provider,
      ...updates
    };
    log.info("ApiPolicy", `Created new policy for ${provider}`, updates);
  }
}
function disableProvider(provider) {
  updateProviderPolicy(provider, { enabled: false });
}
function enableProvider(provider) {
  updateProviderPolicy(provider, { enabled: true });
}
function getWindowDurationMs(windowType) {
  switch (windowType) {
    case "minute":
      return 60 * 1e3;
    case "hour":
      return 60 * 60 * 1e3;
    case "day":
      return 24 * 60 * 60 * 1e3;
    case "week":
      return 7 * 24 * 60 * 60 * 1e3;
  }
}
function getWindowBoundaries(windowType) {
  const now = /* @__PURE__ */ new Date();
  const durationMs = getWindowDurationMs(windowType);
  let start;
  switch (windowType) {
    case "minute":
      start = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        now.getHours(),
        now.getMinutes(),
        0,
        0
      );
      break;
    case "hour":
      start = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        now.getHours(),
        0,
        0,
        0
      );
      break;
    case "day":
      start = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        0,
        0,
        0,
        0
      );
      break;
    case "week":
      const dayOfWeek = now.getDay();
      start = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate() - dayOfWeek,
        0,
        0,
        0,
        0
      );
      break;
  }
  return { start, end: new Date(start.getTime() + durationMs) };
}
function getLimitForWindow(policy, windowType) {
  switch (windowType) {
    case "minute":
      return policy.maxRequestsPerMinute;
    case "hour":
      return policy.maxRequestsPerHour;
    case "day":
      return policy.maxRequestsPerDay;
    case "week":
      return policy.maxRequestsPerWeek;
  }
}
var defaultPolicy, providerPolicies;
var init_apiPolicy = __esm({
  "server/lib/apiPolicy.ts"() {
    "use strict";
    init_logger();
    defaultPolicy = {
      minRequestIntervalMs: 1e3,
      cacheFreshDurationMs: 60 * 1e3,
      cacheStaleDurationMs: 30 * 60 * 1e3,
      priority: 5,
      enabled: true
    };
    providerPolicies = {
      alpaca: {
        provider: "alpaca",
        maxRequestsPerMinute: envInt("ALPACA_RATE_LIMIT_PER_MIN", 180),
        minRequestIntervalMs: envInt("ALPACA_MIN_INTERVAL_MS", 333),
        cacheFreshDurationMs: envInt("ALPACA_CACHE_FRESH_MS", 30 * 1e3),
        cacheStaleDurationMs: envInt("ALPACA_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 10,
        enabled: envBool("ALPACA_ENABLED", true)
      },
      finnhub: {
        provider: "finnhub",
        maxRequestsPerMinute: envInt("FINNHUB_RATE_LIMIT_PER_MIN", 50),
        minRequestIntervalMs: envInt("FINNHUB_MIN_INTERVAL_MS", 1200),
        cacheFreshDurationMs: envInt("FINNHUB_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("FINNHUB_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 8,
        enabled: envBool("FINNHUB_ENABLED", true)
      },
      coingecko: {
        provider: "coingecko",
        maxRequestsPerMinute: envInt("COINGECKO_RATE_LIMIT_PER_MIN", 10),
        maxRequestsPerDay: envInt("COINGECKO_RATE_LIMIT_PER_DAY", 500),
        minRequestIntervalMs: envInt("COINGECKO_MIN_INTERVAL_MS", 2100),
        cacheFreshDurationMs: envInt("COINGECKO_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("COINGECKO_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 6,
        enabled: envBool("COINGECKO_ENABLED", true)
      },
      coinmarketcap: {
        provider: "coinmarketcap",
        maxRequestsPerMinute: envInt("COINMARKETCAP_RATE_LIMIT_PER_MIN", 30),
        maxRequestsPerDay: envInt("COINMARKETCAP_RATE_LIMIT_PER_DAY", 300),
        minRequestIntervalMs: envInt("COINMARKETCAP_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("COINMARKETCAP_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt(
          "COINMARKETCAP_CACHE_STALE_MS",
          60 * 60 * 1e3
        ),
        priority: 6,
        enabled: envBool("COINMARKETCAP_ENABLED", true)
      },
      newsapi: {
        provider: "newsapi",
        maxRequestsPerDay: envInt("NEWSAPI_RATE_LIMIT_PER_DAY", 100),
        minRequestIntervalMs: envInt("NEWSAPI_MIN_INTERVAL_MS", 3e3),
        cacheFreshDurationMs: envInt("NEWSAPI_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("NEWSAPI_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 4,
        enabled: envBool("NEWSAPI_ENABLED", true)
      },
      polygon: {
        provider: "polygon",
        maxRequestsPerMinute: envInt("POLYGON_RATE_LIMIT_PER_MIN", 5),
        minRequestIntervalMs: envInt("POLYGON_MIN_INTERVAL_MS", 12e3),
        cacheFreshDurationMs: envInt("POLYGON_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("POLYGON_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 5,
        enabled: envBool("POLYGON_ENABLED", true)
      },
      twelvedata: {
        provider: "twelvedata",
        maxRequestsPerMinute: envInt("TWELVEDATA_RATE_LIMIT_PER_MIN", 6),
        maxRequestsPerDay: envInt("TWELVEDATA_RATE_LIMIT_PER_DAY", 700),
        minRequestIntervalMs: envInt("TWELVEDATA_MIN_INTERVAL_MS", 1e4),
        cacheFreshDurationMs: envInt("TWELVEDATA_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("TWELVEDATA_CACHE_STALE_MS", 5 * 60 * 1e3),
        priority: 5,
        enabled: envBool("TWELVEDATA_ENABLED", true)
      },
      valyu: {
        provider: "valyu",
        maxRequestsPerWeek: envInt("VALYU_RATE_LIMIT_PER_WEEK", 100),
        minRequestIntervalMs: envInt("VALYU_MIN_INTERVAL_MS", 5e3),
        cacheFreshDurationMs: envInt(
          "VALYU_CACHE_FRESH_MS",
          7 * 24 * 60 * 60 * 1e3
        ),
        cacheStaleDurationMs: envInt(
          "VALYU_CACHE_STALE_MS",
          90 * 24 * 60 * 60 * 1e3
        ),
        priority: 2,
        enabled: envBool("VALYU_ENABLED", true)
      },
      huggingface: {
        provider: "huggingface",
        maxRequestsPerMinute: envInt("HUGGINGFACE_RATE_LIMIT_PER_MIN", 30),
        maxRequestsPerDay: envInt("HUGGINGFACE_RATE_LIMIT_PER_DAY", 1e3),
        minRequestIntervalMs: envInt("HUGGINGFACE_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: envInt("HUGGINGFACE_CACHE_FRESH_MS", 30 * 60 * 1e3),
        cacheStaleDurationMs: envInt(
          "HUGGINGFACE_CACHE_STALE_MS",
          2 * 60 * 60 * 1e3
        ),
        priority: 7,
        enabled: envBool("HUGGINGFACE_ENABLED", true)
      },
      gdelt: {
        provider: "gdelt",
        maxRequestsPerMinute: envInt("GDELT_RATE_LIMIT_PER_MIN", 60),
        minRequestIntervalMs: envInt("GDELT_MIN_INTERVAL_MS", 500),
        cacheFreshDurationMs: envInt("GDELT_CACHE_FRESH_MS", 10 * 60 * 1e3),
        cacheStaleDurationMs: envInt("GDELT_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 5,
        enabled: envBool("GDELT_ENABLED", true)
      },
      openai: {
        provider: "openai",
        maxRequestsPerMinute: envInt("OPENAI_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("OPENAI_TOKENS_PER_MIN", 9e4),
        maxTokensPerDay: envInt("OPENAI_TOKENS_PER_DAY", 1e6),
        minRequestIntervalMs: envInt("OPENAI_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: envInt("OPENAI_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("OPENAI_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 9,
        enabled: envBool("OPENAI_ENABLED", true)
      },
      groq: {
        provider: "groq",
        maxRequestsPerMinute: envInt("GROQ_RATE_LIMIT_PER_MIN", 30),
        maxTokensPerMinute: envInt("GROQ_TOKENS_PER_MIN", 3e4),
        maxTokensPerDay: envInt("GROQ_TOKENS_PER_DAY", 5e5),
        minRequestIntervalMs: envInt("GROQ_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: envInt("GROQ_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("GROQ_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 8,
        enabled: envBool("GROQ_ENABLED", true)
      },
      together: {
        provider: "together",
        maxRequestsPerMinute: envInt("TOGETHER_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("TOGETHER_TOKENS_PER_MIN", 6e4),
        maxTokensPerDay: envInt("TOGETHER_TOKENS_PER_DAY", 8e5),
        minRequestIntervalMs: envInt("TOGETHER_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: envInt("TOGETHER_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt(
          "TOGETHER_CACHE_STALE_MS",
          24 * 60 * 60 * 1e3
        ),
        priority: 8,
        enabled: envBool("TOGETHER_ENABLED", true)
      },
      stocktwits: {
        provider: "stocktwits",
        maxRequestsPerHour: envInt("STOCKTWITS_RATE_LIMIT_PER_HOUR", 200),
        minRequestIntervalMs: envInt("STOCKTWITS_MIN_INTERVAL_MS", 3e3),
        cacheFreshDurationMs: envInt("STOCKTWITS_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("STOCKTWITS_CACHE_STALE_MS", 15 * 60 * 1e3),
        priority: 4,
        enabled: envBool("STOCKTWITS_ENABLED", true)
      },
      reddit: {
        provider: "reddit",
        maxRequestsPerMinute: envInt("REDDIT_RATE_LIMIT_PER_MIN", 60),
        minRequestIntervalMs: envInt("REDDIT_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("REDDIT_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("REDDIT_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 3,
        enabled: envBool("REDDIT_ENABLED", true)
      },
      aitrados_ohlc: {
        provider: "aitrados_ohlc",
        maxRequestsPerHour: envInt("AITRADOS_OHLC_RATE_LIMIT_PER_HOUR", 100),
        maxRequestsPerDay: envInt("AITRADOS_OHLC_RATE_LIMIT_PER_DAY", 1e3),
        minRequestIntervalMs: envInt("AITRADOS_OHLC_MIN_INTERVAL_MS", 500),
        cacheFreshDurationMs: envInt("AITRADOS_OHLC_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt(
          "AITRADOS_OHLC_CACHE_STALE_MS",
          15 * 60 * 1e3
        ),
        priority: 6,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      aitrados_news: {
        provider: "aitrados_news",
        maxRequestsPerHour: envInt("AITRADOS_NEWS_RATE_LIMIT_PER_HOUR", 50),
        maxRequestsPerDay: envInt("AITRADOS_NEWS_RATE_LIMIT_PER_DAY", 500),
        minRequestIntervalMs: envInt("AITRADOS_NEWS_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("AITRADOS_NEWS_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt(
          "AITRADOS_NEWS_CACHE_STALE_MS",
          30 * 60 * 1e3
        ),
        priority: 5,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      aitrados_econ: {
        provider: "aitrados_econ",
        maxRequestsPerHour: envInt("AITRADOS_ECON_RATE_LIMIT_PER_HOUR", 30),
        maxRequestsPerDay: envInt("AITRADOS_ECON_RATE_LIMIT_PER_DAY", 200),
        minRequestIntervalMs: envInt("AITRADOS_ECON_MIN_INTERVAL_MS", 2e3),
        cacheFreshDurationMs: envInt(
          "AITRADOS_ECON_CACHE_FRESH_MS",
          10 * 60 * 1e3
        ),
        cacheStaleDurationMs: envInt(
          "AITRADOS_ECON_CACHE_STALE_MS",
          60 * 60 * 1e3
        ),
        priority: 5,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      claude: {
        provider: "claude",
        maxRequestsPerMinute: envInt("CLAUDE_RATE_LIMIT_PER_MIN", 40),
        maxTokensPerMinute: envInt("CLAUDE_TOKEN_LIMIT_PER_MIN", 4e4),
        maxRequestsPerDay: envInt("CLAUDE_RATE_LIMIT_PER_DAY", 5e3),
        minRequestIntervalMs: envInt("CLAUDE_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 9,
        enabled: envBool("CLAUDE_ENABLED", true)
      },
      openrouter: {
        provider: "openrouter",
        maxRequestsPerMinute: envInt("OPENROUTER_RATE_LIMIT_PER_MIN", 50),
        maxTokensPerMinute: envInt("OPENROUTER_TOKEN_LIMIT_PER_MIN", 1e5),
        maxRequestsPerDay: envInt("OPENROUTER_RATE_LIMIT_PER_DAY", 5e3),
        minRequestIntervalMs: envInt("OPENROUTER_MIN_INTERVAL_MS", 150),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 8,
        enabled: envBool("OPENROUTER_ENABLED", true)
      },
      deepseek: {
        provider: "deepseek",
        maxRequestsPerMinute: envInt("DEEPSEEK_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("DEEPSEEK_TOKEN_LIMIT_PER_MIN", 6e4),
        maxRequestsPerDay: envInt("DEEPSEEK_RATE_LIMIT_PER_DAY", 1e4),
        minRequestIntervalMs: envInt("DEEPSEEK_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 8,
        enabled: envBool("DEEPSEEK_ENABLED", true)
      }
    };
  }
});

// server/lib/apiBudget.ts
import { eq as eq3, and as and2, gte as gte2, lte as lte2 } from "drizzle-orm";
function getCounterKey(provider, windowType) {
  const { start } = getWindowBoundaries(windowType);
  return `${provider}:${windowType}:${start.getTime()}`;
}
async function checkBudget(provider) {
  const policy = getProviderPolicy(provider);
  if (!policy.enabled) {
    return {
      allowed: false,
      reason: `Provider ${provider} is disabled`,
      currentCount: 0,
      limit: 0,
      windowType: "minute"
    };
  }
  const windowTypes = ["minute", "hour", "day", "week"];
  for (const windowType of windowTypes) {
    const limit4 = getLimitForWindow(policy, windowType);
    if (limit4 === void 0) continue;
    const { start, end } = getWindowBoundaries(windowType);
    const counterKey = getCounterKey(provider, windowType);
    let currentCount = 0;
    const cached = inMemoryCounters.get(counterKey);
    if (cached && cached.windowStart === start.getTime()) {
      currentCount = cached.count;
    } else {
      try {
        const result = await db.select().from(externalApiUsageCounters).where(
          and2(
            eq3(externalApiUsageCounters.provider, provider),
            eq3(externalApiUsageCounters.windowType, windowType),
            gte2(externalApiUsageCounters.windowStart, start),
            lte2(externalApiUsageCounters.windowEnd, end)
          )
        ).limit(1);
        if (result.length > 0) {
          currentCount = result[0].requestCount;
          inMemoryCounters.set(counterKey, {
            count: currentCount,
            windowStart: start.getTime()
          });
        }
      } catch (error) {
        log.warn(
          "ApiBudget",
          `Failed to check DB budget for ${provider}, using in-memory only`
        );
      }
    }
    if (currentCount >= limit4) {
      const retryAfterMs = end.getTime() - Date.now();
      return {
        allowed: false,
        reason: `${provider} budget exhausted: ${currentCount}/${limit4} requests per ${windowType}`,
        currentCount,
        limit: limit4,
        windowType,
        retryAfterMs: Math.max(0, retryAfterMs)
      };
    }
  }
  return {
    allowed: true,
    currentCount: 0,
    limit: Infinity,
    windowType: "minute"
  };
}
async function recordUsage(provider, options = {}) {
  const windowTypes = ["minute", "hour", "day", "week"];
  const policy = getProviderPolicy(provider);
  const isCacheHit = options.isCacheHit === true;
  for (const windowType of windowTypes) {
    const limit4 = getLimitForWindow(policy, windowType);
    if (limit4 === void 0) continue;
    const { start, end } = getWindowBoundaries(windowType);
    const counterKey = getCounterKey(provider, windowType);
    if (!isCacheHit) {
      const cached = inMemoryCounters.get(counterKey);
      if (cached && cached.windowStart === start.getTime()) {
        cached.count++;
      } else {
        inMemoryCounters.set(counterKey, {
          count: 1,
          windowStart: start.getTime()
        });
      }
    }
    try {
      const existing = await db.select().from(externalApiUsageCounters).where(
        and2(
          eq3(externalApiUsageCounters.provider, provider),
          eq3(externalApiUsageCounters.windowType, windowType),
          gte2(externalApiUsageCounters.windowStart, start),
          lte2(externalApiUsageCounters.windowEnd, end)
        )
      ).limit(1);
      if (existing.length > 0) {
        const record = existing[0];
        const newRequestCount = isCacheHit ? record.requestCount : record.requestCount + 1;
        const newTokenCount = (record.tokenCount || 0) + (options.tokens || 0);
        const newErrorCount = record.errorCount + (options.isError ? 1 : 0);
        const newRateLimitHits = record.rateLimitHits + (options.isRateLimited ? 1 : 0);
        const newCacheHits = record.cacheHits + (isCacheHit ? 1 : 0);
        const newCacheMisses = record.cacheMisses + (options.isCacheHit === false ? 1 : 0);
        let newAvgLatency = record.avgLatencyMs;
        if (options.latencyMs !== void 0 && !isCacheHit) {
          const prevAvg = parseFloat(record.avgLatencyMs || "0");
          const prevCount = record.requestCount - record.cacheHits;
          const newCount = prevCount + 1;
          newAvgLatency = String(
            (prevAvg * prevCount + options.latencyMs) / newCount
          );
        }
        await db.update(externalApiUsageCounters).set({
          requestCount: newRequestCount,
          tokenCount: newTokenCount,
          errorCount: newErrorCount,
          rateLimitHits: newRateLimitHits,
          cacheHits: newCacheHits,
          cacheMisses: newCacheMisses,
          avgLatencyMs: newAvgLatency,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(externalApiUsageCounters.id, record.id));
      } else {
        await db.insert(externalApiUsageCounters).values({
          provider,
          windowType,
          windowStart: start,
          windowEnd: end,
          requestCount: isCacheHit ? 0 : 1,
          tokenCount: options.tokens || 0,
          errorCount: options.isError ? 1 : 0,
          rateLimitHits: options.isRateLimited ? 1 : 0,
          cacheHits: isCacheHit ? 1 : 0,
          cacheMisses: options.isCacheHit === false ? 1 : 0,
          avgLatencyMs: options.latencyMs !== void 0 && !isCacheHit ? String(options.latencyMs) : null
        });
      }
    } catch (error) {
      log.warn(
        "ApiBudget",
        `Failed to record usage to DB for ${provider}: ${error}`
      );
    }
  }
}
async function getUsageStats(provider) {
  const windowTypes = ["minute", "hour", "day", "week"];
  const stats = [];
  for (const windowType of windowTypes) {
    const { start, end } = getWindowBoundaries(windowType);
    try {
      const result = await db.select().from(externalApiUsageCounters).where(
        and2(
          eq3(externalApiUsageCounters.provider, provider),
          eq3(externalApiUsageCounters.windowType, windowType),
          gte2(externalApiUsageCounters.windowStart, start),
          lte2(externalApiUsageCounters.windowEnd, end)
        )
      ).limit(1);
      if (result.length > 0) {
        const r = result[0];
        stats.push({
          provider: r.provider,
          windowType: r.windowType,
          windowStart: r.windowStart,
          windowEnd: r.windowEnd,
          requestCount: r.requestCount,
          tokenCount: r.tokenCount || 0,
          errorCount: r.errorCount,
          rateLimitHits: r.rateLimitHits,
          cacheHits: r.cacheHits,
          cacheMisses: r.cacheMisses,
          avgLatencyMs: r.avgLatencyMs ? parseFloat(r.avgLatencyMs) : null
        });
      } else {
        stats.push({
          provider,
          windowType,
          windowStart: start,
          windowEnd: end,
          requestCount: 0,
          tokenCount: 0,
          errorCount: 0,
          rateLimitHits: 0,
          cacheHits: 0,
          cacheMisses: 0,
          avgLatencyMs: null
        });
      }
    } catch (error) {
      log.warn(
        "ApiBudget",
        `Failed to get usage stats for ${provider}: ${error}`
      );
    }
  }
  return stats;
}
async function getAllUsageStats() {
  const providers3 = [
    "alpaca",
    "finnhub",
    "coingecko",
    "coinmarketcap",
    "newsapi",
    "polygon",
    "twelvedata",
    "valyu",
    "huggingface",
    "gdelt",
    "openai",
    "groq",
    "together"
  ];
  const allStats = {};
  for (const provider of providers3) {
    allStats[provider] = await getUsageStats(provider);
  }
  return allStats;
}
var inMemoryCounters;
var init_apiBudget = __esm({
  "server/lib/apiBudget.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_logger();
    init_apiPolicy();
    inMemoryCounters = /* @__PURE__ */ new Map();
  }
});

// server/lib/persistentApiCache.ts
import { eq as eq4, and as and3, lt as lt2 } from "drizzle-orm";
function getCacheKey(provider, key) {
  return `${provider}:${key}`;
}
async function getFromCache(provider, key) {
  const cacheKey = getCacheKey(provider, key);
  const now = Date.now();
  const memCached = inMemoryCache.get(cacheKey);
  if (memCached) {
    if (now < memCached.expiresAt) {
      return {
        data: memCached.data,
        isFresh: true,
        isStale: false,
        hitCount: 0
      };
    }
    if (now < memCached.staleUntilAt) {
      return {
        data: memCached.data,
        isFresh: false,
        isStale: true,
        hitCount: 0
      };
    }
    inMemoryCache.delete(cacheKey);
  }
  try {
    const result = await db.select().from(externalApiCacheEntries).where(
      and3(
        eq4(externalApiCacheEntries.provider, provider),
        eq4(externalApiCacheEntries.cacheKey, key)
      )
    ).limit(1);
    if (result.length === 0) return null;
    const entry = result[0];
    const expiresAt = entry.expiresAt.getTime();
    const staleUntilAt = entry.staleUntilAt.getTime();
    const data = JSON.parse(entry.responseJson);
    inMemoryCache.set(cacheKey, { data, expiresAt, staleUntilAt });
    await db.update(externalApiCacheEntries).set({
      hitCount: entry.hitCount + 1,
      lastAccessedAt: /* @__PURE__ */ new Date()
    }).where(eq4(externalApiCacheEntries.id, entry.id));
    if (now < expiresAt) {
      return {
        data,
        isFresh: true,
        isStale: false,
        hitCount: entry.hitCount + 1
      };
    }
    if (now < staleUntilAt) {
      return {
        data,
        isFresh: false,
        isStale: true,
        hitCount: entry.hitCount + 1
      };
    }
    await db.delete(externalApiCacheEntries).where(eq4(externalApiCacheEntries.id, entry.id));
    inMemoryCache.delete(cacheKey);
    return null;
  } catch (error) {
    log.warn(
      "PersistentCache",
      `Failed to get from DB cache for ${provider}:${key}: ${error}`
    );
    return null;
  }
}
async function setInCache(provider, key, data) {
  const policy = getProviderPolicy(provider);
  const now = Date.now();
  const expiresAt = new Date(now + policy.cacheFreshDurationMs);
  const staleUntilAt = new Date(now + policy.cacheStaleDurationMs);
  const cacheKey = getCacheKey(provider, key);
  inMemoryCache.set(cacheKey, {
    data,
    expiresAt: expiresAt.getTime(),
    staleUntilAt: staleUntilAt.getTime()
  });
  try {
    const existing = await db.select().from(externalApiCacheEntries).where(
      and3(
        eq4(externalApiCacheEntries.provider, provider),
        eq4(externalApiCacheEntries.cacheKey, key)
      )
    ).limit(1);
    if (existing.length > 0) {
      await db.update(externalApiCacheEntries).set({
        responseJson: JSON.stringify(data),
        expiresAt,
        staleUntilAt,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq4(externalApiCacheEntries.id, existing[0].id));
    } else {
      await db.insert(externalApiCacheEntries).values({
        provider,
        cacheKey: key,
        responseJson: JSON.stringify(data),
        expiresAt,
        staleUntilAt
      });
    }
  } catch (error) {
    log.warn(
      "PersistentCache",
      `Failed to set DB cache for ${provider}:${key}: ${error}`
    );
  }
}
async function invalidateCache(provider, key) {
  let deletedCount = 0;
  if (key) {
    const cacheKey = getCacheKey(provider, key);
    inMemoryCache.delete(cacheKey);
    try {
      const result = await db.delete(externalApiCacheEntries).where(
        and3(
          eq4(externalApiCacheEntries.provider, provider),
          eq4(externalApiCacheEntries.cacheKey, key)
        )
      );
      deletedCount = 1;
    } catch (error) {
      log.warn(
        "PersistentCache",
        `Failed to invalidate cache for ${provider}:${key}: ${error}`
      );
    }
  } else {
    for (const k of inMemoryCache.keys()) {
      if (k.startsWith(`${provider}:`)) {
        inMemoryCache.delete(k);
      }
    }
    try {
      await db.delete(externalApiCacheEntries).where(eq4(externalApiCacheEntries.provider, provider));
    } catch (error) {
      log.warn(
        "PersistentCache",
        `Failed to invalidate all cache for ${provider}: ${error}`
      );
    }
  }
  return deletedCount;
}
async function purgeExpiredCache() {
  const now = /* @__PURE__ */ new Date();
  let purgedCount = 0;
  for (const [key, entry] of inMemoryCache.entries()) {
    if (Date.now() > entry.staleUntilAt) {
      inMemoryCache.delete(key);
      purgedCount++;
    }
  }
  try {
    await db.delete(externalApiCacheEntries).where(lt2(externalApiCacheEntries.staleUntilAt, now));
  } catch (error) {
    log.warn(
      "PersistentCache",
      `Failed to purge expired cache from DB: ${error}`
    );
  }
  log.info(
    "PersistentCache",
    `Purged ${purgedCount} expired entries from memory cache`
  );
  return purgedCount;
}
async function getCacheStats(provider) {
  const now = /* @__PURE__ */ new Date();
  try {
    let query = db.select().from(externalApiCacheEntries);
    if (provider) {
      query = query.where(
        eq4(externalApiCacheEntries.provider, provider)
      );
    }
    const entries = await query;
    let freshEntries = 0;
    let staleEntries = 0;
    let expiredEntries = 0;
    let totalHits = 0;
    for (const entry of entries) {
      totalHits += entry.hitCount;
      if (now < entry.expiresAt) {
        freshEntries++;
      } else if (now < entry.staleUntilAt) {
        staleEntries++;
      } else {
        expiredEntries++;
      }
    }
    return {
      totalEntries: entries.length,
      freshEntries,
      staleEntries,
      expiredEntries,
      totalHits
    };
  } catch (error) {
    log.warn("PersistentCache", `Failed to get cache stats: ${error}`);
    return {
      totalEntries: 0,
      freshEntries: 0,
      staleEntries: 0,
      expiredEntries: 0,
      totalHits: 0
    };
  }
}
async function getAllCacheEntries(provider) {
  try {
    let query = db.select().from(externalApiCacheEntries);
    if (provider) {
      query = query.where(
        eq4(externalApiCacheEntries.provider, provider)
      );
    }
    const entries = await query;
    return entries.map((entry) => ({
      provider: entry.provider,
      cacheKey: entry.cacheKey,
      expiresAt: entry.expiresAt,
      staleUntilAt: entry.staleUntilAt,
      hitCount: entry.hitCount,
      lastAccessedAt: entry.lastAccessedAt,
      sizeBytes: entry.responseJson.length
    }));
  } catch (error) {
    log.warn("PersistentCache", `Failed to get cache entries: ${error}`);
    return [];
  }
}
var inMemoryCache;
var init_persistentApiCache = __esm({
  "server/lib/persistentApiCache.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_logger();
    init_apiPolicy();
    inMemoryCache = /* @__PURE__ */ new Map();
  }
});

// server/lib/callExternal.ts
var callExternal_exports = {};
__export(callExternal_exports, {
  callExternal: () => callExternal,
  getAllProviderStatuses: () => getAllProviderStatuses,
  getProviderStatus: () => getProviderStatus2
});
async function enforceMinInterval(provider) {
  const policy = getProviderPolicy(provider);
  const lastCall = lastCallTimes.get(provider) || 0;
  const elapsed = Date.now() - lastCall;
  const minInterval = policy.minRequestIntervalMs;
  if (elapsed < minInterval) {
    const waitTime = minInterval - elapsed;
    await new Promise((resolve2) => setTimeout(resolve2, waitTime));
  }
  lastCallTimes.set(provider, Date.now());
}
async function callExternal(fetcher, options) {
  const {
    provider,
    endpoint,
    cacheKey,
    budgetPolicy = {},
    cachePolicy = {},
    fallbackProvider,
    fallbackFetcher
  } = options;
  const effectiveCacheKey = cacheKey || `${provider}:${endpoint}`;
  const startTime = Date.now();
  let cacheStatus = "miss";
  let usedFallback = false;
  if (!cachePolicy.skipCache && !cachePolicy.forceRefresh) {
    const cached = await getFromCache(provider, effectiveCacheKey);
    if (cached) {
      if (cached.isFresh) {
        cacheStatus = "fresh";
        await recordUsage(provider, { isCacheHit: true });
        log.debug(
          "CallExternal",
          `Cache HIT (fresh) for ${provider}:${effectiveCacheKey}`
        );
        return {
          data: cached.data,
          provenance: {
            provider,
            cacheStatus: "fresh",
            budgetRemaining: Infinity,
            latencyMs: Date.now() - startTime,
            usedFallback: false
          }
        };
      }
      cacheStatus = "stale";
    }
  }
  if (!budgetPolicy.skipBudgetCheck) {
    const budgetCheck = await checkBudget(provider);
    if (!budgetCheck.allowed) {
      log.warn(
        "CallExternal",
        `Budget exhausted for ${provider}: ${budgetCheck.reason}`
      );
      if (cacheStatus === "stale") {
        const staleData = await getFromCache(provider, effectiveCacheKey);
        if (staleData) {
          log.info(
            "CallExternal",
            `Serving stale data for ${provider} due to budget limit`
          );
          await recordUsage(provider, { isCacheHit: true });
          return {
            data: staleData.data,
            provenance: {
              provider,
              cacheStatus: "stale",
              budgetRemaining: 0,
              latencyMs: Date.now() - startTime,
              usedFallback: false
            }
          };
        }
      }
      if (fallbackProvider && fallbackFetcher) {
        log.info(
          "CallExternal",
          `Trying fallback provider ${fallbackProvider} for ${provider}`
        );
        try {
          const fallbackResult = await callExternal(
            fallbackFetcher,
            {
              provider: fallbackProvider,
              endpoint,
              cacheKey: effectiveCacheKey,
              budgetPolicy,
              cachePolicy
            }
          );
          return {
            ...fallbackResult,
            provenance: {
              ...fallbackResult.provenance,
              usedFallback: true
            }
          };
        } catch (fallbackError) {
          log.warn(
            "CallExternal",
            `Fallback provider ${fallbackProvider} also failed`
          );
        }
      }
      throw new Error(
        `Budget exhausted for ${provider}: ${budgetCheck.reason}`
      );
    }
  }
  await enforceMinInterval(provider);
  try {
    const data = await fetcher();
    const latencyMs = Date.now() - startTime;
    await setInCache(provider, effectiveCacheKey, data);
    const requestCount = budgetPolicy.countAsMultiple || 1;
    for (let i = 0; i < requestCount; i++) {
      await recordUsage(provider, {
        isCacheHit: false,
        latencyMs: i === 0 ? latencyMs : void 0
      });
    }
    log.debug(
      "CallExternal",
      `Fetched ${provider}:${effectiveCacheKey} in ${latencyMs}ms`
    );
    const postBudget = await checkBudget(provider);
    return {
      data,
      provenance: {
        provider,
        cacheStatus: "miss",
        budgetRemaining: postBudget.allowed ? postBudget.limit - postBudget.currentCount : 0,
        latencyMs,
        usedFallback
      }
    };
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    await recordUsage(provider, {
      isCacheHit: false,
      isError: true,
      latencyMs
    });
    if (cacheStatus === "stale") {
      const staleData = await getFromCache(provider, effectiveCacheKey);
      if (staleData) {
        log.warn(
          "CallExternal",
          `Serving stale data for ${provider} after fetch error: ${error}`
        );
        return {
          data: staleData.data,
          provenance: {
            provider,
            cacheStatus: "stale",
            budgetRemaining: 0,
            latencyMs,
            usedFallback: false
          }
        };
      }
    }
    if (fallbackProvider && fallbackFetcher) {
      log.info(
        "CallExternal",
        `Trying fallback provider ${fallbackProvider} after error`
      );
      try {
        const fallbackResult = await callExternal(
          fallbackFetcher,
          {
            provider: fallbackProvider,
            endpoint,
            cacheKey: effectiveCacheKey,
            budgetPolicy,
            cachePolicy
          }
        );
        return {
          ...fallbackResult,
          provenance: {
            ...fallbackResult.provenance,
            usedFallback: true
          }
        };
      } catch (fallbackError) {
        log.warn(
          "CallExternal",
          `Fallback provider ${fallbackProvider} also failed`
        );
      }
    }
    throw error;
  }
}
async function getProviderStatus2(provider) {
  const policy = getProviderPolicy(provider);
  const budgetCheck = await checkBudget(provider);
  const lastCall = lastCallTimes.get(provider) || null;
  return {
    enabled: policy.enabled,
    budgetStatus: {
      allowed: budgetCheck.allowed,
      currentCount: budgetCheck.currentCount,
      limit: budgetCheck.limit,
      windowType: budgetCheck.windowType
    },
    lastCallTime: lastCall,
    policy: {
      maxRequestsPerMinute: policy.maxRequestsPerMinute,
      maxRequestsPerDay: policy.maxRequestsPerDay,
      maxRequestsPerWeek: policy.maxRequestsPerWeek,
      cacheFreshDurationMs: policy.cacheFreshDurationMs
    }
  };
}
async function getAllProviderStatuses() {
  const providers3 = [
    "alpaca",
    "finnhub",
    "coingecko",
    "coinmarketcap",
    "newsapi",
    "polygon",
    "twelvedata",
    "valyu",
    "huggingface",
    "gdelt",
    "openai",
    "groq",
    "together",
    "aitrados_ohlc",
    "aitrados_news",
    "aitrados_econ"
  ];
  const statuses = {};
  for (const provider of providers3) {
    statuses[provider] = await getProviderStatus2(provider);
  }
  return statuses;
}
var lastCallTimes;
var init_callExternal = __esm({
  "server/lib/callExternal.ts"() {
    "use strict";
    init_logger();
    init_apiBudget();
    init_persistentApiCache();
    init_apiPolicy();
    lastCallTimes = /* @__PURE__ */ new Map();
  }
});

// server/lib/connectorClient.ts
async function connectorFetch(url, options) {
  const {
    provider,
    endpoint,
    cacheKey,
    headers = {},
    method = "GET",
    body,
    skipCache = false,
    forceRefresh = false,
    customTTLMs,
    countAsMultiple
  } = options;
  const startTime = Date.now();
  const fetcher = async () => {
    const fetchOptions = {
      method,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        ...headers
      }
    };
    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }
    const response = await fetch(url, fetchOptions);
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      throw new Error(
        `${provider} API error ${response.status}: ${errorText.substring(0, 200)}`
      );
    }
    return response.json();
  };
  const callExternalOptions = {
    provider,
    endpoint,
    cacheKey,
    cachePolicy: {
      skipCache,
      forceRefresh,
      customTTLMs
    },
    budgetPolicy: {
      countAsMultiple
    }
  };
  const result = await callExternal(
    fetcher,
    callExternalOptions
  );
  log.debug("ConnectorClient", `${provider}:${endpoint}`, {
    cacheStatus: result.provenance.cacheStatus,
    budgetRemaining: result.provenance.budgetRemaining,
    latencyMs: result.provenance.latencyMs
  });
  return {
    data: result.data,
    provenance: {
      provider,
      cacheStatus: result.provenance.cacheStatus,
      budgetRemaining: result.provenance.budgetRemaining,
      latencyMs: result.provenance.latencyMs,
      usedFallback: result.provenance.usedFallback,
      timestamp: Date.now()
    }
  };
}
function buildCacheKey(provider, ...parts) {
  const filteredParts = parts.filter((p) => p !== void 0 && p !== null);
  return `${provider}:${filteredParts.join(":")}`;
}
var init_connectorClient = __esm({
  "server/lib/connectorClient.ts"() {
    "use strict";
    init_callExternal();
    init_logger();
  }
});

// server/connectors/gdelt.ts
var GDELT_DOC_API, GdeltConnector, gdelt;
var init_gdelt = __esm({
  "server/connectors/gdelt.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    GDELT_DOC_API = "https://api.gdeltproject.org/api/v2/doc/doc";
    GdeltConnector = class {
      articleCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      volumeCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      toneCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      sentimentCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      isAvailable() {
        return true;
      }
      buildUrl(query, options = {}) {
        const params = new URLSearchParams({
          query,
          mode: options.mode || "ArtList",
          format: "json",
          timespan: options.timespan || "24hours",
          maxrecords: String(options.maxRecords || 75)
        });
        if (options.theme) {
          params.set("theme", options.theme);
        }
        if (options.sourceLang) {
          params.set("sourcelang", options.sourceLang);
        }
        if (options.sourceCountry) {
          params.set("sourcecountry", options.sourceCountry);
        }
        return `${GDELT_DOC_API}?${params.toString()}`;
      }
      async searchArticles(query, options = {}) {
        const l1CacheKey = `articles_${query}_${JSON.stringify(options)}`;
        const cached = this.articleCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { ...options, mode: "ArtList" });
        const cacheKey = buildCacheKey(
          "gdelt",
          "articles",
          query,
          options.timespan || "24hours"
        );
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "searchArticles",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const result = {
            articles: (data.articles || []).map((a) => ({
              url: a.url || "",
              title: a.title || "",
              domain: a.domain || "",
              language: a.language || "",
              seenDate: a.seendate || "",
              socialImage: a.socialimage,
              tone: a.tone ? parseFloat(String(a.tone)) : void 0
            })),
            totalResults: data.articles?.length || 0
          };
          this.articleCache.set(l1CacheKey, result);
          log.info("GDELT", "Articles fetched", {
            query,
            count: result.totalResults
          });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch articles", {
            query,
            error: String(error)
          });
          const stale = this.articleCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { articles: [], totalResults: 0 };
        }
      }
      async getVolumeTimeline(query, timespan = "24hours") {
        const l1CacheKey = `volume_${query}_${timespan}`;
        const cached = this.volumeCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { mode: "TimelineVol", timespan });
        const cacheKey = buildCacheKey("gdelt", "volume", query, timespan);
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "getVolumeTimeline",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const result = {
            timeline: (data.timeline || []).map((t) => ({
              date: t.date || "",
              value: parseFloat(String(t.value || 0))
            })),
            query
          };
          this.volumeCache.set(l1CacheKey, result);
          log.info("GDELT", "Volume timeline fetched", {
            query,
            points: result.timeline.length
          });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch volume", {
            query,
            error: String(error)
          });
          const stale = this.volumeCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { timeline: [], query };
        }
      }
      async getToneTimeline(query, timespan = "24hours") {
        const l1CacheKey = `tone_${query}_${timespan}`;
        const cached = this.toneCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { mode: "TimelineTone", timespan });
        const cacheKey = buildCacheKey("gdelt", "tone", query, timespan);
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "getToneTimeline",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const timeline = (data.timeline || []).map((t) => ({
            date: t.date || "",
            tone: parseFloat(String(t.tone || 0)),
            positiveScore: parseFloat(String(t.tonescore || 0)),
            negativeScore: parseFloat(String(t.negtonescore || 0))
          }));
          const avgTone = timeline.length > 0 ? timeline.reduce((sum, t) => sum + t.tone, 0) / timeline.length : 0;
          const result = {
            timeline,
            query,
            averageTone: avgTone
          };
          this.toneCache.set(l1CacheKey, result);
          log.info("GDELT", "Tone timeline fetched", {
            query,
            avgTone: avgTone.toFixed(2)
          });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch tone", {
            query,
            error: String(error)
          });
          const stale = this.toneCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { timeline: [], query, averageTone: 0 };
        }
      }
      async analyzeSymbolSentiment(symbol, companyName) {
        const query = companyName ? `${symbol} OR "${companyName}" stock` : `${symbol} stock`;
        const l1CacheKey = `sentiment_${symbol}`;
        const cached = this.sentimentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const [articles, volume24h, volume3h, tone] = await Promise.all([
          this.searchArticles(query, { timespan: "24hours", maxRecords: 50 }),
          this.getVolumeTimeline(query, "24hours"),
          this.getVolumeTimeline(query, "3hours"),
          this.getToneTimeline(query, "24hours")
        ]);
        const recentVolume = volume3h.timeline.length > 0 ? volume3h.timeline.slice(-3).reduce((sum, t) => sum + t.value, 0) / 3 : 0;
        const baselineVolume = volume24h.timeline.length > 0 ? volume24h.timeline.reduce((sum, t) => sum + t.value, 0) / volume24h.timeline.length : 0;
        const volumeSpike = baselineVolume > 0 && recentVolume > baselineVolume * 2;
        let sentiment = "neutral";
        if (tone.averageTone > 3) {
          sentiment = "bullish";
        } else if (tone.averageTone < -3) {
          sentiment = "bearish";
        }
        const result = {
          symbol,
          query,
          articleCount: articles.totalResults,
          averageTone: tone.averageTone,
          sentiment,
          volumeSpike,
          recentVolume,
          baselineVolume,
          topHeadlines: articles.articles.slice(0, 5).map((a) => a.title),
          timestamp: /* @__PURE__ */ new Date()
        };
        this.sentimentCache.set(l1CacheKey, result);
        log.info("GDELT", "Symbol sentiment analyzed", {
          symbol,
          sentiment,
          articleCount: articles.totalResults,
          volumeSpike
        });
        return result;
      }
      async detectBreakingNews(keywords, threshold = 2) {
        const alerts = [];
        for (const keyword of keywords) {
          const [volume3h, volume24h, articles] = await Promise.all([
            this.getVolumeTimeline(keyword, "3hours"),
            this.getVolumeTimeline(keyword, "24hours"),
            this.searchArticles(keyword, { timespan: "3hours", maxRecords: 10 })
          ]);
          const recentVolume = volume3h.timeline.length > 0 ? volume3h.timeline.slice(-2).reduce((sum, t) => sum + t.value, 0) / 2 : 0;
          const baselineVolume = volume24h.timeline.length > 6 ? volume24h.timeline.slice(0, -6).reduce((sum, t) => sum + t.value, 0) / (volume24h.timeline.length - 6) : 0;
          const volumeIncrease = baselineVolume > 0 ? recentVolume / baselineVolume : 0;
          const isBreaking = volumeIncrease >= threshold;
          alerts.push({
            query: keyword,
            isBreaking,
            volumeIncrease,
            toneShift: 0,
            relevantArticles: articles.articles.slice(0, 5)
          });
        }
        const breakingAlerts = alerts.filter((a) => a.isBreaking);
        if (breakingAlerts.length > 0) {
          log.warn("GDELT", "Breaking news detected", {
            keywords: breakingAlerts.map((a) => a.query)
          });
        }
        return alerts;
      }
      async getEconomicSentiment() {
        const [inflation, recession, interestRates] = await Promise.all([
          this.getToneTimeline("inflation economy", "24hours"),
          this.getToneTimeline("recession economic downturn", "24hours"),
          this.getToneTimeline("Federal Reserve interest rate", "24hours")
        ]);
        const avgTone = (inflation.averageTone + recession.averageTone + interestRates.averageTone) / 3;
        let overall = "neutral";
        if (avgTone > 2) {
          overall = "bullish";
        } else if (avgTone < -2) {
          overall = "bearish";
        }
        return { inflation, recession, interestRates, overall };
      }
      async getCryptoSentiment(cryptoName) {
        const cryptoNameMap = {
          BTC: "Bitcoin",
          ETH: "Ethereum",
          SOL: "Solana",
          XRP: "Ripple",
          DOGE: "Dogecoin",
          ADA: "Cardano",
          DOT: "Polkadot",
          LINK: "Chainlink",
          AVAX: "Avalanche",
          MATIC: "Polygon",
          LTC: "Litecoin",
          SHIB: "Shiba"
        };
        const fullName = cryptoNameMap[cryptoName.toUpperCase()] || cryptoName;
        const query = `${fullName} cryptocurrency`;
        const l1CacheKey = `crypto_sentiment_${cryptoName}`;
        const cached = this.sentimentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const [articles, volume, tone] = await Promise.all([
          this.searchArticles(query, { timespan: "24hours", maxRecords: 50 }),
          this.getVolumeTimeline(query, "24hours"),
          this.getToneTimeline(query, "24hours")
        ]);
        const recentVolume = volume.timeline.length > 0 ? volume.timeline.slice(-3).reduce((sum, t) => sum + t.value, 0) / 3 : 0;
        const baselineVolume = volume.timeline.length > 0 ? volume.timeline.reduce((sum, t) => sum + t.value, 0) / volume.timeline.length : 0;
        let sentiment = "neutral";
        if (tone.averageTone > 2) {
          sentiment = "bullish";
        } else if (tone.averageTone < -2) {
          sentiment = "bearish";
        }
        const result = {
          symbol: cryptoName.toUpperCase(),
          query,
          articleCount: articles.totalResults,
          averageTone: tone.averageTone,
          sentiment,
          volumeSpike: recentVolume > baselineVolume * 2,
          recentVolume,
          baselineVolume,
          topHeadlines: articles.articles.slice(0, 5).map((a) => a.title),
          timestamp: /* @__PURE__ */ new Date()
        };
        this.sentimentCache.set(l1CacheKey, result);
        return result;
      }
      getConnectionStatus() {
        return {
          connected: true,
          cacheSize: this.articleCache.size() + this.volumeCache.size() + this.toneCache.size() + this.sentimentCache.size(),
          lastRequest: null
        };
      }
      clearCache() {
        this.articleCache.clear();
        this.volumeCache.clear();
        this.toneCache.clear();
        this.sentimentCache.clear();
      }
    };
    gdelt = new GdeltConnector();
  }
});

// server/connectors/valyu.ts
var VALYU_BASE_URL, DEFAULT_MAX_RESULTS, DEFAULT_RELEVANCE_THRESHOLD, ValyuConnector, valyu;
var init_valyu = __esm({
  "server/connectors/valyu.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    init_callExternal();
    init_connectorClient();
    init_apiBudget();
    VALYU_BASE_URL = "https://api.valyu.ai/v1";
    DEFAULT_MAX_RESULTS = 5;
    DEFAULT_RELEVANCE_THRESHOLD = 0.7;
    ValyuConnector = class {
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      earningsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      ratiosCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      filingsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      balanceSheetCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      incomeStatementCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      cashFlowCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      dividendCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      insiderCache = new ApiCache({
        freshDuration: 30 * 60 * 1e3,
        staleDuration: 4 * 60 * 60 * 1e3
      });
      marketMoversCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      getApiKey() {
        return process.env.VALYU_API_KEY;
      }
      isAvailable() {
        return !!this.getApiKey();
      }
      async search(query, options = {}) {
        const apiKey2 = this.getApiKey();
        if (!apiKey2) {
          throw new Error("VALYU_API_KEY is not configured");
        }
        const maxResults = options.maxResults ?? DEFAULT_MAX_RESULTS;
        const maxPrice = options.maxPrice ?? 0.1;
        const relevanceThreshold = options.relevanceThreshold ?? DEFAULT_RELEVANCE_THRESHOLD;
        const cacheKey = buildCacheKey(
          "valyu",
          "search",
          query,
          maxResults.toString(),
          maxPrice.toString(),
          options.sources?.join(",") || "all"
        );
        const l1Cached = this.searchCache.get(cacheKey);
        if (l1Cached?.isFresh) {
          log.debug("Valyu", "L1 cache hit", { query: query.substring(0, 30) });
          return l1Cached.data;
        }
        const body = {
          query,
          max_num_results: maxResults,
          max_price: maxPrice,
          relevance_threshold: relevanceThreshold
        };
        if (options.sources && options.sources.length > 0) {
          body.included_sources = options.sources;
        }
        const fetcher = async () => {
          const response = await fetch(`${VALYU_BASE_URL}/deepsearch`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": apiKey2
            },
            body: JSON.stringify(body)
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            throw new Error(`Valyu API error: ${response.status} - ${errorText}`);
          }
          return response.json();
        };
        const result = await callExternal(fetcher, {
          provider: "valyu",
          endpoint: "deepsearch",
          cacheKey,
          budgetPolicy: {
            countAsMultiple: 1
          }
        });
        const retrievalCount = result.data.results?.length || 0;
        if (retrievalCount > 1 && result.provenance.cacheStatus === "miss") {
          for (let i = 1; i < retrievalCount; i++) {
            await recordUsage("valyu", { isCacheHit: false });
          }
        }
        this.searchCache.set(cacheKey, result.data);
        log.info("Valyu", "Search completed", {
          query: query.substring(0, 50),
          resultsCount: retrievalCount,
          cacheStatus: result.provenance.cacheStatus,
          cost: result.data.total_deduction_dollars
        });
        return result.data;
      }
      async getEarnings(symbol) {
        const cacheKey = buildCacheKey("valyu", "earnings", symbol);
        const cached = this.earningsCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} latest quarterly earnings report EPS revenue net income`,
          {
            sources: ["valyu/valyu-earnings-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const epsMatch = content.match(/EPS[:\s]*\$?([\d.]+)/i);
        if (epsMatch) data.eps = parseFloat(epsMatch[1]);
        const revenueMatch = content.match(
          /revenue[:\s]*\$?([\d.]+)\s*(billion|million)?/i
        );
        if (revenueMatch) {
          let revenue = parseFloat(revenueMatch[1]);
          if (revenueMatch[2]?.toLowerCase() === "billion") revenue *= 1e9;
          if (revenueMatch[2]?.toLowerCase() === "million") revenue *= 1e6;
          data.revenue = revenue;
        }
        this.earningsCache.set(cacheKey, data);
        return data;
      }
      async getFinancialRatios(symbol) {
        const cacheKey = buildCacheKey("valyu", "ratios", symbol);
        const cached = this.ratiosCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} P/E ratio ROE debt to equity revenue growth financial ratios`,
          {
            sources: ["valyu/valyu-financial-ratios-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const peMatch = content.match(/P\/E[:\s]*([\d.]+)/i);
        if (peMatch) data.peRatio = parseFloat(peMatch[1]);
        const roeMatch = content.match(/ROE[:\s]*([\d.]+)%?/i);
        if (roeMatch) data.roe = parseFloat(roeMatch[1]);
        const debtMatch = content.match(/debt.?to.?equity[:\s]*([\d.]+)/i);
        if (debtMatch) data.debtToEquity = parseFloat(debtMatch[1]);
        this.ratiosCache.set(cacheKey, data);
        return data;
      }
      async getSECFiling(symbol, filingType = "10-K") {
        const cacheKey = buildCacheKey("valyu", "filing", symbol, filingType);
        const cached = this.filingsCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} ${filingType} SEC filing annual report`,
          {
            sources: ["valyu/valyu-sec-filings-US"],
            maxResults: 3
          }
        );
        const result = response.results[0];
        const data = {
          symbol,
          filingType,
          content: result?.content || "",
          url: result?.url
        };
        this.filingsCache.set(cacheKey, data);
        return data;
      }
      async getCompanyFinancials(symbol) {
        const [earnings, ratios] = await Promise.all([
          this.getEarnings(symbol),
          this.getFinancialRatios(symbol)
        ]);
        return { earnings, ratios };
      }
      async searchFinancialData(query) {
        return this.search(query, {
          sources: [
            "valyu/valyu-earnings-US",
            "valyu/valyu-financial-ratios-US",
            "valyu/valyu-balance-sheet-US",
            "valyu/valyu-income-statement-US",
            "valyu/valyu-cash-flow-US"
          ],
          maxResults: 15
        });
      }
      async getBalanceSheet(symbol) {
        const cacheKey = buildCacheKey("valyu", "balance", symbol);
        const cached = this.balanceSheetCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} balance sheet total assets liabilities equity cash debt`,
          {
            sources: ["valyu/valyu-balance-sheet-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const assetsMatch = content.match(
          /total\s*assets[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (assetsMatch) {
          data.totalAssets = this.parseFinancialValue(
            assetsMatch[1],
            assetsMatch[2]
          );
        }
        const liabilitiesMatch = content.match(
          /total\s*liabilities[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (liabilitiesMatch) {
          data.totalLiabilities = this.parseFinancialValue(
            liabilitiesMatch[1],
            liabilitiesMatch[2]
          );
        }
        const equityMatch = content.match(
          /(?:total\s*)?(?:shareholders?[']?\s*)?equity[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (equityMatch) {
          data.totalEquity = this.parseFinancialValue(
            equityMatch[1],
            equityMatch[2]
          );
        }
        const cashMatch = content.match(
          /cash\s*(?:and\s*)?(?:equivalents)?[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (cashMatch) {
          data.cashAndEquivalents = this.parseFinancialValue(
            cashMatch[1],
            cashMatch[2]
          );
        }
        const debtMatch = content.match(
          /total\s*debt[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (debtMatch) {
          data.totalDebt = this.parseFinancialValue(debtMatch[1], debtMatch[2]);
        }
        this.balanceSheetCache.set(cacheKey, data);
        log.info("Valyu", "Balance sheet fetched", { symbol, hasData: !!content });
        return data;
      }
      async getIncomeStatement(symbol) {
        const cacheKey = buildCacheKey("valyu", "income", symbol);
        const cached = this.incomeStatementCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} income statement revenue gross profit operating income net income`,
          {
            sources: ["valyu/valyu-income-statement-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const revenueMatch = content.match(
          /(?:total\s*)?revenue[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (revenueMatch) {
          data.revenue = this.parseFinancialValue(revenueMatch[1], revenueMatch[2]);
        }
        const costMatch = content.match(
          /cost\s*of\s*(?:goods\s*sold|revenue)[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (costMatch) {
          data.costOfRevenue = this.parseFinancialValue(costMatch[1], costMatch[2]);
        }
        const grossMatch = content.match(
          /gross\s*profit[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (grossMatch) {
          data.grossProfit = this.parseFinancialValue(grossMatch[1], grossMatch[2]);
        }
        const opIncomeMatch = content.match(
          /operating\s*income[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (opIncomeMatch) {
          data.operatingIncome = this.parseFinancialValue(
            opIncomeMatch[1],
            opIncomeMatch[2]
          );
        }
        const netIncomeMatch = content.match(
          /net\s*income[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (netIncomeMatch) {
          data.netIncome = this.parseFinancialValue(
            netIncomeMatch[1],
            netIncomeMatch[2]
          );
        }
        this.incomeStatementCache.set(cacheKey, data);
        log.info("Valyu", "Income statement fetched", {
          symbol,
          hasData: !!content
        });
        return data;
      }
      async getCashFlow(symbol) {
        const cacheKey = buildCacheKey("valyu", "cashflow", symbol);
        const cached = this.cashFlowCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} cash flow statement operating investing financing free cash flow`,
          {
            sources: ["valyu/valyu-cash-flow-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const opCashMatch = content.match(
          /(?:net\s*)?(?:cash\s*from\s*)?operating\s*(?:activities|cash\s*flow)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (opCashMatch) {
          data.operatingCashFlow = this.parseFinancialValue(
            opCashMatch[1],
            opCashMatch[2]
          );
        }
        const invCashMatch = content.match(
          /(?:net\s*)?(?:cash\s*from\s*)?investing\s*(?:activities)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (invCashMatch) {
          data.investingCashFlow = this.parseFinancialValue(
            invCashMatch[1],
            invCashMatch[2]
          );
        }
        const finCashMatch = content.match(
          /(?:net\s*)?(?:cash\s*from\s*)?financing\s*(?:activities)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (finCashMatch) {
          data.financingCashFlow = this.parseFinancialValue(
            finCashMatch[1],
            finCashMatch[2]
          );
        }
        const freeCashMatch = content.match(
          /free\s*cash\s*flow[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i
        );
        if (freeCashMatch) {
          data.freeCashFlow = this.parseFinancialValue(
            freeCashMatch[1],
            freeCashMatch[2]
          );
        }
        this.cashFlowCache.set(cacheKey, data);
        log.info("Valyu", "Cash flow fetched", { symbol, hasData: !!content });
        return data;
      }
      async getDividends(symbol) {
        const cacheKey = buildCacheKey("valyu", "dividend", symbol);
        const cached = this.dividendCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} dividend yield amount ex-dividend date payment frequency`,
          {
            sources: ["valyu/valyu-dividends-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const amountMatch = content.match(
          /dividend\s*(?:amount)?[:\s]*\$?([\d.,]+)/i
        );
        if (amountMatch) {
          data.dividendAmount = this.parseFinancialValue(amountMatch[1]);
        }
        const yieldMatch = content.match(/(?:dividend\s*)?yield[:\s]*([\d.,]+)%?/i);
        if (yieldMatch) {
          data.dividendYield = parseFloat(yieldMatch[1].replace(/,/g, ""));
        }
        const exDateMatch = content.match(
          /ex[- ]?dividend\s*date[:\s]*(\d{4}[-/]\d{2}[-/]\d{2}|\w+\s+\d+,?\s*\d{4})/i
        );
        if (exDateMatch) {
          data.exDividendDate = exDateMatch[1];
        }
        const payDateMatch = content.match(
          /payment\s*date[:\s]*(\d{4}[-/]\d{2}[-/]\d{2}|\w+\s+\d+,?\s*\d{4})/i
        );
        if (payDateMatch) {
          data.paymentDate = payDateMatch[1];
        }
        const freqMatch = content.match(
          /(?:dividend\s*)?(?:payment\s*)?frequency[:\s]*(quarterly|monthly|annual|semi-?annual)/i
        );
        if (freqMatch) {
          data.frequency = freqMatch[1].toLowerCase();
        }
        this.dividendCache.set(cacheKey, data);
        log.info("Valyu", "Dividend data fetched", {
          symbol,
          yield: data.dividendYield
        });
        return data;
      }
      async getInsiderTransactions(symbol) {
        const cacheKey = buildCacheKey("valyu", "insider", symbol);
        const cached = this.insiderCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} insider trading transactions buy sell shares officers directors SEC Form 4`,
          {
            sources: ["valyu/valyu-insider-US"],
            maxResults: 10
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          transactions: [],
          netInsiderSentiment: "neutral",
          rawData: content
        };
        let totalBuyValue = 0;
        let totalSellValue = 0;
        const transactionPatterns = [
          /(\w+[\w\s,]+?)\s*(?:,\s*)?(CEO|CFO|COO|CTO|Director|Officer|President|VP|Chairman)?\s*(?:bought|purchased|acquired)\s*([\d,]+)\s*shares?\s*(?:at|@)\s*\$?([\d.]+)/gi,
          /(\w+[\w\s,]+?)\s*(?:,\s*)?(CEO|CFO|COO|CTO|Director|Officer|President|VP|Chairman)?\s*(?:sold|disposed)\s*([\d,]+)\s*shares?\s*(?:at|@)\s*\$?([\d.]+)/gi
        ];
        for (const pattern of transactionPatterns) {
          const isBuy = pattern.source.includes("bought|purchased|acquired");
          let match;
          while ((match = pattern.exec(content)) !== null) {
            const shares = parseInt(match[3].replace(/,/g, ""), 10);
            const price = parseFloat(match[4]);
            const value = shares * price;
            if (isBuy) {
              totalBuyValue += value;
            } else {
              totalSellValue += value;
            }
            data.transactions.push({
              insiderName: match[1].trim(),
              title: match[2] || void 0,
              transactionType: isBuy ? "buy" : "sell",
              shares,
              price
            });
          }
        }
        data.totalBuyValue = totalBuyValue;
        data.totalSellValue = totalSellValue;
        if (totalBuyValue > totalSellValue * 1.5) {
          data.netInsiderSentiment = "bullish";
        } else if (totalSellValue > totalBuyValue * 1.5) {
          data.netInsiderSentiment = "bearish";
        }
        this.insiderCache.set(cacheKey, data);
        log.info("Valyu", "Insider transactions fetched", {
          symbol,
          transactionCount: data.transactions.length,
          sentiment: data.netInsiderSentiment
        });
        return data;
      }
      async getMarketMovers() {
        const cacheKey = buildCacheKey("valyu", "market_movers");
        const cached = this.marketMoversCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          "today top stock gainers losers most active volume market movers",
          {
            sources: ["valyu/valyu-market-movers-US"],
            maxResults: 10
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          gainers: [],
          losers: [],
          mostActive: [],
          rawData: content
        };
        const gainerPattern = /([A-Z]{1,5})\s*(?:\+|up\s*)([\d.]+)%/gi;
        let match;
        while ((match = gainerPattern.exec(content)) !== null) {
          data.gainers.push({
            symbol: match[1],
            change: parseFloat(match[2])
          });
        }
        const loserPattern = /([A-Z]{1,5})\s*(?:-|down\s*)([\d.]+)%/gi;
        while ((match = loserPattern.exec(content)) !== null) {
          data.losers.push({
            symbol: match[1],
            change: -parseFloat(match[2])
          });
        }
        data.gainers = data.gainers.slice(0, 10);
        data.losers = data.losers.slice(0, 10);
        this.marketMoversCache.set(cacheKey, data);
        log.info("Valyu", "Market movers fetched", {
          gainersCount: data.gainers.length,
          losersCount: data.losers.length
        });
        return data;
      }
      async getComprehensiveAnalysis(symbol) {
        const [
          earnings,
          ratios,
          balanceSheet,
          incomeStatement,
          cashFlow,
          dividends,
          insiderActivity
        ] = await Promise.all([
          this.getEarnings(symbol),
          this.getFinancialRatios(symbol),
          this.getBalanceSheet(symbol),
          this.getIncomeStatement(symbol),
          this.getCashFlow(symbol),
          this.getDividends(symbol),
          this.getInsiderTransactions(symbol)
        ]);
        return {
          earnings,
          ratios,
          balanceSheet,
          incomeStatement,
          cashFlow,
          dividends,
          insiderActivity
        };
      }
      parseFinancialValue(valueStr, unit) {
        let value = parseFloat(valueStr.replace(/,/g, ""));
        if (unit) {
          const unitLower = unit.toLowerCase();
          if (unitLower === "billion" || unitLower === "b") {
            value *= 1e9;
          } else if (unitLower === "million" || unitLower === "m") {
            value *= 1e6;
          }
        }
        return value;
      }
      getConnectionStatus() {
        return {
          connected: this.isAvailable(),
          hasApiKey: this.isAvailable(),
          cacheSize: this.searchCache.size() + this.earningsCache.size() + this.ratiosCache.size() + this.filingsCache.size()
        };
      }
      clearCache() {
        this.searchCache.clear();
        this.earningsCache.clear();
        this.ratiosCache.clear();
        this.filingsCache.clear();
        this.balanceSheetCache.clear();
        this.incomeStatementCache.clear();
        this.cashFlowCache.clear();
        this.dividendCache.clear();
        this.insiderCache.clear();
        this.marketMoversCache.clear();
      }
    };
    valyu = new ValyuConnector();
  }
});

// server/connectors/finnhub.ts
var FINNHUB_BASE_URL, FinnhubConnector, finnhub;
var init_finnhub = __esm({
  "server/connectors/finnhub.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    FINNHUB_BASE_URL = "https://finnhub.io/api/v1";
    FinnhubConnector = class {
      quoteCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      candleCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      profileCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      newsCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      financialsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      technicalCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      pendingRefreshes = /* @__PURE__ */ new Set();
      getApiKey() {
        return process.env.FINNHUB_API_KEY;
      }
      async fetchWithL1Cache(endpoint, l1CacheKey, l1Cache) {
        const apiKey2 = this.getApiKey();
        if (!apiKey2) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug(
              "Finnhub",
              `No API key, serving stale L1 data for ${l1CacheKey}`
            );
            return stale;
          }
          throw new Error("FINNHUB_API_KEY is not configured");
        }
        const l1Cached = l1Cache.get(l1CacheKey);
        if (l1Cached?.isFresh) {
          log.debug("Finnhub", `L1 cache HIT (fresh) for ${l1CacheKey}`);
          return l1Cached.data;
        }
        if (l1Cached && !l1Cached.isFresh) {
          if (!this.pendingRefreshes.has(l1CacheKey)) {
            this.pendingRefreshes.add(l1CacheKey);
            this.backgroundRefresh(endpoint, l1CacheKey, l1Cache);
          }
          log.debug(
            "Finnhub",
            `Serving stale L1 data for ${l1CacheKey}, refreshing in background`
          );
          return l1Cached.data;
        }
        return this.doFetch(endpoint, l1CacheKey, l1Cache);
      }
      async backgroundRefresh(endpoint, l1CacheKey, l1Cache) {
        try {
          await this.doFetch(endpoint, l1CacheKey, l1Cache);
        } catch (error) {
          log.warn("Finnhub", `Background refresh failed for ${l1CacheKey}`);
        } finally {
          this.pendingRefreshes.delete(l1CacheKey);
        }
      }
      async doFetch(endpoint, l1CacheKey, l1Cache) {
        const apiKey2 = this.getApiKey();
        const separator = endpoint.includes("?") ? "&" : "?";
        const fullUrl = `${FINNHUB_BASE_URL}${endpoint}${separator}token=${apiKey2}`;
        const cacheKey = buildCacheKey("finnhub", l1CacheKey);
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "finnhub",
            endpoint,
            cacheKey,
            headers: { Accept: "application/json" }
          });
          l1Cache.set(l1CacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug(
              "Finnhub",
              `Error fetching, serving stale L1 data for ${l1CacheKey}`
            );
            return stale;
          }
          throw error;
        }
      }
      async getQuote(symbol) {
        const l1CacheKey = `quote_${symbol}`;
        const endpoint = `/quote?symbol=${symbol.toUpperCase()}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.quoteCache
        );
      }
      async getCandles(symbol, resolution = "D", from, to) {
        const now = Math.floor(Date.now() / 1e3);
        const fromTime = from || now - 30 * 24 * 60 * 60;
        const toTime = to || now;
        const l1CacheKey = `candles_${symbol}_${resolution}_${fromTime}_${toTime}`;
        const endpoint = `/stock/candle?symbol=${symbol.toUpperCase()}&resolution=${resolution}&from=${fromTime}&to=${toTime}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.candleCache
        );
      }
      async getCompanyProfile(symbol) {
        const l1CacheKey = `profile_${symbol}`;
        const endpoint = `/stock/profile2?symbol=${symbol.toUpperCase()}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.profileCache
        );
      }
      async searchSymbols(query) {
        const l1CacheKey = `search_${query}`;
        const endpoint = `/search?q=${encodeURIComponent(query)}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.searchCache
        );
      }
      async getMarketNews(category = "general") {
        const l1CacheKey = `news_${category}`;
        const endpoint = `/news?category=${category}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.newsCache
        );
      }
      async getMultipleQuotes(symbols) {
        const quotes = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          try {
            const quote = await this.getQuote(symbol);
            if (quote && quote.c !== 0) {
              quotes.set(symbol, quote);
            }
          } catch (error) {
            log.error("Finnhub", `Failed to fetch quote for ${symbol}`, {
              error: String(error)
            });
          }
        }
        return quotes;
      }
      async getBasicFinancials(symbol) {
        const l1CacheKey = `financials_${symbol}`;
        const endpoint = `/stock/metric?symbol=${symbol.toUpperCase()}&metric=all`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.financialsCache
        );
      }
      async getTechnicalIndicator(symbol, resolution = "D") {
        const l1CacheKey = `technical_${symbol}_${resolution}`;
        const endpoint = `/scan/technical-indicator?symbol=${symbol.toUpperCase()}&resolution=${resolution}`;
        return this.fetchWithL1Cache(
          endpoint,
          l1CacheKey,
          this.technicalCache
        );
      }
      async getKeyMetrics(symbol) {
        try {
          const financials = await this.getBasicFinancials(symbol);
          const m = financials.metric;
          return {
            peRatio: m.peBasicExclExtraTTM ?? m.peExclExtraTTM ?? null,
            pbRatio: m.pbQuarterly ?? null,
            roe: m.roeTTM ?? m.roeRfy ?? null,
            roa: m.roaTTM ?? m.roaRfy ?? null,
            currentRatio: m.currentRatioQuarterly ?? null,
            debtToEquity: m.totalDebtToEquityQuarterly ?? null,
            grossMargin: m.grossMarginTTM ?? m.grossMargin5Y ?? null,
            netProfitMargin: m.netProfitMarginTTM ?? m.netProfitMargin5Y ?? null,
            beta: m.beta ?? null,
            dividendYield: m.dividendYieldIndicatedAnnual ?? null,
            epsGrowth: m.epsGrowthTTMYoy ?? m.epsGrowth3Y ?? null,
            revenueGrowth: m.revenueGrowthTTMYoy ?? m.revenueGrowth3Y ?? null,
            weekHigh52: m["52WeekHigh"] ?? null,
            weekLow52: m["52WeekLow"] ?? null
          };
        } catch (error) {
          log.warn("Finnhub", `Failed to get key metrics for ${symbol}`, {
            error: String(error)
          });
          return {
            peRatio: null,
            pbRatio: null,
            roe: null,
            roa: null,
            currentRatio: null,
            debtToEquity: null,
            grossMargin: null,
            netProfitMargin: null,
            beta: null,
            dividendYield: null,
            epsGrowth: null,
            revenueGrowth: null,
            weekHigh52: null,
            weekLow52: null
          };
        }
      }
      async getTechnicalSignals(symbol) {
        try {
          const indicator = await this.getTechnicalIndicator(symbol);
          return {
            signal: indicator.technicalAnalysis.signal,
            buyCount: indicator.technicalAnalysis.count.buy,
            sellCount: indicator.technicalAnalysis.count.sell,
            neutralCount: indicator.technicalAnalysis.count.neutral,
            adx: indicator.trend.adx,
            isTrending: indicator.trend.trending
          };
        } catch (error) {
          log.warn("Finnhub", `Failed to get technical signals for ${symbol}`, {
            error: String(error)
          });
          return {
            signal: "neutral",
            buyCount: 0,
            sellCount: 0,
            neutralCount: 0,
            adx: null,
            isTrending: false
          };
        }
      }
      getConnectionStatus() {
        const totalCacheSize = this.quoteCache.size() + this.candleCache.size() + this.profileCache.size() + this.searchCache.size() + this.newsCache.size() + this.financialsCache.size() + this.technicalCache.size();
        return {
          connected: !!this.getApiKey(),
          hasApiKey: !!this.getApiKey(),
          cacheSize: totalCacheSize
        };
      }
      clearCache() {
        this.quoteCache.clear();
        this.candleCache.clear();
        this.profileCache.clear();
        this.searchCache.clear();
        this.newsCache.clear();
        this.financialsCache.clear();
        this.technicalCache.clear();
      }
    };
    finnhub = new FinnhubConnector();
  }
});

// server/connectors/newsapi.ts
var NEWSAPI_BASE_URL, NewsAPIConnector, newsapi;
var init_newsapi = __esm({
  "server/connectors/newsapi.ts"() {
    "use strict";
    init_logger();
    init_connectorClient();
    init_callExternal();
    NEWSAPI_BASE_URL = "https://newsapi.org/v2";
    NewsAPIConnector = class {
      cache = /* @__PURE__ */ new Map();
      cacheDuration = 60 * 60 * 1e3;
      // 60 minutes fresh cache (L1 hot cache)
      staleCacheDuration = 24 * 60 * 60 * 1e3;
      // 24 hours stale data
      getApiKey() {
        return process.env.NEWS_API_KEY;
      }
      getCached(key, allowStale = false) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        const age = Date.now() - entry.timestamp;
        const maxAge = allowStale ? this.staleCacheDuration : this.cacheDuration;
        if (age < maxAge) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async fetchWithRetry(url, endpoint, cacheKey) {
        const apiKey2 = this.getApiKey();
        if (!apiKey2) {
          throw new Error("NEWS_API_KEY is not configured");
        }
        const staleData = this.getCached(cacheKey, true);
        const separator = url.includes("?") ? "&" : "?";
        const fullUrl = `${url}${separator}apiKey=${apiKey2}`;
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "newsapi",
            endpoint,
            cacheKey: buildCacheKey("newsapi", cacheKey),
            headers: { Accept: "application/json" }
          });
          log.debug("NewsAPI", `Fetched ${endpoint}`, {
            cacheStatus: result.provenance.cacheStatus,
            budgetRemaining: result.provenance.budgetRemaining
          });
          return result.data;
        } catch (error) {
          if (staleData) {
            log.debug(
              "NewsAPI",
              `Returning L1 stale data for ${cacheKey} after error`
            );
            return staleData;
          }
          throw error;
        }
      }
      async getTopHeadlines(category = "business", country = "us", pageSize = 20) {
        const cacheKey = `headlines_${category}_${country}_${pageSize}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/top-headlines?category=${category}&country=${country}&pageSize=${pageSize}`;
          const response = await this.fetchWithRetry(
            url,
            "/top-headlines",
            cacheKey
          );
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.articles);
          return response.articles;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug(
              "NewsAPI",
              "getTopHeadlines returning stale data due to error"
            );
            return stale;
          }
          throw error;
        }
      }
      async searchNews(query, sortBy = "publishedAt", pageSize = 20, language = "en") {
        const cacheKey = `search_${query}_${sortBy}_${pageSize}_${language}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/everything?q=${encodeURIComponent(query)}&sortBy=${sortBy}&pageSize=${pageSize}&language=${language}`;
          const response = await this.fetchWithRetry(
            url,
            "/everything",
            cacheKey
          );
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.articles);
          return response.articles;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug("NewsAPI", "searchNews returning stale data due to error");
            return stale;
          }
          throw error;
        }
      }
      async getMarketNews(pageSize = 20) {
        return this.searchNews(
          "stock market OR cryptocurrency OR trading OR investing OR finance",
          "publishedAt",
          pageSize
        );
      }
      async getCryptoNews(pageSize = 20) {
        return this.searchNews(
          "bitcoin OR ethereum OR cryptocurrency OR crypto trading",
          "publishedAt",
          pageSize
        );
      }
      async getStockNews(symbol, pageSize = 10) {
        return this.searchNews(symbol, "relevancy", pageSize);
      }
      async getSources(category = "business", language = "en") {
        const cacheKey = `sources_${category}_${language}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/top-headlines/sources?category=${category}&language=${language}`;
          const response = await this.fetchWithRetry(
            url,
            "/sources",
            cacheKey
          );
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.sources);
          return response.sources;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug("NewsAPI", "getSources returning stale data due to error");
            return stale;
          }
          throw error;
        }
      }
      async getConnectionStatus() {
        const hasApiKey = !!this.getApiKey();
        const providerStatus = await getProviderStatus2("newsapi");
        return {
          connected: hasApiKey && providerStatus.enabled && providerStatus.budgetStatus.allowed,
          hasApiKey,
          cacheSize: this.cache.size,
          budgetStatus: providerStatus.budgetStatus
        };
      }
      clearCache() {
        this.cache.clear();
      }
    };
    newsapi = new NewsAPIConnector();
  }
});

// server/connectors/finra.ts
var REGSHO_BASE_URL, FINRAConnector, finra;
var init_finra = __esm({
  "server/connectors/finra.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    REGSHO_BASE_URL = "https://cdn.finra.org/equity/regsho/daily";
    FINRAConnector = class {
      shortInterestCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        // 4 hours - short interest updates twice monthly
        staleDuration: 7 * 24 * 60 * 60 * 1e3
        // 7 days
      });
      consolidatedCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        staleDuration: 7 * 24 * 60 * 60 * 1e3
      });
      regShoCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        // 1 hour - RegSHO updates daily
        staleDuration: 24 * 60 * 60 * 1e3
      });
      /**
       * Get RegSHO short volume data for a symbol
       * This is daily short volume data from FINRA's public RegSHO files
       */
      async getRegSHOShortVolume(symbol, days = 20) {
        const cacheKey = `regsho_${symbol}_${days}`;
        const cached = this.regShoCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("FINRA", `Cache hit for RegSHO ${symbol}`);
          return cached.data;
        }
        try {
          const results = [];
          const today = /* @__PURE__ */ new Date();
          for (let i = 0; i < days; i++) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dayOfWeek = date.getDay();
            if (dayOfWeek === 0 || dayOfWeek === 6) continue;
            const dateStr = this.formatDateForRegSHO(date);
            try {
              const data = await this.fetchRegSHOFile(dateStr);
              const symbolData = data.find(
                (d) => d.symbol === symbol.toUpperCase()
              );
              if (symbolData) {
                results.push(symbolData);
              }
            } catch {
            }
            if (results.length >= 10) break;
          }
          if (results.length > 0) {
            this.regShoCache.set(cacheKey, results);
            log.info(
              "FINRA",
              `Fetched ${results.length} RegSHO records for ${symbol}`
            );
          }
          return results;
        } catch (error) {
          log.error("FINRA", `Failed to fetch RegSHO data for ${symbol}`, {
            error: String(error)
          });
          return cached?.data || [];
        }
      }
      /**
       * Fetch and parse FINRA RegSHO daily short sale file
       */
      async fetchRegSHOFile(dateStr) {
        const url = `${REGSHO_BASE_URL}/CNMSshvol${dateStr}.txt`;
        const response = await fetch(url, {
          headers: {
            Accept: "text/plain"
          }
        });
        if (!response.ok) {
          throw new Error(`RegSHO file not available for ${dateStr}`);
        }
        const text17 = await response.text();
        return this.parseRegSHOFile(text17, dateStr);
      }
      /**
       * Parse FINRA RegSHO file format
       * Format: Date|Symbol|ShortVolume|ShortExemptVolume|TotalVolume|Market
       */
      parseRegSHOFile(text17, dateStr) {
        const lines = text17.split("\n").filter((line) => line.trim());
        const results = [];
        for (let i = 1; i < lines.length; i++) {
          const parts = lines[i].split("|");
          if (parts.length >= 5) {
            const shortVolume = parseInt(parts[2], 10) || 0;
            const shortExemptVolume = parseInt(parts[3], 10) || 0;
            const totalVolume = parseInt(parts[4], 10) || 0;
            if (totalVolume > 0) {
              results.push({
                symbol: parts[1],
                settlementDate: dateStr,
                shortVolume,
                shortExemptVolume,
                totalVolume,
                shortRatio: totalVolume > 0 ? shortVolume / totalVolume : 0,
                market: parts[5] || "N/A"
              });
            }
          }
        }
        return results;
      }
      /**
       * Get short interest summary with trend analysis
       */
      async getShortInterestSummary(symbol) {
        const historicalData = await this.getRegSHOShortVolume(symbol, 30);
        if (historicalData.length === 0) {
          return null;
        }
        const shortRatios = historicalData.map((d) => d.shortRatio);
        const latestShortRatio = shortRatios[0];
        const averageShortRatio = shortRatios.reduce((a, b) => a + b, 0) / shortRatios.length;
        const midpoint = Math.floor(shortRatios.length / 2);
        const recentAvg = shortRatios.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint || 0;
        const olderAvg = shortRatios.slice(midpoint).reduce((a, b) => a + b, 0) / (shortRatios.length - midpoint) || 0;
        let shortRatioTrend;
        const trendThreshold = 0.05;
        if (recentAvg > olderAvg * (1 + trendThreshold)) {
          shortRatioTrend = "increasing";
        } else if (recentAvg < olderAvg * (1 - trendThreshold)) {
          shortRatioTrend = "decreasing";
        } else {
          shortRatioTrend = "stable";
        }
        const avgVolume = historicalData.reduce((sum, d) => sum + d.totalVolume, 0) / historicalData.length;
        const avgShortVolume = historicalData.reduce((sum, d) => sum + d.shortVolume, 0) / historicalData.length;
        const daysToCover = avgVolume > 0 ? avgShortVolume / avgVolume * 10 : null;
        return {
          symbol: symbol.toUpperCase(),
          latestShortRatio,
          averageShortRatio,
          shortRatioTrend,
          daysTocover: daysToCover,
          lastUpdated: /* @__PURE__ */ new Date(),
          historicalData
        };
      }
      /**
       * Get short interest data for multiple symbols
       */
      async getBulkShortInterest(symbols) {
        const results = /* @__PURE__ */ new Map();
        const batchSize = 5;
        for (let i = 0; i < symbols.length; i += batchSize) {
          const batch = symbols.slice(i, i + batchSize);
          const batchResults = await Promise.all(
            batch.map(async (symbol) => {
              const summary = await this.getShortInterestSummary(symbol);
              return { symbol, summary };
            })
          );
          for (const { symbol, summary } of batchResults) {
            if (summary) {
              results.set(symbol, summary);
            }
          }
          if (i + batchSize < symbols.length) {
            await new Promise((resolve2) => setTimeout(resolve2, 500));
          }
        }
        log.info(
          "FINRA",
          `Fetched short interest for ${results.size}/${symbols.length} symbols`
        );
        return results;
      }
      /**
       * Analyze short squeeze potential based on short interest metrics
       */
      analyzeShortSqueezePotential(summary) {
        const factors = [];
        let score = 0;
        if (summary.latestShortRatio > 0.5) {
          score += 40;
          factors.push(
            `Very high short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`
          );
        } else if (summary.latestShortRatio > 0.4) {
          score += 30;
          factors.push(
            `High short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`
          );
        } else if (summary.latestShortRatio > 0.3) {
          score += 20;
          factors.push(
            `Elevated short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`
          );
        }
        if (summary.shortRatioTrend === "increasing") {
          score += 20;
          factors.push("Short interest is increasing");
        }
        if (summary.daysTocover && summary.daysTocover > 5) {
          score += 25;
          factors.push(`High days to cover: ${summary.daysTocover.toFixed(1)}`);
        } else if (summary.daysTocover && summary.daysTocover > 3) {
          score += 15;
          factors.push(`Elevated days to cover: ${summary.daysTocover.toFixed(1)}`);
        }
        if (summary.latestShortRatio > summary.averageShortRatio * 1.2) {
          score += 15;
          factors.push("Short ratio above 20-day average");
        }
        let potential;
        if (score >= 60) {
          potential = "high";
        } else if (score >= 35) {
          potential = "medium";
        } else {
          potential = "low";
        }
        return { potential, score, factors };
      }
      formatDateForRegSHO(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}${month}${day}`;
      }
      /**
       * Clear all caches
       */
      clearCache() {
        this.shortInterestCache.clear();
        this.consolidatedCache.clear();
        this.regShoCache.clear();
      }
      /**
       * Check connection status
       */
      getConnectionStatus() {
        const cacheSize = this.shortInterestCache.size() + this.consolidatedCache.size() + this.regShoCache.size();
        return {
          connected: true,
          // FINRA public data doesn't require authentication
          cacheSize
        };
      }
    };
    finra = new FINRAConnector();
  }
});

// server/connectors/sec-edgar.ts
import { z as z7 } from "zod";
async function fetchSEC(url) {
  return wrapWithLimiter("sec-edgar", async () => {
    const response = await fetch(url, {
      headers: {
        "User-Agent": SEC_USER_AGENT,
        Accept: "application/json"
      }
    });
    if (!response.ok) {
      throw new Error(
        `SEC API error: ${response.status} ${response.statusText}`
      );
    }
    return response.json();
  });
}
async function getCIKByTicker(ticker) {
  const normalizedTicker = ticker.toUpperCase();
  if (cikCache.has(normalizedTicker)) {
    return cikCache.get(normalizedTicker);
  }
  try {
    const tickersData = await fetchSEC(
      `https://www.sec.gov/files/company_tickers.json`
    );
    for (const entry of Object.values(tickersData)) {
      if (entry.ticker === normalizedTicker) {
        const cik = String(entry.cik_str).padStart(10, "0");
        cikCache.set(normalizedTicker, cik);
        return cik;
      }
    }
    return null;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to get CIK for ${ticker}: ${error.message}`
    );
    return null;
  }
}
async function getCompanyInfo(ticker) {
  const cacheKey = `sec-company-${ticker}`;
  const cached = cache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const info = {
      cik,
      name: data.name,
      ticker: data.tickers?.[0] || ticker,
      exchanges: data.exchanges || [],
      sic: data.sic || "",
      sicDescription: data.sicDescription || "",
      category: data.category,
      fiscalYearEnd: data.fiscalYearEnd
    };
    cache.set(cacheKey, info);
    return info;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to fetch company info for ${ticker}: ${error.message}`
    );
    return null;
  }
}
async function getCompanyFacts(ticker) {
  const cacheKey = `sec-facts-${ticker}`;
  const cached = cache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  try {
    const data = await fetchSEC(
      `${SEC_BASE_URL}/api/xbrl/companyfacts/CIK${cik}.json`
    );
    const parsed = CompanyFactsSchema.parse(data);
    const getLatestValue = (concept, namespace = "us-gaap") => {
      const facts = parsed.facts?.[namespace]?.[concept]?.units?.USD;
      if (!facts || facts.length === 0) return void 0;
      const annual = facts.filter((f) => f.form === "10-K").sort(
        (a, b) => new Date(b.end).getTime() - new Date(a.end).getTime()
      );
      return annual[0]?.val;
    };
    const fundamentals = {
      cik,
      ticker: ticker.toUpperCase(),
      name: parsed.entityName,
      revenue: getLatestValue("Revenues") || getLatestValue("RevenueFromContractWithCustomerExcludingAssessedTax") || getLatestValue("SalesRevenueNet"),
      netIncome: getLatestValue("NetIncomeLoss"),
      totalAssets: getLatestValue("Assets"),
      totalLiabilities: getLatestValue("Liabilities"),
      eps: getLatestValue("EarningsPerShareBasic"),
      sharesOutstanding: getLatestValue("CommonStockSharesOutstanding")
    };
    cache.set(cacheKey, fundamentals);
    log.info(
      "SEC-EDGAR",
      `Fetched fundamentals for ${ticker}: revenue=${fundamentals.revenue}, netIncome=${fundamentals.netIncome}`
    );
    return fundamentals;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to fetch facts for ${ticker}: ${error.message}`
    );
    return null;
  }
}
async function getRecentFilings(ticker, formTypes = ["10-K", "10-Q", "8-K"], limit4 = 10) {
  const cik = await getCIKByTicker(ticker);
  if (!cik) return [];
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const filings = [];
    const recent = data.filings?.recent || data;
    const accessionNumbers = recent.accessionNumber || [];
    const forms = recent.form || [];
    const filingDates = recent.filingDate || [];
    const primaryDocuments = recent.primaryDocument || [];
    for (let i = 0; i < Math.min(accessionNumbers.length, 100); i++) {
      const form = forms[i];
      if (!formTypes.includes(form)) continue;
      const accNum = accessionNumbers[i];
      const primaryDoc = primaryDocuments[i] || "index.html";
      filings.push({
        accessionNumber: accNum,
        filingDate: new Date(filingDates[i]),
        form,
        primaryDocument: primaryDoc,
        documentUrl: `https://www.sec.gov/Archives/edgar/data/${parseInt(cik)}/${accNum.replace(/-/g, "")}/${primaryDoc}`
      });
      if (filings.length >= limit4) break;
    }
    log.info("SEC-EDGAR", `Found ${filings.length} filings for ${ticker}`);
    return filings;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to fetch filings for ${ticker}: ${error.message}`
    );
    return [];
  }
}
async function getBulkCompanyFacts(tickers) {
  const results = /* @__PURE__ */ new Map();
  const batchSize = 5;
  for (let i = 0; i < tickers.length; i += batchSize) {
    const batch = tickers.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(async (ticker) => {
        const facts = await getCompanyFacts(ticker);
        return { ticker, facts };
      })
    );
    for (const { ticker, facts } of batchResults) {
      if (facts) {
        results.set(ticker, facts);
      }
    }
    if (i + batchSize < tickers.length) {
      await new Promise((resolve2) => setTimeout(resolve2, 200));
    }
  }
  return results;
}
async function getInsiderTransactions(ticker, limit4 = 20) {
  const cik = await getCIKByTicker(ticker);
  if (!cik) return [];
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const transactions = [];
    const recent = data.filings?.recent || data;
    const accessionNumbers = recent.accessionNumber || [];
    const forms = recent.form || [];
    const filingDates = recent.filingDate || [];
    for (let i = 0; i < Math.min(accessionNumbers.length, 200); i++) {
      const form = forms[i];
      if (form !== "4" && form !== "4/A") continue;
      const accNum = accessionNumbers[i];
      const filingDate = new Date(filingDates[i]);
      try {
        const transaction = await parseForm4Filing(cik, accNum, filingDate);
        if (transaction) {
          transactions.push(...transaction);
        }
      } catch (e) {
      }
      if (transactions.length >= limit4) break;
    }
    log.info(
      "SEC-EDGAR",
      `Found ${transactions.length} insider transactions for ${ticker}`
    );
    return transactions;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to fetch insider transactions for ${ticker}: ${error.message}`
    );
    return [];
  }
}
async function parseForm4Filing(companyCik, accessionNumber, filingDate) {
  const accNumClean = accessionNumber.replace(/-/g, "");
  const url = `https://www.sec.gov/Archives/edgar/data/${parseInt(companyCik)}/${accNumClean}`;
  try {
    const indexResponse = await wrapWithLimiter("sec-edgar", async () => {
      return fetch(`${url}/index.json`, {
        headers: { "User-Agent": SEC_USER_AGENT }
      });
    });
    if (!indexResponse.ok) return [];
    const indexData = await indexResponse.json();
    const xmlFile = indexData.directory?.item?.find(
      (item) => item.name?.endsWith(".xml") && !item.name?.includes("primary_doc")
    );
    if (!xmlFile) return [];
    const xmlResponse = await wrapWithLimiter("sec-edgar", async () => {
      return fetch(`${url}/${xmlFile.name}`, {
        headers: { "User-Agent": SEC_USER_AGENT }
      });
    });
    if (!xmlResponse.ok) return [];
    const xmlText = await xmlResponse.text();
    return parseForm4XML(xmlText, accessionNumber, filingDate, url);
  } catch {
    return [];
  }
}
function parseForm4XML(xml, accessionNumber, filingDate, baseUrl) {
  const transactions = [];
  const ownerMatch = xml.match(/<rptOwnerName>([^<]+)<\/rptOwnerName>/);
  const ownerCikMatch = xml.match(/<rptOwnerCik>([^<]+)<\/rptOwnerCik>/);
  const reportingOwner = ownerMatch?.[1] || "Unknown";
  const ownerCik = ownerCikMatch?.[1] || "";
  let relationship = "";
  if (xml.includes("<isDirector>true</isDirector>") || xml.includes("<isDirector>1</isDirector>"))
    relationship += "Director ";
  if (xml.includes("<isOfficer>true</isOfficer>") || xml.includes("<isOfficer>1</isOfficer>")) {
    const titleMatch = xml.match(/<officerTitle>([^<]+)<\/officerTitle>/);
    relationship += titleMatch?.[1] || "Officer ";
  }
  if (xml.includes("<isTenPercentOwner>true</isTenPercentOwner>") || xml.includes("<isTenPercentOwner>1</isTenPercentOwner>"))
    relationship += "10% Owner ";
  relationship = relationship.trim() || "Other";
  const transactionMatches = xml.matchAll(
    /<nonDerivativeTransaction>[\s\S]*?<\/nonDerivativeTransaction>/g
  );
  for (const match of transactionMatches) {
    const txXml = match[0];
    const dateMatch = txXml.match(
      /<transactionDate>[\s\S]*?<value>([^<]+)<\/value>/
    );
    const codeMatch = txXml.match(
      /<transactionCode>([^<]+)<\/transactionCode>/
    );
    const sharesMatch = txXml.match(
      /<transactionShares>[\s\S]*?<value>([^<]+)<\/value>/
    );
    const priceMatch = txXml.match(
      /<transactionPricePerShare>[\s\S]*?<value>([^<]*)<\/value>/
    );
    const sharesAfterMatch = txXml.match(
      /<sharesOwnedFollowingTransaction>[\s\S]*?<value>([^<]+)<\/value>/
    );
    const ownershipMatch = txXml.match(
      /<directOrIndirectOwnership>[\s\S]*?<value>([^<]+)<\/value>/
    );
    const acquiredDisposedMatch = txXml.match(
      /<transactionAcquiredDisposedCode>[\s\S]*?<value>([^<]+)<\/value>/
    );
    const transactionDate = dateMatch?.[1] ? new Date(dateMatch[1]) : filingDate;
    const transactionCode = codeMatch?.[1] || "";
    const sharesTransacted = parseFloat(sharesMatch?.[1] || "0");
    const pricePerShare = priceMatch?.[1] ? parseFloat(priceMatch[1]) : null;
    const sharesOwnedAfter = parseFloat(sharesAfterMatch?.[1] || "0");
    const isDirectOwnership = ownershipMatch?.[1]?.toUpperCase() === "D";
    const isAcquisition = acquiredDisposedMatch?.[1]?.toUpperCase() === "A";
    let transactionType = "P";
    if (transactionCode === "P")
      transactionType = "P";
    else if (transactionCode === "S")
      transactionType = "S";
    else if (transactionCode === "A")
      transactionType = "A";
    else if (transactionCode === "D")
      transactionType = "D";
    else if (transactionCode === "G")
      transactionType = "G";
    else if (transactionCode === "M")
      transactionType = "M";
    else if (transactionCode === "C")
      transactionType = "C";
    else if (transactionCode === "X")
      transactionType = "X";
    else transactionType = isAcquisition ? "P" : "S";
    const value = pricePerShare && sharesTransacted ? pricePerShare * sharesTransacted : null;
    transactions.push({
      filingDate,
      reportingOwner,
      ownerCik,
      relationship,
      transactionDate,
      transactionType,
      transactionCode,
      sharesTransacted,
      pricePerShare,
      sharesOwnedAfter,
      value,
      isDirectOwnership,
      accessionNumber,
      documentUrl: `${baseUrl}`
    });
  }
  return transactions;
}
async function getInsiderSummary(ticker, days = 90) {
  const cacheKey = `insider-${ticker}-${days}`;
  const cached = insiderCache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  const info = await getCompanyInfo(ticker);
  if (!info) return null;
  try {
    const transactions = await getInsiderTransactions(ticker, 50);
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    const recentTransactions = transactions.filter(
      (t) => t.transactionDate >= cutoffDate
    );
    let totalBuys = 0;
    let totalSells = 0;
    let buyValue = 0;
    let sellValue = 0;
    for (const t of recentTransactions) {
      if (t.transactionType === "P" || t.transactionCode === "P") {
        totalBuys += t.sharesTransacted;
        buyValue += t.value || 0;
      } else if (t.transactionType === "S" || t.transactionCode === "S") {
        totalSells += t.sharesTransacted;
        sellValue += t.value || 0;
      }
    }
    const netActivity = totalBuys - totalSells;
    const netValue = buyValue - sellValue;
    const buyToSellRatio = totalSells > 0 ? totalBuys / totalSells : totalBuys > 0 ? Infinity : 0;
    let sentiment = "neutral";
    if (buyToSellRatio > 1.5 || netValue > 1e5 && totalBuys > totalSells) {
      sentiment = "bullish";
    } else if (buyToSellRatio < 0.5 || netValue < -1e5 && totalSells > totalBuys) {
      sentiment = "bearish";
    }
    const summary = {
      ticker: ticker.toUpperCase(),
      cik,
      companyName: info.name,
      totalInsiderBuys: totalBuys,
      totalInsiderSells: totalSells,
      netInsiderActivity: netActivity,
      netInsiderValue: netValue,
      buyToSellRatio,
      recentTransactions: recentTransactions.slice(0, 10),
      sentiment,
      lastUpdated: /* @__PURE__ */ new Date()
    };
    insiderCache.set(cacheKey, summary);
    log.info(
      "SEC-EDGAR",
      `Insider summary for ${ticker}: ${sentiment} (${recentTransactions.length} transactions)`
    );
    return summary;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to get insider summary for ${ticker}: ${error.message}`
    );
    return null;
  }
}
async function getInstitutionalOwnership(ticker) {
  const cacheKey = `institutional-${ticker}`;
  const cached = institutionalCache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  const info = await getCompanyInfo(ticker);
  if (!info) return null;
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const owners = data.owners || [];
    const ownership = {
      ticker: ticker.toUpperCase(),
      cik,
      companyName: info.name,
      totalInstitutionalShares: 0,
      totalInstitutionalValue: 0,
      numberOfInstitutions: owners.length,
      topHolders: [],
      quarterlyChange: null,
      lastUpdated: /* @__PURE__ */ new Date()
    };
    institutionalCache.set(cacheKey, ownership);
    log.info(
      "SEC-EDGAR",
      `Institutional ownership for ${ticker}: ${owners.length} institutions found`
    );
    return ownership;
  } catch (error) {
    log.error(
      "SEC-EDGAR",
      `Failed to get institutional ownership for ${ticker}: ${error.message}`
    );
    return null;
  }
}
async function getBulkInsiderSummaries(tickers) {
  const results = /* @__PURE__ */ new Map();
  const batchSize = 3;
  for (let i = 0; i < tickers.length; i += batchSize) {
    const batch = tickers.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(async (ticker) => {
        const summary = await getInsiderSummary(ticker);
        return { ticker, summary };
      })
    );
    for (const { ticker, summary } of batchResults) {
      if (summary) {
        results.set(ticker, summary);
      }
    }
    if (i + batchSize < tickers.length) {
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
    }
  }
  log.info(
    "SEC-EDGAR",
    `Fetched insider summaries for ${results.size}/${tickers.length} tickers`
  );
  return results;
}
var SEC_BASE_URL, SEC_USER_AGENT, CompanyFactsSchema, cache, cikCache, insiderCache, institutionalCache, SECEdgarConnector, secEdgarConnector;
var init_sec_edgar = __esm({
  "server/connectors/sec-edgar.ts"() {
    "use strict";
    init_rateLimiter();
    init_api_cache();
    init_logger();
    SEC_BASE_URL = "https://data.sec.gov";
    SEC_USER_AGENT = `AI-Active-Trader/1.0 (support@aiactivetrader.com)`;
    CompanyFactsSchema = z7.object({
      cik: z7.union([z7.number(), z7.string()]).transform((v) => String(v)),
      entityName: z7.string(),
      facts: z7.object({
        "us-gaap": z7.record(z7.any()).optional(),
        dei: z7.record(z7.any()).optional()
      })
    });
    cache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 24 * 60 * 60 * 1e3
    });
    cikCache = /* @__PURE__ */ new Map();
    insiderCache = new ApiCache({
      freshDuration: 60 * 60 * 1e3,
      // 1 hour
      staleDuration: 24 * 60 * 60 * 1e3
      // 24 hours
    });
    institutionalCache = new ApiCache({
      freshDuration: 6 * 60 * 60 * 1e3,
      // 6 hours - 13F filings are quarterly
      staleDuration: 30 * 24 * 60 * 60 * 1e3
      // 30 days
    });
    SECEdgarConnector = class {
      async getCompanyFacts(ticker) {
        return getCompanyFacts(ticker);
      }
      async getRecentFilings(ticker, formTypes, limit4) {
        return getRecentFilings(ticker, formTypes, limit4);
      }
      async getCompanyInfo(ticker) {
        return getCompanyInfo(ticker);
      }
      async getCIKByTicker(ticker) {
        return getCIKByTicker(ticker);
      }
      async getBulkCompanyFacts(tickers) {
        return getBulkCompanyFacts(tickers);
      }
      // Form 4 - Insider Trading
      async getInsiderTransactions(ticker, limit4) {
        return getInsiderTransactions(ticker, limit4);
      }
      async getInsiderSummary(ticker, days) {
        return getInsiderSummary(ticker, days);
      }
      async getBulkInsiderSummaries(tickers) {
        return getBulkInsiderSummaries(tickers);
      }
      // 13F - Institutional Ownership
      async getInstitutionalOwnership(ticker) {
        return getInstitutionalOwnership(ticker);
      }
    };
    secEdgarConnector = new SECEdgarConnector();
  }
});

// server/connectors/fred.ts
var FRED_BASE_URL, FRED_SERIES, CRITICAL_INDICATORS, FREDConnector, fred;
var init_fred = __esm({
  "server/connectors/fred.ts"() {
    "use strict";
    init_connectorClient();
    init_logger();
    FRED_BASE_URL = "https://api.stlouisfed.org/fred";
    FRED_SERIES = {
      DGS10: {
        name: "10-Year Treasury Constant Maturity Rate",
        category: "treasury_yields"
      },
      DGS2: {
        name: "2-Year Treasury Constant Maturity Rate",
        category: "treasury_yields"
      },
      DGS30: {
        name: "30-Year Treasury Constant Maturity Rate",
        category: "treasury_yields"
      },
      T10Y2Y: {
        name: "10-Year Treasury Minus 2-Year Treasury (Yield Curve)",
        category: "treasury_yields"
      },
      T10Y3M: {
        name: "10-Year Treasury Minus 3-Month Treasury",
        category: "treasury_yields"
      },
      CPIAUCSL: {
        name: "Consumer Price Index for All Urban Consumers",
        category: "inflation"
      },
      CPILFESL: { name: "Core CPI (Less Food and Energy)", category: "inflation" },
      PCEPI: {
        name: "Personal Consumption Expenditures Price Index",
        category: "inflation"
      },
      UNRATE: { name: "Unemployment Rate", category: "employment" },
      PAYEMS: { name: "Total Nonfarm Payrolls", category: "employment" },
      ICSA: { name: "Initial Jobless Claims", category: "employment" },
      VIXCLS: { name: "CBOE Volatility Index (VIX)", category: "volatility" },
      FEDFUNDS: {
        name: "Federal Funds Effective Rate",
        category: "interest_rates"
      },
      DFEDTARU: {
        name: "Federal Funds Target Rate - Upper Bound",
        category: "interest_rates"
      },
      M2SL: { name: "M2 Money Stock", category: "money_supply" },
      GDP: { name: "Gross Domestic Product", category: "gdp" },
      GDPC1: { name: "Real Gross Domestic Product", category: "gdp" },
      UMCSENT: {
        name: "University of Michigan Consumer Sentiment",
        category: "consumer"
      },
      HOUST: { name: "Housing Starts", category: "housing" },
      INDPRO: { name: "Industrial Production Index", category: "manufacturing" },
      NAPM: { name: "ISM Manufacturing PMI", category: "manufacturing" }
    };
    CRITICAL_INDICATORS = [
      "DGS10",
      "DGS2",
      "T10Y2Y",
      "VIXCLS",
      "FEDFUNDS",
      "UNRATE",
      "CPIAUCSL",
      "UMCSENT"
    ];
    FREDConnector = class {
      CACHE_TTL_MS = 6 * 60 * 60 * 1e3;
      constructor() {
      }
      getApiKey() {
        const apiKey2 = process.env.FRED_API_KEY;
        if (!apiKey2) {
          log.warn(
            "FRED",
            "No API key configured, using unauthenticated access (limited)"
          );
          return "";
        }
        return apiKey2;
      }
      async getSeriesInfo(seriesId) {
        try {
          const apiKey2 = this.getApiKey();
          const url = `${FRED_BASE_URL}/series?series_id=${seriesId}&api_key=${apiKey2}&file_type=json`;
          const response = await connectorFetch(url, {
            provider: "FRED",
            endpoint: "series",
            cacheKey: buildCacheKey("FRED", "series", seriesId),
            customTTLMs: 24 * 60 * 60 * 1e3
          });
          return response.data.seriess?.[0] || null;
        } catch (error) {
          log.error("FRED", `Failed to get series info for ${seriesId}`, { error });
          return null;
        }
      }
      async getLatestObservations(seriesId, limit4 = 10) {
        try {
          const apiKey2 = this.getApiKey();
          if (!apiKey2) {
            log.warn("FRED", `Skipping ${seriesId}: No API key available`);
            return [];
          }
          const url = `${FRED_BASE_URL}/series/observations?series_id=${seriesId}&api_key=${apiKey2}&file_type=json&sort_order=desc&limit=${limit4}`;
          const response = await connectorFetch(url, {
            provider: "FRED",
            endpoint: "observations",
            cacheKey: buildCacheKey(
              "FRED",
              "observations",
              seriesId,
              limit4.toString()
            ),
            customTTLMs: this.CACHE_TTL_MS
          });
          return response.data.observations || [];
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error(
            "FRED",
            `Failed to get observations for ${seriesId}: ${errorMsg}`
          );
          return [];
        }
      }
      async getIndicatorData(seriesId) {
        const seriesConfig = FRED_SERIES[seriesId];
        if (!seriesConfig) {
          log.warn("FRED", `Unknown series ID: ${seriesId}`);
          return null;
        }
        try {
          const observations = await this.getLatestObservations(seriesId, 5);
          if (observations.length === 0) {
            return null;
          }
          const latestValue = observations[0]?.value === "." ? null : parseFloat(observations[0]?.value || "");
          const previousValue = observations[1]?.value === "." ? null : parseFloat(observations[1]?.value || "");
          let changePercent = null;
          if (latestValue !== null && previousValue !== null && previousValue !== 0) {
            changePercent = (latestValue - previousValue) / Math.abs(previousValue) * 100;
          }
          return {
            indicatorId: seriesId,
            name: seriesConfig.name,
            category: seriesConfig.category,
            latestValue: isNaN(latestValue) ? null : latestValue,
            previousValue: isNaN(previousValue) ? null : previousValue,
            changePercent: changePercent !== null && isNaN(changePercent) ? null : changePercent,
            frequency: "variable",
            lastUpdatedAt: /* @__PURE__ */ new Date(),
            source: "FRED",
            rawJson: {
              realtime_start: "",
              realtime_end: "",
              observation_start: "",
              observation_end: "",
              units: "",
              output_type: 0,
              file_type: "json",
              order_by: "observation_date",
              sort_order: "desc",
              count: observations.length,
              offset: 0,
              limit: 5,
              observations
            }
          };
        } catch (error) {
          log.error("FRED", `Failed to get indicator data for ${seriesId}`, {
            error
          });
          return null;
        }
      }
      async getCriticalIndicators() {
        const results = [];
        for (const seriesId of CRITICAL_INDICATORS) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        log.info(
          "FRED",
          `Fetched ${results.length}/${CRITICAL_INDICATORS.length} critical indicators`
        );
        return results;
      }
      async getAllIndicators() {
        const results = [];
        for (const seriesId of Object.keys(FRED_SERIES)) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        log.info(
          "FRED",
          `Fetched ${results.length}/${Object.keys(FRED_SERIES).length} indicators`
        );
        return results;
      }
      async getIndicatorsByCategory(category) {
        const seriesIds = Object.entries(FRED_SERIES).filter(([_, config2]) => config2.category === category).map(([id]) => id);
        const results = [];
        for (const seriesId of seriesIds) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        return results;
      }
      getYieldCurveSpread() {
        return this.getIndicatorData("T10Y2Y");
      }
      getVIX() {
        return this.getIndicatorData("VIXCLS");
      }
      getFedFundsRate() {
        return this.getIndicatorData("FEDFUNDS");
      }
      getUnemploymentRate() {
        return this.getIndicatorData("UNRATE");
      }
      getCPI() {
        return this.getIndicatorData("CPIAUCSL");
      }
      isConfigured() {
        return !!process.env.FRED_API_KEY;
      }
      getAvailableSeries() {
        return Object.keys(FRED_SERIES);
      }
      getSeriesMetadata(seriesId) {
        return FRED_SERIES[seriesId] || null;
      }
    };
    fred = new FREDConnector();
  }
});

// server/connectors/frankfurter.ts
var FRANKFURTER_BASE_URL, MAJOR_FOREX_PAIRS, FrankfurterConnector, frankfurter;
var init_frankfurter = __esm({
  "server/connectors/frankfurter.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    FRANKFURTER_BASE_URL = "https://api.frankfurter.app";
    MAJOR_FOREX_PAIRS = [
      { base: "EUR", quote: "USD", name: "Euro / US Dollar" },
      { base: "GBP", quote: "USD", name: "British Pound / US Dollar" },
      { base: "USD", quote: "JPY", name: "US Dollar / Japanese Yen" },
      { base: "USD", quote: "CHF", name: "US Dollar / Swiss Franc" },
      { base: "AUD", quote: "USD", name: "Australian Dollar / US Dollar" },
      { base: "USD", quote: "CAD", name: "US Dollar / Canadian Dollar" },
      { base: "NZD", quote: "USD", name: "New Zealand Dollar / US Dollar" },
      { base: "EUR", quote: "GBP", name: "Euro / British Pound" },
      { base: "EUR", quote: "JPY", name: "Euro / Japanese Yen" },
      { base: "GBP", quote: "JPY", name: "British Pound / Japanese Yen" }
    ];
    FrankfurterConnector = class {
      latestRatesCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        // 1 hour - ECB updates once daily
        staleDuration: 24 * 60 * 60 * 1e3
        // 24 hours
      });
      historicalRatesCache = new ApiCache({
        freshDuration: 24 * 60 * 60 * 1e3,
        // Historical data doesn't change
        staleDuration: 7 * 24 * 60 * 60 * 1e3
        // 7 days
      });
      currenciesCache = new ApiCache({
        freshDuration: 24 * 60 * 60 * 1e3,
        // Currencies rarely change
        staleDuration: 30 * 24 * 60 * 60 * 1e3
        // 30 days
      });
      /**
       * Get latest exchange rates
       */
      async getLatestRates(base = "USD", symbols) {
        const cacheKey = `latest_${base}_${symbols?.join(",") || "all"}`;
        const cached = this.latestRatesCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("Frankfurter", `Cache hit for latest rates ${base}`);
          return cached.data;
        }
        try {
          let url = `${FRANKFURTER_BASE_URL}/latest?from=${base.toUpperCase()}`;
          if (symbols && symbols.length > 0) {
            url += `&to=${symbols.map((s) => s.toUpperCase()).join(",")}`;
          }
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(
              `Frankfurter API error: ${response.status} ${response.statusText}`
            );
          }
          const data = await response.json();
          this.latestRatesCache.set(cacheKey, data);
          log.info(
            "Frankfurter",
            `Fetched latest rates for ${base}: ${Object.keys(data.rates).length} currencies`
          );
          return data;
        } catch (error) {
          log.error("Frankfurter", `Failed to fetch latest rates for ${base}`, {
            error: String(error)
          });
          return cached?.data || null;
        }
      }
      /**
       * Get historical exchange rates for a date range
       */
      async getHistoricalRates(base, startDate, endDate, symbols) {
        const cacheKey = `historical_${base}_${startDate}_${endDate}_${symbols?.join(",") || "all"}`;
        const cached = this.historicalRatesCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("Frankfurter", `Cache hit for historical rates ${base}`);
          return cached.data;
        }
        try {
          let url = `${FRANKFURTER_BASE_URL}/${startDate}..${endDate}?from=${base.toUpperCase()}`;
          if (symbols && symbols.length > 0) {
            url += `&to=${symbols.map((s) => s.toUpperCase()).join(",")}`;
          }
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(
              `Frankfurter API error: ${response.status} ${response.statusText}`
            );
          }
          const data = await response.json();
          this.historicalRatesCache.set(cacheKey, data);
          log.info(
            "Frankfurter",
            `Fetched historical rates for ${base} from ${startDate} to ${endDate}`
          );
          return data;
        } catch (error) {
          log.error("Frankfurter", `Failed to fetch historical rates for ${base}`, {
            error: String(error)
          });
          return cached?.data || null;
        }
      }
      /**
       * Get exchange rate for a specific date
       */
      async getRateOnDate(base, quote, date) {
        try {
          const url = `${FRANKFURTER_BASE_URL}/${date}?from=${base.toUpperCase()}&to=${quote.toUpperCase()}`;
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          return data.rates[quote.toUpperCase()] || null;
        } catch (error) {
          log.error(
            "Frankfurter",
            `Failed to fetch rate for ${base}/${quote} on ${date}`,
            { error: String(error) }
          );
          return null;
        }
      }
      /**
       * Get all available currencies
       */
      async getCurrencies() {
        const cacheKey = "currencies";
        const cached = this.currenciesCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        try {
          const response = await fetch(`${FRANKFURTER_BASE_URL}/currencies`, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          const currencies = Object.entries(data).map(
            ([code, name]) => ({
              code,
              name
            })
          );
          this.currenciesCache.set(cacheKey, currencies);
          log.info("Frankfurter", `Fetched ${currencies.length} currencies`);
          return currencies;
        } catch (error) {
          log.error("Frankfurter", "Failed to fetch currencies", {
            error: String(error)
          });
          return cached?.data || [];
        }
      }
      /**
       * Convert amount between currencies
       */
      async convert(amount, from, to, date) {
        try {
          const endpoint = date || "latest";
          const url = `${FRANKFURTER_BASE_URL}/${endpoint}?amount=${amount}&from=${from.toUpperCase()}&to=${to.toUpperCase()}`;
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          const convertedAmount = data.rates[to.toUpperCase()];
          const rate = convertedAmount / amount;
          return {
            amount: convertedAmount,
            rate,
            date: data.date
          };
        } catch (error) {
          log.error("Frankfurter", `Failed to convert ${amount} ${from} to ${to}`, {
            error: String(error)
          });
          return null;
        }
      }
      /**
       * Get forex pair data with trend analysis
       */
      async getForexPairSummary(base, quote) {
        try {
          const latestRates = await this.getLatestRates(base, [quote]);
          if (!latestRates || !latestRates.rates[quote.toUpperCase()]) {
            return null;
          }
          const currentRate = latestRates.rates[quote.toUpperCase()];
          const today = /* @__PURE__ */ new Date();
          const thirtyDaysAgo = new Date(today);
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          const startDate = this.formatDate(thirtyDaysAgo);
          const endDate = this.formatDate(today);
          const historicalRates = await this.getHistoricalRates(
            base,
            startDate,
            endDate,
            [quote]
          );
          if (!historicalRates || !historicalRates.rates) {
            return {
              pair: `${base}/${quote}`,
              currentRate,
              previousRate: currentRate,
              change: 0,
              changePercent: 0,
              high30d: currentRate,
              low30d: currentRate,
              trend: "neutral",
              lastUpdated: /* @__PURE__ */ new Date()
            };
          }
          const rates = Object.values(historicalRates.rates).map((r) => r[quote.toUpperCase()]).filter((r) => r !== void 0);
          if (rates.length === 0) {
            return null;
          }
          const previousRate = rates[rates.length - 1] || currentRate;
          const change = currentRate - previousRate;
          const changePercent = previousRate !== 0 ? change / previousRate * 100 : 0;
          const high30d = Math.max(...rates, currentRate);
          const low30d = Math.min(...rates, currentRate);
          const midpoint = Math.floor(rates.length / 2);
          const recentAvg = rates.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint || currentRate;
          const olderAvg = rates.slice(midpoint).reduce((a, b) => a + b, 0) / (rates.length - midpoint) || currentRate;
          let trend;
          const trendThreshold = 0.01;
          if (recentAvg > olderAvg * (1 + trendThreshold)) {
            trend = "bullish";
          } else if (recentAvg < olderAvg * (1 - trendThreshold)) {
            trend = "bearish";
          } else {
            trend = "neutral";
          }
          return {
            pair: `${base}/${quote}`,
            currentRate,
            previousRate,
            change,
            changePercent,
            high30d,
            low30d,
            trend,
            lastUpdated: /* @__PURE__ */ new Date()
          };
        } catch (error) {
          log.error("Frankfurter", `Failed to get summary for ${base}/${quote}`, {
            error: String(error)
          });
          return null;
        }
      }
      /**
       * Get summaries for all major forex pairs
       */
      async getMajorPairsSummaries() {
        const summaries = [];
        for (const pair of MAJOR_FOREX_PAIRS) {
          const summary = await this.getForexPairSummary(pair.base, pair.quote);
          if (summary) {
            summaries.push(summary);
          }
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
        log.info(
          "Frankfurter",
          `Fetched ${summaries.length} major forex pair summaries`
        );
        return summaries;
      }
      /**
       * Get USD strength index (simplified DXY proxy)
       * Compares USD against a basket of major currencies
       */
      async getUSDStrengthIndex() {
        try {
          const basket = [
            { currency: "EUR", weight: 0.576 },
            { currency: "JPY", weight: 0.136 },
            { currency: "GBP", weight: 0.119 },
            { currency: "CAD", weight: 0.091 },
            { currency: "SEK", weight: 0.042 },
            { currency: "CHF", weight: 0.036 }
          ];
          const rates = await this.getLatestRates(
            "USD",
            basket.map((b) => b.currency)
          );
          if (!rates) return null;
          const today = /* @__PURE__ */ new Date();
          const weekAgo = new Date(today);
          weekAgo.setDate(weekAgo.getDate() - 7);
          const historicalRates = await this.getHistoricalRates(
            "USD",
            this.formatDate(weekAgo),
            this.formatDate(today),
            basket.map((b) => b.currency)
          );
          const components = basket.map((b) => ({
            currency: b.currency,
            weight: b.weight,
            rate: rates.rates[b.currency] || 0,
            contribution: (rates.rates[b.currency] || 0) * b.weight
          }));
          const currentIndex = components.reduce((sum, c) => sum + c.contribution, 0) * 10;
          let trend = "stable";
          if (historicalRates) {
            const historicalDates = Object.keys(historicalRates.rates).sort();
            if (historicalDates.length > 0) {
              const oldestDate = historicalDates[0];
              const oldestRates = historicalRates.rates[oldestDate];
              const oldIndex = basket.reduce(
                (sum, b) => sum + (oldestRates[b.currency] || 0) * b.weight,
                0
              ) * 10;
              const changePercent = (currentIndex - oldIndex) / oldIndex * 100;
              if (changePercent > 0.5) {
                trend = "weakening";
              } else if (changePercent < -0.5) {
                trend = "strengthening";
              }
            }
          }
          return {
            index: currentIndex,
            components,
            trend
          };
        } catch (error) {
          log.error("Frankfurter", "Failed to calculate USD strength index", {
            error: String(error)
          });
          return null;
        }
      }
      formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      /**
       * Clear all caches
       */
      clearCache() {
        this.latestRatesCache.clear();
        this.historicalRatesCache.clear();
        this.currenciesCache.clear();
      }
      /**
       * Check connection status
       */
      getConnectionStatus() {
        const cacheSize = this.latestRatesCache.size() + this.historicalRatesCache.size() + this.currenciesCache.size();
        return {
          connected: true,
          // No API key required
          cacheSize
        };
      }
    };
    frankfurter = new FrankfurterConnector();
  }
});

// server/ai/technical-analysis-fallback.ts
var CACHE_TTL_MS2, analysisCache, ANALYSIS_CACHE_TTL_MS, ANALYSIS_STALE_TTL_MS, TechnicalAnalysisFallback, technicalAnalysisFallback;
var init_technical_analysis_fallback = __esm({
  "server/ai/technical-analysis-fallback.ts"() {
    "use strict";
    init_logger();
    init_money();
    CACHE_TTL_MS2 = 5 * 60 * 1e3;
    analysisCache = /* @__PURE__ */ new Map();
    ANALYSIS_CACHE_TTL_MS = 2 * 60 * 1e3;
    ANALYSIS_STALE_TTL_MS = 10 * 60 * 1e3;
    TechnicalAnalysisFallback = class {
      /**
       * Get cached analysis if available and fresh enough
       */
      getCachedAnalysis(symbol, currentPrice) {
        const cached = analysisCache.get(symbol);
        if (!cached) return null;
        const age = Date.now() - cached.timestamp.getTime();
        const priceChange = Math.abs(currentPrice - cached.marketData.currentPrice) / cached.marketData.currentPrice;
        if (priceChange > 0.02) {
          log.debug(
            "TechFallback",
            `Cache invalid for ${symbol} - price moved ${(priceChange * 100).toFixed(1)}%`
          );
          return null;
        }
        if (age > ANALYSIS_STALE_TTL_MS) {
          analysisCache.delete(symbol);
          return null;
        }
        const isStale = age > ANALYSIS_CACHE_TTL_MS;
        return { decision: cached.decision, isStale };
      }
      /**
       * Cache analysis result
       */
      cacheAnalysis(symbol, decision, marketData) {
        analysisCache.set(symbol, {
          decision,
          timestamp: /* @__PURE__ */ new Date(),
          marketData
        });
      }
      /**
       * Main entry point - analyze opportunity without LLM
       */
      async analyzeWithoutLLM(symbol, marketData, newsContext, priceHistory) {
        const cached = this.getCachedAnalysis(symbol, marketData.currentPrice);
        if (cached && !cached.isStale) {
          log.info("TechFallback", `Using cached analysis for ${symbol}`, {
            confidence: cached.decision.confidence,
            action: cached.decision.action
          });
          return {
            ...cached.decision,
            reasoning: cached.decision.reasoning + " (cached)"
          };
        }
        log.info("TechFallback", `Analyzing ${symbol} without LLM`, {
          price: marketData.currentPrice,
          change: marketData.priceChangePercent24h,
          usingStaleCache: cached?.isStale || false
        });
        try {
          const prices = priceHistory || this.estimatePriceHistory(marketData);
          const indicators = this.calculateIndicators(prices, marketData);
          const regime = this.detectMarketRegime(indicators, marketData);
          const momentumScore = this.scoreMomentum(indicators, marketData);
          const trendScore = this.scoreTrend(indicators, marketData);
          const volatilityScore = this.scoreVolatility(indicators, marketData);
          const sentimentScore = this.scoreSentiment(newsContext);
          const combinedScore = this.combineScores([
            { score: momentumScore, weight: regime.adaptiveWeights.momentum },
            { score: trendScore, weight: regime.adaptiveWeights.trend },
            { score: volatilityScore, weight: regime.adaptiveWeights.volatility },
            { score: sentimentScore, weight: regime.adaptiveWeights.sentiment }
          ]);
          const decision = this.generateDecision(
            combinedScore,
            marketData,
            indicators,
            regime
          );
          this.cacheAnalysis(symbol, decision, marketData);
          log.info("TechFallback", `Analysis complete for ${symbol}`, {
            action: decision.action,
            confidence: decision.confidence,
            combinedSignal: combinedScore.signal,
            regime: regime.type,
            indicatorCount: Object.values(indicators).filter((v) => v !== null).length
          });
          return decision;
        } catch (error) {
          log.error("TechFallback", `Analysis failed for ${symbol}`, {
            error: String(error)
          });
          return this.getSafeDefaultDecision(symbol, marketData);
        }
      }
      /**
       * Estimate price history from available data when full history isn't available
       */
      estimatePriceHistory(marketData) {
        const { currentPrice, high24h, low24h, priceChange24h } = marketData;
        const prices = [];
        const previousPrice = priceChange24h !== void 0 ? currentPrice - priceChange24h : currentPrice;
        const range = (high24h ?? currentPrice * 1.02) - (low24h ?? currentPrice * 0.98);
        const volatility = range / currentPrice;
        for (let i = 0; i < 20; i++) {
          const progress = i / 19;
          const base = previousPrice + (currentPrice - previousPrice) * progress;
          const noise = (Math.random() - 0.5) * volatility * base * 0.5;
          prices.push(base + noise);
        }
        prices[prices.length - 1] = currentPrice;
        return prices;
      }
      /**
       * Calculate technical indicators from price data
       */
      calculateIndicators(prices, marketData) {
        const currentPrice = marketData.currentPrice;
        const high24h = marketData.high24h ?? currentPrice * 1.02;
        const low24h = marketData.low24h ?? currentPrice * 0.98;
        const rsi = this.calculateRSI(prices);
        const sma20 = this.calculateSMA(prices, 20);
        const sma50 = prices.length >= 50 ? this.calculateSMA(prices, 50) : null;
        const sma200 = prices.length >= 200 ? this.calculateSMA(prices, 200) : null;
        const macd = this.calculateMACD(prices);
        const bollinger = this.calculateBollinger(prices);
        const stochastic = this.calculateStochastic(prices, high24h, low24h);
        const williamsR = this.calculateWilliamsR(prices, high24h, low24h);
        const cci = this.calculateCCI(prices, high24h, low24h);
        const adxData = this.calculateADX(prices, high24h, low24h);
        const atr = this.calculateATR(prices, high24h, low24h);
        const rsiDivergence = this.detectRSIDivergence(prices, rsi);
        const macdDivergence = this.detectMACDDivergence(prices, macd.histogram);
        const trendStrength = this.determineTrendStrength(adxData.adx);
        return {
          // Core
          rsi,
          sma20,
          sma50,
          sma200,
          ema12: this.calculateEMA(prices, 12),
          ema26: this.calculateEMA(prices, 26),
          macdLine: macd.line,
          macdSignal: macd.signal,
          macdHistogram: macd.histogram,
          bollingerUpper: bollinger.upper,
          bollingerLower: bollinger.lower,
          bollingerWidth: bollinger.width,
          // Advanced
          stochasticK: stochastic.k,
          stochasticD: stochastic.d,
          williamsR,
          cci,
          adx: adxData.adx,
          plusDI: adxData.plusDI,
          minusDI: adxData.minusDI,
          atr,
          atrPercent: atr !== null ? atr / currentPrice * 100 : null,
          // Derived
          pricePosition: this.determinePricePosition(currentPrice, sma20),
          trendStrength,
          volumeTrend: this.estimateVolumeTrend(marketData),
          volatility: this.estimateVolatility(marketData),
          // Divergences
          rsiDivergence,
          macdDivergence
        };
      }
      /**
       * Calculate Stochastic Oscillator (%K and %D)
       */
      calculateStochastic(prices, high24h, low24h, period = 14) {
        if (prices.length < period) return { k: null, d: null };
        const recentPrices = prices.slice(-period);
        const highestHigh = Math.max(high24h, ...recentPrices);
        const lowestLow = Math.min(low24h, ...recentPrices);
        const currentPrice = prices[prices.length - 1];
        if (highestHigh === lowestLow) return { k: 50, d: 50 };
        const k = (currentPrice - lowestLow) / (highestHigh - lowestLow) * 100;
        const d = k * 0.85 + 7.5;
        return { k, d };
      }
      /**
       * Calculate Williams %R
       */
      calculateWilliamsR(prices, high24h, low24h, period = 14) {
        if (prices.length < period) return null;
        const recentPrices = prices.slice(-period);
        const highestHigh = Math.max(high24h, ...recentPrices);
        const lowestLow = Math.min(low24h, ...recentPrices);
        const currentPrice = prices[prices.length - 1];
        if (highestHigh === lowestLow) return -50;
        return (highestHigh - currentPrice) / (highestHigh - lowestLow) * -100;
      }
      /**
       * Calculate Commodity Channel Index (CCI)
       */
      calculateCCI(prices, high24h, low24h, period = 20) {
        if (prices.length < period) return null;
        const currentPrice = prices[prices.length - 1];
        const typicalPrice = (high24h + low24h + currentPrice) / 3;
        const sma = this.calculateSMA(prices, period);
        if (sma === null) return null;
        const recentPrices = prices.slice(-period);
        const meanDeviation = recentPrices.reduce((sum, p) => sum + Math.abs(p - sma), 0) / period;
        if (meanDeviation === 0) return 0;
        return (typicalPrice - sma) / (0.015 * meanDeviation);
      }
      /**
       * Calculate Average Directional Index (ADX) with +DI and -DI
       */
      calculateADX(prices, high24h, low24h, period = 14) {
        if (prices.length < period + 1)
          return { adx: null, plusDI: null, minusDI: null };
        let plusDM = 0;
        let minusDM = 0;
        let tr = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const currentHigh = Math.max(prices[i], prices[i] * 1.01);
          const currentLow = Math.min(prices[i], prices[i] * 0.99);
          const prevHigh = Math.max(prices[i - 1], prices[i - 1] * 1.01);
          const prevLow = Math.min(prices[i - 1], prices[i - 1] * 0.99);
          const prevClose = prices[i - 1];
          const trueRange = Math.max(
            currentHigh - currentLow,
            Math.abs(currentHigh - prevClose),
            Math.abs(currentLow - prevClose)
          );
          tr += trueRange;
          const upMove = currentHigh - prevHigh;
          const downMove = prevLow - currentLow;
          if (upMove > downMove && upMove > 0) {
            plusDM += upMove;
          }
          if (downMove > upMove && downMove > 0) {
            minusDM += downMove;
          }
        }
        if (tr === 0) return { adx: 0, plusDI: 0, minusDI: 0 };
        const plusDI = plusDM / tr * 100;
        const minusDI = minusDM / tr * 100;
        const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI + 1e-3) * 100;
        const adx = dx * 0.9;
        return { adx, plusDI, minusDI };
      }
      /**
       * Calculate Average True Range (ATR)
       */
      calculateATR(prices, high24h, low24h, period = 14) {
        if (prices.length < period + 1) return null;
        let atrSum = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const currentHigh = prices[i] * 1.005;
          const currentLow = prices[i] * 0.995;
          const prevClose = prices[i - 1];
          const trueRange = Math.max(
            currentHigh - currentLow,
            Math.abs(currentHigh - prevClose),
            Math.abs(currentLow - prevClose)
          );
          atrSum += trueRange;
        }
        return atrSum / period;
      }
      /**
       * Detect RSI divergence (price making new highs/lows but RSI not confirming)
       */
      detectRSIDivergence(prices, currentRSI) {
        if (currentRSI === null || prices.length < 10) return null;
        const recentPrices = prices.slice(-10);
        const midPrice = recentPrices[4];
        const currentPrice = recentPrices[recentPrices.length - 1];
        if (currentPrice < midPrice && currentRSI > 35) {
          return "bullish";
        }
        if (currentPrice > midPrice && currentRSI < 65) {
          return "bearish";
        }
        return null;
      }
      /**
       * Detect MACD divergence
       */
      detectMACDDivergence(prices, macdHistogram) {
        if (macdHistogram === null || prices.length < 10) return null;
        const recentPrices = prices.slice(-10);
        const midPrice = recentPrices[4];
        const currentPrice = recentPrices[recentPrices.length - 1];
        if (currentPrice < midPrice && macdHistogram > 0) {
          return "bullish";
        }
        if (currentPrice > midPrice && macdHistogram < 0) {
          return "bearish";
        }
        return null;
      }
      /**
       * Determine trend strength from ADX value
       */
      determineTrendStrength(adx) {
        if (adx === null) return null;
        if (adx >= 40) return "strong";
        if (adx >= 25) return "moderate";
        if (adx >= 15) return "weak";
        return "none";
      }
      /**
       * Detect market regime for adaptive weighting
       */
      detectMarketRegime(indicators, marketData) {
        const volatility = indicators.volatility;
        const adx = indicators.adx ?? 20;
        const bbWidth = indicators.bollingerWidth ?? 0.04;
        const priceChange = Math.abs(marketData.priceChangePercent24h ?? 0);
        let type = "ranging";
        let strength = 0.5;
        if (volatility === "high" || bbWidth > 0.08) {
          type = "volatile";
          strength = Math.min(bbWidth * 10, 1);
        } else if (adx >= 30) {
          const plusDI = indicators.plusDI ?? 0;
          const minusDI = indicators.minusDI ?? 0;
          type = plusDI > minusDI ? "trending_up" : "trending_down";
          strength = Math.min(adx / 50, 1);
        } else if (priceChange > 4 && adx >= 20) {
          type = "breakout";
          strength = Math.min(priceChange / 10, 1);
        } else {
          type = "ranging";
          strength = 1 - adx / 30;
        }
        const adaptiveWeights = this.getAdaptiveWeights(type, volatility);
        return { type, strength, adaptiveWeights };
      }
      /**
       * Get adaptive weights based on market regime
       */
      getAdaptiveWeights(regime, volatility) {
        const defaults = {
          momentum: 0.35,
          trend: 0.3,
          volatility: 0.15,
          sentiment: 0.2
        };
        switch (regime) {
          case "trending_up":
          case "trending_down":
            return { momentum: 0.4, trend: 0.35, volatility: 0.1, sentiment: 0.15 };
          case "volatile":
            return { momentum: 0.25, trend: 0.25, volatility: 0.3, sentiment: 0.2 };
          case "breakout":
            return { momentum: 0.45, trend: 0.3, volatility: 0.1, sentiment: 0.15 };
          case "ranging":
            return { momentum: 0.3, trend: 0.25, volatility: 0.15, sentiment: 0.3 };
          default:
            return defaults;
        }
      }
      /**
       * Calculate RSI (Relative Strength Index)
       */
      calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        let gains = 0;
        let losses = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const change = prices[i] - prices[i - 1];
          if (change > 0) gains += change;
          else losses -= change;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        if (avgLoss === 0) return 100;
        const rs = avgGain / avgLoss;
        return 100 - 100 / (1 + rs);
      }
      /**
       * Calculate Simple Moving Average
       */
      calculateSMA(prices, period) {
        if (prices.length < period) return null;
        const slice = prices.slice(-period);
        return slice.reduce((a, b) => a + b, 0) / period;
      }
      /**
       * Calculate Exponential Moving Average
       */
      calculateEMA(prices, period) {
        if (prices.length < period) return null;
        const multiplier = 2 / (period + 1);
        let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < prices.length; i++) {
          ema = (prices[i] - ema) * multiplier + ema;
        }
        return ema;
      }
      /**
       * Calculate MACD with proper EMA9 signal line
       */
      calculateMACD(prices) {
        const ema12 = this.calculateEMA(prices, 12);
        const ema26 = this.calculateEMA(prices, 26);
        if (ema12 === null || ema26 === null) {
          return { line: null, signal: null, histogram: null };
        }
        const line = ema12 - ema26;
        if (prices.length >= 35) {
          const macdHistory = [];
          for (let i = 26; i <= prices.length; i++) {
            const slice = prices.slice(0, i);
            const e12 = this.calculateEMA(slice, 12);
            const e26 = this.calculateEMA(slice, 26);
            if (e12 !== null && e26 !== null) {
              macdHistory.push(e12 - e26);
            }
          }
          if (macdHistory.length >= 9) {
            const multiplier = 2 / (9 + 1);
            let ema = macdHistory.slice(0, 9).reduce((a, b) => a + b, 0) / 9;
            for (let i = 9; i < macdHistory.length; i++) {
              ema = (macdHistory[i] - ema) * multiplier + ema;
            }
            const signal2 = ema;
            const histogram2 = line - signal2;
            return { line, signal: signal2, histogram: histogram2 };
          }
        }
        const signal = line * 0.85;
        const histogram = line - signal;
        return { line, signal, histogram };
      }
      /**
       * Calculate Bollinger Bands with width metric
       */
      calculateBollinger(prices, period = 20) {
        const sma = this.calculateSMA(prices, period);
        if (sma === null || prices.length < period) {
          return { upper: null, lower: null, width: null };
        }
        const slice = prices.slice(-period);
        const stdDevValue = stdDev(slice).toNumber();
        const upper = sma + stdDevValue * 2;
        const lower = sma - stdDevValue * 2;
        const width = (upper - lower) / sma;
        return { upper, lower, width };
      }
      /**
       * Determine price position relative to SMA
       */
      determinePricePosition(price, sma) {
        if (sma === null) return null;
        const threshold = sma * 5e-3;
        if (price > sma + threshold) return "above_sma";
        if (price < sma - threshold) return "below_sma";
        return "at_sma";
      }
      /**
       * Estimate volume trend from available data
       */
      estimateVolumeTrend(marketData) {
        const changePercent = marketData.priceChangePercent24h ?? 0;
        if (Math.abs(changePercent) > 3) return "increasing";
        if (Math.abs(changePercent) < 1) return "stable";
        return "stable";
      }
      /**
       * Estimate volatility from price range
       */
      estimateVolatility(marketData) {
        const { currentPrice, high24h, low24h } = marketData;
        if (high24h === void 0 || low24h === void 0) return null;
        const range = (high24h - low24h) / currentPrice;
        if (range > 0.05) return "high";
        if (range > 0.02) return "medium";
        return "low";
      }
      /**
       * Score momentum indicators (enhanced with Stochastic, Williams %R, CCI)
       */
      scoreMomentum(indicators, marketData) {
        const signals = [];
        let bullishPoints = 0;
        let bearishPoints = 0;
        if (indicators.rsi !== null) {
          if (indicators.rsi < 30) {
            bullishPoints += 3;
            signals.push("RSI oversold (<30)");
          } else if (indicators.rsi > 70) {
            bearishPoints += 3;
            signals.push("RSI overbought (>70)");
          } else if (indicators.rsi < 40) {
            bullishPoints += 1;
            signals.push("RSI approaching oversold");
          } else if (indicators.rsi > 60) {
            bearishPoints += 1;
            signals.push("RSI elevated");
          }
        }
        if (indicators.stochasticK !== null && indicators.stochasticD !== null) {
          if (indicators.stochasticK < 20 && indicators.stochasticD < 20) {
            bullishPoints += 2;
            signals.push("Stochastic oversold");
          } else if (indicators.stochasticK > 80 && indicators.stochasticD > 80) {
            bearishPoints += 2;
            signals.push("Stochastic overbought");
          }
          if (indicators.stochasticK > indicators.stochasticD && indicators.stochasticK < 50) {
            bullishPoints += 1;
            signals.push("Stochastic bullish crossover");
          } else if (indicators.stochasticK < indicators.stochasticD && indicators.stochasticK > 50) {
            bearishPoints += 1;
            signals.push("Stochastic bearish crossover");
          }
        }
        if (indicators.williamsR !== null) {
          if (indicators.williamsR > -20) {
            bearishPoints += 1;
            signals.push("Williams %R overbought");
          } else if (indicators.williamsR < -80) {
            bullishPoints += 1;
            signals.push("Williams %R oversold");
          }
        }
        if (indicators.cci !== null) {
          if (indicators.cci > 100) {
            bearishPoints += 1;
            signals.push("CCI overbought (>100)");
          } else if (indicators.cci < -100) {
            bullishPoints += 1;
            signals.push("CCI oversold (<-100)");
          }
        }
        if (indicators.macdHistogram !== null) {
          if (indicators.macdHistogram > 0) {
            bullishPoints += 2;
            signals.push("MACD histogram positive");
          } else {
            bearishPoints += 2;
            signals.push("MACD histogram negative");
          }
          if (indicators.macdLine !== null && indicators.macdSignal !== null) {
            if (indicators.macdLine > indicators.macdSignal && indicators.macdHistogram > 0) {
              bullishPoints += 1;
              signals.push("MACD bullish crossover");
            } else if (indicators.macdLine < indicators.macdSignal && indicators.macdHistogram < 0) {
              bearishPoints += 1;
              signals.push("MACD bearish crossover");
            }
          }
        }
        if (indicators.rsiDivergence === "bullish") {
          bullishPoints += 3;
          signals.push("RSI bullish divergence detected");
        } else if (indicators.rsiDivergence === "bearish") {
          bearishPoints += 3;
          signals.push("RSI bearish divergence detected");
        }
        if (indicators.macdDivergence === "bullish") {
          bullishPoints += 2;
          signals.push("MACD bullish divergence");
        } else if (indicators.macdDivergence === "bearish") {
          bearishPoints += 2;
          signals.push("MACD bearish divergence");
        }
        const changePercent = marketData.priceChangePercent24h ?? 0;
        if (changePercent > 3) {
          bullishPoints += 2;
          signals.push(`Strong bullish momentum (+${changePercent.toFixed(1)}%)`);
        } else if (changePercent > 1) {
          bullishPoints += 1;
          signals.push(`Positive momentum (+${changePercent.toFixed(1)}%)`);
        } else if (changePercent < -3) {
          bearishPoints += 2;
          signals.push(`Strong bearish momentum (${changePercent.toFixed(1)}%)`);
        } else if (changePercent < -1) {
          bearishPoints += 1;
          signals.push(`Negative momentum (${changePercent.toFixed(1)}%)`);
        }
        const totalPoints = bullishPoints + bearishPoints;
        const strength = totalPoints > 0 ? Math.abs(bullishPoints - bearishPoints) / (totalPoints + 3) : 0;
        return {
          signal: bullishPoints > bearishPoints ? "bullish" : bearishPoints > bullishPoints ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: signals
        };
      }
      /**
       * Score trend indicators (enhanced with ADX, SMA200, multi-timeframe)
       */
      scoreTrend(indicators, marketData) {
        const signals = [];
        let bullishPoints = 0;
        let bearishPoints = 0;
        if (indicators.pricePosition === "above_sma") {
          bullishPoints += 2;
          signals.push("Price above SMA20");
        } else if (indicators.pricePosition === "below_sma") {
          bearishPoints += 2;
          signals.push("Price below SMA20");
        }
        if (indicators.sma50 !== null) {
          const price = marketData.currentPrice;
          if (price > indicators.sma50 * 1.02) {
            bullishPoints += 2;
            signals.push("Price above SMA50");
          } else if (price < indicators.sma50 * 0.98) {
            bearishPoints += 2;
            signals.push("Price below SMA50");
          }
        }
        if (indicators.sma200 !== null) {
          const price = marketData.currentPrice;
          if (price > indicators.sma200) {
            bullishPoints += 3;
            signals.push("Price above SMA200 (long-term bullish)");
          } else {
            bearishPoints += 3;
            signals.push("Price below SMA200 (long-term bearish)");
          }
        }
        if (indicators.adx !== null && indicators.plusDI !== null && indicators.minusDI !== null) {
          const trendStrength = indicators.trendStrength;
          if (trendStrength === "strong" || trendStrength === "moderate") {
            if (indicators.plusDI > indicators.minusDI) {
              bullishPoints += trendStrength === "strong" ? 4 : 2;
              signals.push(
                `ADX ${indicators.adx.toFixed(0)} - Strong uptrend (+DI>${-1}DI)`
              );
            } else {
              bearishPoints += trendStrength === "strong" ? 4 : 2;
              signals.push(
                `ADX ${indicators.adx.toFixed(0)} - Strong downtrend (-DI>+DI)`
              );
            }
          } else if (trendStrength === "weak" || trendStrength === "none") {
            signals.push(`ADX ${indicators.adx.toFixed(0)} - Ranging/weak trend`);
          }
        }
        if (indicators.ema12 !== null && indicators.ema26 !== null) {
          if (indicators.ema12 > indicators.ema26) {
            bullishPoints += 2;
            signals.push("EMA12 > EMA26 (bullish alignment)");
          } else {
            bearishPoints += 2;
            signals.push("EMA12 < EMA26 (bearish alignment)");
          }
        }
        if (indicators.bollingerLower !== null && indicators.bollingerUpper !== null) {
          const price = marketData.currentPrice;
          if (price < indicators.bollingerLower) {
            bullishPoints += 2;
            signals.push("Price at lower Bollinger (oversold)");
          } else if (price > indicators.bollingerUpper) {
            bearishPoints += 2;
            signals.push("Price at upper Bollinger (overbought)");
          }
          if (indicators.bollingerWidth !== null && indicators.bollingerWidth < 0.03) {
            signals.push("Bollinger squeeze - potential breakout");
          }
        }
        const totalPoints = bullishPoints + bearishPoints;
        const strength = totalPoints > 0 ? Math.abs(bullishPoints - bearishPoints) / (totalPoints + 4) : 0;
        return {
          signal: bullishPoints > bearishPoints ? "bullish" : bearishPoints > bullishPoints ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: signals
        };
      }
      /**
       * Score volatility conditions (enhanced with ATR analysis)
       */
      scoreVolatility(indicators, marketData) {
        const signals = [];
        let riskAdjustment = 0;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 5) {
            riskAdjustment -= 3;
            signals.push(
              `Very high ATR volatility (${indicators.atrPercent.toFixed(1)}%)`
            );
          } else if (indicators.atrPercent > 3) {
            riskAdjustment -= 2;
            signals.push(
              `High ATR volatility (${indicators.atrPercent.toFixed(1)}%)`
            );
          } else if (indicators.atrPercent > 1.5) {
            riskAdjustment -= 1;
            signals.push(
              `Moderate ATR volatility (${indicators.atrPercent.toFixed(1)}%)`
            );
          } else if (indicators.atrPercent < 1) {
            riskAdjustment += 1;
            signals.push(
              `Low ATR volatility (${indicators.atrPercent.toFixed(1)}%) - stable`
            );
          }
        }
        if (indicators.volatility === "high") {
          riskAdjustment -= 2;
          signals.push("High 24h price range volatility");
        } else if (indicators.volatility === "low") {
          riskAdjustment += 1;
          signals.push("Low 24h range - stable conditions");
        }
        if (indicators.bollingerWidth !== null) {
          if (indicators.bollingerWidth > 0.08) {
            riskAdjustment -= 2;
            signals.push("Wide Bollinger bands - high volatility");
          } else if (indicators.bollingerWidth < 0.02) {
            riskAdjustment += 1;
            signals.push("Tight Bollinger bands - low volatility");
          }
        }
        if (indicators.volumeTrend === "increasing") {
          signals.push("Volume increasing - confirming movement");
        }
        return {
          signal: riskAdjustment > 0 ? "bullish" : riskAdjustment < 0 ? "bearish" : "neutral",
          strength: Math.abs(riskAdjustment) / 5,
          indicators: signals
        };
      }
      /**
       * Score sentiment from news context
       */
      scoreSentiment(newsContext) {
        if (!newsContext) {
          return { signal: "neutral", strength: 0, indicators: ["No news data"] };
        }
        const signals = [];
        let sentimentScore = 0;
        if (newsContext.sentiment === "bullish") {
          sentimentScore = 1;
          signals.push("Bullish news sentiment");
        } else if (newsContext.sentiment === "bearish") {
          sentimentScore = -1;
          signals.push("Bearish news sentiment");
        }
        if (newsContext.headlines && newsContext.headlines.length > 0) {
          signals.push(`${newsContext.headlines.length} recent headlines`);
        }
        return {
          signal: sentimentScore > 0 ? "bullish" : sentimentScore < 0 ? "bearish" : "neutral",
          strength: Math.abs(sentimentScore) * 0.5,
          indicators: signals
        };
      }
      /**
       * Combine multiple signal scores with weights
       */
      combineScores(scores) {
        let weightedBullish = 0;
        let weightedBearish = 0;
        const allIndicators = [];
        for (const { score, weight } of scores) {
          if (score.signal === "bullish") {
            weightedBullish += score.strength * weight;
          } else if (score.signal === "bearish") {
            weightedBearish += score.strength * weight;
          }
          allIndicators.push(...score.indicators);
        }
        const netSignal = weightedBullish - weightedBearish;
        const strength = Math.abs(netSignal);
        return {
          signal: netSignal > 0.1 ? "bullish" : netSignal < -0.1 ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: allIndicators
        };
      }
      /**
       * Generate final decision from combined scores (enhanced with regime and ATR)
       */
      generateDecision(combinedScore, marketData, indicators, regime) {
        const { signal, strength, indicators: usedIndicators } = combinedScore;
        const actionThreshold = regime.type === "volatile" ? 0.35 : regime.type === "trending_up" || regime.type === "trending_down" ? 0.15 : regime.type === "breakout" ? 0.2 : 0.25;
        let action;
        if (signal === "bullish" && strength > actionThreshold) {
          action = "buy";
        } else if (signal === "bearish" && strength > actionThreshold) {
          action = "sell";
        } else {
          action = "hold";
        }
        const confidence = this.calculateDynamicConfidence(
          strength,
          indicators,
          regime,
          usedIndicators.length
        );
        const riskLevel = this.calculateRiskLevel(indicators, regime);
        const reasoning = this.generateReasoning(
          action,
          usedIndicators,
          signal,
          strength,
          regime
        );
        let stopLoss;
        let targetPrice;
        let suggestedQuantity;
        if (action === "buy") {
          const { stop, target } = this.calculateATRBasedTargets(
            marketData,
            indicators,
            riskLevel
          );
          stopLoss = stop;
          targetPrice = target;
          suggestedQuantity = this.calculateDynamicPositionSize(
            confidence,
            riskLevel,
            indicators
          );
        } else if (action === "sell") {
          suggestedQuantity = strength > 0.5 ? 0.5 : strength > 0.3 ? 0.35 : 0.25;
        }
        return {
          action,
          confidence,
          reasoning,
          riskLevel,
          suggestedQuantity,
          targetPrice,
          stopLoss
        };
      }
      /**
       * Calculate dynamic confidence based on multiple factors
       */
      calculateDynamicConfidence(signalStrength, indicators, regime, indicatorCount) {
        let confidence = 0.35 + signalStrength * 0.3;
        const totalPossibleIndicators = 20;
        const coverageRatio = indicatorCount / totalPossibleIndicators;
        confidence += coverageRatio * 0.1;
        if (regime.type === "trending_up" || regime.type === "trending_down") {
          confidence += 0.08;
        } else if (regime.type === "volatile") {
          confidence -= 0.1;
        } else if (regime.type === "breakout") {
          confidence += 0.05;
        }
        if (indicators.adx !== null) {
          if (indicators.adx >= 40) {
            confidence += 0.08;
          } else if (indicators.adx >= 25) {
            confidence += 0.04;
          } else if (indicators.adx < 15) {
            confidence -= 0.05;
          }
        }
        const oscillatorAgreement = this.checkOscillatorAgreement(indicators);
        confidence += oscillatorAgreement * 0.1;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 5) {
            confidence -= 0.1;
          } else if (indicators.atrPercent > 3) {
            confidence -= 0.05;
          }
        }
        return Math.max(0.4, Math.min(confidence, 0.88));
      }
      /**
       * Check if multiple oscillators agree on signal
       */
      checkOscillatorAgreement(indicators) {
        let bullishCount = 0;
        let bearishCount = 0;
        let total = 0;
        if (indicators.rsi !== null) {
          total++;
          if (indicators.rsi < 40) bullishCount++;
          else if (indicators.rsi > 60) bearishCount++;
        }
        if (indicators.stochasticK !== null) {
          total++;
          if (indicators.stochasticK < 30) bullishCount++;
          else if (indicators.stochasticK > 70) bearishCount++;
        }
        if (indicators.williamsR !== null) {
          total++;
          if (indicators.williamsR < -70) bullishCount++;
          else if (indicators.williamsR > -30) bearishCount++;
        }
        if (indicators.cci !== null) {
          total++;
          if (indicators.cci < -50) bullishCount++;
          else if (indicators.cci > 50) bearishCount++;
        }
        if (total === 0) return 0;
        return Math.max(bullishCount, bearishCount) / total;
      }
      /**
       * Calculate risk level from multiple volatility indicators
       */
      calculateRiskLevel(indicators, regime) {
        let riskScore = 0;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 4) riskScore += 3;
          else if (indicators.atrPercent > 2.5) riskScore += 2;
          else if (indicators.atrPercent > 1.5) riskScore += 1;
        }
        if (indicators.volatility === "high") riskScore += 2;
        else if (indicators.volatility === "medium") riskScore += 1;
        if (regime.type === "volatile") riskScore += 2;
        else if (regime.type === "breakout") riskScore += 1;
        else if (regime.type === "ranging") riskScore += 1;
        if (indicators.trendStrength === "strong") riskScore -= 1;
        else if (indicators.trendStrength === "none") riskScore += 1;
        if (riskScore >= 5) return "high";
        if (riskScore >= 2) return "medium";
        return "low";
      }
      /**
       * Calculate ATR-based stop loss and target price
       */
      calculateATRBasedTargets(marketData, indicators, riskLevel) {
        const currentPrice = marketData.currentPrice;
        const atr = indicators.atr;
        if (atr !== null && atr > 0) {
          const atrMultiplier = riskLevel === "high" ? 2.5 : riskLevel === "medium" ? 2 : 1.5;
          const targetMultiplier = riskLevel === "high" ? 3 : riskLevel === "medium" ? 3.5 : 4;
          const stop = currentPrice - atr * atrMultiplier;
          const target = currentPrice + atr * targetMultiplier;
          return { stop, target };
        }
        const stopPercent = riskLevel === "high" ? 0.05 : riskLevel === "medium" ? 0.04 : 0.03;
        const targetPercent = riskLevel === "high" ? 0.06 : riskLevel === "medium" ? 0.07 : 0.08;
        return {
          stop: currentPrice * (1 - stopPercent),
          target: currentPrice * (1 + targetPercent)
        };
      }
      /**
       * Calculate dynamic position size based on confidence and risk
       */
      calculateDynamicPositionSize(confidence, riskLevel, indicators) {
        const baseSize = riskLevel === "low" ? 0.1 : riskLevel === "medium" ? 0.06 : 0.03;
        const confidenceMultiplier = 0.7 + confidence * 0.6;
        let volatilityAdjustment = 1;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 4) volatilityAdjustment = 0.6;
          else if (indicators.atrPercent > 2.5) volatilityAdjustment = 0.8;
          else if (indicators.atrPercent < 1) volatilityAdjustment = 1.2;
        }
        let trendBonus = 1;
        if (indicators.trendStrength === "strong") trendBonus = 1.15;
        else if (indicators.trendStrength === "moderate") trendBonus = 1.05;
        const finalSize = baseSize * confidenceMultiplier * volatilityAdjustment * trendBonus;
        return Math.max(0.02, Math.min(finalSize, 0.15));
      }
      /**
       * Generate human-readable reasoning with regime context
       */
      generateReasoning(action, indicators, signal, strength, regime) {
        const signalStrength = strength > 0.5 ? "strong" : strength > 0.25 ? "moderate" : "weak";
        const topIndicators = indicators.slice(0, 4).join(", ");
        const regimeDesc = this.getRegimeDescription(regime);
        if (action === "buy") {
          return `${signalStrength.charAt(0).toUpperCase() + signalStrength.slice(1)} bullish signal detected. ${regimeDesc}. Key indicators: ${topIndicators}. (Enhanced algorithmic analysis)`;
        } else if (action === "sell") {
          return `${signalStrength.charAt(0).toUpperCase() + signalStrength.slice(1)} bearish signal detected. ${regimeDesc}. Key indicators: ${topIndicators}. (Enhanced algorithmic analysis)`;
        } else {
          return `Mixed signals in ${regime.type} market. ${topIndicators}. Holding position recommended. (Enhanced algorithmic analysis)`;
        }
      }
      /**
       * Get human-readable regime description
       */
      getRegimeDescription(regime) {
        switch (regime.type) {
          case "trending_up":
            return "Market in confirmed uptrend";
          case "trending_down":
            return "Market in confirmed downtrend";
          case "volatile":
            return "High volatility environment";
          case "breakout":
            return "Potential breakout detected";
          case "ranging":
            return "Ranging/consolidation market";
          default:
            return "Market conditions analyzed";
        }
      }
      /**
       * Safe default when everything fails
       */
      getSafeDefaultDecision(symbol, marketData) {
        return {
          action: "hold",
          confidence: 0.4,
          reasoning: `Technical analysis fallback for ${symbol} at $${marketData.currentPrice.toFixed(2)}. Insufficient data for confident signal. Holding for safety.`,
          riskLevel: "medium"
        };
      }
      /**
       * Check if this fallback should be used
       */
      shouldUseFallback(llmError) {
        if (!llmError) return false;
        const errorLower = llmError.toLowerCase();
        return errorLower.includes("401") || // Unauthorized - invalid/not approved API key
        errorLower.includes("402") || // Payment required - out of credits
        errorLower.includes("403") || // Forbidden - access denied
        errorLower.includes("429") || // Rate limit exceeded
        errorLower.includes("rate limit") || errorLower.includes("budget") || errorLower.includes("credits") || errorLower.includes("payment") || errorLower.includes("all providers failed") || errorLower.includes("unavailable") || errorLower.includes("not approved") || errorLower.includes("api key") || errorLower.includes("authentication");
      }
    };
    technicalAnalysisFallback = new TechnicalAnalysisFallback();
  }
});

// server/ai/decision-engine.ts
import pLimit2 from "p-limit";
import pRetry from "p-retry";
async function executeToolCall(name, args) {
  try {
    switch (name) {
      case "get_news_sentiment": {
        const symbol = args.symbol;
        const isCrypto = args.isCrypto;
        if (isCrypto) {
          const sentiment = await gdelt.getCryptoSentiment(symbol);
          return JSON.stringify({
            sentiment: sentiment.sentiment,
            articleCount: sentiment.articleCount,
            averageTone: sentiment.averageTone,
            volumeSpike: sentiment.volumeSpike,
            topHeadlines: sentiment.topHeadlines.slice(0, 3)
          });
        } else {
          const articles = await gdelt.searchArticles(`${symbol} stock`, {
            timespan: "24hours",
            maxRecords: 20
          });
          const tone = await gdelt.getToneTimeline(
            `${symbol} stock`,
            "24hours"
          );
          const sentiment = tone.averageTone > 2 ? "bullish" : tone.averageTone < -2 ? "bearish" : "neutral";
          return JSON.stringify({
            sentiment,
            articleCount: articles.totalResults,
            averageTone: tone.averageTone,
            volumeSpike: false,
            topHeadlines: articles.articles.slice(0, 3).map((a) => a.title)
          });
        }
      }
      case "get_financial_ratios": {
        const ratios = await valyu.getFinancialRatios(args.symbol);
        return JSON.stringify({
          peRatio: ratios.peRatio,
          roe: ratios.roe,
          debtToEquity: ratios.debtToEquity,
          hasData: !!ratios.rawData
        });
      }
      case "get_earnings_data": {
        const earnings = await valyu.getEarnings(args.symbol);
        return JSON.stringify({
          eps: earnings.eps,
          revenue: earnings.revenue,
          hasData: !!earnings.rawData
        });
      }
      case "get_insider_transactions": {
        const insider = await valyu.getInsiderTransactions(
          args.symbol
        );
        const buys = insider.transactions.filter(
          (t) => t.transactionType === "buy"
        );
        const sells = insider.transactions.filter(
          (t) => t.transactionType === "sell"
        );
        return JSON.stringify({
          recentBuys: buys.length,
          recentSells: sells.length,
          netInsiderSentiment: insider.netInsiderSentiment,
          totalBuyValue: insider.totalBuyValue,
          totalSellValue: insider.totalSellValue
        });
      }
      case "get_additional_news": {
        const news = await newsapi.searchNews(
          args.query,
          "relevancy",
          5
        );
        return JSON.stringify({
          articles: news.slice(0, 3).map((a) => ({
            title: a.title,
            source: a.source
          })),
          totalResults: news.length
        });
      }
      case "get_market_quote": {
        const quote = await finnhub.getQuote(args.symbol);
        return JSON.stringify({
          currentPrice: quote.c,
          change: quote.d,
          changePercent: quote.dp,
          high: quote.h,
          low: quote.l,
          open: quote.o,
          previousClose: quote.pc
        });
      }
      // New enhanced data source handlers
      case "get_short_interest": {
        const symbol = args.symbol;
        const summary = await finra.getShortInterestSummary(symbol);
        if (!summary) {
          return JSON.stringify({
            error: `No short interest data available for ${symbol}`
          });
        }
        const analysis = finra.analyzeShortSqueezePotential(summary);
        return JSON.stringify({
          shortRatio: (summary.latestShortRatio * 100).toFixed(1) + "%",
          averageShortRatio: (summary.averageShortRatio * 100).toFixed(1) + "%",
          trend: summary.shortRatioTrend,
          daysToCover: summary.daysTocover?.toFixed(1) || "N/A",
          squeezePotential: analysis.potential,
          squeezeScore: analysis.score,
          factors: analysis.factors,
          dataSource: "FINRA RegSHO"
        });
      }
      case "get_sec_insider_activity": {
        const symbol = args.symbol;
        const summary = await secEdgarConnector.getInsiderSummary(symbol);
        if (!summary) {
          return JSON.stringify({
            error: `No insider data available for ${symbol}`
          });
        }
        return JSON.stringify({
          totalBuys: summary.totalInsiderBuys,
          totalSells: summary.totalInsiderSells,
          netActivity: summary.netInsiderActivity,
          netValue: summary.netInsiderValue,
          buyToSellRatio: summary.buyToSellRatio === Infinity ? "All buys" : summary.buyToSellRatio.toFixed(2),
          sentiment: summary.sentiment,
          recentTransactions: summary.recentTransactions.slice(0, 5).map((t) => ({
            owner: t.reportingOwner,
            type: t.transactionType,
            shares: t.sharesTransacted,
            date: t.transactionDate.toISOString().split("T")[0]
          })),
          dataSource: "SEC EDGAR Form 4"
        });
      }
      case "get_sec_fundamentals": {
        const symbol = args.symbol;
        const facts = await secEdgarConnector.getCompanyFacts(symbol);
        if (!facts) {
          return JSON.stringify({
            error: `No SEC fundamentals available for ${symbol}`
          });
        }
        return JSON.stringify({
          companyName: facts.name,
          revenue: facts.revenue ? `$${(facts.revenue / 1e9).toFixed(2)}B` : "N/A",
          netIncome: facts.netIncome ? `$${(facts.netIncome / 1e9).toFixed(2)}B` : "N/A",
          totalAssets: facts.totalAssets ? `$${(facts.totalAssets / 1e9).toFixed(2)}B` : "N/A",
          eps: facts.eps?.toFixed(2) || "N/A",
          sharesOutstanding: facts.sharesOutstanding ? `${(facts.sharesOutstanding / 1e9).toFixed(2)}B` : "N/A",
          dataSource: "SEC EDGAR XBRL"
        });
      }
      case "get_macro_indicators": {
        const indicators = await fred.getCriticalIndicators();
        const vix = indicators.find((i) => i.indicatorId === "VIXCLS");
        const fedFunds = indicators.find((i) => i.indicatorId === "FEDFUNDS");
        const yieldCurve = indicators.find((i) => i.indicatorId === "T10Y2Y");
        const unemployment = indicators.find((i) => i.indicatorId === "UNRATE");
        const cpi = indicators.find((i) => i.indicatorId === "CPIAUCSL");
        let marketRegime = "neutral";
        if (vix && vix.latestValue !== null) {
          if (vix.latestValue > 30) marketRegime = "risk_off (high fear)";
          else if (vix.latestValue < 15) marketRegime = "risk_on (low fear)";
        }
        return JSON.stringify({
          vix: vix?.latestValue?.toFixed(1) || "N/A",
          fedFundsRate: fedFunds?.latestValue?.toFixed(2) + "%" || "N/A",
          yieldCurve: yieldCurve?.latestValue?.toFixed(2) + "%" || "N/A",
          unemployment: unemployment?.latestValue?.toFixed(1) + "%" || "N/A",
          inflation: cpi?.changePercent?.toFixed(1) + "% (YoY change)" || "N/A",
          marketRegime,
          dataSource: "FRED (Federal Reserve)"
        });
      }
      case "get_forex_rate": {
        const base = args.base;
        const quote = args.quote;
        const summary = await frankfurter.getForexPairSummary(base, quote);
        if (!summary) {
          return JSON.stringify({
            error: `No forex data available for ${base}/${quote}`
          });
        }
        return JSON.stringify({
          pair: summary.pair,
          rate: summary.currentRate.toFixed(4),
          change: summary.change.toFixed(4),
          changePercent: summary.changePercent.toFixed(2) + "%",
          high30d: summary.high30d.toFixed(4),
          low30d: summary.low30d.toFixed(4),
          trend: summary.trend,
          dataSource: "Frankfurter (ECB)"
        });
      }
      case "get_usd_strength": {
        const strength = await frankfurter.getUSDStrengthIndex();
        if (!strength) {
          return JSON.stringify({
            error: "Unable to calculate USD strength index"
          });
        }
        return JSON.stringify({
          index: strength.index.toFixed(2),
          trend: strength.trend,
          components: strength.components.map((c) => ({
            currency: c.currency,
            weight: (c.weight * 100).toFixed(1) + "%",
            rate: c.rate.toFixed(4)
          })),
          dataSource: "Frankfurter (ECB)"
        });
      }
      default:
        return JSON.stringify({ error: `Unknown tool: ${name}` });
    }
  } catch (error) {
    log.warn("AI", `Tool call failed: ${name}`, { error: String(error) });
    return JSON.stringify({
      error: `Failed to fetch data: ${error.message}`
    });
  }
}
function isRateLimitOrQuotaError(error) {
  const errorMsg = error?.message || String(error);
  return errorMsg.includes("401") || // Unauthorized - invalid/not approved API key
  errorMsg.includes("429") || errorMsg.includes("402") || // Payment required - budget exhausted
  errorMsg.includes("403") || errorMsg.includes("RATELIMIT_EXCEEDED") || errorMsg.toLowerCase().includes("quota") || errorMsg.toLowerCase().includes("rate limit") || errorMsg.toLowerCase().includes("spend limit") || errorMsg.toLowerCase().includes("exceeded") || errorMsg.toLowerCase().includes("budget") || errorMsg.toLowerCase().includes("credits") || errorMsg.toLowerCase().includes("payment");
}
var DATA_QUERY_TOOLS, limit2, AIDecisionEngine, aiDecisionEngine;
var init_decision_engine = __esm({
  "server/ai/decision-engine.ts"() {
    "use strict";
    init_logger();
    init_gdelt();
    init_valyu();
    init_finnhub();
    init_newsapi();
    init_finra();
    init_sec_edgar();
    init_fred();
    init_frankfurter();
    init_llmGateway();
    init_technical_analysis_fallback();
    DATA_QUERY_TOOLS = [
      {
        type: "function",
        function: {
          name: "get_news_sentiment",
          description: "Get real-time news sentiment and headlines for a stock or crypto symbol from GDELT (free, updates every 15 min)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker (e.g., AAPL, MSFT) or crypto name (e.g., Bitcoin, Ethereum)"
              },
              isCrypto: {
                type: "boolean",
                description: "Whether this is a cryptocurrency (true) or stock (false)"
              }
            },
            required: ["symbol", "isCrypto"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_financial_ratios",
          description: "Get fundamental financial ratios for a stock (P/E, ROE, debt-to-equity, etc.) from Valyu.ai",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_earnings_data",
          description: "Get recent earnings data (EPS, revenue, surprises) for a stock",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_insider_transactions",
          description: "Get recent insider trading activity (buys/sells by executives)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_additional_news",
          description: "Get additional news headlines from NewsAPI for broader market context",
          parameters: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "Search query for news (e.g., 'Apple earnings', 'tech sector')"
              }
            },
            required: ["query"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_market_quote",
          description: "Get real-time stock quote data from Finnhub",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      // New tools for enhanced data sources
      {
        type: "function",
        function: {
          name: "get_short_interest",
          description: "Get FINRA RegSHO short interest data including short ratio, days to cover, and short squeeze potential",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT, GME)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_sec_insider_activity",
          description: "Get SEC EDGAR Form 4 insider trading activity (executives buying/selling) with sentiment analysis",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_sec_fundamentals",
          description: "Get SEC EDGAR company fundamentals from official filings (revenue, net income, assets, EPS)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_macro_indicators",
          description: "Get FRED macroeconomic indicators including VIX, Fed Funds Rate, yield curve spread, unemployment rate, and inflation (CPI). Returns all critical indicators.",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_forex_rate",
          description: "Get exchange rate between two currencies from Frankfurter (ECB data)",
          parameters: {
            type: "object",
            properties: {
              base: {
                type: "string",
                description: "Base currency code (e.g., USD, EUR, GBP)"
              },
              quote: {
                type: "string",
                description: "Quote currency code (e.g., EUR, JPY, GBP)"
              }
            },
            required: ["base", "quote"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_usd_strength",
          description: "Get USD strength index (DXY proxy) showing dollar strength against major currencies",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      }
    ];
    limit2 = pLimit2(2);
    AIDecisionEngine = class {
      getSystemPrompt() {
        return `You are an expert trading analyst AI assistant for a paper trading application. Your role is to analyze market data and provide trading recommendations.

You MUST respond with a valid JSON object containing these exact fields:
- action: "buy", "sell", or "hold"
- confidence: number between 0 and 1 (e.g., 0.75 for 75% confidence)
- reasoning: a brief explanation of your decision (2-3 sentences)
- riskLevel: "low", "medium", or "high"
- suggestedQuantity: optional number suggesting position size as a percentage of portfolio (0.01-0.25)
- targetPrice: optional number for take-profit target
- stopLoss: optional number for stop-loss level

Consider:
1. Current price action and technical indicators implied by price data
2. Market sentiment from news if available
3. Risk management - never suggest more than 25% of portfolio on any single trade
4. The strategy type and parameters if provided

This is for PAPER TRADING only - educational purposes. Be decisive but conservative.`;
      }
      async analyzeOpportunity(symbol, marketData, newsContext, strategy, options) {
        const systemPrompt = this.getSystemPrompt();
        const userPrompt = this.buildUserPrompt(
          symbol,
          marketData,
          newsContext,
          strategy
        );
        const traceId = options?.traceId || generateTraceId();
        const criticality = options?.criticality || "high";
        return limit2(
          () => pRetry(
            async () => {
              try {
                const response = await callLLM({
                  role: "technical_analyst",
                  criticality,
                  purpose: "analyze_trade_opportunity",
                  traceId,
                  symbol,
                  system: systemPrompt,
                  messages: [{ role: "user", content: userPrompt }],
                  responseFormat: { type: "json_object" },
                  maxTokens: 1024,
                  temperature: 0.3
                });
                const content = response.text;
                if (!content) {
                  log.warn("AI", "Empty response from LLM Gateway", { traceId });
                  return {
                    ...this.getDefaultDecision("AI returned empty response"),
                    traceId
                  };
                }
                const parsed = response.json || JSON.parse(content);
                return { ...this.validateDecision(parsed), traceId };
              } catch (error) {
                const errorMsg = error.message || String(error);
                log.error("AI", "LLM Gateway failed", { traceId, error: errorMsg });
                if (isRateLimitOrQuotaError(error) || technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
                  log.info("AI", "Using technical analysis fallback", {
                    symbol,
                    traceId,
                    reason: errorMsg
                  });
                  const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
                    symbol,
                    marketData,
                    newsContext
                  );
                  return {
                    ...fallbackDecision,
                    traceId,
                    aiDecisionId: `tech-fallback-${Date.now()}`
                  };
                }
                return {
                  ...this.getDefaultDecision(`AI analysis failed: ${errorMsg}`),
                  traceId
                };
              }
            },
            {
              retries: 2,
              minTimeout: 1e3,
              maxTimeout: 5e3,
              factor: 2,
              onFailedAttempt: async (error) => {
                const errorMsg = error.error.message || String(error.error);
                if (error.retriesLeft === 0 && technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
                  log.info(
                    "AI",
                    "Retries exhausted, technical fallback will be used",
                    { symbol, traceId }
                  );
                }
              }
            }
          )
        ).catch(async (error) => {
          const errorMsg = error.message || String(error);
          log.warn(
            "AI",
            "All LLM retries failed, using technical analysis fallback",
            { symbol, traceId, error: errorMsg }
          );
          const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
            symbol,
            marketData,
            newsContext
          );
          return {
            ...fallbackDecision,
            traceId,
            aiDecisionId: `tech-fallback-${Date.now()}`
          };
        });
      }
      async analyzeWithFunctionCalling(symbol, marketData, newsContext, strategy, options) {
        const systemPrompt = `You are an expert trading analyst AI assistant for a paper trading application.

You have access to tools to query real-time market data, news sentiment, financial ratios, earnings, and insider trading activity. Use these tools when you need additional information to make a better trading decision.

After gathering the data you need, provide your final recommendation as a valid JSON object with these fields:
- action: "buy", "sell", or "hold"
- confidence: number between 0 and 1
- reasoning: explanation of your decision including data sources used
- riskLevel: "low", "medium", or "high"
- suggestedQuantity: optional position size (0.01-0.25)
- targetPrice: optional take-profit target
- stopLoss: optional stop-loss level

This is for PAPER TRADING only. Be decisive but conservative.`;
        const userPrompt = this.buildUserPrompt(
          symbol,
          marketData,
          newsContext,
          strategy
        );
        const toolsUsed = [];
        const traceId = options?.traceId || generateTraceId();
        const criticality = options?.criticality || "high";
        try {
          const messages = [{ role: "user", content: userPrompt }];
          let response = await callLLM({
            role: "technical_analyst",
            criticality,
            purpose: "analyze_with_tools",
            traceId,
            symbol,
            system: systemPrompt,
            messages,
            tools: DATA_QUERY_TOOLS,
            toolChoice: "auto",
            maxTokens: 2048,
            temperature: 0.3
          });
          let iterations = 0;
          const maxIterations = 3;
          while (response.toolCalls && response.toolCalls.length > 0 && iterations < maxIterations) {
            for (const toolCall of response.toolCalls) {
              log.debug("AI", `Function call: ${toolCall.name}`, {
                args: toolCall.arguments
              });
              toolsUsed.push(toolCall.name);
              const result = await executeToolCall(
                toolCall.name,
                toolCall.arguments
              );
              messages.push({
                role: "tool",
                content: result,
                tool_call_id: toolCall.id
              });
            }
            response = await callLLM({
              role: "technical_analyst",
              criticality,
              purpose: "analyze_with_tools_continue",
              traceId,
              symbol,
              system: systemPrompt,
              messages,
              tools: DATA_QUERY_TOOLS,
              toolChoice: "auto",
              maxTokens: 2048,
              temperature: 0.3
            });
            iterations++;
          }
          const content = response.text;
          if (!content) {
            log.warn("AI", "Empty response from function-calling analysis", {
              traceId
            });
            return {
              ...this.getDefaultDecision("Empty response"),
              toolsUsed,
              traceId
            };
          }
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            log.warn("AI", "No JSON found in function-calling response", {
              traceId
            });
            return {
              ...this.getDefaultDecision("No JSON in response"),
              toolsUsed,
              traceId
            };
          }
          const parsed = JSON.parse(jsonMatch[0]);
          log.info("AI", `Function-calling analysis complete`, {
            symbol,
            action: parsed.action,
            toolsUsed: toolsUsed.length,
            traceId
          });
          return { ...this.validateDecision(parsed), toolsUsed, traceId };
        } catch (error) {
          const errorMsg = error.message || String(error);
          log.error("AI", "Function-calling analysis failed", {
            error: errorMsg,
            traceId
          });
          if (technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
            log.info(
              "AI",
              "Using technical analysis fallback for function-calling",
              { symbol, traceId }
            );
            const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
              symbol,
              marketData,
              newsContext
            );
            return {
              ...fallbackDecision,
              toolsUsed,
              traceId,
              aiDecisionId: `tech-fallback-fc-${Date.now()}`
            };
          }
          return {
            ...await this.analyzeOpportunity(
              symbol,
              marketData,
              newsContext,
              strategy,
              { traceId, criticality }
            ),
            toolsUsed
          };
        }
      }
      getDefaultDecision(reason) {
        return {
          action: "hold",
          confidence: 0.3,
          reasoning: reason + ". Defaulting to hold for safety.",
          riskLevel: "medium"
        };
      }
      buildUserPrompt(symbol, marketData, newsContext, strategy) {
        let prompt = `Analyze the following trading opportunity and provide a recommendation:

## Asset
Symbol: ${symbol}

## Market Data
- Current Price: $${marketData.currentPrice.toFixed(4)}`;
        if (marketData.priceChange24h !== void 0) {
          prompt += `
- 24h Price Change: $${marketData.priceChange24h.toFixed(4)}`;
        }
        if (marketData.priceChangePercent24h !== void 0) {
          prompt += `
- 24h Change %: ${marketData.priceChangePercent24h.toFixed(2)}%`;
        }
        if (marketData.high24h !== void 0) {
          prompt += `
- 24h High: $${marketData.high24h.toFixed(4)}`;
        }
        if (marketData.low24h !== void 0) {
          prompt += `
- 24h Low: $${marketData.low24h.toFixed(4)}`;
        }
        if (marketData.volume !== void 0) {
          prompt += `
- 24h Volume: $${marketData.volume.toLocaleString()}`;
        }
        if (newsContext) {
          prompt += `

## News Context`;
          if (newsContext.sentiment) {
            prompt += `
- Overall Sentiment: ${newsContext.sentiment}`;
          }
          if (newsContext.headlines && newsContext.headlines.length > 0) {
            prompt += `
- Recent Headlines:
${newsContext.headlines.slice(0, 5).map((h) => `  - ${h}`).join("\n")}`;
          }
          if (newsContext.summary) {
            prompt += `
- Summary: ${newsContext.summary}`;
          }
        }
        if (strategy) {
          prompt += `

## Strategy Context
- Strategy Name: ${strategy.name}
- Strategy Type: ${strategy.type}`;
          if (strategy.parameters) {
            prompt += `
- Parameters: ${JSON.stringify(strategy.parameters)}`;
          }
        }
        prompt += `

Based on this information, what is your trading recommendation? Provide your response as a JSON object.`;
        return prompt;
      }
      validateDecision(decision) {
        const validActions = ["buy", "sell", "hold"];
        const validRiskLevels = ["low", "medium", "high"];
        const action = validActions.includes(
          decision.action
        ) ? decision.action : "hold";
        let confidence = Number(decision.confidence);
        if (isNaN(confidence) || confidence < 0 || confidence > 1) {
          confidence = 0.5;
        }
        const riskLevel = validRiskLevels.includes(
          decision.riskLevel
        ) ? decision.riskLevel : "medium";
        let trailingStopPercent = decision.trailingStopPercent;
        if (trailingStopPercent !== void 0) {
          trailingStopPercent = Number(trailingStopPercent);
          if (isNaN(trailingStopPercent) || trailingStopPercent < 0.5 || trailingStopPercent > 20) {
            trailingStopPercent = void 0;
          }
        }
        return {
          action,
          confidence,
          reasoning: decision.reasoning || "Unable to provide detailed reasoning.",
          riskLevel,
          suggestedQuantity: decision.suggestedQuantity,
          targetPrice: decision.targetPrice,
          stopLoss: decision.stopLoss,
          trailingStopPercent
        };
      }
      async batchAnalyze(opportunities) {
        const results = /* @__PURE__ */ new Map();
        const promises = opportunities.map(async (opp) => {
          try {
            const decision = await this.analyzeOpportunity(
              opp.symbol,
              opp.marketData,
              opp.newsContext,
              opp.strategy
            );
            results.set(opp.symbol, decision);
          } catch (error) {
            log.error("AI", `Failed to analyze ${opp.symbol}`, {
              error: String(error)
            });
            results.set(
              opp.symbol,
              this.getDefaultDecision(`Analysis failed for ${opp.symbol}`)
            );
          }
        });
        await Promise.all(promises);
        return results;
      }
      getStatus() {
        const { llmGateway: llmGateway2 } = (init_llmGateway(), __toCommonJS(llmGateway_exports));
        const availableProviders = llmGateway2.getAvailableProviders();
        return {
          available: availableProviders.length > 0,
          model: "dynamic (gateway-routed)",
          provider: availableProviders.length > 0 ? availableProviders.join(", ") : "none",
          usingGateway: true
        };
      }
    };
    aiDecisionEngine = new AIDecisionEngine();
  }
});

// server/ai/data-fusion-engine.ts
function fuseMarketData(input) {
  const {
    symbol,
    assetType = "unknown",
    marketData = [],
    sentimentData = [],
    fundamentalData = [],
    technicalData = [],
    shortInterestData = [],
    macroData = []
  } = input;
  const warnings = [];
  const now = /* @__PURE__ */ new Date();
  const fusedPrice = fusePriceData(marketData, warnings);
  const fusedSentiment = fuseSentimentData(sentimentData, warnings);
  const fusedFundamentals = fuseFundamentalData(fundamentalData, warnings);
  const fusedTechnicals = fuseTechnicalData(technicalData, warnings);
  const fusedShortInterest = fuseShortInterestData(shortInterestData, warnings);
  const fusedMacro = fuseMacroData(macroData, warnings);
  const trendStrength = calculateTrendStrength(
    fusedPrice,
    fusedSentiment,
    fusedTechnicals
  );
  const volatilityIndicator = calculateVolatilityWithTechnicals(
    marketData,
    technicalData
  );
  const signalAgreement = calculateSignalAgreementWithTechnicals(
    fusedPrice,
    fusedSentiment,
    fusedFundamentals,
    fusedTechnicals
  );
  const dataQuality = assessDataQuality(
    marketData,
    sentimentData,
    fundamentalData,
    now
  );
  log.debug("DataFusion", `Fused data for ${symbol}`, {
    priceSources: fusedPrice.sources.length,
    sentimentSources: fusedSentiment.sources.length,
    fundamentalSources: fusedFundamentals?.sources.length || 0,
    technicalSources: fusedTechnicals?.sources.length || 0,
    shortInterestSources: fusedShortInterest?.sources.length || 0,
    macroSources: fusedMacro?.sources.length || 0,
    signalAgreement: signalAgreement.toFixed(2),
    warnings: warnings.length
  });
  return {
    symbol,
    assetType,
    price: fusedPrice,
    sentiment: fusedSentiment,
    fundamentals: fusedFundamentals,
    technicals: fusedTechnicals,
    shortInterest: fusedShortInterest,
    macro: fusedMacro,
    trendStrength,
    volatilityIndicator,
    signalAgreement,
    dataQuality,
    warnings,
    timestamp: now
  };
}
function fusePriceData(data, warnings) {
  if (data.length === 0) {
    warnings.push("No price data available");
    return {
      current: 0,
      change: 0,
      changePercent: 0,
      confidence: 0,
      sources: []
    };
  }
  data.sort(
    (a, b) => (SOURCE_RELIABILITY[a.source] || 0.5) - (SOURCE_RELIABILITY[b.source] || 0.5)
  );
  data.reverse();
  let totalWeight = 0;
  let weightedPrice = 0;
  let weightedChange = 0;
  let weightedChangePercent = 0;
  const sources = [];
  for (const point of data) {
    if (point.price === void 0) continue;
    const weight = point.reliability * (SOURCE_RELIABILITY[point.source] || 0.5);
    weightedPrice += toDecimal(point.price).times(weight).toNumber();
    weightedChange += (point.priceChange || 0) * weight;
    weightedChangePercent += (point.priceChangePercent || 0) * weight;
    totalWeight += weight;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  if (totalWeight === 0) {
    warnings.push("No valid price data after filtering");
    return {
      current: 0,
      change: 0,
      changePercent: 0,
      confidence: 0,
      sources: []
    };
  }
  const prices = data.filter((d) => d.price !== void 0).map((d) => d.price);
  const avgPrice = mean(prices).toNumber();
  const priceVarianceValue = variance(prices).toNumber();
  const priceStdDev = stdDev(prices).toNumber();
  const priceConsistency = avgPrice > 0 ? Math.max(0, 1 - priceStdDev / avgPrice) : 0;
  if (priceConsistency < 0.95) {
    warnings.push(
      `Price sources show ${((1 - priceConsistency) * 100).toFixed(1)}% variance`
    );
  }
  return {
    current: weightedPrice / totalWeight,
    change: weightedChange / totalWeight,
    changePercent: weightedChangePercent / totalWeight,
    confidence: Math.min(1, totalWeight / data.length * priceConsistency),
    sources
  };
}
function fuseSentimentData(data, warnings) {
  if (data.length === 0) {
    return {
      overall: "neutral",
      score: 0,
      confidence: 0,
      agreementLevel: 0,
      sources: []
    };
  }
  let totalWeight = 0;
  let weightedScore = 0;
  const sources = [];
  let positiveCount = 0;
  let negativeCount = 0;
  let neutralCount = 0;
  for (const point of data) {
    const weight = point.confidence * (SOURCE_RELIABILITY[point.source] || 0.5);
    let normalizedScore = point.score;
    if (point.sentiment === "positive") {
      normalizedScore = Math.abs(normalizedScore);
      positiveCount++;
    } else if (point.sentiment === "negative") {
      normalizedScore = -Math.abs(normalizedScore);
      negativeCount++;
    } else {
      neutralCount++;
    }
    weightedScore += normalizedScore * weight;
    totalWeight += weight;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const avgScore = totalWeight > 0 ? weightedScore / totalWeight : 0;
  let overall = "neutral";
  if (avgScore > 0.15) overall = "bullish";
  else if (avgScore < -0.15) overall = "bearish";
  const totalSentiments = positiveCount + negativeCount + neutralCount;
  const maxCount = Math.max(positiveCount, negativeCount, neutralCount);
  const agreementLevel = totalSentiments > 0 ? maxCount / totalSentiments : 0;
  if (agreementLevel < 0.6 && data.length > 1) {
    warnings.push("Sentiment sources show conflicting signals");
  }
  return {
    overall,
    score: avgScore,
    confidence: Math.min(1, totalWeight / data.length),
    agreementLevel,
    sources
  };
}
function fuseFundamentalData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let eps;
  let peRatio;
  let pbRatio;
  let roe;
  let roa;
  let revenueGrowth;
  let freeCashFlow;
  let dividendYield;
  let debtToEquity;
  let currentRatio;
  let grossMargin;
  let netProfitMargin;
  let beta;
  let epsGrowth;
  let weekHigh52;
  let weekLow52;
  let insiderSentiment;
  let insiderBullishCount = 0;
  let insiderBearishCount = 0;
  for (const point of data) {
    if (point.eps !== void 0 && eps === void 0) eps = point.eps;
    if (point.peRatio !== void 0 && peRatio === void 0)
      peRatio = point.peRatio;
    if (point.pbRatio !== void 0 && pbRatio === void 0)
      pbRatio = point.pbRatio;
    if (point.roe !== void 0 && roe === void 0) roe = point.roe;
    if (point.roa !== void 0 && roa === void 0) roa = point.roa;
    if (point.revenueGrowth !== void 0 && revenueGrowth === void 0)
      revenueGrowth = point.revenueGrowth;
    if (point.freeCashFlow !== void 0 && freeCashFlow === void 0)
      freeCashFlow = point.freeCashFlow;
    if (point.dividendYield !== void 0 && dividendYield === void 0)
      dividendYield = point.dividendYield;
    if (point.debtToEquity !== void 0 && debtToEquity === void 0)
      debtToEquity = point.debtToEquity;
    if (point.currentRatio !== void 0 && currentRatio === void 0)
      currentRatio = point.currentRatio;
    if (point.grossMargin !== void 0 && grossMargin === void 0)
      grossMargin = point.grossMargin;
    if (point.netProfitMargin !== void 0 && netProfitMargin === void 0)
      netProfitMargin = point.netProfitMargin;
    if (point.beta !== void 0 && beta === void 0) beta = point.beta;
    if (point.epsGrowth !== void 0 && epsGrowth === void 0)
      epsGrowth = point.epsGrowth;
    if (point.weekHigh52 !== void 0 && weekHigh52 === void 0)
      weekHigh52 = point.weekHigh52;
    if (point.weekLow52 !== void 0 && weekLow52 === void 0)
      weekLow52 = point.weekLow52;
    if (point.insiderSentiment) {
      if (point.insiderSentiment === "bullish") insiderBullishCount++;
      else if (point.insiderSentiment === "bearish") insiderBearishCount++;
    }
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  if (insiderBullishCount > insiderBearishCount) {
    insiderSentiment = "bullish";
  } else if (insiderBearishCount > insiderBullishCount) {
    insiderSentiment = "bearish";
  } else if (insiderBullishCount > 0 || insiderBearishCount > 0) {
    insiderSentiment = "neutral";
  }
  const coreFields = [eps, peRatio, revenueGrowth].filter(
    (f) => f !== void 0
  ).length;
  const valuationFields = [pbRatio, roe, roa].filter(
    (f) => f !== void 0
  ).length;
  const marginFields = [grossMargin, netProfitMargin].filter(
    (f) => f !== void 0
  ).length;
  const rangeFields = [weekHigh52, weekLow52].filter(
    (f) => f !== void 0
  ).length;
  const extendedFields = [
    freeCashFlow,
    dividendYield,
    debtToEquity,
    currentRatio,
    beta,
    epsGrowth,
    insiderSentiment
  ].filter((f) => f !== void 0).length;
  const totalFields = coreFields + valuationFields + marginFields + rangeFields + extendedFields;
  const maxFields = 17;
  const confidence = Math.min(1, totalFields / maxFields);
  if (insiderSentiment === "bearish" && coreFields > 0) {
    warnings.push(
      "Insider activity shows bearish sentiment - insiders selling"
    );
  }
  return {
    eps,
    peRatio,
    pbRatio,
    roe,
    roa,
    revenueGrowth,
    freeCashFlow,
    dividendYield,
    debtToEquity,
    currentRatio,
    grossMargin,
    netProfitMargin,
    beta,
    epsGrowth,
    weekHigh52,
    weekLow52,
    insiderSentiment,
    confidence,
    sources
  };
}
function fuseTechnicalData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let totalBuyCount = 0;
  let totalSellCount = 0;
  let totalNeutralCount = 0;
  let adxSum = 0;
  let adxCount = 0;
  let trendingCount = 0;
  let supportSum = 0;
  let supportCount = 0;
  let resistanceSum = 0;
  let resistanceCount = 0;
  let volatilitySum = 0;
  let volatilityCount = 0;
  let bullishTrendCount = 0;
  let bearishTrendCount = 0;
  for (const point of data) {
    if (point.buyCount !== void 0) totalBuyCount += point.buyCount;
    if (point.sellCount !== void 0) totalSellCount += point.sellCount;
    if (point.neutralCount !== void 0)
      totalNeutralCount += point.neutralCount;
    if (point.adx !== void 0) {
      adxSum += point.adx;
      adxCount++;
    }
    if (point.isTrending) trendingCount++;
    if (point.support !== void 0) {
      supportSum += point.support;
      supportCount++;
    }
    if (point.resistance !== void 0) {
      resistanceSum += point.resistance;
      resistanceCount++;
    }
    if (point.volatility !== void 0) {
      volatilitySum += point.volatility;
      volatilityCount++;
    }
    if (point.trend === "bullish") bullishTrendCount++;
    else if (point.trend === "bearish") bearishTrendCount++;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const overallSignal = totalBuyCount > totalSellCount + totalNeutralCount ? "buy" : totalSellCount > totalBuyCount + totalNeutralCount ? "sell" : "neutral";
  const trend = bullishTrendCount > bearishTrendCount ? "bullish" : bearishTrendCount > bullishTrendCount ? "bearish" : "neutral";
  const totalIndicators = totalBuyCount + totalSellCount + totalNeutralCount;
  const confidence = totalIndicators > 0 ? Math.max(totalBuyCount, totalSellCount) / totalIndicators : 0;
  if (overallSignal === "sell" && totalSellCount > totalBuyCount * 2) {
    warnings.push("Strong sell signals from technical indicators");
  }
  return {
    signal: overallSignal,
    buyCount: totalBuyCount,
    sellCount: totalSellCount,
    neutralCount: totalNeutralCount,
    adx: adxCount > 0 ? adxSum / adxCount : void 0,
    isTrending: trendingCount > data.length / 2,
    support: supportCount > 0 ? supportSum / supportCount : void 0,
    resistance: resistanceCount > 0 ? resistanceSum / resistanceCount : void 0,
    volatility: volatilityCount > 0 ? volatilitySum / volatilityCount : void 0,
    trend,
    confidence,
    sources
  };
}
function fuseShortInterestData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let totalWeight = 0;
  let weightedShortRatio = 0;
  let daysToCoverSum = 0;
  let daysToCoverCount = 0;
  let increasingCount = 0;
  let decreasingCount = 0;
  let highSqueezeCount = 0;
  let mediumSqueezeCount = 0;
  for (const point of data) {
    const weight = SOURCE_RELIABILITY[point.source] || 0.5;
    weightedShortRatio += point.shortRatio * weight;
    totalWeight += weight;
    if (point.daysToCover !== void 0) {
      daysToCoverSum += point.daysToCover;
      daysToCoverCount++;
    }
    if (point.shortRatioTrend === "increasing") increasingCount++;
    else if (point.shortRatioTrend === "decreasing") decreasingCount++;
    if (point.shortSqueezePotential === "high") highSqueezeCount++;
    else if (point.shortSqueezePotential === "medium") mediumSqueezeCount++;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const avgShortRatio = totalWeight > 0 ? weightedShortRatio / totalWeight : 0;
  const avgDaysToCover = daysToCoverCount > 0 ? daysToCoverSum / daysToCoverCount : void 0;
  const trend = increasingCount > decreasingCount ? "increasing" : decreasingCount > increasingCount ? "decreasing" : "stable";
  const squeezePotential = highSqueezeCount > 0 ? "high" : mediumSqueezeCount > 0 ? "medium" : "low";
  if (avgShortRatio > 0.4) {
    warnings.push(
      `High short interest: ${(avgShortRatio * 100).toFixed(1)}% of volume is short selling`
    );
  }
  if (squeezePotential === "high" && trend === "increasing") {
    warnings.push("Potential short squeeze setup detected");
  }
  return {
    shortRatio: avgShortRatio,
    daysToCover: avgDaysToCover,
    trend,
    squeezePotential,
    confidence: Math.min(1, totalWeight / data.length),
    sources
  };
}
function fuseMacroData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let vix;
  let fedFundsRate;
  let yieldCurve;
  let inflation;
  let unemployment;
  for (const point of data) {
    const indicator = point.indicator.toUpperCase();
    if (indicator.includes("VIX") && vix === void 0) {
      vix = point.value;
    } else if ((indicator.includes("FEDFUNDS") || indicator.includes("FED_FUNDS")) && fedFundsRate === void 0) {
      fedFundsRate = point.value;
    } else if ((indicator.includes("T10Y2Y") || indicator.includes("YIELD_CURVE")) && yieldCurve === void 0) {
      yieldCurve = point.value;
    } else if ((indicator.includes("CPI") || indicator.includes("INFLATION")) && inflation === void 0) {
      inflation = point.value;
    } else if ((indicator.includes("UNRATE") || indicator.includes("UNEMPLOYMENT")) && unemployment === void 0) {
      unemployment = point.value;
    }
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  let marketRegime = "neutral";
  if (vix !== void 0) {
    if (vix > 30) {
      marketRegime = "risk_off";
      warnings.push(
        `Elevated VIX (${vix.toFixed(1)}) indicates high market fear`
      );
    } else if (vix < 15) {
      marketRegime = "risk_on";
    }
  }
  if (yieldCurve !== void 0 && yieldCurve < 0) {
    if (marketRegime === "risk_on") {
      marketRegime = "neutral";
    } else {
      marketRegime = "risk_off";
    }
    warnings.push("Inverted yield curve detected - recession warning signal");
  }
  const fieldsPresent = [
    vix,
    fedFundsRate,
    yieldCurve,
    inflation,
    unemployment
  ].filter((f) => f !== void 0).length;
  const confidence = Math.min(1, fieldsPresent / 5);
  return {
    vix,
    fedFundsRate,
    yieldCurve,
    inflation,
    unemployment,
    marketRegime,
    confidence,
    sources
  };
}
function calculateTrendStrength(price, sentiment, technicals) {
  if (price.confidence === 0) return 0;
  const priceDirection = price.changePercent > 0 ? 1 : price.changePercent < 0 ? -1 : 0;
  const sentimentDirection = sentiment.score > 0 ? 1 : sentiment.score < 0 ? -1 : 0;
  const technicalDirection = technicals ? technicals.signal === "buy" ? 1 : technicals.signal === "sell" ? -1 : 0 : 0;
  const priceStrength = Math.min(1, Math.abs(price.changePercent) / 5);
  const sentimentStrength = Math.abs(sentiment.score);
  const technicalStrength = technicals?.confidence || 0;
  const directions = [priceDirection, sentimentDirection];
  const strengths = [
    priceStrength * price.confidence,
    sentimentStrength * sentiment.confidence
  ];
  if (technicals && technicals.confidence > 0) {
    directions.push(technicalDirection);
    strengths.push(technicalStrength);
  }
  const totalStrength = strengths.reduce((a, b) => a + b, 0);
  const avgDirection = directions.reduce((a, b) => a + b, 0) / directions.length;
  if (Math.abs(avgDirection) > 0.5) {
    return totalStrength / strengths.length * Math.sign(avgDirection);
  }
  if (priceDirection === sentimentDirection && priceDirection !== 0) {
    return (priceStrength + sentimentStrength) / 2 * price.confidence * sentiment.confidence;
  }
  if (priceDirection !== sentimentDirection && priceDirection !== 0 && sentimentDirection !== 0) {
    return -Math.abs(priceStrength - sentimentStrength) / 2;
  }
  return priceStrength * price.confidence;
}
function calculateVolatility(data) {
  if (data.length === 0) return 0;
  const withRange = data.filter(
    (d) => d.high !== void 0 && d.low !== void 0 && d.price
  );
  if (withRange.length === 0) return 0;
  let totalVolatility = 0;
  for (const point of withRange) {
    const range = (point.high - point.low) / point.price;
    totalVolatility += range;
  }
  return Math.min(1, totalVolatility / withRange.length);
}
function calculateVolatilityWithTechnicals(marketData, technicalData) {
  const baseVolatility = calculateVolatility(marketData);
  if (technicalData.length === 0) return baseVolatility;
  const technicalVolatilities = technicalData.filter((t) => t.volatility !== void 0).map((t) => t.volatility);
  if (technicalVolatilities.length === 0) return baseVolatility;
  const avgTechnicalVolatility = technicalVolatilities.reduce((a, b) => a + b, 0) / technicalVolatilities.length;
  const normalizedTechnicalVolatility = Math.min(
    1,
    avgTechnicalVolatility / 100
  );
  return baseVolatility * 0.6 + normalizedTechnicalVolatility * 0.4;
}
function calculateSignalAgreementWithTechnicals(price, sentiment, fundamentals, technicals) {
  const signals = [];
  if (price.confidence > 0) {
    signals.push(
      price.changePercent > 0 ? 1 : price.changePercent < 0 ? -1 : 0
    );
  }
  if (sentiment.confidence > 0) {
    signals.push(sentiment.score > 0.1 ? 1 : sentiment.score < -0.1 ? -1 : 0);
  }
  if (fundamentals && fundamentals.confidence > 0) {
    let fundamentalSignal = 0;
    if (fundamentals.revenueGrowth !== void 0) {
      fundamentalSignal = fundamentals.revenueGrowth > 0 ? 1 : -1;
    }
    if (fundamentalSignal !== 0) signals.push(fundamentalSignal);
  }
  if (technicals && technicals.confidence > 0) {
    const technicalSignal = technicals.signal === "buy" ? 1 : technicals.signal === "sell" ? -1 : 0;
    if (technicalSignal !== 0) signals.push(technicalSignal);
  }
  if (signals.length <= 1) return 1;
  const sum = signals.reduce((a, b) => a + b, 0);
  const agreement = Math.abs(sum) / signals.length;
  return agreement;
}
function assessDataQuality(marketData, sentimentData, fundamentalData, now) {
  const hasMarket = marketData.length > 0;
  const hasSentiment = sentimentData.length > 0;
  const hasFundamentals = fundamentalData.length > 0;
  const completeness = (Number(hasMarket) + Number(hasSentiment) + Number(hasFundamentals)) / 3;
  const allTimestamps = [
    ...marketData.map((d) => d.timestamp),
    ...sentimentData.map((d) => d.timestamp),
    ...fundamentalData.map((d) => d.timestamp)
  ];
  let freshness = 0;
  if (allTimestamps.length > 0) {
    const avgAge = allTimestamps.reduce(
      (sum, ts) => sum + (now.getTime() - ts.getTime()),
      0
    ) / allTimestamps.length;
    const maxFreshAge = 60 * 60 * 1e3;
    freshness = Math.max(0, 1 - avgAge / maxFreshAge);
  }
  const avgReliability = [
    ...marketData.map((d) => SOURCE_RELIABILITY[d.source] || 0.5),
    ...sentimentData.map((d) => SOURCE_RELIABILITY[d.source] || 0.5)
  ];
  const reliability = avgReliability.length > 0 ? avgReliability.reduce((a, b) => a + b, 0) / avgReliability.length : 0;
  return {
    completeness,
    freshness,
    reliability
  };
}
var SOURCE_RELIABILITY;
var init_data_fusion_engine = __esm({
  "server/ai/data-fusion-engine.ts"() {
    "use strict";
    init_logger();
    init_money();
    SOURCE_RELIABILITY = {
      // Primary market data sources
      alpaca: 0.95,
      finnhub: 0.9,
      coingecko: 0.85,
      coinmarketcap: 0.85,
      twelvedata: 0.85,
      // Fundamental data sources
      valyu: 0.9,
      "sec-edgar": 0.95,
      // Official SEC filings - highest reliability
      secedgar: 0.95,
      // Short interest data
      finra: 0.9,
      // Official FINRA RegSHO data
      // Forex data
      frankfurter: 0.9,
      // ECB-backed exchange rates
      // Sentiment sources
      newsapi: 0.75,
      huggingface: 0.8,
      finbert: 0.8,
      gdelt: 0.8,
      // Macro data
      fred: 0.95
      // Federal Reserve Economic Data
    };
  }
});

// server/ai/enhanced-decision-log.ts
function createInputSnapshot(marketData, newsContext, strategy, fusedIntelligence) {
  const snapshot = {
    marketData: {
      symbol: marketData.symbol,
      price: marketData.currentPrice,
      change24h: marketData.priceChange24h,
      changePercent24h: marketData.priceChangePercent24h,
      volume: marketData.volume,
      high24h: marketData.high24h,
      low24h: marketData.low24h
    }
  };
  if (newsContext) {
    snapshot.sentiment = {
      overall: newsContext.sentiment || "neutral",
      score: 0,
      confidence: 0.5,
      sources: ["newsapi"],
      headlines: newsContext.headlines?.slice(0, 5)
    };
  }
  if (fusedIntelligence) {
    snapshot.sentiment = {
      overall: fusedIntelligence.sentiment.overall,
      score: fusedIntelligence.sentiment.score,
      confidence: fusedIntelligence.sentiment.confidence,
      sources: fusedIntelligence.sentiment.sources
    };
    if (fusedIntelligence.fundamentals) {
      snapshot.fundamentals = {
        eps: fusedIntelligence.fundamentals.eps,
        peRatio: fusedIntelligence.fundamentals.peRatio,
        revenueGrowth: fusedIntelligence.fundamentals.revenueGrowth,
        sources: fusedIntelligence.fundamentals.sources
      };
    }
    snapshot.fusedIntelligence = {
      trendStrength: fusedIntelligence.trendStrength,
      signalAgreement: fusedIntelligence.signalAgreement,
      dataQuality: fusedIntelligence.dataQuality,
      warnings: fusedIntelligence.warnings
    };
  }
  if (strategy) {
    snapshot.strategyContext = {
      id: strategy.id,
      name: strategy.name,
      type: strategy.type,
      parameters: strategy.parameters
    };
  }
  return snapshot;
}
function generateReasoningSteps(input, decision) {
  const steps = [];
  let stepNum = 1;
  steps.push({
    step: stepNum++,
    category: "market_analysis",
    observation: `Current price: $${input.marketData.price.toFixed(2)}, 24h change: ${(input.marketData.changePercent24h || 0).toFixed(2)}%`,
    implication: input.marketData.changePercent24h && input.marketData.changePercent24h > 0 ? "Positive short-term momentum" : input.marketData.changePercent24h && input.marketData.changePercent24h < 0 ? "Negative short-term momentum" : "Neutral price action",
    weight: 0.3
  });
  if (input.sentiment) {
    steps.push({
      step: stepNum++,
      category: "sentiment_analysis",
      observation: `Sentiment: ${input.sentiment.overall} (score: ${input.sentiment.score.toFixed(2)}, confidence: ${(input.sentiment.confidence * 100).toFixed(0)}%)`,
      implication: input.sentiment.overall === "bullish" ? "Market sentiment supports buying" : input.sentiment.overall === "bearish" ? "Market sentiment suggests caution" : "Neutral sentiment, no strong directional bias",
      weight: 0.25
    });
  }
  if (input.fundamentals) {
    const fundObs = [];
    if (input.fundamentals.peRatio !== void 0) {
      fundObs.push(`P/E: ${input.fundamentals.peRatio.toFixed(1)}`);
    }
    if (input.fundamentals.revenueGrowth !== void 0) {
      fundObs.push(
        `Revenue growth: ${(input.fundamentals.revenueGrowth * 100).toFixed(1)}%`
      );
    }
    if (fundObs.length > 0) {
      steps.push({
        step: stepNum++,
        category: "fundamental_analysis",
        observation: fundObs.join(", "),
        implication: input.fundamentals.revenueGrowth && input.fundamentals.revenueGrowth > 0 ? "Fundamentals indicate growth" : "Fundamentals suggest caution",
        weight: 0.2
      });
    }
  }
  if (input.fusedIntelligence) {
    steps.push({
      step: stepNum++,
      category: "signal_synthesis",
      observation: `Signal agreement: ${(input.fusedIntelligence.signalAgreement * 100).toFixed(0)}%, Trend strength: ${(input.fusedIntelligence.trendStrength * 100).toFixed(0)}%`,
      implication: input.fusedIntelligence.signalAgreement > 0.7 ? "Strong consensus across data sources" : input.fusedIntelligence.signalAgreement < 0.3 ? "Conflicting signals suggest uncertainty" : "Mixed signals require careful evaluation",
      weight: 0.15
    });
  }
  steps.push({
    step: stepNum++,
    category: "risk_assessment",
    observation: `Risk level: ${decision.riskLevel}, Confidence: ${(decision.confidence * 100).toFixed(0)}%`,
    implication: decision.riskLevel === "low" ? "Low risk supports position taking" : decision.riskLevel === "high" ? "High risk warrants smaller position or waiting" : "Moderate risk, proceed with caution",
    weight: 0.1
  });
  steps.push({
    step: stepNum++,
    category: "final_decision",
    observation: `Action: ${decision.action.toUpperCase()}`,
    implication: decision.reasoning,
    weight: 1
  });
  return steps;
}
function generateAlternatives(input, chosenDecision) {
  const alternatives = [];
  const actions = ["buy", "sell", "hold"];
  for (const action of actions) {
    if (action === chosenDecision.action) continue;
    let confidence = 0;
    let reasoning = "";
    let whyRejected = "";
    switch (action) {
      case "buy":
        confidence = input.sentiment?.overall === "bullish" ? 0.4 : 0.2;
        if (input.marketData.changePercent24h && input.marketData.changePercent24h > 0) {
          confidence += 0.1;
        }
        reasoning = "Potential entry point based on market conditions";
        whyRejected = chosenDecision.action === "hold" ? "Insufficient conviction for entry" : "Better opportunity identified in opposite direction";
        break;
      case "sell":
        confidence = input.sentiment?.overall === "bearish" ? 0.4 : 0.2;
        if (input.marketData.changePercent24h && input.marketData.changePercent24h < 0) {
          confidence += 0.1;
        }
        reasoning = "Exit or short opportunity based on bearish signals";
        whyRejected = chosenDecision.action === "hold" ? "No existing position or insufficient bearish confirmation" : "Bullish signals outweigh bearish indicators";
        break;
      case "hold":
        confidence = 0.5;
        reasoning = "Wait for clearer signals before acting";
        whyRejected = chosenDecision.confidence > 0.6 ? "Strong signals support taking action" : "Opportunity cost of waiting outweighed by potential gains";
        break;
    }
    alternatives.push({
      action,
      confidence,
      reasoning,
      whyRejected
    });
  }
  alternatives.sort((a, b) => b.confidence - a.confidence);
  return alternatives;
}
function createEnhancedDecisionLog(decision, marketData, newsContext, strategy, fusedIntelligence, providerInfo, cycleId) {
  const id = `decision_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const input = createInputSnapshot(
    marketData,
    newsContext,
    strategy,
    fusedIntelligence
  );
  const reasoning = generateReasoningSteps(input, decision);
  const alternatives = generateAlternatives(input, decision);
  const dataSourcesUsed = [];
  if (input.marketData) dataSourcesUsed.push("market_data");
  if (input.sentiment) dataSourcesUsed.push(...input.sentiment.sources || []);
  if (input.fundamentals)
    dataSourcesUsed.push(...input.fundamentals.sources || []);
  const keyFactors = [];
  const sortedSteps = [...reasoning].sort((a, b) => b.weight - a.weight);
  for (const step of sortedSteps.slice(0, 3)) {
    if (step.category !== "final_decision") {
      keyFactors.push(step.implication);
    }
  }
  const enhancedLog = {
    id,
    timestamp: /* @__PURE__ */ new Date(),
    cycleId,
    input,
    reasoning: {
      steps: reasoning,
      summary: decision.reasoning,
      keyFactors
    },
    alternatives,
    decision,
    providerInfo: {
      provider: providerInfo?.provider || "unknown",
      model: providerInfo?.model || "unknown",
      tokensUsed: providerInfo?.tokensUsed,
      latencyMs: providerInfo?.latencyMs,
      cost: providerInfo?.cost
    },
    metadata: {
      dataSourcesUsed: [...new Set(dataSourcesUsed)],
      enrichmentApplied: !!fusedIntelligence,
      fusionConfidence: fusedIntelligence?.dataQuality.reliability || 0,
      warningCount: fusedIntelligence?.warnings.length || 0
    }
  };
  log.ai("Enhanced decision logged", {
    id,
    symbol: marketData.symbol,
    action: decision.action,
    confidence: decision.confidence,
    alternativesCount: alternatives.length,
    reasoningSteps: reasoning.length
  });
  return enhancedLog;
}
var init_enhanced_decision_log = __esm({
  "server/ai/enhanced-decision-log.ts"() {
    "use strict";
    init_logger();
  }
});

// server/connectors/huggingface.ts
var HF_INFERENCE_URL, HuggingFaceConnector, huggingface;
var init_huggingface = __esm({
  "server/connectors/huggingface.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    HF_INFERENCE_URL = "https://api-inference.huggingface.co/models";
    HuggingFaceConnector = class {
      rawSentimentCache = new ApiCache({
        freshDuration: 30 * 60 * 1e3,
        staleDuration: 2 * 60 * 60 * 1e3
      });
      enrichmentCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      getApiKey() {
        return process.env.HUGGINGFACE_API_KEY || process.env.HF_API_KEY;
      }
      isAvailable() {
        return !!this.getApiKey();
      }
      async callModel(modelId, inputs, l1CacheKey, l1Cache) {
        const apiKey2 = this.getApiKey();
        if (!apiKey2) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug(
              "HuggingFace",
              `No API key, serving stale L1 data for ${l1CacheKey}`
            );
            return stale;
          }
          throw new Error("HUGGINGFACE_API_KEY is not configured");
        }
        const l1Cached = l1Cache.get(l1CacheKey);
        if (l1Cached?.isFresh) {
          log.debug("HuggingFace", `L1 cache hit for ${l1CacheKey}`);
          return l1Cached.data;
        }
        const url = `${HF_INFERENCE_URL}/${modelId}`;
        const cacheKey = buildCacheKey("huggingface", modelId, l1CacheKey);
        try {
          const result = await connectorFetch(url, {
            provider: "huggingface",
            endpoint: `model/${modelId}`,
            cacheKey,
            method: "POST",
            body: { inputs },
            headers: {
              Authorization: `Bearer ${apiKey2}`
            }
          });
          l1Cache.set(l1CacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug(
              "HuggingFace",
              `Error fetching, serving stale L1 data for ${l1CacheKey}`
            );
            return stale;
          }
          throw error;
        }
      }
      async analyzeSentiment(text17, model = "finbert") {
        const modelIds = {
          finbert: "ProsusAI/finbert",
          financialbert: "ahmedrachid/FinancialBERT-Sentiment-Analysis",
          deberta: "mrm8488/deberta-v3-ft-financial-news-sentiment-analysis"
        };
        const modelId = modelIds[model];
        const l1CacheKey = `sentiment_${model}_${text17.substring(0, 50)}`;
        const result = await this.callModel(
          modelId,
          text17,
          l1CacheKey,
          this.rawSentimentCache
        );
        if (!result || !result[0]) {
          return [{ label: "neutral", score: 0.5 }];
        }
        return result[0].map((r) => ({
          label: this.normalizeSentimentLabel(r.label),
          score: r.score
        }));
      }
      normalizeSentimentLabel(label) {
        const lower = label.toLowerCase();
        if (lower.includes("positive") || lower === "pos" || lower === "bullish") {
          return "positive";
        }
        if (lower.includes("negative") || lower === "neg" || lower === "bearish") {
          return "negative";
        }
        return "neutral";
      }
      async analyzeNewsHeadlines(headlines) {
        const results = [];
        for (const headline of headlines.slice(0, 10)) {
          try {
            const sentiment = await this.analyzeSentiment(headline);
            const topSentiment = sentiment.reduce(
              (a, b) => a.score > b.score ? a : b
            );
            results.push({
              headline,
              sentiment: topSentiment
            });
          } catch (error) {
            log.warn(
              "HuggingFace",
              `Failed to analyze headline: ${headline.substring(0, 30)}...`
            );
            results.push({
              headline,
              sentiment: { label: "neutral", score: 0.5 }
            });
          }
        }
        return results;
      }
      async generateEnrichmentSignal(symbol, newsHeadlines, priceChange) {
        const l1CacheKey = `enrichment_${symbol}_${Date.now() % (15 * 60 * 1e3)}`;
        const cached = this.enrichmentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const sentimentResults = await this.analyzeNewsHeadlines(newsHeadlines);
        let positiveCount = 0;
        let negativeCount = 0;
        let totalScore = 0;
        let totalConfidence = 0;
        for (const result of sentimentResults) {
          if (result.sentiment.label === "positive") {
            positiveCount++;
            totalScore += result.sentiment.score;
          } else if (result.sentiment.label === "negative") {
            negativeCount++;
            totalScore -= result.sentiment.score;
          }
          totalConfidence += result.sentiment.score;
        }
        const netSentiment = sentimentResults.length > 0 ? totalScore / sentimentResults.length : 0;
        const avgConfidence = sentimentResults.length > 0 ? totalConfidence / sentimentResults.length : 0.5;
        let overallLabel = "neutral";
        if (netSentiment > 0.2) overallLabel = "positive";
        else if (netSentiment < -0.2) overallLabel = "negative";
        let trendStrength;
        if (priceChange !== void 0) {
          const priceDirection = priceChange > 0 ? 1 : priceChange < 0 ? -1 : 0;
          const sentimentDirection = netSentiment > 0 ? 1 : netSentiment < 0 ? -1 : 0;
          if (priceDirection === sentimentDirection) {
            trendStrength = Math.abs(netSentiment) * avgConfidence;
          } else {
            trendStrength = -Math.abs(netSentiment) * avgConfidence;
          }
        }
        const signal = {
          symbol,
          sentimentScore: netSentiment,
          sentimentLabel: overallLabel,
          confidence: avgConfidence,
          trendStrength,
          model: "finbert",
          timestamp: /* @__PURE__ */ new Date()
        };
        this.enrichmentCache.set(l1CacheKey, signal);
        log.info("HuggingFace", "Generated enrichment signal", {
          symbol,
          sentimentLabel: overallLabel,
          sentimentScore: netSentiment.toFixed(3),
          confidence: avgConfidence.toFixed(3),
          headlinesAnalyzed: sentimentResults.length
        });
        return signal;
      }
      async batchAnalyzeSymbols(symbolsWithNews) {
        const results = /* @__PURE__ */ new Map();
        for (const [symbol, headlines] of symbolsWithNews) {
          try {
            const signal = await this.generateEnrichmentSignal(symbol, headlines);
            results.set(symbol, signal);
          } catch (error) {
            log.warn(
              "HuggingFace",
              `Failed to analyze ${symbol}: ${String(error)}`
            );
          }
        }
        return results;
      }
      getConnectionStatus() {
        return {
          connected: this.isAvailable(),
          hasApiKey: this.isAvailable(),
          cacheSize: this.rawSentimentCache.size() + this.enrichmentCache.size()
        };
      }
      clearCache() {
        this.rawSentimentCache.clear();
        this.enrichmentCache.clear();
      }
    };
    huggingface = new HuggingFaceConnector();
  }
});

// server/trading/ai-analyzer.ts
var AIAnalyzer, aiAnalyzer;
var init_ai_analyzer = __esm({
  "server/trading/ai-analyzer.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_decision_engine();
    init_llmGateway();
    init_newsapi();
    init_data_fusion_engine();
    init_enhanced_decision_log();
    init_huggingface();
    init_valyu();
    init_gdelt();
    init_logger();
    AIAnalyzer = class {
      /**
       * Normalize crypto symbols to slash format
       *
       * Converts crypto symbols to Alpaca's required slash format (e.g., "BTCUSD" -> "BTC/USD")
       *
       * @private
       * @param symbol - Symbol to normalize
       * @returns Normalized crypto symbol with slash format
       *
       * @example
       * ```typescript
       * normalizeCryptoSymbol("BTCUSD") // returns "BTC/USD"
       * normalizeCryptoSymbol("BTC/USD") // returns "BTC/USD"
       * normalizeCryptoSymbol("SOLUSD") // returns "SOL/USD"
       * ```
       */
      normalizeCryptoSymbol(symbol) {
        const upperSymbol = symbol.toUpperCase();
        if (upperSymbol.includes("/")) {
          return upperSymbol;
        }
        if (upperSymbol === "BTCUSD") return "BTC/USD";
        if (upperSymbol === "ETHUSD") return "ETH/USD";
        if (upperSymbol === "SOLUSD") return "SOL/USD";
        if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
          const base = upperSymbol.slice(0, -3);
          return `${base}/USD`;
        }
        return upperSymbol;
      }
      /**
       * Check if a symbol is a crypto symbol
       *
       * Determines if a symbol represents a cryptocurrency pair based on known
       * crypto pairs and slash format detection.
       *
       * @private
       * @param symbol - Symbol to check
       * @returns True if symbol is a cryptocurrency pair
       *
       * @example
       * ```typescript
       * isCryptoSymbol("BTC/USD") // returns true
       * isCryptoSymbol("BTCUSD") // returns true
       * isCryptoSymbol("AAPL") // returns false
       * ```
       */
      isCryptoSymbol(symbol) {
        const upperSymbol = symbol.toUpperCase();
        const cryptoPairs = [
          "BTC/USD",
          "ETH/USD",
          "SOL/USD",
          "DOGE/USD",
          "SHIB/USD",
          "AVAX/USD",
          "DOT/USD",
          "LINK/USD",
          "UNI/USD",
          "AAVE/USD",
          "LTC/USD",
          "BCH/USD",
          "BTCUSD",
          "ETHUSD",
          "SOLUSD",
          "DOGEUSD",
          "SHIBUSD",
          "AVAXUSD",
          "DOTUSD",
          "LINKUSD",
          "UNIUSD",
          "AAVEUSD",
          "LTCUSD",
          "BCHUSD"
        ];
        return cryptoPairs.includes(upperSymbol) || symbol.includes("/") && upperSymbol.endsWith("USD");
      }
      /**
       * Normalize symbol for Alpaca API calls
       *
       * Handles different symbol format requirements for crypto vs stocks
       * and for orders vs lookups.
       *
       * @private
       * @param symbol - Symbol to normalize
       * @param forOrder - If true, use format required for orders (default: false)
       * @returns Normalized symbol for Alpaca API
       *
       * @example
       * ```typescript
       * // For crypto orders - use slash format
       * normalizeSymbolForAlpaca("BTC/USD", true) // returns "BTC/USD"
       *
       * // For stock lookups - remove slashes
       * normalizeSymbolForAlpaca("AAPL", false) // returns "AAPL"
       * normalizeSymbolForAlpaca("BTC/USD", false) // returns "BTCUSD"
       * ```
       */
      normalizeSymbolForAlpaca(symbol, forOrder = false) {
        if (forOrder && this.isCryptoSymbol(symbol)) {
          return this.normalizeCryptoSymbol(symbol);
        }
        return symbol.replace("/", "").toUpperCase();
      }
      /**
       * Get market data for a symbol from Alpaca
       *
       * Fetches real-time market data including price, volume, and 24-hour changes.
       * Handles both stocks and crypto with appropriate API endpoints.
       *
       * @param symbol - Stock symbol or crypto pair
       * @returns Promise resolving to market data or null if unavailable
       *
       * @example
       * ```typescript
       * const data = await aiAnalyzer.getMarketDataForSymbol("AAPL");
       * if (data) {
       *   console.log(`Price: $${data.currentPrice}`);
       *   console.log(`Change: ${data.priceChangePercent24h.toFixed(2)}%`);
       *   console.log(`Volume: ${data.volume}`);
       * }
       * ```
       *
       * @note Returns null if no valid price data is available
       * @note Handles crypto vs stock snapshot endpoints automatically
       */
      async getMarketDataForSymbol(symbol) {
        try {
          const isCrypto = this.isCryptoSymbol(symbol);
          const lookupSymbol = isCrypto ? this.normalizeCryptoSymbol(symbol) : this.normalizeSymbolForAlpaca(symbol);
          const snapshots = isCrypto ? await alpaca.getCryptoSnapshots([lookupSymbol]) : await alpaca.getSnapshots([lookupSymbol]);
          const snapshot = snapshots[lookupSymbol];
          if (snapshot) {
            const currentPrice = snapshot.latestTrade?.p || snapshot.dailyBar?.c || snapshot.prevDailyBar?.c || 0;
            if (!currentPrice || currentPrice <= 0) {
              log.warn("AIAnalyzer", "No valid price sources for symbol", {
                symbol,
                latestTrade: snapshot.latestTrade?.p,
                dailyBarClose: snapshot.dailyBar?.c,
                prevDailyBarClose: snapshot.prevDailyBar?.c
              });
              return null;
            }
            const prevClose = snapshot.prevDailyBar?.c || currentPrice;
            const priceChange = currentPrice - prevClose;
            const priceChangePercent = prevClose > 0 ? priceChange / prevClose * 100 : 0;
            return {
              symbol: symbol.toUpperCase(),
              currentPrice,
              priceChange24h: priceChange,
              priceChangePercent24h: priceChangePercent,
              high24h: snapshot.dailyBar?.h,
              low24h: snapshot.dailyBar?.l,
              volume: snapshot.dailyBar?.v
            };
          }
          log.warn("AIAnalyzer", "No snapshot data returned", { symbol });
          return null;
        } catch (error) {
          log.error("AIAnalyzer", "Failed to get market data", {
            symbol,
            error: error.message
          });
          return null;
        }
      }
      /**
       * Analyze sentiment from news headlines
       *
       * Simple keyword-based sentiment analysis of news headlines.
       * Counts bullish vs bearish keywords to determine overall sentiment.
       *
       * @param headlines - Array of news headline strings
       * @returns Sentiment classification: "bullish", "bearish", or "neutral"
       *
       * @example
       * ```typescript
       * const headlines = [
       *   "Stock surges to record high on strong earnings",
       *   "Company announces major growth initiative"
       * ];
       * const sentiment = aiAnalyzer.analyzeSentiment(headlines);
       * console.log(sentiment); // "bullish"
       * ```
       *
       * @note This is a simple keyword-based approach
       * @note For advanced sentiment, use Hugging Face FinBERT integration
       */
      analyzeSentiment(headlines) {
        const bullishWords = [
          "surge",
          "rally",
          "gain",
          "rise",
          "up",
          "growth",
          "positive",
          "beat",
          "record",
          "high"
        ];
        const bearishWords = [
          "drop",
          "fall",
          "decline",
          "down",
          "loss",
          "negative",
          "miss",
          "crash",
          "low",
          "sell"
        ];
        let score = 0;
        const text17 = headlines.join(" ").toLowerCase();
        for (const word of bullishWords) {
          if (text17.includes(word)) score++;
        }
        for (const word of bearishWords) {
          if (text17.includes(word)) score--;
        }
        if (score > 1) return "bullish";
        if (score < -1) return "bearish";
        return "neutral";
      }
      /**
       * Gather enrichment data from multiple optional sources
       *
       * Collects sentiment and fundamental data from various providers to enrich
       * AI decision-making. All sources are optional - returns empty arrays if
       * API keys aren't configured.
       *
       * @param symbol - Stock symbol or crypto pair to analyze
       * @param marketData - Current market data for the symbol
       * @param newsContext - Optional news context with headlines
       *
       * @returns Promise resolving to enrichment data from available sources
       *
       * @example
       * ```typescript
       * const enrichment = await aiAnalyzer.gatherEnrichmentData(
       *   "AAPL",
       *   marketData,
       *   newsContext
       * );
       *
       * if (enrichment.hasEnrichment) {
       *   console.log(`Sentiment sources: ${enrichment.sentimentData.length}`);
       *   console.log(`Fundamental sources: ${enrichment.fundamentalData.length}`);
       *
       *   enrichment.sentimentData.forEach(s => {
       *     console.log(`${s.source}: ${s.sentiment} (${s.score.toFixed(2)})`);
       *   });
       * }
       * ```
       *
       * @enrichmentSources Three primary enrichment sources:
       * 1. **GDELT** (FREE, no API key needed):
       *    - Real-time global news sentiment
       *    - Article volume spike detection
       *    - Works for both stocks and crypto
       *
       * 2. **Hugging Face FinBERT** (optional, requires API key):
       *    - Advanced AI sentiment analysis
       *    - Analyzes news headlines with financial context
       *    - Provides confidence scores
       *
       * 3. **Valyu.ai** (optional, requires API key, stocks only):
       *    - Financial ratios (P/E, debt/equity, revenue growth)
       *    - Free cash flow analysis
       *    - Dividend yield data
       *    - Insider transaction sentiment
       *
       * @note Runs all enrichment sources in parallel for performance
       * @note Gracefully handles missing API keys - logs debug message and continues
       * @note Crypto symbols skip Valyu.ai (stocks only)
       */
      async gatherEnrichmentData(symbol, marketData, newsContext) {
        const sentimentData = [];
        const fundamentalData = [];
        const enrichmentPromises = [];
        if (newsContext?.headlines && newsContext.headlines.length > 0 && huggingface.isAvailable()) {
          enrichmentPromises.push(
            (async () => {
              try {
                const signal = await huggingface.generateEnrichmentSignal(
                  symbol,
                  newsContext.headlines,
                  marketData.priceChangePercent24h
                );
                if (signal) {
                  const sentiment = signal.sentimentScore > 0.2 ? "positive" : signal.sentimentScore < -0.2 ? "negative" : "neutral";
                  sentimentData.push({
                    source: "huggingface_finbert",
                    symbol,
                    sentiment,
                    score: signal.sentimentScore,
                    confidence: signal.confidence,
                    timestamp: /* @__PURE__ */ new Date()
                  });
                }
              } catch (e) {
                log.debug("AI", `HuggingFace enrichment skipped for ${symbol}`, {
                  reason: e.message
                });
              }
            })()
          );
        }
        const isCrypto = this.isCryptoSymbol(symbol);
        enrichmentPromises.push(
          (async () => {
            try {
              const gdeltSentiment = isCrypto ? await gdelt.getCryptoSentiment(
                symbol.replace(/USD$|USDT$|\/USD$/i, "")
              ) : await gdelt.analyzeSymbolSentiment(symbol);
              if (gdeltSentiment && gdeltSentiment.articleCount > 0) {
                const sentiment = gdeltSentiment.sentiment === "bullish" ? "positive" : gdeltSentiment.sentiment === "bearish" ? "negative" : "neutral";
                sentimentData.push({
                  source: "gdelt",
                  symbol,
                  sentiment,
                  score: gdeltSentiment.averageTone / 10,
                  confidence: Math.min(0.9, gdeltSentiment.articleCount / 50),
                  headlines: gdeltSentiment.topHeadlines,
                  timestamp: /* @__PURE__ */ new Date()
                });
                if (gdeltSentiment.volumeSpike) {
                  log.info("GDELT", `Breaking news detected for ${symbol}`, {
                    articleCount: gdeltSentiment.articleCount,
                    sentiment: gdeltSentiment.sentiment
                  });
                }
              }
            } catch (e) {
              log.debug("AI", `GDELT enrichment skipped for ${symbol}`, {
                reason: e.message
              });
            }
          })()
        );
        if (!isCrypto && valyu.isAvailable()) {
          enrichmentPromises.push(
            (async () => {
              try {
                const [ratios, cashFlow, dividends, insiderData] = await Promise.all([
                  valyu.getFinancialRatios(symbol),
                  valyu.getCashFlow(symbol).catch(() => null),
                  valyu.getDividends(symbol).catch(() => null),
                  valyu.getInsiderTransactions(symbol).catch(() => null)
                ]);
                if (ratios || cashFlow || dividends || insiderData) {
                  fundamentalData.push({
                    source: "valyu",
                    symbol,
                    peRatio: ratios?.peRatio,
                    revenueGrowth: ratios?.revenueGrowth,
                    debtToEquity: ratios?.debtToEquity,
                    freeCashFlow: cashFlow?.freeCashFlow,
                    dividendYield: dividends?.dividendYield,
                    insiderSentiment: insiderData?.netInsiderSentiment,
                    timestamp: /* @__PURE__ */ new Date()
                  });
                  if (insiderData?.netInsiderSentiment === "bearish") {
                    log.warn("Valyu", `Insider selling detected for ${symbol}`, {
                      sentiment: insiderData.netInsiderSentiment,
                      sellValue: insiderData.totalSellValue
                    });
                  }
                }
              } catch (e) {
                log.debug("AI", `Valyu.ai enrichment skipped for ${symbol}`, {
                  reason: e.message
                });
              }
            })()
          );
        }
        await Promise.allSettled(enrichmentPromises);
        return {
          hasEnrichment: sentimentData.length > 0 || fundamentalData.length > 0,
          sentimentData,
          fundamentalData
        };
      }
      /**
       * Analyze a symbol with AI decision engine
       *
       * Orchestrates comprehensive market analysis by gathering multi-source data,
       * fusing intelligence, generating AI decision, and creating full transparency logs.
       *
       * This is the main entry point for AI-powered trading analysis.
       *
       * @param symbol - Stock symbol or crypto pair to analyze
       * @param strategyId - Optional strategy ID for context and tracking
       * @param traceId - Optional trace ID for request tracking (auto-generated if not provided)
       *
       * @returns Promise resolving to complete analysis package
       * @returns result.decision - AI trading decision (buy/sell/hold with confidence)
       * @returns result.marketData - Real-time market data from Alpaca
       * @returns result.fusedIntelligence - Fused data from multiple sources (if available)
       * @returns result.enhancedLog - Full transparency log of decision process
       *
       * @example
       * ```typescript
       * const analysis = await aiAnalyzer.analyzeSymbol("AAPL", "strategy-123");
       *
       * console.log(`Decision: ${analysis.decision.action}`);
       * console.log(`Confidence: ${analysis.decision.confidence}%`);
       * console.log(`Reasoning: ${analysis.decision.reasoning}`);
       *
       * if (analysis.decision.action === "buy") {
       *   console.log(`Suggested quantity: ${analysis.decision.suggestedQuantity}`);
       *   console.log(`Target price: $${analysis.decision.targetPrice}`);
       *   console.log(`Stop loss: $${analysis.decision.stopLoss}`);
       * }
       *
       * if (analysis.fusedIntelligence) {
       *   console.log(`Data quality: ${analysis.fusedIntelligence.dataQuality.completeness}%`);
       *   console.log(`Signal agreement: ${analysis.fusedIntelligence.signalAgreement}`);
       * }
       * ```
       *
       * @analysisProcess Complete analysis workflow:
       * 1. **Market Data**: Fetch real-time price, volume, change from Alpaca
       * 2. **News Context**: Gather recent headlines from NewsAPI
       * 3. **Enrichment**: Collect sentiment/fundamentals from GDELT, Hugging Face, Valyu.ai
       * 4. **Data Fusion**: Combine multi-source intelligence with consensus analysis
       * 5. **AI Decision**: Generate trading decision with GPT-4o-mini
       * 6. **Transparency Log**: Create enhanced decision log for full auditability
       * 7. **Database Record**: Store AI decision with all context
       *
       * @throws Error if market data cannot be retrieved
       *
       * @note Creates AI decision record in database with full context
       * @note Enhanced log includes all data sources, reasoning, and metadata
       */
      async analyzeSymbol(symbol, strategyId, traceId) {
        const effectiveTraceId = traceId || generateTraceId();
        const marketData = await this.getMarketDataForSymbol(symbol);
        if (!marketData) {
          throw new Error(`Could not get market data for ${symbol}`);
        }
        let strategy;
        let newsContext;
        let fusedIntelligence;
        if (strategyId) {
          strategy = await storage.getStrategy(strategyId);
        }
        try {
          const newsArticles = await newsapi.getStockNews(symbol, 5);
          if (newsArticles.length > 0) {
            newsContext = {
              headlines: newsArticles.map((a) => a.title),
              sentiment: this.analyzeSentiment(newsArticles.map((a) => a.title)),
              summary: `Recent news about ${symbol}`
            };
          }
        } catch (e) {
          log.debug("AIAnalyzer", "Could not fetch news", {
            symbol,
            error: e.message
          });
        }
        const enrichmentData = await this.gatherEnrichmentData(
          symbol,
          marketData,
          newsContext
        );
        if (enrichmentData.hasEnrichment) {
          try {
            fusedIntelligence = fuseMarketData({
              symbol,
              assetType: this.isCryptoSymbol(symbol) ? "crypto" : "stock",
              marketData: [
                {
                  source: "alpaca",
                  symbol,
                  price: marketData.currentPrice,
                  priceChange: marketData.priceChange24h,
                  priceChangePercent: marketData.priceChangePercent24h,
                  volume: marketData.volume,
                  timestamp: /* @__PURE__ */ new Date(),
                  reliability: 0.95
                }
              ],
              sentimentData: enrichmentData.sentimentData,
              fundamentalData: enrichmentData.fundamentalData
            });
            log.info("AI", `Fused intelligence for ${symbol}`, {
              signalAgreement: fusedIntelligence.signalAgreement,
              trendStrength: fusedIntelligence.trendStrength,
              dataQuality: fusedIntelligence.dataQuality.completeness
            });
          } catch (e) {
            log.warn("AI", `Data fusion failed for ${symbol}`, {
              error: e.message
            });
          }
        }
        const strategyContext = strategy ? {
          id: strategy.id,
          name: strategy.name,
          type: strategy.type,
          parameters: strategy.parameters ? JSON.parse(strategy.parameters) : void 0
        } : void 0;
        const decision = await aiDecisionEngine.analyzeOpportunity(
          symbol,
          marketData,
          newsContext,
          strategyContext,
          { traceId: effectiveTraceId }
        );
        const enhancedLog = createEnhancedDecisionLog(
          decision,
          marketData,
          newsContext,
          strategyContext,
          fusedIntelligence,
          { provider: "openai", model: "gpt-4o-mini" }
        );
        await storage.createAiDecision({
          strategyId: strategyId || null,
          symbol,
          action: decision.action,
          confidence: decision.confidence.toString(),
          reasoning: decision.reasoning,
          traceId: effectiveTraceId,
          marketContext: JSON.stringify({
            marketData,
            newsContext,
            riskLevel: decision.riskLevel,
            suggestedQuantity: decision.suggestedQuantity,
            targetPrice: decision.targetPrice,
            stopLoss: decision.stopLoss,
            fusedIntelligence: fusedIntelligence ? {
              signalAgreement: fusedIntelligence.signalAgreement,
              trendStrength: fusedIntelligence.trendStrength,
              dataQuality: fusedIntelligence.dataQuality,
              warnings: fusedIntelligence.warnings
            } : void 0,
            enhancedLogId: enhancedLog.id
          })
        });
        return { decision, marketData, fusedIntelligence, enhancedLog };
      }
      /**
       * Link an AI decision to an executed trade
       *
       * Creates a linkage between an AI decision and the trade that resulted from it.
       * This enables tracking of which AI recommendations were actually executed.
       *
       * @param symbol - Symbol that was traded
       * @param strategyId - Optional strategy ID to match decision
       * @param tradeId - ID of the executed trade to link
       *
       * @returns Promise that resolves when link is created
       *
       * @example
       * ```typescript
       * // After executing a trade based on AI decision
       * const tradeResult = await orderExecutor.executeAlpacaTrade({ ... });
       * if (tradeResult.success && tradeResult.trade) {
       *   await aiAnalyzer.linkAiDecisionToTrade(
       *     "AAPL",
       *     "strategy-123",
       *     tradeResult.trade.id
       *   );
       * }
       * ```
       *
       * @note Only links to the most recent AI decision for the symbol/strategy
       * @note Skips if decision already has an associated trade
       * @note Errors are logged but don't throw
       */
      async linkAiDecisionToTrade(symbol, strategyId, tradeId) {
        try {
          const latestDecision = await storage.getLatestAiDecisionForSymbol(
            symbol,
            strategyId
          );
          if (latestDecision && !latestDecision.executedTradeId) {
            await storage.updateAiDecision(latestDecision.id, {
              executedTradeId: tradeId
            });
            log.debug("AIAnalyzer", "Linked AI decision to trade", {
              decisionId: latestDecision.id,
              tradeId
            });
          }
        } catch (error) {
          log.error("AIAnalyzer", "Failed to link AI decision to trade", {
            error: error.message
          });
        }
      }
    };
    aiAnalyzer = new AIAnalyzer();
  }
});

// server/trading/risk-validator.ts
async function checkRiskLimits(side, symbol, tradeValue, killSwitchActive, normalizeSymbolForAlpaca3) {
  const status = await storage.getAgentStatus();
  if (status?.killSwitchActive || killSwitchActive) {
    return { allowed: false, reason: "Kill switch is active - trading halted" };
  }
  if (side === "buy") {
    try {
      const account = await alpaca.getAccount();
      const positions2 = await alpaca.getPositions();
      const maxPositions = status?.maxPositionsCount ?? 10;
      if (positions2.length >= maxPositions) {
        return {
          allowed: false,
          reason: `Maximum positions limit reached (${maxPositions})`
        };
      }
      const riskSymbol = normalizeSymbolForAlpaca3(symbol);
      const snapshot = await alpaca.getSnapshots([riskSymbol]);
      const snapshotData = snapshot[riskSymbol];
      const price = snapshotData?.latestTrade?.p || snapshotData?.dailyBar?.c || snapshotData?.prevDailyBar?.c || 0;
      if (!price || price <= 0 || !Number.isFinite(price)) {
        log.warn("RiskValidator", "Risk check: invalid price", {
          symbol,
          price
        });
        return {
          allowed: false,
          reason: `Cannot verify trade value - no valid price data for ${symbol}`
        };
      }
      const effectiveTradeValue = tradeValue > 0 && tradeValue < 1e6 ? tradeValue : tradeValue * price;
      if (!Number.isFinite(effectiveTradeValue)) {
        return {
          allowed: false,
          reason: `Invalid trade value calculation for ${symbol}`
        };
      }
      const buyingPower = safeParseFloat(account.buying_power);
      const rawPercent = status?.maxPositionSizePercent;
      const parsedPercent = rawPercent ? safeParseFloat(rawPercent) : NaN;
      const maxPositionSizePercent = isNaN(parsedPercent) || parsedPercent <= 0 ? 10 : parsedPercent;
      const maxPositionSizeDecimal = maxPositionSizePercent / 100;
      const maxTradeValue = buyingPower * maxPositionSizeDecimal;
      if (effectiveTradeValue > maxTradeValue) {
        return {
          allowed: false,
          reason: `Trade exceeds max position size (${maxPositionSizePercent.toFixed(0)}% = $${maxTradeValue.toFixed(2)})`
        };
      }
    } catch (error) {
      log.error("RiskValidator", "Risk check error", {
        error: error.message
      });
      return { allowed: false, reason: "Could not verify risk limits" };
    }
  }
  return { allowed: true };
}
async function checkSellLossProtection(symbol, notes, normalizeSymbolForAlpaca3, isStopLossTriggered, isEmergencyStop) {
  try {
    const alpacaSymbol = normalizeSymbolForAlpaca3(symbol, true);
    const position = await alpaca.getPosition(alpacaSymbol);
    if (!position) {
      return { allowed: true };
    }
    const entryPrice = safeParseFloat(position.avg_entry_price);
    const currentPrice = safeParseFloat(position.current_price);
    const isAtLoss = currentPrice < entryPrice;
    const isStopLossOrEmergency = notes?.toLowerCase().includes("stop-loss") || notes?.toLowerCase().includes("emergency") || notes?.toLowerCase().includes("stop loss") || isStopLossTriggered || isEmergencyStop;
    if (isAtLoss && !isStopLossOrEmergency) {
      const lossPercentDecimal = percentChange(currentPrice, entryPrice).abs();
      const lossPercent = formatPrice(lossPercentDecimal, 2);
      log.warn(
        "RiskValidator",
        `LOSS_PROTECTION: ${symbol} - Position at loss`,
        {
          symbol,
          reason: "LOSS_PROTECTION_ACTIVE",
          entryPrice,
          currentPrice,
          lossPercent: lossPercentDecimal.toNumber(),
          isStopLossOrEmergency
        }
      );
      return {
        allowed: false,
        reason: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`
      };
    }
    return { allowed: true };
  } catch (posError) {
    return { allowed: true };
  }
}
var init_risk_validator = __esm({
  "server/trading/risk-validator.ts"() {
    "use strict";
    init_storage();
    init_logger();
    init_money();
    init_alpaca();
    init_numeric();
  }
});

// server/trading/order-executor.ts
var OrderExecutor, orderExecutor;
var init_order_executor = __esm({
  "server/trading/order-executor.ts"() {
    "use strict";
    init_alpaca();
    init_storage();
    init_orchestration2();
    init_logger();
    init_numeric();
    init_risk_validator();
    init_orchestrator_controller();
    init_symbol_normalizer();
    init_tradability_service();
    OrderExecutor = class {
      /**
       * Execute a trade with Alpaca with comprehensive validation and risk management
       *
       * This is the main entry point for all trade execution. It runs through 6 critical guard clauses,
       * selects the appropriate order type, executes the trade, and creates post-execution records.
       *
       * @param request - The trade request parameters
       * @param request.symbol - Stock symbol (e.g., "AAPL") or crypto pair (e.g., "BTC/USD")
       * @param request.side - Trade direction: "buy" or "sell"
       * @param request.quantity - Number of shares/units to trade (must be > 0)
       * @param request.strategyId - Optional strategy ID for tracking
       * @param request.notes - Optional notes for trade record
       * @param request.orderType - Order type: "market", "limit", "stop", "stop_limit" (default: "market")
       * @param request.limitPrice - Required for limit/stop_limit orders
       * @param request.stopLossPrice - Optional stop-loss price for bracket orders
       * @param request.takeProfitPrice - Optional take-profit price for bracket orders
       * @param request.useBracketOrder - Whether to use bracket order (requires stopLossPrice and takeProfitPrice)
       * @param request.trailingStopPercent - Optional trailing stop percentage for sell orders
       * @param request.extendedHours - Whether to allow extended hours trading (requires limit order)
       * @param request.authorizedByOrchestrator - SECURITY: Must be true if orchestrator control is enabled
       *
       * @returns Promise resolving to trade result with success status, order details, and trade record
       *
       * @example Basic market order
       * ```typescript
       * const result = await orderExecutor.executeAlpacaTrade({
       *   symbol: "AAPL",
       *   side: "buy",
       *   quantity: 10,
       *   orderType: "market",
       *   authorizedByOrchestrator: true
       * });
       * ```
       *
       * @example Bracket order with stop-loss and take-profit
       * ```typescript
       * const result = await orderExecutor.executeAlpacaTrade({
       *   symbol: "TSLA",
       *   side: "buy",
       *   quantity: 5,
       *   orderType: "limit",
       *   limitPrice: 200.00,
       *   stopLossPrice: 190.00,    // 5% stop-loss
       *   takeProfitPrice: 220.00,  // 10% take-profit
       *   useBracketOrder: true,
       *   authorizedByOrchestrator: true
       * });
       * ```
       *
       * @example Extended hours limit order
       * ```typescript
       * const result = await orderExecutor.executeAlpacaTrade({
       *   symbol: "NVDA",
       *   side: "buy",
       *   quantity: 10,
       *   orderType: "limit",
       *   limitPrice: 450.00,
       *   extendedHours: true,
       *   authorizedByOrchestrator: true
       * });
       * ```
       *
       * @throws Never throws - all errors are caught and returned in result.error
       *
       * @guardClauses The method runs through 6 critical guard clauses before execution:
       * 1. **Quantity validation**: Ensures quantity > 0
       * 2. **Orchestrator control**: Blocks unauthorized trades when orchestrator is active
       * 3. **Loss protection**: Prevents selling at a loss unless it's a stop-loss order
       * 4. **Risk limits**: Validates against daily loss limits and kill switch
       * 5. **Tradability**: Ensures symbol is tradable in broker universe
       * 6. **Extended hours restrictions**: Validates extended hours compatibility
       *
       * @orderTypeSelection After guard clauses, the method selects the appropriate order type:
       * - **Bracket order**: If useBracketOrder=true, side=buy, has stop/profit prices, not crypto, not extended hours
       * - **Trailing stop**: If trailingStopPercent set, side=sell, not crypto, not extended hours
       * - **Extended hours limit**: If extendedHours=true (must be limit or stop_limit order)
       * - **Standard order**: Market or limit order with appropriate time_in_force
       *
       * @automatedStopLoss After successful buy orders (non-bracket, non-crypto, non-extended-hours):
       * - Automatically creates a stop-loss order at 2% below entry price
       * - Links stop-loss order ID to trade record for tracking
       * - Non-blocking: Logs error if stop-loss creation fails but doesn't fail the main trade
       */
      async executeAlpacaTrade(request) {
        try {
          const {
            symbol,
            side,
            quantity,
            strategyId,
            notes,
            orderType = "market",
            limitPrice,
            stopLossPrice,
            takeProfitPrice,
            useBracketOrder,
            trailingStopPercent,
            extendedHours = false
          } = request;
          if (quantity <= 0) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Quantity must be greater than 0`,
              {
                symbol,
                side,
                quantity,
                reason: "INVALID_QUANTITY"
              }
            );
            return { success: false, error: "Quantity must be greater than 0" };
          }
          if (orchestratorController.isOrchestratorControlEnabled() && !request.authorizedByOrchestrator) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Orchestrator control active`,
              {
                symbol,
                side,
                quantity,
                reason: "ORCHESTRATOR_CONTROL_ACTIVE",
                orchestratorControlEnabled: orchestratorController.isOrchestratorControlEnabled(),
                authorizedByOrchestrator: request.authorizedByOrchestrator
              }
            );
            return {
              success: false,
              error: "Orchestrator control active - direct trade execution blocked. Trades must go through the work queue."
            };
          }
          if (side === "sell") {
            const lossProtectionResult = await checkSellLossProtection(
              symbol,
              notes,
              normalizeSymbolForAlpaca
            );
            if (!lossProtectionResult.allowed) {
              log.warn(
                "Trading",
                `ORDER_BLOCKED: ${symbol} - Loss protection active`,
                {
                  symbol,
                  side,
                  quantity,
                  reason: "LOSS_PROTECTION_ACTIVE"
                }
              );
              return {
                success: false,
                error: lossProtectionResult.reason || "Position at loss - holding until stop-loss triggers or price recovers"
              };
            }
          }
          const agentStatus2 = await storage.getAgentStatus();
          const riskCheck = await checkRiskLimits(
            side,
            symbol,
            quantity,
            agentStatus2?.killSwitchActive || false,
            normalizeSymbolForAlpaca
          );
          if (!riskCheck.allowed) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Risk limit exceeded`, {
              symbol,
              side,
              quantity,
              reason: "RISK_LIMIT_EXCEEDED",
              riskCheckReason: riskCheck.reason
            });
            return { success: false, error: riskCheck.reason };
          }
          const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
          if (!tradabilityCheck.tradable) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Symbol not tradable`, {
              symbol,
              side,
              quantity,
              reason: "SYMBOL_NOT_TRADABLE",
              tradabilityReason: tradabilityCheck.reason
            });
            return {
              success: false,
              error: `Symbol ${symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}`
            };
          }
          const alpacaSymbol = normalizeSymbolForAlpaca(symbol, true);
          const isCrypto = isCryptoSymbol(symbol);
          let order;
          if (extendedHours && isCrypto) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Extended hours not available for crypto`,
              {
                symbol,
                side,
                quantity,
                reason: "EXTENDED_HOURS_CRYPTO_NOT_SUPPORTED"
              }
            );
            return {
              success: false,
              error: "Extended hours trading is not available for crypto"
            };
          }
          if (extendedHours && !["limit", "stop_limit"].includes(orderType)) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Extended hours requires limit or stop_limit orders`,
              {
                symbol,
                side,
                quantity,
                orderType,
                reason: "EXTENDED_HOURS_REQUIRES_LIMIT_OR_STOP_LIMIT"
              }
            );
            return {
              success: false,
              error: "Extended hours trading requires limit or stop_limit orders only"
            };
          }
          if (extendedHours && !limitPrice) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Extended hours requires limit price`,
              {
                symbol,
                side,
                quantity,
                reason: "EXTENDED_HOURS_REQUIRES_LIMIT_PRICE"
              }
            );
            return {
              success: false,
              error: "Extended hours trading requires a limit price"
            };
          }
          if (extendedHours && !Number.isInteger(quantity)) {
            log.warn(
              "Trading",
              `ORDER_BLOCKED: ${symbol} - Extended hours requires whole shares`,
              {
                symbol,
                side,
                quantity,
                reason: "EXTENDED_HOURS_REQUIRES_WHOLE_SHARES"
              }
            );
            return {
              success: false,
              error: "Extended hours trading requires whole share quantities (no fractional shares)"
            };
          }
          const shouldUseBracketOrder = useBracketOrder && side === "buy" && stopLossPrice && takeProfitPrice && !isCrypto && !extendedHours;
          if (shouldUseBracketOrder) {
            const bracketParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: orderType === "limit" ? "limit" : "market",
              time_in_force: "day",
              // FIXED: Was "gtc" which causes 422 rejection
              take_profit_price: takeProfitPrice.toFixed(2),
              stop_loss_price: stopLossPrice.toFixed(2)
            };
            if (orderType === "limit" && limitPrice) {
              bracketParams.limit_price = limitPrice.toString();
            }
            logger.info(
              "Trading",
              `Creating bracket order for ${symbol}: Entry=${limitPrice || "market"}, TP=$${takeProfitPrice.toFixed(2)}, SL=$${stopLossPrice.toFixed(2)}, TIF=day`
            );
            order = await alpaca.createBracketOrder(bracketParams);
            logger.info("Trading", `Bracket order submitted for ${symbol}`, {
              orderId: order.id,
              status: order.status
            });
          } else if (trailingStopPercent && side === "sell" && !isCrypto && !extendedHours) {
            log.info("Trading", "Creating trailing stop order", {
              symbol,
              trailingStopPercent
            });
            order = await alpaca.createTrailingStopOrder({
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              trail_percent: trailingStopPercent,
              time_in_force: "gtc"
            });
          } else if (extendedHours) {
            const orderParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: "limit",
              time_in_force: "day",
              limit_price: limitPrice.toString(),
              extended_hours: true
            };
            log.info("Trading", "Creating extended hours limit order", {
              symbol,
              side,
              quantity,
              limitPrice
            });
            order = await alpaca.createOrder(orderParams);
          } else {
            const effectiveTif = orderType === "market" ? "day" : isCrypto ? "gtc" : "day";
            const orderParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: orderType,
              time_in_force: effectiveTif
            };
            if (orderType === "limit" && limitPrice) {
              orderParams.limit_price = limitPrice.toString();
            }
            order = await alpaca.createOrder(orderParams);
          }
          const filledPrice = order.filled_avg_price ? safeParseFloat(order.filled_avg_price) : limitPrice || 0;
          let tradeNotes = notes || `Alpaca Order ID: ${order.id}`;
          if (shouldUseBracketOrder) {
            tradeNotes += ` | Bracket: SL=$${stopLossPrice?.toFixed(2)}, TP=$${takeProfitPrice?.toFixed(2)}`;
          }
          const trade = await storage.createTrade({
            symbol: symbol.toUpperCase(),
            side,
            quantity: quantity.toString(),
            price: filledPrice.toString(),
            strategyId: strategyId || null,
            status: order.status,
            notes: tradeNotes,
            pnl: null
          });
          await this.updateAgentStats();
          const tradeEvent = {
            tradeId: trade.id,
            orderId: order.id,
            symbol: symbol.toUpperCase(),
            side,
            quantity,
            price: filledPrice,
            status: order.status,
            strategyId
          };
          eventBus.emit("trade:executed", tradeEvent, "order-executor");
          logger.trade(`Executed ${side} ${quantity} ${symbol} @ $${filledPrice}`, {
            orderId: order.id,
            status: order.status
          });
          if (side === "buy" && order.status === "filled" && !shouldUseBracketOrder && !isCrypto && !extendedHours) {
            try {
              const entryPrice = filledPrice || limitPrice || 0;
              const stopLossPrice2 = entryPrice * 0.98;
              logger.info("Trading", `Creating automated stop-loss for ${symbol}`, {
                entryPrice,
                stopLossPrice: stopLossPrice2.toFixed(2),
                quantity
              });
              const stopLossOrder = await alpaca.createOrder({
                symbol: alpacaSymbol,
                qty: quantity.toString(),
                side: "sell",
                type: "stop",
                stop_price: stopLossPrice2.toFixed(2),
                time_in_force: "gtc"
              });
              await storage.updateTrade(trade.id, {
                notes: `${tradeNotes} | Stop-Loss: Order ${stopLossOrder.id} @ $${stopLossPrice2.toFixed(2)}`
              });
              logger.info("Trading", `Automated stop-loss created for ${symbol}`, {
                stopLossOrderId: stopLossOrder.id,
                stopLossPrice: stopLossPrice2.toFixed(2),
                tradeId: trade.id
              });
            } catch (stopLossError) {
              logger.error(
                "Trading",
                `Failed to create automated stop-loss for ${symbol}`,
                {
                  error: stopLossError.message,
                  tradeId: trade.id
                }
              );
            }
          }
          return { success: true, order, trade };
        } catch (error) {
          const errorMsg = error.message;
          logger.error(
            "Trading",
            `Trade execution FAILED for ${request.symbol}: ${errorMsg}`,
            {
              symbol: request.symbol,
              side: request.side,
              quantity: request.quantity,
              orderType: request.orderType,
              useBracketOrder: request.useBracketOrder,
              error: errorMsg
            }
          );
          eventBus.emit(
            "trade:error",
            {
              symbol: request.symbol,
              side: request.side,
              quantity: request.quantity,
              message: errorMsg,
              orderType: request.orderType,
              useBracketOrder: request.useBracketOrder
            },
            "order-executor"
          );
          return { success: false, error: errorMsg };
        }
      }
      /**
       * Update agent statistics after trade execution
       *
       * Calculates and updates key trading performance metrics:
       * - Total number of trades
       * - Total realized P&L (profit/loss)
       * - Win rate percentage
       * - Last heartbeat timestamp
       *
       * @private
       * @returns Promise that resolves when stats are updated
       *
       * @note Only counts trades with non-null, non-zero P&L for win rate calculation
       */
      async updateAgentStats() {
        try {
          const trades3 = await storage.getTrades(void 0, 1e3);
          const closingTrades = trades3.filter(
            (t) => t.pnl !== null && t.pnl !== "0"
          );
          const totalRealizedPnl = closingTrades.reduce(
            (sum, t) => sum + safeParseFloat(t.pnl, 0),
            0
          );
          const winningTrades = closingTrades.filter(
            (t) => safeParseFloat(t.pnl, 0) > 0
          );
          const winRate = closingTrades.length > 0 ? winningTrades.length / closingTrades.length * 100 : 0;
          await storage.updateAgentStatus({
            totalTrades: trades3.length,
            totalPnl: totalRealizedPnl.toString(),
            winRate: winRate.toString(),
            lastHeartbeat: /* @__PURE__ */ new Date()
          });
        } catch (error) {
          log.error("OrderExecutor", "Failed to update agent stats", {
            error: error.message
          });
        }
      }
    };
    orderExecutor = new OrderExecutor();
  }
});

// server/trading/position-manager.ts
var PositionManager, positionManager;
var init_position_manager = __esm({
  "server/trading/position-manager.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_orchestration2();
    init_logger();
    init_money();
    init_numeric();
    init_symbol_normalizer();
    PositionManager = class {
      orchestratorControlEnabled = false;
      /**
       * Enable or disable orchestrator control mode
       *
       * When enabled, all position operations must be authorized by the orchestrator
       * to prevent conflicting autonomous actions.
       *
       * @param enabled - Whether orchestrator control should be enabled
       */
      setOrchestratorControl(enabled) {
        this.orchestratorControlEnabled = enabled;
      }
      /**
       * Check if orchestrator control is currently enabled
       *
       * @returns True if orchestrator control is active
       */
      isOrchestratorControlEnabled() {
        return this.orchestratorControlEnabled;
      }
      /**
       * Close a position in Alpaca with loss protection
       *
       * Closes an open position, calculating P&L and creating a trade record.
       * Includes loss protection that prevents closing positions at a loss unless
       * it's an emergency stop or stop-loss trigger.
       *
       * Extracted from lines 703-805 of alpaca-trading-engine.ts
       *
       * @param symbol - Stock symbol or crypto pair to close
       * @param strategyId - Optional strategy ID for tracking
       * @param options - Closing options
       * @param options.isStopLossTriggered - True if this is a stop-loss execution (bypasses loss protection)
       * @param options.isEmergencyStop - True if this is an emergency stop (bypasses loss protection)
       * @param options.authorizedByOrchestrator - SECURITY: Must be true if orchestrator control is enabled
       *
       * @returns Promise resolving to trade result with order and trade details
       *
       * @example Normal position close
       * ```typescript
       * const result = await positionManager.closeAlpacaPosition("AAPL", "strategy-123", {
       *   authorizedByOrchestrator: true
       * });
       * ```
       *
       * @example Emergency stop (bypasses loss protection)
       * ```typescript
       * const result = await positionManager.closeAlpacaPosition("TSLA", undefined, {
       *   isEmergencyStop: true
       * });
       * ```
       *
       * @lossProtection This method implements loss protection:
       * - Calculates current P&L by comparing entry price vs current price
       * - If position is at a loss AND not a stop-loss/emergency stop, blocks the close
       * - Returns error with loss percentage to inform user
       * - Exception: Stop-loss triggers and emergency stops always execute
       *
       * @note For crypto symbols, automatically converts to slash format (e.g., "BTC/USD")
       * @note Handles 404 errors gracefully if position is already closed
       */
      async closeAlpacaPosition(symbol, strategyId, options = {}) {
        try {
          if (this.orchestratorControlEnabled && !options.authorizedByOrchestrator && !options.isEmergencyStop) {
            log.warn(
              "PositionManager",
              "Position close blocked - orchestrator has control",
              { symbol }
            );
            return {
              success: false,
              error: "Orchestrator control active - direct position close blocked. Must go through work queue or be an emergency stop."
            };
          }
          const alpacaSymbol = isCryptoSymbol(symbol) ? normalizeCryptoSymbol(symbol) : normalizeSymbolForAlpaca(symbol);
          let position = null;
          try {
            position = await alpaca.getPosition(alpacaSymbol);
          } catch (posError) {
            const errorMsg = posError.message?.toLowerCase() || "";
            if (errorMsg.includes("404") || errorMsg.includes("not found") || errorMsg.includes("position does not exist")) {
              return {
                success: true,
                error: `Position for ${symbol} already closed or does not exist`
              };
            }
            throw posError;
          }
          if (!position) {
            return {
              success: true,
              error: `No position found for ${symbol} - may already be closed`
            };
          }
          const entryPrice = safeParseFloat(position.avg_entry_price);
          const currentPrice = safeParseFloat(position.current_price);
          const isAtLoss = currentPrice < entryPrice;
          const isProtectedClose = options.isStopLossTriggered || options.isEmergencyStop;
          if (isAtLoss && !isProtectedClose) {
            const lossPercentDecimal = percentChange(
              currentPrice,
              entryPrice
            ).abs();
            const lossPercent = formatPrice(lossPercentDecimal, 2);
            log.warn(
              "LossProtection",
              "Blocking close at loss - waiting for stop-loss or price recovery",
              { symbol, lossPercent: lossPercentDecimal.toNumber() }
            );
            return {
              success: false,
              error: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`
            };
          }
          let order;
          try {
            order = await alpaca.closePosition(alpacaSymbol);
          } catch (closeError) {
            const errorMsg = closeError.message?.toLowerCase() || "";
            if (errorMsg.includes("404") || errorMsg.includes("not found") || errorMsg.includes("position does not exist")) {
              return {
                success: true,
                error: `Position for ${symbol} was already closed`
              };
            }
            throw closeError;
          }
          const quantity = safeParseFloat(position.qty);
          const exitPrice = safeParseFloat(
            order.filled_avg_price || position.current_price
          );
          const isShort = position.side === "short";
          const pnl = calculatePnL(
            entryPrice,
            exitPrice,
            quantity,
            isShort ? "short" : "long"
          );
          const tradeSide = isShort ? "buy" : "sell";
          const trade = await storage.createTrade({
            symbol: symbol.toUpperCase(),
            side: tradeSide,
            quantity: quantity.toString(),
            price: exitPrice.toString(),
            strategyId: strategyId || null,
            status: "completed",
            notes: `Closed Alpaca ${position.side} position. Order ID: ${order.id}`,
            pnl: pnl.toString()
          });
          await this.updateAgentStats();
          const positionEvent = {
            symbol: symbol.toUpperCase(),
            quantity: 0,
            entryPrice,
            currentPrice: exitPrice,
            unrealizedPnl: 0,
            side: isShort ? "short" : "long"
          };
          eventBus.emit("position:closed", positionEvent, "position-manager");
          log.info(
            "PositionManager",
            `Closed ${position.side} position ${symbol}`,
            { pnl, exitPrice }
          );
          return { success: true, order, trade };
        } catch (error) {
          log.error("PositionManager", "Close Alpaca position error", {
            symbol,
            error: error.message
          });
          eventBus.emit(
            "trade:error",
            { message: error.message },
            "position-manager"
          );
          return { success: false, error: error.message };
        }
      }
      /**
       * Reconcile positions between Alpaca and database
       *
       * Compares positions in Alpaca broker account with local database records
       * and identifies any discrepancies that need to be synchronized.
       *
       * Extracted from lines 1661-1727 of alpaca-trading-engine.ts
       *
       * @returns Promise resolving to reconciliation report with positions and discrepancies
       * @returns result.alpacaPositions - Current positions in Alpaca
       * @returns result.dbPositions - Current positions in database
       * @returns result.discrepancies - List of differences requiring sync
       * @returns result.synced - True if no discrepancies found
       *
       * @example
       * ```typescript
       * const report = await positionManager.reconcilePositions();
       *
       * if (!report.synced) {
       *   console.log("Found discrepancies:", report.discrepancies);
       *   // Discrepancies might include:
       *   // - { symbol: "AAPL", action: "create_in_db" } - exists in Alpaca but not DB
       *   // - { symbol: "TSLA", action: "update_db_quantity" } - quantity mismatch
       *   // - { symbol: "MSFT", action: "remove_from_db" } - exists in DB but not Alpaca
       * }
       * ```
       *
       * @note This is a read-only operation - use syncPositionsFromAlpaca() to apply fixes
       */
      async reconcilePositions() {
        const alpacaPositions = await alpaca.getPositions();
        const dbPositions = await storage.getPositions();
        const alpacaMap = new Map(
          alpacaPositions.map((p) => [p.symbol.toUpperCase(), p])
        );
        const dbMap = new Map(dbPositions.map((p) => [p.symbol.toUpperCase(), p]));
        const discrepancies = [];
        for (const [symbol, alpacaPos] of alpacaMap) {
          const dbPos = dbMap.get(symbol);
          if (!dbPos) {
            discrepancies.push({
              symbol,
              alpacaQty: alpacaPos.qty,
              dbQty: "0",
              action: "create_in_db"
            });
          } else if (alpacaPos.qty !== dbPos.quantity) {
            discrepancies.push({
              symbol,
              alpacaQty: alpacaPos.qty,
              dbQty: dbPos.quantity,
              action: "update_db_quantity"
            });
          }
        }
        for (const [symbol, dbPos] of dbMap) {
          if (!alpacaMap.has(symbol)) {
            discrepancies.push({
              symbol,
              alpacaQty: "0",
              dbQty: dbPos.quantity,
              action: "remove_from_db"
            });
          }
        }
        log.info("Reconciliation", "Position reconciliation complete", {
          discrepancies: discrepancies.length
        });
        return {
          alpacaPositions: alpacaPositions.map((p) => ({
            symbol: p.symbol,
            qty: p.qty,
            side: p.side,
            marketValue: p.market_value,
            unrealizedPnl: p.unrealized_pl
          })),
          dbPositions: dbPositions.map((p) => ({
            id: p.id,
            symbol: p.symbol,
            quantity: p.quantity
          })),
          discrepancies,
          synced: discrepancies.length === 0
        };
      }
      /**
       * Sync positions from Alpaca to database
       *
       * Synchronizes all positions from Alpaca broker to local database.
       * Creates missing positions, updates existing ones, and removes stale positions.
       *
       * Extracted from lines 1729-1811 of alpaca-trading-engine.ts
       *
       * @param userId - Optional user ID (defaults to admin user for system-level sync)
       *
       * @returns Promise resolving to sync report
       * @returns result.created - Array of symbols for newly created positions
       * @returns result.updated - Array of symbols for updated positions
       * @returns result.removed - Array of symbols for removed positions
       * @returns result.errors - Array of errors encountered during sync
       *
       * @example System-level sync (uses admin user)
       * ```typescript
       * const result = await positionManager.syncPositionsFromAlpaca();
       * console.log(`Created: ${result.created.length}, Updated: ${result.updated.length}`);
       * ```
       *
       * @example User-specific sync
       * ```typescript
       * const result = await positionManager.syncPositionsFromAlpaca("user-123");
       * ```
       *
       * @note This applies the fixes identified by reconcilePositions()
       * @note If no userId provided, uses admin user from database
       */
      async syncPositionsFromAlpaca(userId) {
        const created = [];
        const updated = [];
        const removed = [];
        const errors = [];
        try {
          const alpacaPositions = await alpaca.getPositions();
          let effectiveUserId = userId;
          if (!effectiveUserId) {
            const adminUser = await storage.getUserByUsername("admintest");
            if (!adminUser) {
              throw new Error("No admin user found for system-level position sync");
            }
            effectiveUserId = adminUser.id;
            log.info("Sync", "Using admin user for system-level sync", {
              username: adminUser.username
            });
          }
          const dbPositions = await storage.getPositions(effectiveUserId);
          const alpacaMap = new Map(
            alpacaPositions.map((p) => [p.symbol.toUpperCase(), p])
          );
          const dbMap = new Map(
            dbPositions.map((p) => [p.symbol.toUpperCase(), p])
          );
          for (const [symbol, alpacaPos] of alpacaMap) {
            try {
              const dbPos = dbMap.get(symbol);
              if (!dbPos) {
                await storage.createPosition({
                  userId: effectiveUserId,
                  symbol: alpacaPos.symbol,
                  side: alpacaPos.side,
                  quantity: alpacaPos.qty,
                  entryPrice: alpacaPos.avg_entry_price,
                  currentPrice: alpacaPos.current_price,
                  unrealizedPnl: alpacaPos.unrealized_pl,
                  strategyId: null
                });
                created.push(symbol);
                log.info("Sync", "Created position", {
                  symbol,
                  userId: effectiveUserId
                });
              } else {
                await storage.updatePosition(dbPos.id, {
                  quantity: alpacaPos.qty,
                  currentPrice: alpacaPos.current_price,
                  unrealizedPnl: alpacaPos.unrealized_pl
                });
                updated.push(symbol);
              }
            } catch (err) {
              errors.push({ symbol, error: err.message });
            }
          }
          for (const [symbol, dbPos] of dbMap) {
            if (!alpacaMap.has(symbol)) {
              try {
                await storage.deletePosition(dbPos.id);
                removed.push(symbol);
                log.info("Sync", "Removed stale position", { symbol });
              } catch (err) {
                errors.push({ symbol, error: err.message });
              }
            }
          }
          log.info("Sync", "Position sync completed", {
            created: created.length,
            updated: updated.length,
            removed: removed.length
          });
        } catch (err) {
          log.error("Sync", "Failed to sync positions", {
            error: err.message
          });
          throw err;
        }
        return { created, updated, removed, errors };
      }
      /**
       * Sync orders from Alpaca to database (fixes TE-003)
       *
       * Fetches recent orders from Alpaca and creates missing records in the database.
       * This ensures order records persist across server restarts and aren't lost.
       *
       * TE-003 FIX: Bi-directional order sync
       * - Problem: Orders placed in Alpaca but not in DB after restart
       * - Solution: Poll Alpaca orders and sync to database
       * - Run this on server startup to restore order state
       *
       * @param userId - Optional user ID (defaults to admin user for system-level sync)
       * @param limit - Number of recent orders to sync (default: 100)
       *
       * @returns Promise resolving to sync report
       * @returns result.created - Array of order IDs for newly created orders
       * @returns result.skipped - Array of order IDs that already exist
       * @returns result.errors - Array of errors encountered during sync
       *
       * @example System-level sync (uses admin user)
       * ```typescript
       * const result = await positionManager.syncOrdersFromAlpaca();
       * console.log(`Created: ${result.created.length}, Skipped: ${result.skipped.length}`);
       * ```
       *
       * @example Sync recent 50 orders
       * ```typescript
       * const result = await positionManager.syncOrdersFromAlpaca(undefined, 50);
       * ```
       *
       * @note Run on server startup to restore order state from Alpaca
       * @note Only syncs orders that don't already exist in database
       * @note Uses broker_order_id (Alpaca's order.id) for deduplication
       */
      async syncOrdersFromAlpaca(userId, limit4 = 100) {
        const created = [];
        const skipped = [];
        const errors = [];
        try {
          const alpacaOrders = await alpaca.getOrders("all", limit4);
          let effectiveUserId = userId;
          if (!effectiveUserId) {
            const adminUser = await storage.getUserByUsername("admintest");
            if (!adminUser) {
              throw new Error("No admin user found for system-level order sync");
            }
            effectiveUserId = adminUser.id;
            log.info("OrderSync", "Using admin user for system-level sync", {
              username: adminUser.username
            });
          }
          log.info("OrderSync", "Starting order sync from Alpaca", {
            orderCount: alpacaOrders.length,
            userId: effectiveUserId
          });
          for (const alpacaOrder of alpacaOrders) {
            try {
              const existingOrder = await storage.getOrderByBrokerOrderId(
                alpacaOrder.id
              );
              if (existingOrder) {
                skipped.push(alpacaOrder.id);
                continue;
              }
              await storage.createOrder({
                userId: effectiveUserId,
                broker: "alpaca",
                symbol: alpacaOrder.symbol,
                side: alpacaOrder.side,
                qty: alpacaOrder.qty,
                limitPrice: alpacaOrder.limit_price || void 0,
                stopPrice: alpacaOrder.stop_price || void 0,
                type: alpacaOrder.order_type,
                status: this.mapAlpacaOrderStatus(alpacaOrder.status),
                brokerOrderId: alpacaOrder.id,
                clientOrderId: alpacaOrder.client_order_id,
                submittedAt: new Date(alpacaOrder.submitted_at),
                updatedAt: new Date(
                  alpacaOrder.updated_at || alpacaOrder.submitted_at
                ),
                // Optional fields
                filledQty: alpacaOrder.filled_qty || void 0,
                filledAvgPrice: alpacaOrder.filled_avg_price || void 0,
                timeInForce: alpacaOrder.time_in_force || void 0,
                orderClass: alpacaOrder.order_class || void 0,
                extendedHours: alpacaOrder.extended_hours || false
              });
              created.push(alpacaOrder.id);
              log.debug("OrderSync", "Created order", {
                orderId: alpacaOrder.id,
                symbol: alpacaOrder.symbol,
                status: alpacaOrder.status
              });
            } catch (err) {
              const errorMsg = err.message;
              errors.push({ orderId: alpacaOrder.id, error: errorMsg });
              log.error("OrderSync", "Failed to sync order", {
                orderId: alpacaOrder.id,
                error: errorMsg
              });
            }
          }
          log.info("OrderSync", "Order sync completed", {
            created: created.length,
            skipped: skipped.length,
            errors: errors.length
          });
        } catch (err) {
          log.error("OrderSync", "Failed to sync orders from Alpaca", {
            error: err.message
          });
          throw err;
        }
        return { created, skipped, errors };
      }
      /**
       * Map Alpaca order status to our database status
       *
       * @private
       */
      mapAlpacaOrderStatus(alpacaStatus) {
        const statusMap = {
          new: "pending",
          accepted: "pending",
          pending_new: "pending",
          accepted_for_bidding: "pending",
          stopped: "pending",
          rejected: "rejected",
          pending_cancel: "open",
          pending_replace: "open",
          partially_filled: "open",
          filled: "filled",
          done_for_day: "filled",
          canceled: "cancelled",
          expired: "cancelled",
          replaced: "cancelled",
          suspended: "cancelled",
          calculated: "filled"
        };
        return statusMap[alpacaStatus.toLowerCase()] || "pending";
      }
      /**
       * Close all positions in Alpaca
       *
       * Closes all open positions in the broker account and creates trade records for each.
       * Includes orchestrator control check to prevent unauthorized mass closures.
       *
       * Extracted from lines 1813-1887 of alpaca-trading-engine.ts
       *
       * @param options - Closing options
       * @param options.authorizedByOrchestrator - SECURITY: Must be true if orchestrator control is enabled
       * @param options.isEmergencyStop - True if this is an emergency stop (bypasses orchestrator control)
       *
       * @returns Promise resolving to close-all report
       * @returns result.closed - Array of closed positions with symbols, quantities, and P&L
       * @returns result.tradesCreated - Number of trade records created
       * @returns result.errors - Array of errors encountered during closing
       *
       * @example Close all positions (requires authorization)
       * ```typescript
       * const result = await positionManager.closeAllPositions({
       *   authorizedByOrchestrator: true
       * });
       *
       * console.log(`Closed ${result.closed.length} positions`);
       * result.closed.forEach(pos => {
       *   console.log(`${pos.symbol}: P&L $${pos.pnl}`);
       * });
       * ```
       *
       * @example Emergency stop (bypasses orchestrator)
       * ```typescript
       * const result = await positionManager.closeAllPositions({
       *   isEmergencyStop: true
       * });
       * ```
       *
       * @note Automatically syncs positions after closing
       * @note Updates agent statistics after completion
       * @note Continues closing remaining positions even if some fail
       */
      async closeAllPositions(options = {}) {
        if (this.orchestratorControlEnabled && !options.authorizedByOrchestrator && !options.isEmergencyStop) {
          log.warn(
            "PositionManager",
            "Close all positions blocked - orchestrator has control"
          );
          return {
            closed: [],
            tradesCreated: 0,
            errors: [
              {
                symbol: "ALL",
                error: "Orchestrator control active - close all blocked. Use emergency stop or go through orchestrator."
              }
            ]
          };
        }
        const closed = [];
        const errors = [];
        let tradesCreated = 0;
        try {
          const positions2 = await alpaca.getPositions();
          for (const position of positions2) {
            try {
              const qty = safeParseFloat(position.qty);
              const entryPrice = safeParseFloat(position.avg_entry_price);
              const currentPrice = safeParseFloat(position.current_price);
              const isShort = position.side === "short";
              const order = await alpaca.closePosition(position.symbol);
              const exitPrice = order.filled_avg_price ? safeParseFloat(order.filled_avg_price) : currentPrice;
              const realizedPnl = calculatePnL(
                entryPrice,
                exitPrice,
                qty,
                isShort ? "short" : "long"
              );
              const tradeSide = isShort ? "buy" : "sell";
              await storage.createTrade({
                symbol: position.symbol,
                side: tradeSide,
                quantity: position.qty,
                price: exitPrice.toString(),
                strategyId: null,
                status: "completed",
                notes: `Closed all positions (${position.side}). Order ID: ${order.id}. Entry: $${entryPrice.toFixed(2)}, Exit: $${exitPrice.toFixed(2)}`,
                pnl: realizedPnl.toString()
              });
              tradesCreated++;
              closed.push({
                symbol: position.symbol,
                qty: position.qty,
                pnl: realizedPnl.toFixed(2)
              });
              log.info("Reconciliation", "Closed position", {
                symbol: position.symbol,
                side: position.side,
                qty,
                pnl: realizedPnl.toFixed(2)
              });
            } catch (err) {
              errors.push({
                symbol: position.symbol,
                error: err.message
              });
            }
          }
          await this.syncPositionsFromAlpaca();
          await this.updateAgentStats();
          log.info("Reconciliation", "Close all positions complete", {
            closed: closed.length,
            tradesCreated,
            errors: errors.length
          });
        } catch (err) {
          log.error("Reconciliation", "Failed to close all positions", {
            error: err.message
          });
          throw err;
        }
        return { closed, tradesCreated, errors };
      }
      /**
       * Get current portfolio allocations
       *
       * Calculates current portfolio allocation percentages and values for all positions.
       * Includes cash as a position for complete portfolio view.
       *
       * Extracted from lines 1897-1943 of alpaca-trading-engine.ts
       *
       * @returns Promise resolving to portfolio allocation report
       * @returns result.allocations - Array of allocations with percentages and values
       * @returns result.portfolioValue - Total portfolio value (positions + cash)
       * @returns result.cashBalance - Current cash balance
       *
       * @example
       * ```typescript
       * const { allocations, portfolioValue, cashBalance } = await positionManager.getCurrentAllocations();
       *
       * console.log(`Total Portfolio Value: $${portfolioValue.toFixed(2)}`);
       * console.log(`Cash: $${cashBalance.toFixed(2)}\n`);
       *
       * allocations.forEach(alloc => {
       *   if (alloc.symbol !== "CASH") {
       *     console.log(`${alloc.symbol}: ${alloc.currentPercent.toFixed(1)}% ($${alloc.currentValue.toFixed(2)})`);
       *     console.log(`  Quantity: ${alloc.quantity} @ $${alloc.price.toFixed(2)}/share`);
       *   }
       * });
       * ```
       *
       * @note Allocations array includes CASH as the last entry
       * @note Percentages are calculated as (position value / total portfolio value) * 100
       */
      async getCurrentAllocations() {
        const account = await alpaca.getAccount();
        const positions2 = await alpaca.getPositions();
        const cashBalance = safeParseFloat(account.cash);
        let positionsValue = 0;
        const allocations = [];
        for (const position of positions2) {
          const marketValue = safeParseFloat(position.market_value);
          const quantity = safeParseFloat(position.qty);
          const price = safeParseFloat(position.current_price);
          positionsValue += marketValue;
          allocations.push({
            symbol: position.symbol.toUpperCase(),
            currentPercent: 0,
            currentValue: marketValue,
            quantity,
            price
          });
        }
        const portfolioValue = cashBalance + positionsValue;
        for (const allocation of allocations) {
          allocation.currentPercent = portfolioValue > 0 ? allocation.currentValue / portfolioValue * 100 : 0;
        }
        allocations.push({
          symbol: "CASH",
          currentPercent: portfolioValue > 0 ? cashBalance / portfolioValue * 100 : 100,
          currentValue: cashBalance,
          quantity: cashBalance,
          price: 1
        });
        return { allocations, portfolioValue, cashBalance };
      }
      /**
       * Update agent statistics after position operations
       *
       * Calculates and updates key trading performance metrics:
       * - Total number of trades
       * - Total realized P&L (profit/loss)
       * - Win rate percentage
       * - Last heartbeat timestamp
       *
       * Extracted from lines 1529-1551 of alpaca-trading-engine.ts
       *
       * @private
       * @returns Promise that resolves when stats are updated
       *
       * @note Only counts trades with non-null, non-zero P&L for win rate calculation
       */
      async updateAgentStats() {
        try {
          const trades3 = await storage.getTrades(void 0, 1e3);
          const closingTrades = trades3.filter(
            (t) => t.pnl !== null && t.pnl !== "0"
          );
          const totalRealizedPnl = closingTrades.reduce(
            (sum, t) => sum + safeParseFloat(t.pnl, 0),
            0
          );
          const winningTrades = closingTrades.filter(
            (t) => safeParseFloat(t.pnl, 0) > 0
          );
          const winRate = closingTrades.length > 0 ? winningTrades.length / closingTrades.length * 100 : 0;
          await storage.updateAgentStatus({
            totalTrades: trades3.length,
            totalPnl: totalRealizedPnl.toString(),
            winRate: winRate.toString(),
            lastHeartbeat: /* @__PURE__ */ new Date()
          });
        } catch (error) {
          log.error("PositionManager", "Failed to update agent stats", {
            error: error.message
          });
        }
      }
    };
    positionManager = new PositionManager();
  }
});

// server/trading/strategy-runner.ts
var StrategyRunner, strategyRunner;
var init_strategy_runner = __esm({
  "server/trading/strategy-runner.ts"() {
    "use strict";
    init_storage();
    init_orchestration2();
    init_logger();
    init_orchestrator_controller();
    init_llmGateway();
    StrategyRunner = class {
      strategyRunners = /* @__PURE__ */ new Map();
      strategyStates = /* @__PURE__ */ new Map();
      checkIntervalMs = 6e4;
      backgroundGeneratorInterval = null;
      backgroundGeneratorIntervalMs = 12e4;
      autoStartStrategyId = null;
      /**
       * Set the auto-start strategy ID
       *
       * Configures which strategy should automatically start when the agent resumes.
       * Typically this is the Auto-Pilot Strategy for autonomous trading.
       *
       * @param strategyId - ID of the strategy to auto-start
       */
      setAutoStartStrategyId(strategyId) {
        this.autoStartStrategyId = strategyId;
      }
      /**
       * Get the auto-start strategy ID
       *
       * @returns The strategy ID that will auto-start, or null if not configured
       */
      getAutoStartStrategyId() {
        return this.autoStartStrategyId;
      }
      /**
       * Start a strategy - analyzes assets on an interval
       *
       * Starts a strategy that will analyze and trade its configured assets on a regular interval.
       * The strategy runs immediately once, then on the configured interval (default 60 seconds).
       *
       * @param strategyId - ID of the strategy to start
       * @param analyzeAndExecuteCallback - Callback to analyze and execute trades for a symbol
       *   - Called for each asset in the strategy
       *   - Receives: symbol, strategyId, traceId
       *   - Returns: { decision: AIDecision, tradeResult?: any }
       *
       * @returns Promise resolving to success result with optional error
       *
       * @example
       * ```typescript
       * const result = await strategyRunner.startStrategy(
       *   "strategy-123",
       *   async (symbol, strategyId, traceId) => {
       *     // Analyze the symbol with AI
       *     const analysis = await aiAnalyzer.analyzeSymbol(symbol, strategyId, traceId);
       *
       *     // Execute trade if AI recommends it
       *     if (analysis.decision.action === "buy") {
       *       const trade = await orderExecutor.executeAlpacaTrade({ ... });
       *       return { decision: analysis.decision, tradeResult: trade };
       *     }
       *
       *     return { decision: analysis.decision };
       *   }
       * );
       *
       * if (!result.success) {
       *   console.error("Failed to start strategy:", result.error);
       * }
       * ```
       *
       * @validationChecks Performs several validation checks before starting:
       * 1. Strategy exists in database
       * 2. Strategy has at least one asset configured
       * 3. Kill switch is not active
       * 4. Strategy is not already running
       * 5. Orchestrator control is not enabled (would block autonomous execution)
       *
       * @strategyLifecycle Strategy lifecycle:
       * 1. Validates strategy and system state
       * 2. Marks strategy as active in database
       * 3. Runs analysis immediately for all assets
       * 4. Sets up interval for subsequent runs (every 60 seconds)
       * 5. Updates strategy state map with results
       * 6. Emits "strategy:started" event
       *
       * @note Strategy will auto-stop if kill switch is activated or strategy is deactivated
       */
      async startStrategy(strategyId, analyzeAndExecuteCallback) {
        const strategy = await storage.getStrategy(strategyId);
        if (!strategy) {
          return { success: false, error: "Strategy not found" };
        }
        if (!strategy.assets || strategy.assets.length === 0) {
          return {
            success: false,
            error: "Strategy has no assets configured. Please add at least one symbol/asset to trade before starting the strategy."
          };
        }
        const agentStatus2 = await storage.getAgentStatus();
        if (agentStatus2?.killSwitchActive) {
          return {
            success: false,
            error: "Kill switch is active - trading disabled"
          };
        }
        if (this.strategyRunners.has(strategyId)) {
          return { success: false, error: "Strategy is already running" };
        }
        if (orchestratorController.isOrchestratorControlEnabled()) {
          log.info(
            "StrategyRunner",
            "Strategy start skipped - orchestrator has control",
            { strategyId }
          );
          return {
            success: false,
            error: "Orchestrator has control - autonomous strategy execution disabled. Use orchestrator for trade execution."
          };
        }
        await storage.toggleStrategy(strategyId, true);
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        const runStrategy = async () => {
          try {
            const currentStrategy = await storage.getStrategy(strategyId);
            if (!currentStrategy || !currentStrategy.isActive) {
              this.stopStrategy(strategyId);
              return;
            }
            const agentStatus3 = await storage.getAgentStatus();
            if (agentStatus3?.killSwitchActive) {
              this.stopStrategy(strategyId);
              return;
            }
            const assets = currentStrategy.assets || [];
            let lastSuccessfulDecision;
            let lastError;
            const runTraceId = generateTraceId();
            for (const asset of assets) {
              try {
                const result = await analyzeAndExecuteCallback(
                  asset,
                  strategyId,
                  runTraceId
                );
                lastSuccessfulDecision = result.decision;
              } catch (assetError) {
                const errorMsg = assetError.message || String(assetError);
                log.error("StrategyRunner", "Error analyzing asset", {
                  asset,
                  error: errorMsg
                });
                lastError = `${asset}: ${errorMsg}`;
              }
            }
            this.strategyStates.set(strategyId, {
              strategyId,
              isRunning: true,
              lastCheck: /* @__PURE__ */ new Date(),
              lastDecision: lastSuccessfulDecision,
              error: lastError
            });
            await storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() });
          } catch (error) {
            log.error("StrategyRunner", "Strategy run error", {
              strategyId,
              error: error.message
            });
            this.strategyStates.set(strategyId, {
              strategyId,
              isRunning: true,
              lastCheck: /* @__PURE__ */ new Date(),
              error: error.message
            });
          }
        };
        await runStrategy();
        const interval = setInterval(runStrategy, this.checkIntervalMs);
        this.strategyRunners.set(strategyId, interval);
        this.strategyStates.set(strategyId, {
          strategyId,
          isRunning: true,
          lastCheck: /* @__PURE__ */ new Date()
        });
        eventBus.emit(
          "strategy:started",
          { strategyId, strategyName: strategy.name },
          "strategy-runner"
        );
        logger.strategy(strategy.name, "Started", { assets: strategy.assets });
        return { success: true };
      }
      /**
       * Stop a running strategy
       *
       * Stops a running strategy by clearing its interval timer and marking it inactive.
       * Updates agent running status if this was the last active strategy.
       *
       * @param strategyId - ID of the strategy to stop
       *
       * @returns Promise resolving to success result with optional error
       *
       * @example
       * ```typescript
       * await strategyRunner.stopStrategy("strategy-123");
       * console.log("Strategy stopped");
       * ```
       *
       * @note If no other strategies are running, sets agent isRunning to false
       * @note Emits "strategy:stopped" event
       */
      async stopStrategy(strategyId) {
        const interval = this.strategyRunners.get(strategyId);
        if (interval) {
          clearInterval(interval);
          this.strategyRunners.delete(strategyId);
        }
        const strategy = await storage.getStrategy(strategyId);
        await storage.toggleStrategy(strategyId, false);
        this.strategyStates.set(strategyId, {
          strategyId,
          isRunning: false,
          lastCheck: /* @__PURE__ */ new Date()
        });
        const runningStrategies = await storage.getStrategies();
        const anyActive = runningStrategies.some((s) => s.isActive);
        if (!anyActive) {
          await storage.updateAgentStatus({ isRunning: false });
        }
        eventBus.emit(
          "strategy:stopped",
          { strategyId, strategyName: strategy?.name || strategyId },
          "strategy-runner"
        );
        logger.strategy(strategy?.name || strategyId, "Stopped");
        return { success: true };
      }
      /**
       * Stop all running strategies
       *
       * Stops all currently running strategies and the background AI generator.
       * Sets agent running status to false.
       *
       * @returns Promise that resolves when all strategies are stopped
       *
       * @example
       * ```typescript
       * await strategyRunner.stopAllStrategies();
       * console.log("All strategies stopped");
       * ```
       *
       * @note Also stops the background AI suggestion generator
       */
      async stopAllStrategies() {
        for (const [strategyId] of this.strategyRunners) {
          await this.stopStrategy(strategyId);
        }
        this.stopBackgroundGenerator();
        await storage.updateAgentStatus({ isRunning: false });
      }
      /**
       * Resume the trading agent
       *
       * Restarts the background AI generator and attempts to start the auto-start strategy
       * if Alpaca connection is available.
       *
       * @param isAlpacaConnectedCallback - Callback to check if Alpaca is connected
       * @param backgroundGeneratorCallback - Callback for background AI generation
       *
       * @returns Promise that resolves when agent is resumed
       *
       * @example
       * ```typescript
       * await strategyRunner.resumeAgent(
       *   async () => alpaca.isConnected(),
       *   async () => aiAnalyzer.generateBackgroundSuggestions()
       * );
       * ```
       *
       * @note Sets agent isRunning status to true
       * @note Only starts auto-start strategy if Alpaca is connected
       */
      async resumeAgent(isAlpacaConnectedCallback, backgroundGeneratorCallback) {
        log.info("StrategyRunner", "Resuming trading agent...");
        this.startBackgroundAIGenerator(backgroundGeneratorCallback);
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        if (this.autoStartStrategyId) {
          const isConnected = await isAlpacaConnectedCallback();
          if (isConnected) {
            log.info("StrategyRunner", "Auto-start strategy should be started", {
              strategyId: this.autoStartStrategyId
            });
          }
        }
      }
      /**
       * Get the state of a specific strategy
       *
       * Returns the current run state for a strategy including last check time,
       * last decision, and any errors.
       *
       * @param strategyId - ID of the strategy
       *
       * @returns Strategy state or undefined if not found
       *
       * @example
       * ```typescript
       * const state = strategyRunner.getStrategyState("strategy-123");
       * if (state) {
       *   console.log(`Running: ${state.isRunning}`);
       *   console.log(`Last check: ${state.lastCheck}`);
       *   if (state.error) {
       *     console.error(`Error: ${state.error}`);
       *   }
       * }
       * ```
       */
      getStrategyState(strategyId) {
        return this.strategyStates.get(strategyId);
      }
      /**
       * Get all strategy states
       *
       * Returns an array of all tracked strategy states, both running and stopped.
       *
       * @returns Array of all strategy states
       *
       * @example
       * ```typescript
       * const states = strategyRunner.getAllStrategyStates();
       * states.forEach(state => {
       *   console.log(`${state.strategyId}: ${state.isRunning ? "Running" : "Stopped"}`);
       * });
       * ```
       */
      getAllStrategyStates() {
        return Array.from(this.strategyStates.values());
      }
      /**
       * Get count of currently running strategies
       *
       * @returns Number of strategies with active interval timers
       *
       * @example
       * ```typescript
       * const count = strategyRunner.getRunningStrategiesCount();
       * console.log(`${count} strategies currently running`);
       * ```
       */
      getRunningStrategiesCount() {
        return this.strategyRunners.size;
      }
      /**
       * Get overall status of the strategy runner
       *
       * Provides a complete status report including count of running strategies
       * and detailed state for each tracked strategy.
       *
       * @returns Status object with running strategies count and all strategy states
       *
       * @example
       * ```typescript
       * const status = strategyRunner.getStatus();
       * console.log(`Running: ${status.runningStrategies}`);
       * console.log(`Total tracked: ${status.strategyStates.length}`);
       * ```
       */
      getStatus() {
        const states = this.getAllStrategyStates();
        return {
          runningStrategies: this.strategyRunners.size,
          strategyStates: states
        };
      }
      /**
       * Start the background AI suggestion generator
       *
       * Starts a background process that generates AI trading suggestions on a regular interval.
       * Runs immediately once, then every 120 seconds (2 minutes).
       *
       * @param backgroundGeneratorCallback - Callback for generating background AI suggestions
       *   - Called immediately and then on interval
       *   - Should not throw - errors are logged but don't stop the generator
       *
       * @example
       * ```typescript
       * strategyRunner.startBackgroundAIGenerator(async () => {
       *   const suggestions = await aiAnalyzer.generateSuggestions();
       *   await storage.saveSuggestions(suggestions);
       * });
       * ```
       *
       * @note Clears any existing background generator before starting new one
       * @note Errors in callback are caught and logged, don't stop the generator
       */
      startBackgroundAIGenerator(backgroundGeneratorCallback) {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
        }
        log.info(
          "StrategyRunner",
          "Starting background AI suggestion generator..."
        );
        backgroundGeneratorCallback().catch(
          (err) => log.error("StrategyRunner", "Background AI generation failed", {
            error: err.message
          })
        );
        this.backgroundGeneratorInterval = setInterval(() => {
          backgroundGeneratorCallback().catch(
            (err) => log.error("StrategyRunner", "Background AI generation failed", {
              error: err.message
            })
          );
        }, this.backgroundGeneratorIntervalMs);
      }
      /**
       * Stop the background AI suggestion generator
       *
       * Stops the background AI generator by clearing its interval timer.
       *
       * @example
       * ```typescript
       * strategyRunner.stopBackgroundGenerator();
       * ```
       *
       * @note Safe to call even if generator is not running
       */
      stopBackgroundGenerator() {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
          this.backgroundGeneratorInterval = null;
          log.info("StrategyRunner", "Background AI generator stopped");
        }
      }
    };
    strategyRunner = new StrategyRunner();
  }
});

// server/trading/portfolio-rebalancer.ts
var PortfolioRebalancer, portfolioRebalancer;
var init_portfolio_rebalancer = __esm({
  "server/trading/portfolio-rebalancer.ts"() {
    "use strict";
    init_alpaca();
    init_orchestration2();
    init_money();
    init_numeric();
    PortfolioRebalancer = class {
      /**
       * Preview a rebalance operation without executing trades
       *
       * Calculates what trades would be needed to reach target allocations without
       * actually executing them. Useful for reviewing changes before committing.
       *
       * @param targetAllocations - Target allocation percentages for each symbol
       *   - Array of { symbol, targetPercent } objects
       *   - Total percentages must not exceed 100%
       *   - Remaining percentage becomes cash reserve
       *
       * @param getCurrentAllocationsCallback - Callback to get current portfolio allocations
       *   - Returns { allocations, portfolioValue, cashBalance }
       *
       * @returns Promise resolving to rebalance preview with proposed trades
       *
       * @example
       * ```typescript
       * const preview = await portfolioRebalancer.previewRebalance(
       *   [
       *     { symbol: "AAPL", targetPercent: 30 },
       *     { symbol: "TSLA", targetPercent: 25 }
       *   ],
       *   async () => positionManager.getCurrentAllocations()
       * );
       *
       * console.log(`Portfolio value: $${preview.portfolioValue}`);
       * console.log(`Cash available: $${preview.cashAvailable}`);
       * console.log(`Cash after rebalance: $${preview.cashAfterRebalance}`);
       * console.log(`\nProposed trades:`);
       * preview.proposedTrades.forEach(trade => {
       *   console.log(`${trade.side.toUpperCase()} ${trade.quantity} ${trade.symbol}`);
       *   console.log(`  Value: $${trade.estimatedValue.toFixed(2)}`);
       *   console.log(`  ${trade.currentPercent.toFixed(1)}% -> ${trade.targetPercent}%`);
       * });
       * ```
       *
       * @throws Error if target allocations exceed 100%
       *
       * @note Trades are sorted with sells first, then buys (largest first)
       * @note Trades under $10 value difference are ignored
       * @note Only whole shares are traded (no fractional shares)
       */
      async previewRebalance(targetAllocations, getCurrentAllocationsCallback) {
        const {
          allocations: currentAllocations,
          portfolioValue,
          cashBalance
        } = await getCurrentAllocationsCallback();
        const totalTargetPercent = targetAllocations.reduce(
          (sum, t) => sum + t.targetPercent,
          0
        );
        if (totalTargetPercent > 100) {
          throw new Error(
            `Target allocations sum to ${totalTargetPercent}%, must be <= 100%`
          );
        }
        const proposedTrades = [];
        let estimatedCashChange = 0;
        const currentMap = new Map(
          currentAllocations.filter((a) => a.symbol !== "CASH").map((a) => [a.symbol, a])
        );
        for (const target of targetAllocations) {
          if (target.symbol === "CASH") continue;
          const symbol = target.symbol.toUpperCase();
          const targetValue = toDecimal(target.targetPercent).dividedBy(100).times(portfolioValue);
          const current = currentMap.get(symbol);
          const currentValue = current?.currentValue || 0;
          const currentPercent = current?.currentPercent || 0;
          const currentPrice = current?.price || 0;
          const valueDiff = targetValue.minus(currentValue);
          if (valueDiff.abs().lessThan(10)) continue;
          if (valueDiff.isPositive() && currentPrice > 0) {
            const buyQuantity = calculateWholeShares(
              valueDiff,
              currentPrice
            ).toNumber();
            if (buyQuantity >= 1) {
              const estimatedValue = positionValue(
                buyQuantity,
                currentPrice
              ).toNumber();
              proposedTrades.push({
                symbol,
                side: "buy",
                quantity: buyQuantity,
                estimatedValue,
                currentPercent,
                targetPercent: target.targetPercent,
                reason: `Increase allocation from ${currentPercent.toFixed(1)}% to ${target.targetPercent}%`
              });
              estimatedCashChange -= estimatedValue;
            }
          } else if (valueDiff.isNegative() && currentPrice > 0 && current) {
            const maxSellQty = calculateWholeShares(
              valueDiff.abs(),
              currentPrice
            ).toNumber();
            const sellQuantity = Math.min(maxSellQty, current.quantity);
            if (sellQuantity >= 1) {
              const estimatedValue = positionValue(
                sellQuantity,
                currentPrice
              ).toNumber();
              proposedTrades.push({
                symbol,
                side: "sell",
                quantity: sellQuantity,
                estimatedValue,
                currentPercent,
                targetPercent: target.targetPercent,
                reason: `Decrease allocation from ${currentPercent.toFixed(1)}% to ${target.targetPercent}%`
              });
              estimatedCashChange += estimatedValue;
            }
          }
        }
        for (const [symbol, current] of currentMap) {
          const hasTarget = targetAllocations.some(
            (t) => t.symbol.toUpperCase() === symbol
          );
          if (!hasTarget && current.quantity > 0) {
            proposedTrades.push({
              symbol,
              side: "sell",
              quantity: current.quantity,
              estimatedValue: current.currentValue,
              currentPercent: current.currentPercent,
              targetPercent: 0,
              reason: `Close position - not in target allocation`
            });
            estimatedCashChange += current.currentValue;
          }
        }
        proposedTrades.sort((a, b) => {
          if (a.side === "sell" && b.side === "buy") return -1;
          if (a.side === "buy" && b.side === "sell") return 1;
          return b.estimatedValue - a.estimatedValue;
        });
        const estimatedTradingCost = proposedTrades.length * 0.01;
        return {
          currentAllocations,
          targetAllocations,
          proposedTrades,
          portfolioValue,
          cashAvailable: cashBalance,
          cashAfterRebalance: cashBalance + estimatedCashChange,
          estimatedTradingCost
        };
      }
      /**
       * Execute a portfolio rebalance
       *
       * Executes rebalancing trades in two phases: sells first to free capital, then buys.
       * Tracks all executed trades and any errors that occur.
       *
       * @param targetAllocations - Target allocation percentages for each symbol
       *   - Array of { symbol, targetPercent } objects
       *   - Total must not exceed 100%
       *
       * @param dryRun - If true, preview trades without executing (default: false)
       *
       * @param getCurrentAllocationsCallback - Callback to get current portfolio allocations
       *   - Returns { allocations, portfolioValue, cashBalance }
       *
       * @param executeTradeCallback - Callback to execute individual trades
       *   - Receives trade parameters: { symbol, side, quantity, notes }
       *   - Returns { success, order?, error? }
       *
       * @returns Promise resolving to rebalance result with execution details
       *
       * @example
       * ```typescript
       * const result = await portfolioRebalancer.executeRebalance(
       *   [
       *     { symbol: "AAPL", targetPercent: 30 },
       *     { symbol: "MSFT", targetPercent: 25 },
       *     { symbol: "GOOGL", targetPercent: 20 }
       *   ],
       *   false,
       *   async () => positionManager.getCurrentAllocations(),
       *   async (trade) => orderExecutor.executeAlpacaTrade({
       *     ...trade,
       *     orderType: "market",
       *     authorizedByOrchestrator: true
       *   })
       * );
       *
       * if (result.success) {
       *   console.log(`Rebalance complete: ${result.tradesExecuted.length} trades`);
       *   console.log(`Portfolio: $${result.portfolioValueBefore} -> $${result.portfolioValueAfter}`);
       * } else {
       *   console.error(`Rebalance had ${result.errors.length} errors:`, result.errors);
       * }
       * ```
       *
       * @twoPhaseExecution Executes in two critical phases:
       * 1. **PHASE 1 - SELLS**: Execute all sell orders first
       *    - Frees up capital for subsequent buys
       *    - Reduces over-allocated positions
       *    - Closes positions not in target allocation
       * 2. **2-SECOND PAUSE**: Allow positions to settle
       * 3. **PHASE 2 - BUYS**: Execute buy orders with freed capital
       *    - Refreshes allocations and cash balance first
       *    - Increases under-allocated positions
       *    - Capped at 95% of available cash for safety
       *
       * @note Dry run returns mock trades with "dry_run" status
       * @note Real execution continues even if some trades fail
       * @note Emits "portfolio:rebalanced" event on completion
       */
      async executeRebalance(targetAllocations, dryRun = false, getCurrentAllocationsCallback, executeTradeCallback) {
        const preview = await this.previewRebalance(
          targetAllocations,
          getCurrentAllocationsCallback
        );
        const portfolioValueBefore = safeParseFloat(preview.portfolioValue);
        if (dryRun) {
          return {
            success: true,
            tradesExecuted: preview.proposedTrades.map((t) => ({
              symbol: t.symbol,
              side: t.side,
              quantity: Math.floor(safeParseFloat(t.quantity)),
              status: "dry_run"
            })),
            errors: [],
            portfolioValueBefore,
            portfolioValueAfter: portfolioValueBefore
          };
        }
        const tradesExecuted = [];
        const errors = [];
        const sellTrades = preview.proposedTrades.filter((t) => t.side === "sell");
        for (const trade of sellTrades) {
          try {
            const quantity = Math.floor(safeParseFloat(trade.quantity));
            if (quantity < 1) continue;
            const result = await executeTradeCallback({
              symbol: trade.symbol,
              side: "sell",
              quantity,
              notes: `Rebalance: ${trade.reason}`
            });
            tradesExecuted.push({
              symbol: trade.symbol,
              side: "sell",
              quantity,
              status: result.success ? "executed" : "failed",
              orderId: result.order?.id,
              error: result.error
            });
            if (!result.success) {
              errors.push(`${trade.symbol} sell failed: ${result.error}`);
            }
          } catch (err) {
            const errorMsg = err.message;
            errors.push(`${trade.symbol} sell error: ${errorMsg}`);
            tradesExecuted.push({
              symbol: trade.symbol,
              side: "sell",
              quantity: Math.floor(safeParseFloat(trade.quantity)),
              status: "error",
              error: errorMsg
            });
          }
        }
        if (sellTrades.length > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, 2e3));
        }
        const {
          allocations: refreshedAllocations,
          portfolioValue: refreshedPortfolioValue,
          cashBalance: availableCash
        } = await getCurrentAllocationsCallback();
        const refreshedPositionMap = new Map(
          refreshedAllocations.filter((a) => a.symbol !== "CASH").map((a) => [a.symbol, a])
        );
        for (const target of targetAllocations) {
          if (target.symbol === "CASH") continue;
          const symbol = target.symbol.toUpperCase();
          const targetValue = toDecimal(safeParseFloat(target.targetPercent)).dividedBy(100).times(refreshedPortfolioValue);
          const current = refreshedPositionMap.get(symbol);
          const currentValue = current ? safeParseFloat(current.currentValue) : 0;
          const currentPrice = current ? safeParseFloat(current.price) : 0;
          const valueDiff = targetValue.minus(currentValue);
          if (valueDiff.lessThanOrEqualTo(10) || currentPrice <= 0) continue;
          const maxBuyValue = toDecimal(availableCash).times(0.95).toNumber();
          const maxBuyValueCapped = Math.min(valueDiff.toNumber(), maxBuyValue);
          const buyQuantity = calculateWholeShares(
            maxBuyValueCapped,
            currentPrice
          ).toNumber();
          if (buyQuantity < 1) continue;
          try {
            const result = await executeTradeCallback({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              notes: `Rebalance: Increase allocation to ${target.targetPercent}%`
            });
            tradesExecuted.push({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              status: result.success ? "executed" : "failed",
              orderId: result.order?.id,
              error: result.error
            });
            if (!result.success) {
              errors.push(`${symbol} buy failed: ${result.error}`);
            }
          } catch (err) {
            const errorMsg = err.message;
            errors.push(`${symbol} buy error: ${errorMsg}`);
            tradesExecuted.push({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              status: "error",
              error: errorMsg
            });
          }
        }
        await new Promise((resolve2) => setTimeout(resolve2, 1e3));
        const finalAccount = await alpaca.getAccount();
        const finalPositions = await alpaca.getPositions();
        const cashAfter = safeParseFloat(finalAccount.cash);
        const positionsValueAfter = finalPositions.reduce(
          (sum, p) => sum + safeParseFloat(p.market_value),
          0
        );
        const portfolioValueAfter = cashAfter + positionsValueAfter;
        logger.trade(
          `Rebalance complete: ${tradesExecuted.length} trades, ${errors.length} errors`,
          {
            tradesExecuted: tradesExecuted.length,
            errors: errors.length,
            portfolioValueBefore,
            portfolioValueAfter
          }
        );
        eventBus.emit(
          "portfolio:rebalanced",
          {
            tradesExecuted: tradesExecuted.length,
            errors: errors.length,
            portfolioValueBefore,
            portfolioValueAfter
          },
          "portfolio-rebalancer"
        );
        return {
          success: errors.length === 0,
          tradesExecuted,
          errors,
          portfolioValueBefore,
          portfolioValueAfter
        };
      }
      /**
       * Get suggested rebalance allocations based on current portfolio
       *
       * Generates intelligent rebalancing suggestions based on current holdings.
       * Uses equal-weight strategy across current positions or watchlist.
       *
       * @param getCurrentAllocationsCallback - Callback to get current portfolio allocations
       *   - Returns { allocations, portfolioValue, cashBalance }
       *
       * @param getDefaultWatchlist - Callback to get default watchlist symbols
       *   - Returns array of symbol strings
       *   - Used when no current positions exist
       *
       * @returns Promise resolving to suggestions with current state, targets, and reasoning
       *
       * @example With existing positions
       * ```typescript
       * const suggestions = await portfolioRebalancer.getRebalanceSuggestions(
       *   async () => positionManager.getCurrentAllocations(),
       *   () => ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA"]
       * );
       *
       * console.log(suggestions.reasoning);
       * // "Suggesting equal-weight rebalancing across 3 positions (~26% each) with 20% cash reserve."
       *
       * suggestions.suggestedAllocations.forEach(alloc => {
       *   console.log(`${alloc.symbol}: ${alloc.targetPercent}%`);
       * });
       * ```
       *
       * @example With no positions (uses watchlist)
       * ```typescript
       * const suggestions = await portfolioRebalancer.getRebalanceSuggestions(
       *   async () => ({ allocations: [], portfolioValue: 10000, cashBalance: 10000 }),
       *   () => ["AAPL", "MSFT", "GOOGL", "TSLA", "NVDA"]
       * );
       *
       * console.log(suggestions.reasoning);
       * // "No current positions. Suggesting equal-weight allocation across top 5 watchlist stocks (15% each, 25% cash reserve)."
       * ```
       *
       * @strategyLogic Suggestion strategy:
       * - **No positions**: Equal-weight top 5 watchlist stocks (15% each, 25% cash)
       * - **With positions**: Equal-weight current positions (80% total, 20% cash reserve)
       * - Always maintains 20-25% cash reserve for risk management
       */
      async getRebalanceSuggestions(getCurrentAllocationsCallback, getDefaultWatchlist2) {
        const { allocations: currentAllocations, portfolioValue } = await getCurrentAllocationsCallback();
        const nonCashAllocations = currentAllocations.filter(
          (a) => a.symbol !== "CASH"
        );
        if (nonCashAllocations.length === 0) {
          const defaultWatchlist = getDefaultWatchlist2();
          return {
            currentAllocations,
            suggestedAllocations: defaultWatchlist.slice(0, 5).map((symbol, i) => ({
              symbol,
              targetPercent: 15
            })),
            reasoning: "No current positions. Suggesting equal-weight allocation across top 5 watchlist stocks (15% each, 25% cash reserve)."
          };
        }
        const symbolCount = nonCashAllocations.length;
        const equalWeight = Math.floor(80 / symbolCount);
        const suggestedAllocations = nonCashAllocations.map(
          (a) => ({
            symbol: a.symbol,
            targetPercent: equalWeight
          })
        );
        const allocatedPercent = suggestedAllocations.reduce(
          (sum, a) => sum + a.targetPercent,
          0
        );
        if (allocatedPercent < 80 && suggestedAllocations.length > 0) {
          suggestedAllocations[0].targetPercent += 80 - allocatedPercent;
        }
        return {
          currentAllocations,
          suggestedAllocations,
          reasoning: `Suggesting equal-weight rebalancing across ${symbolCount} positions (~${equalWeight}% each) with 20% cash reserve for risk management.`
        };
      }
    };
    portfolioRebalancer = new PortfolioRebalancer();
  }
});

// server/trading/alpaca-trading-engine.ts
var alpaca_trading_engine_exports = {};
__export(alpaca_trading_engine_exports, {
  alpacaTradingEngine: () => alpacaTradingEngine
});
var AlpacaTradingEngine, alpacaTradingEngine;
var init_alpaca_trading_engine = __esm({
  "server/trading/alpaca-trading-engine.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_llmGateway();
    init_orchestration2();
    init_logger();
    init_order_execution_cache();
    init_order_execution_cache();
    init_symbol_normalizer();
    init_broker_connection();
    init_orchestrator_controller();
    init_ai_analyzer();
    init_order_executor();
    init_position_manager();
    init_strategy_runner();
    init_portfolio_rebalancer();
    AlpacaTradingEngine = class {
      backgroundGeneratorInterval = null;
      backgroundGeneratorIntervalMs = 12e4;
      initialized = false;
      autoStartStrategyId = null;
      // ============================================================================
      // ORCHESTRATOR CONTROL (delegates to orchestrator-controller)
      // ============================================================================
      enableOrchestratorControl() {
        orchestratorController.enableOrchestratorControl();
      }
      disableOrchestratorControl() {
        orchestratorController.disableOrchestratorControl();
      }
      isOrchestratorControlEnabled() {
        return orchestratorController.isOrchestratorControlEnabled();
      }
      // ============================================================================
      // INITIALIZATION & BACKGROUND GENERATOR
      // ============================================================================
      async initialize() {
        if (this.initialized) return;
        this.initialized = true;
        try {
          const strategies2 = await storage.getStrategies();
          let autoPilotStrategy = strategies2.find(
            (s) => s.name === "Auto-Pilot Strategy"
          );
          if (!autoPilotStrategy) {
            log.info(
              "AlpacaTradingEngine",
              "Creating default Auto-Pilot Strategy..."
            );
            autoPilotStrategy = await storage.createStrategy({
              name: "Auto-Pilot Strategy",
              type: "momentum",
              description: "Default AI-powered trading strategy that automatically analyzes market opportunities",
              isActive: true,
              assets: getDefaultWatchlist(),
              parameters: JSON.stringify({
                riskLevel: "medium",
                maxPositionSize: 0.05,
                confidenceThreshold: 0.6,
                autoExecute: true
              })
            });
            log.info("AlpacaTradingEngine", "Created Auto-Pilot Strategy", {
              strategyId: autoPilotStrategy.id
            });
          }
          this.autoStartStrategyId = autoPilotStrategy.id;
          this.startBackgroundAIGenerator();
          await storage.updateAgentStatus({
            isRunning: true,
            lastHeartbeat: /* @__PURE__ */ new Date()
          });
          log.info(
            "AlpacaTradingEngine",
            "Trading agent initialized and active by default"
          );
          this.warmupCaches().catch(
            (err) => log.debug("AlpacaTradingEngine", "Cache warmup skipped", {
              error: err.message
            })
          );
          setTimeout(async () => {
            try {
              const isConnected = await isAlpacaConnected();
              if (isConnected) {
                log.info(
                  "AlpacaTradingEngine",
                  "Alpaca connected, auto-starting all active strategies..."
                );
                const allStrategies = await storage.getStrategies();
                const activeStrategies = allStrategies.filter((s) => s.isActive);
                for (const strategy of activeStrategies) {
                  if (!strategyRunner.getStrategyState(strategy.id)?.isRunning) {
                    log.info("AlpacaTradingEngine", "Auto-starting strategy", {
                      strategyName: strategy.name
                    });
                    const result = await this.startStrategy(strategy.id);
                    if (result.success) {
                      log.info(
                        "AlpacaTradingEngine",
                        "Strategy started successfully",
                        { strategyName: strategy.name }
                      );
                    } else {
                      log.warn("AlpacaTradingEngine", "Could not start strategy", {
                        strategyName: strategy.name,
                        error: result.error
                      });
                    }
                  }
                }
                if (activeStrategies.length === 0 && this.autoStartStrategyId) {
                  log.info(
                    "AlpacaTradingEngine",
                    "No active strategies found, starting Auto-Pilot Strategy..."
                  );
                  const result = await this.startStrategy(this.autoStartStrategyId);
                  if (result.success) {
                    log.info(
                      "AlpacaTradingEngine",
                      "Auto-Pilot Strategy started successfully"
                    );
                  }
                }
              } else {
                log.info(
                  "AlpacaTradingEngine",
                  "Alpaca not connected - running in AI suggestion mode only"
                );
              }
            } catch (err) {
              log.error("AlpacaTradingEngine", "Error during auto-start", {
                error: err.message
              });
            }
          }, 5e3);
        } catch (error) {
          log.error("AlpacaTradingEngine", "Failed to initialize trading engine", {
            error: error.message
          });
        }
      }
      async warmupCaches() {
        log.info("Cache", "Warming up order execution caches...");
        const startTime = Date.now();
        try {
          const account = await alpaca.getAccount();
          cacheAccountSnapshot({
            buyingPower: parseFloat(account.buying_power),
            cash: parseFloat(account.cash),
            equity: parseFloat(account.equity),
            timestamp: Date.now()
          });
          const symbols = getDefaultWatchlist().slice(0, 10);
          const snapshots = await alpaca.getSnapshots(symbols);
          for (const symbol of symbols) {
            const snapshot = snapshots[symbol];
            if (snapshot?.latestTrade) {
              cacheQuickQuote({
                symbol,
                price: snapshot.latestTrade.p,
                bid: snapshot.latestQuote?.bp || snapshot.latestTrade.p,
                ask: snapshot.latestQuote?.ap || snapshot.latestTrade.p,
                spread: (snapshot.latestQuote?.ap || 0) - (snapshot.latestQuote?.bp || 0),
                timestamp: Date.now()
              });
            }
          }
          const assets = await alpaca.getAssets();
          const relevantAssets = assets.filter((a) => symbols.includes(a.symbol));
          for (const asset of relevantAssets) {
            cacheTradability({
              symbol: asset.symbol,
              tradable: asset.tradable,
              fractionable: asset.fractionable,
              shortable: asset.shortable,
              marginable: asset.marginable,
              timestamp: Date.now()
            });
          }
          const elapsed = Date.now() - startTime;
          const stats = getOrderCacheStats();
          log.info("Cache", "Warmup complete", {
            elapsedMs: elapsed,
            quotes: stats.quotes,
            tradability: stats.tradability
          });
        } catch (error) {
          log.warn("Cache", "Warmup failed", { error: error.message });
        }
      }
      startBackgroundAIGenerator() {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
        }
        log.info(
          "AlpacaTradingEngine",
          "Starting background AI suggestion generator..."
        );
        this.generateBackgroundAISuggestions();
        this.backgroundGeneratorInterval = setInterval(
          () => this.generateBackgroundAISuggestions(),
          this.backgroundGeneratorIntervalMs
        );
      }
      async generateBackgroundAISuggestions() {
        try {
          const agentStatus2 = await storage.getAgentStatus();
          if (agentStatus2?.killSwitchActive) {
            log.info(
              "AlpacaTradingEngine",
              "Kill switch active - skipping background AI generation"
            );
            return;
          }
          const batchTraceId = generateTraceId();
          log.info(
            "AlpacaTradingEngine",
            "Generating background AI suggestions...",
            { batchTraceId }
          );
          const symbolsToAnalyze = getDefaultWatchlist().slice(0, 5);
          for (const symbol of symbolsToAnalyze) {
            try {
              await this.analyzeSymbol(symbol, void 0, batchTraceId);
              log.debug("AlpacaTradingEngine", "Generated AI suggestion", {
                symbol
              });
            } catch (err) {
              log.debug("AlpacaTradingEngine", "Could not analyze symbol", {
                symbol,
                error: err.message
              });
            }
            await new Promise((resolve2) => setTimeout(resolve2, 2e3));
          }
          await storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() });
        } catch (error) {
          log.error("AlpacaTradingEngine", "Background AI generation error", {
            error: error.message
          });
        }
      }
      stopBackgroundGenerator() {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
          this.backgroundGeneratorInterval = null;
          log.info("AlpacaTradingEngine", "Background AI generator stopped");
        }
      }
      // ============================================================================
      // BROKER CONNECTION (delegates to broker-connection)
      // ============================================================================
      async isAlpacaConnected() {
        return isAlpacaConnected();
      }
      async getAlpacaAccount() {
        return getAlpacaAccount();
      }
      async getAlpacaPositions() {
        return getAlpacaPositions();
      }
      async getMarketStatus() {
        return getMarketStatus();
      }
      async getClock() {
        return getClock();
      }
      async canTradeExtendedHours(symbol) {
        return canTradeExtendedHours(symbol, isCryptoSymbol);
      }
      // ============================================================================
      // ORDER EXECUTION (delegates to order-executor)
      // ============================================================================
      async executeAlpacaTrade(request) {
        return orderExecutor.executeAlpacaTrade(request);
      }
      // ============================================================================
      // POSITION MANAGEMENT (delegates to position-manager)
      // ============================================================================
      async closeAlpacaPosition(symbol, strategyId, options = {}) {
        return positionManager.closeAlpacaPosition(symbol, strategyId, options);
      }
      async reconcilePositions() {
        return positionManager.reconcilePositions();
      }
      async syncPositionsFromAlpaca(userId) {
        return positionManager.syncPositionsFromAlpaca(userId);
      }
      async closeAllPositions(options = {}) {
        return positionManager.closeAllPositions(options);
      }
      async getOpenOrders() {
        return await alpaca.getOrders("open", 100);
      }
      async getOrderDetails(orderId) {
        return await alpaca.getOrder(orderId);
      }
      async cancelStaleOrders(maxAgeMinutes = 60) {
        const cancelled = [];
        const errors = [];
        const PENDING_ORDER_MAX_AGE_MINUTES = 10;
        const DEFAULT_ORDER_MAX_AGE_MINUTES = maxAgeMinutes;
        try {
          const openOrders = await alpaca.getOrders("open", 100);
          const now = /* @__PURE__ */ new Date();
          for (const order of openOrders) {
            const createdAt = new Date(order.created_at);
            const ageMs = now.getTime() - createdAt.getTime();
            const ageMinutes = ageMs / 6e4;
            if (order.status === "filled" || order.status === "partially_filled") {
              continue;
            }
            const isPendingOrder = order.status === "pending" || order.status === "new" || order.status === "pending_new";
            const effectiveMaxAgeMinutes = isPendingOrder ? PENDING_ORDER_MAX_AGE_MINUTES : DEFAULT_ORDER_MAX_AGE_MINUTES;
            if (ageMinutes > effectiveMaxAgeMinutes) {
              try {
                await alpaca.cancelOrder(order.id);
                cancelled.push(order.id);
                log.info(
                  "AlpacaTradingEngine",
                  `Cancelled stale ${order.status} order`,
                  {
                    orderId: order.id,
                    symbol: order.symbol,
                    ageMinutes: Math.round(ageMinutes),
                    threshold: effectiveMaxAgeMinutes
                  }
                );
              } catch (err) {
                errors.push({ orderId: order.id, error: err.message });
              }
            }
          }
          log.info("AlpacaTradingEngine", "Stale order cancellation complete", {
            cancelled: cancelled.length,
            errors: errors.length
          });
        } catch (err) {
          log.error("AlpacaTradingEngine", "Failed to cancel stale orders", {
            error: err.message
          });
          throw err;
        }
        return { cancelled, errors };
      }
      async cancelAllOpenOrders() {
        try {
          const ordersBefore = await alpaca.getOrders("open", 100);
          const countBefore = ordersBefore.length;
          if (countBefore === 0) {
            log.info("AlpacaTradingEngine", "No open orders to cancel");
            return { cancelled: 0, ordersCancelledBefore: 0, remainingAfter: 0 };
          }
          await alpaca.cancelAllOrders();
          const ordersAfter = await alpaca.getOrders("open", 100);
          const countAfter = ordersAfter.length;
          const cancelledCount = countBefore - countAfter;
          log.info("AlpacaTradingEngine", "Cancelled all open orders", {
            before: countBefore,
            after: countAfter,
            cancelled: cancelledCount
          });
          return {
            cancelled: cancelledCount,
            ordersCancelledBefore: countBefore,
            remainingAfter: countAfter
          };
        } catch (err) {
          log.error("AlpacaTradingEngine", "Failed to cancel all orders", {
            error: err.message
          });
          return {
            cancelled: 0,
            ordersCancelledBefore: 0,
            remainingAfter: 0,
            error: err.message
          };
        }
      }
      // ============================================================================
      // AI ANALYSIS (delegates to ai-analyzer)
      // ============================================================================
      async analyzeSymbol(symbol, strategyId, traceId) {
        return aiAnalyzer.analyzeSymbol(symbol, strategyId, traceId);
      }
      async analyzeAndExecute(symbol, strategyId, traceId) {
        const effectiveTraceId = traceId || generateTraceId();
        const { decision } = await aiAnalyzer.analyzeSymbol(
          symbol,
          strategyId,
          effectiveTraceId
        );
        if (orchestratorController.isOrchestratorControlEnabled()) {
          log.info(
            "AlpacaTradingEngine",
            "Analysis complete - orchestrator has control, skipping autonomous execution",
            {
              symbol,
              action: decision.action,
              confidence: `${(decision.confidence * 100).toFixed(0)}%`
            }
          );
          return { decision };
        }
        const agentStatus2 = await storage.getAgentStatus();
        if (!agentStatus2?.isRunning) {
          return { decision };
        }
        if (decision.action === "hold" || decision.confidence < 0.6) {
          return { decision };
        }
        try {
          const tradeRequest = {
            symbol,
            side: decision.action === "buy" ? "buy" : "sell",
            quantity: decision.suggestedQuantity || 1,
            strategyId,
            notes: `AI Decision: ${decision.reasoning}`
          };
          const tradeResult = await orderExecutor.executeAlpacaTrade(tradeRequest);
          if (tradeResult.success && tradeResult.trade) {
            await aiAnalyzer.linkAiDecisionToTrade(
              symbol,
              strategyId,
              tradeResult.trade.id
            );
          }
          return { decision, tradeResult };
        } catch (error) {
          log.error("AlpacaTradingEngine", "Trade execution failed", {
            symbol,
            error: error.message
          });
          return {
            decision,
            tradeResult: {
              success: false,
              error: error.message
            }
          };
        }
      }
      // ============================================================================
      // STRATEGY MANAGEMENT (delegates to strategy-runner)
      // ============================================================================
      async startStrategy(strategyId) {
        if (orchestratorController.isOrchestratorControlEnabled()) {
          log.info(
            "AlpacaTradingEngine",
            "Strategy start skipped - orchestrator has control",
            { strategyId }
          );
          return {
            success: false,
            error: "Orchestrator has control - autonomous strategy execution disabled. Use orchestrator for trade execution."
          };
        }
        const result = await strategyRunner.startStrategy(
          strategyId,
          (symbol, strategyId2, traceId) => this.analyzeAndExecute(symbol, strategyId2, traceId)
        );
        if (result.success) {
          const strategy = await storage.getStrategy(strategyId);
          eventBus.emit(
            "strategy:started",
            { strategyId, strategyName: strategy?.name || strategyId },
            "alpaca-trading-engine"
          );
          if (strategy) {
            logger.strategy(strategy.name, "Started", { assets: strategy.assets });
          }
        }
        return result;
      }
      async stopStrategy(strategyId) {
        const result = await strategyRunner.stopStrategy(strategyId);
        const strategy = await storage.getStrategy(strategyId);
        eventBus.emit(
          "strategy:stopped",
          { strategyId, strategyName: strategy?.name || strategyId },
          "alpaca-trading-engine"
        );
        logger.strategy(strategy?.name || strategyId, "Stopped");
        return result;
      }
      async stopAllStrategies() {
        await strategyRunner.stopAllStrategies();
        this.stopBackgroundGenerator();
        await storage.updateAgentStatus({ isRunning: false });
      }
      async resumeAgent() {
        log.info("AlpacaTradingEngine", "Resuming trading agent...");
        this.startBackgroundAIGenerator();
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        if (this.autoStartStrategyId) {
          const isConnected = await isAlpacaConnected();
          if (isConnected) {
            await this.startStrategy(this.autoStartStrategyId);
          }
        }
      }
      getStrategyState(strategyId) {
        return strategyRunner.getStrategyState(strategyId);
      }
      getAllStrategyStates() {
        return strategyRunner.getAllStrategyStates();
      }
      getRunningStrategiesCount() {
        return strategyRunner.getRunningStrategiesCount();
      }
      // ============================================================================
      // PORTFOLIO REBALANCING (delegates to portfolio-rebalancer)
      // ============================================================================
      async getCurrentAllocations() {
        return positionManager.getCurrentAllocations();
      }
      async previewRebalance(targetAllocations) {
        return portfolioRebalancer.previewRebalance(
          targetAllocations,
          () => positionManager.getCurrentAllocations()
        );
      }
      async executeRebalance(targetAllocations, dryRun = false) {
        return portfolioRebalancer.executeRebalance(
          targetAllocations,
          dryRun,
          () => positionManager.getCurrentAllocations(),
          (req) => orderExecutor.executeAlpacaTrade(req)
        );
      }
      async getRebalanceSuggestions() {
        return portfolioRebalancer.getRebalanceSuggestions(
          () => positionManager.getCurrentAllocations(),
          () => getDefaultWatchlist()
        );
      }
      // ============================================================================
      // STATUS & UTILITIES
      // ============================================================================
      getStatus() {
        const states = this.getAllStrategyStates();
        return {
          alpacaConnected: alpaca.getConnectionStatus().hasCredentials,
          runningStrategies: this.getRunningStrategiesCount(),
          strategyStates: states
        };
      }
    };
    alpacaTradingEngine = new AlpacaTradingEngine();
  }
});

// server/services/trading-session-manager.ts
var trading_session_manager_exports = {};
__export(trading_session_manager_exports, {
  tradingSessionManager: () => tradingSessionManager
});
var US_MARKET_HOLIDAYS_2024_2025, MARKET_SESSIONS, TradingSessionManager, tradingSessionManager;
var init_trading_session_manager = __esm({
  "server/services/trading-session-manager.ts"() {
    "use strict";
    init_logger();
    US_MARKET_HOLIDAYS_2024_2025 = [
      // 2024
      "2024-01-01",
      // New Year's Day
      "2024-01-15",
      // Martin Luther King Jr. Day
      "2024-02-19",
      // Presidents' Day
      "2024-03-29",
      // Good Friday
      "2024-05-27",
      // Memorial Day
      "2024-06-19",
      // Juneteenth
      "2024-07-04",
      // Independence Day
      "2024-09-02",
      // Labor Day
      "2024-11-28",
      // Thanksgiving
      "2024-12-25",
      // Christmas
      // 2025
      "2025-01-01",
      // New Year's Day
      "2025-01-20",
      // Martin Luther King Jr. Day
      "2025-02-17",
      // Presidents' Day
      "2025-04-18",
      // Good Friday
      "2025-05-26",
      // Memorial Day
      "2025-06-19",
      // Juneteenth
      "2025-07-04",
      // Independence Day
      "2025-09-01",
      // Labor Day
      "2025-11-27",
      // Thanksgiving
      "2025-12-25"
      // Christmas
    ];
    MARKET_SESSIONS = {
      US_EQUITIES: {
        name: "US Equities",
        exchange: "NYSE/NASDAQ",
        timezone: "America/New_York",
        regularHours: {
          start: "09:30",
          end: "16:00"
        },
        extendedHours: {
          preMarket: {
            start: "04:00",
            end: "09:30"
          },
          afterHours: {
            start: "16:00",
            end: "20:00"
          }
        },
        holidays: US_MARKET_HOLIDAYS_2024_2025
      },
      CRYPTO: {
        name: "Cryptocurrency",
        exchange: "24/7",
        timezone: "UTC",
        regularHours: {
          start: "00:00",
          end: "23:59"
        },
        holidays: []
        // Crypto markets never close
      },
      EUROPEAN_DAX: {
        name: "European DAX",
        exchange: "XETRA",
        timezone: "Europe/Berlin",
        regularHours: {
          start: "09:00",
          end: "17:30"
        },
        holidays: []
        // Simplified - would need European holiday calendar
      },
      ASIAN_NIKKEI: {
        name: "Asian Nikkei",
        exchange: "TSE",
        timezone: "Asia/Tokyo",
        regularHours: {
          start: "09:00",
          end: "15:00"
        },
        holidays: []
        // Simplified - would need Japanese holiday calendar
      }
    };
    TradingSessionManager = class {
      sessionCache = /* @__PURE__ */ new Map();
      CACHE_TTL_MS = 6e4;
      // 1 minute cache
      /**
       * Get the market session configuration for an exchange
       */
      getSessionConfig(exchange) {
        return MARKET_SESSIONS[exchange] || null;
      }
      /**
       * Check if a market is open right now
       */
      isMarketOpen(exchange, now = /* @__PURE__ */ new Date()) {
        const session = this.getCurrentSession(exchange, now);
        return session.isOpen;
      }
      /**
       * Get the next market open time
       */
      getNextMarketOpen(exchange, now = /* @__PURE__ */ new Date()) {
        const config2 = MARKET_SESSIONS[exchange];
        if (!config2) {
          log.warn("SessionManager", `Unknown exchange: ${exchange}`);
          return null;
        }
        if (exchange === "CRYPTO") {
          return now;
        }
        const session = this.getCurrentSession(exchange, now);
        if (session.nextOpen) {
          return session.nextOpen;
        }
        const nextOpen = this.calculateNextOpen(config2, now);
        return nextOpen;
      }
      /**
       * Get the next market close time
       */
      getNextMarketClose(exchange, now = /* @__PURE__ */ new Date()) {
        const config2 = MARKET_SESSIONS[exchange];
        if (!config2) {
          log.warn("SessionManager", `Unknown exchange: ${exchange}`);
          return null;
        }
        if (exchange === "CRYPTO") {
          return null;
        }
        const session = this.getCurrentSession(exchange, now);
        if (session.nextClose) {
          return session.nextClose;
        }
        return this.calculateNextClose(config2, now);
      }
      /**
       * Get the current session type (pre-market, regular, after-hours, closed)
       */
      getCurrentSession(exchange, now = /* @__PURE__ */ new Date()) {
        const cacheKey = `${exchange}-${now.getTime()}`;
        const cached = this.sessionCache.get(exchange);
        if (cached && now.getTime() - cached.timestamp < this.CACHE_TTL_MS) {
          return cached.info;
        }
        const config2 = MARKET_SESSIONS[exchange];
        if (!config2) {
          return {
            session: "closed",
            isOpen: false,
            isExtendedHours: false,
            nextOpen: null,
            nextClose: null,
            volatilityMultiplier: 1,
            timezone: "UTC"
          };
        }
        const info = this.calculateSessionInfo(config2, now);
        this.sessionCache.set(exchange, { info, timestamp: now.getTime() });
        return info;
      }
      /**
       * Check if a specific date is a market holiday
       */
      isHoliday(exchange, date) {
        const config2 = MARKET_SESSIONS[exchange];
        if (!config2) return false;
        const dateStr = this.formatDateISO(date);
        return config2.holidays.includes(dateStr);
      }
      /**
       * Get volatility multiplier based on session
       * Higher volatility during extended hours and market opens/closes
       */
      getSessionVolatilityMultiplier(exchange, session) {
        if (exchange === "CRYPTO") {
          return 1.5;
        }
        switch (session) {
          case "pre_market":
            return 2;
          // Highest volatility - low liquidity
          case "after_hours":
            return 1.8;
          // High volatility - reduced liquidity
          case "regular":
            return 1;
          // Normal volatility
          case "closed":
            return 0;
          // Market is closed
          default:
            return 1;
        }
      }
      /**
       * Calculate detailed session information
       */
      calculateSessionInfo(config2, now) {
        const timezone = config2.timezone;
        const dateStr = this.formatDateISO(now);
        const isHoliday = config2.holidays.includes(dateStr);
        const dayOfWeek = now.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
        if (config2.exchange === "24/7") {
          return {
            session: "regular",
            isOpen: true,
            isExtendedHours: false,
            nextOpen: null,
            nextClose: null,
            volatilityMultiplier: 1.5,
            // Crypto baseline volatility
            timezone
          };
        }
        if (isWeekend || isHoliday) {
          const nextOpen2 = this.calculateNextOpen(config2, now);
          return {
            session: "closed",
            isOpen: false,
            isExtendedHours: false,
            nextOpen: nextOpen2,
            nextClose: null,
            volatilityMultiplier: 0,
            timezone
          };
        }
        const currentTime = this.getTimeInTimezone(now, timezone);
        const currentMinutes = this.timeToMinutes(currentTime);
        const regularStart = this.timeToMinutes(config2.regularHours.start);
        const regularEnd = this.timeToMinutes(config2.regularHours.end);
        if (currentMinutes >= regularStart && currentMinutes < regularEnd) {
          const nextClose = this.createDateFromTime(
            now,
            config2.regularHours.end,
            timezone
          );
          return {
            session: "regular",
            isOpen: true,
            isExtendedHours: false,
            nextOpen: null,
            nextClose,
            volatilityMultiplier: this.getSessionVolatilityMultiplier(
              config2.exchange,
              "regular"
            ),
            timezone
          };
        }
        if (config2.extendedHours) {
          const preMarketStart = this.timeToMinutes(
            config2.extendedHours.preMarket.start
          );
          const preMarketEnd = this.timeToMinutes(
            config2.extendedHours.preMarket.end
          );
          const afterHoursStart = this.timeToMinutes(
            config2.extendedHours.afterHours.start
          );
          const afterHoursEnd = this.timeToMinutes(
            config2.extendedHours.afterHours.end
          );
          if (currentMinutes >= preMarketStart && currentMinutes < preMarketEnd) {
            const nextClose = this.createDateFromTime(
              now,
              config2.extendedHours.preMarket.end,
              timezone
            );
            return {
              session: "pre_market",
              isOpen: true,
              isExtendedHours: true,
              nextOpen: null,
              nextClose,
              volatilityMultiplier: this.getSessionVolatilityMultiplier(
                config2.exchange,
                "pre_market"
              ),
              timezone
            };
          }
          if (currentMinutes >= afterHoursStart && currentMinutes < afterHoursEnd) {
            const nextClose = this.createDateFromTime(
              now,
              config2.extendedHours.afterHours.end,
              timezone
            );
            return {
              session: "after_hours",
              isOpen: true,
              isExtendedHours: true,
              nextOpen: null,
              nextClose,
              volatilityMultiplier: this.getSessionVolatilityMultiplier(
                config2.exchange,
                "after_hours"
              ),
              timezone
            };
          }
        }
        const nextOpen = this.calculateNextOpen(config2, now);
        return {
          session: "closed",
          isOpen: false,
          isExtendedHours: false,
          nextOpen,
          nextClose: null,
          volatilityMultiplier: 0,
          timezone
        };
      }
      /**
       * Calculate the next market open time
       */
      calculateNextOpen(config2, now) {
        const timezone = config2.timezone;
        let checkDate = new Date(now);
        if (config2.exchange === "24/7") {
          return now;
        }
        for (let i = 0; i < 10; i++) {
          const dayOfWeek = checkDate.getDay();
          const dateStr = this.formatDateISO(checkDate);
          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
          const isHoliday = config2.holidays.includes(dateStr);
          if (isWeekend || isHoliday) {
            checkDate = this.addDays(checkDate, 1);
            continue;
          }
          const currentTime = this.getTimeInTimezone(now, timezone);
          const currentMinutes = this.timeToMinutes(currentTime);
          const openTime = config2.extendedHours ? config2.extendedHours.preMarket.start : config2.regularHours.start;
          const openMinutes = this.timeToMinutes(openTime);
          if (this.isSameDay(checkDate, now) && currentMinutes < openMinutes) {
            return this.createDateFromTime(checkDate, openTime, timezone);
          }
          if (this.isSameDay(checkDate, now)) {
            checkDate = this.addDays(checkDate, 1);
            continue;
          }
          return this.createDateFromTime(checkDate, openTime, timezone);
        }
        return this.addDays(now, 1);
      }
      /**
       * Calculate the next market close time
       */
      calculateNextClose(config2, now) {
        const timezone = config2.timezone;
        const currentTime = this.getTimeInTimezone(now, timezone);
        const currentMinutes = this.timeToMinutes(currentTime);
        const closeTime = config2.extendedHours ? config2.extendedHours.afterHours.end : config2.regularHours.end;
        const closeMinutes = this.timeToMinutes(closeTime);
        if (currentMinutes < closeMinutes) {
          return this.createDateFromTime(now, closeTime, timezone);
        }
        const tomorrow = this.addDays(now, 1);
        return this.createDateFromTime(tomorrow, closeTime, timezone);
      }
      /**
       * Get all available exchanges
       */
      getAvailableExchanges() {
        return Object.keys(MARKET_SESSIONS);
      }
      /**
       * Get session info for all exchanges
       */
      getAllSessionInfo(now = /* @__PURE__ */ new Date()) {
        const result = {};
        for (const exchange of this.getAvailableExchanges()) {
          result[exchange] = this.getCurrentSession(exchange, now);
        }
        return result;
      }
      /**
       * Detect exchange from symbol
       */
      detectExchange(symbol) {
        const upperSymbol = symbol.toUpperCase();
        if (upperSymbol.includes("/") || upperSymbol.includes("BTC") || upperSymbol.includes("ETH") || upperSymbol.includes("USD") && upperSymbol.length <= 8) {
          return "CRYPTO";
        }
        return "US_EQUITIES";
      }
      // Utility functions
      formatDateISO(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      getTimeInTimezone(date, timezone) {
        const options = {
          timeZone: timezone,
          hour: "2-digit",
          minute: "2-digit",
          hour12: false
        };
        return new Intl.DateTimeFormat("en-US", options).format(date);
      }
      timeToMinutes(time) {
        const [hours, minutes] = time.split(":").map(Number);
        return hours * 60 + minutes;
      }
      createDateFromTime(date, time, timezone) {
        const [hours, minutes] = time.split(":").map(Number);
        const result = new Date(date);
        result.setHours(hours, minutes, 0, 0);
        if (timezone === "America/New_York") {
          result.setHours(result.getHours() + 5);
        }
        return result;
      }
      addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
      }
      isSameDay(date1, date2) {
        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
      }
      /**
       * Clear the session cache (useful for testing)
       */
      clearCache() {
        this.sessionCache.clear();
      }
    };
    tradingSessionManager = new TradingSessionManager();
  }
});

// server/lib/sse-emitter.ts
var sse_emitter_exports = {};
__export(sse_emitter_exports, {
  emitAIDecision: () => emitAIDecision,
  emitAgentStatus: () => emitAgentStatus,
  emitAlert: () => emitAlert,
  emitOrderFill: () => emitOrderFill,
  emitOrderUpdate: () => emitOrderUpdate,
  emitPositionUpdate: () => emitPositionUpdate,
  emitPriceUpdate: () => emitPriceUpdate,
  emitStrategyUpdate: () => emitStrategyUpdate,
  emitTradeNew: () => emitTradeNew,
  sseEmitter: () => sseEmitter
});
import { EventEmitter as EventEmitter2 } from "node:events";
var SSEEmitter, sseEmitter, emitOrderUpdate, emitOrderFill, emitPositionUpdate, emitTradeNew, emitPriceUpdate, emitAIDecision, emitAgentStatus, emitStrategyUpdate, emitAlert;
var init_sse_emitter = __esm({
  "server/lib/sse-emitter.ts"() {
    "use strict";
    init_logger();
    SSEEmitter = class extends EventEmitter2 {
      clients = /* @__PURE__ */ new Map();
      userClients = /* @__PURE__ */ new Map();
      // userId -> Set<clientId>
      /**
       * Add a new SSE client connection
       */
      addClient(clientId, res, userId) {
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        this.sendToClient(res, {
          type: "agent:status",
          data: { connected: true, clientId },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        this.clients.set(clientId, res);
        if (userId) {
          if (!this.userClients.has(userId)) {
            this.userClients.set(userId, /* @__PURE__ */ new Set());
          }
          this.userClients.get(userId).add(clientId);
        }
        res.on("close", () => {
          this.removeClient(clientId, userId);
        });
        log.info("SSE", "Client connected", {
          clientId,
          userId: userId || "anonymous"
        });
        log.debug("SSE", "Total clients", { count: this.clients.size });
      }
      /**
       * Remove a client connection
       */
      removeClient(clientId, userId) {
        this.clients.delete(clientId);
        if (userId) {
          const userSet = this.userClients.get(userId);
          if (userSet) {
            userSet.delete(clientId);
            if (userSet.size === 0) {
              this.userClients.delete(userId);
            }
          }
        }
        log.info("SSE", "Client disconnected", { clientId });
        log.debug("SSE", "Total clients", { count: this.clients.size });
      }
      /**
       * Broadcast event to all connected clients
       */
      broadcast(event) {
        const fullEvent = {
          ...event,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        let successCount = 0;
        let errorCount = 0;
        for (const [clientId, res] of this.clients) {
          try {
            this.sendToClient(res, fullEvent);
            successCount++;
          } catch (error) {
            log.error("SSE", "Failed to send to client", {
              clientId,
              error: error instanceof Error ? error.message : String(error)
            });
            errorCount++;
            this.removeClient(clientId);
          }
        }
        if (this.clients.size > 0) {
          log.debug("SSE", "Broadcast complete", {
            eventType: event.type,
            successCount,
            errorCount
          });
        }
      }
      /**
       * Send event to specific user's clients
       */
      sendToUser(userId, event) {
        const clientIds = this.userClients.get(userId);
        if (!clientIds || clientIds.size === 0) {
          return;
        }
        const fullEvent = {
          ...event,
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        let successCount = 0;
        const deadClients = [];
        for (const clientId of clientIds) {
          const res = this.clients.get(clientId);
          if (!res) {
            deadClients.push(clientId);
            continue;
          }
          try {
            this.sendToClient(res, fullEvent);
            successCount++;
          } catch (error) {
            log.error("SSE", "Failed to send to user client", {
              userId,
              clientId,
              error: error instanceof Error ? error.message : String(error)
            });
            deadClients.push(clientId);
          }
        }
        for (const clientId of deadClients) {
          this.removeClient(clientId, userId);
        }
        if (successCount > 0) {
          log.debug("SSE", "Sent event to user", {
            eventType: event.type,
            userId,
            clientCount: successCount
          });
        }
      }
      /**
       * Send SSE formatted message to a specific client
       */
      sendToClient(res, event) {
        const eventData = `event: ${event.type}
data: ${JSON.stringify(event.data)}
id: ${Date.now()}

`;
        res.write(eventData);
      }
      /**
       * Send keepalive ping to all clients
       */
      sendKeepalive() {
        for (const [clientId, res] of this.clients) {
          try {
            res.write(": keepalive\n\n");
          } catch (error) {
            log.error("SSE", "Keepalive failed for client", {
              clientId,
              error: error instanceof Error ? error.message : String(error)
            });
            this.removeClient(clientId);
          }
        }
      }
      /**
       * Get statistics
       */
      getStats() {
        return {
          totalClients: this.clients.size,
          totalUsers: this.userClients.size,
          clientsPerUser: Array.from(this.userClients.entries()).map(
            ([userId, clients]) => ({
              userId,
              clientCount: clients.size
            })
          )
        };
      }
    };
    sseEmitter = new SSEEmitter();
    setInterval(() => {
      sseEmitter.sendKeepalive();
    }, 3e4);
    emitOrderUpdate = (orderId, orderData, userId) => {
      const event = {
        type: "order:update",
        data: { orderId, ...orderData }
      };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitOrderFill = (orderId, fillData, userId) => {
      const event = { type: "order:fill", data: { orderId, ...fillData } };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitPositionUpdate = (positionData, userId) => {
      const event = { type: "position:update", data: positionData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitTradeNew = (tradeData, userId) => {
      const event = { type: "trade:new", data: tradeData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitPriceUpdate = (symbol, priceData) => {
      const event = {
        type: "price:update",
        data: { symbol, ...priceData }
      };
      sseEmitter.broadcast(event);
    };
    emitAIDecision = (decisionData, userId) => {
      const event = { type: "ai:decision", data: decisionData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitAgentStatus = (statusData) => {
      const event = { type: "agent:status", data: statusData };
      sseEmitter.broadcast(event);
    };
    emitStrategyUpdate = (strategyId, statusData, userId) => {
      const event = {
        type: "strategy:update",
        data: { strategyId, ...statusData }
      };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitAlert = (alertData, userId) => {
      const event = { type: "alert:new", data: alertData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
  }
});

// server/connectors/coingecko.ts
var COINGECKO_BASE_URL, CoinGeckoConnector, coingecko;
var init_coingecko = __esm({
  "server/connectors/coingecko.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    COINGECKO_BASE_URL = "https://api.coingecko.com/api/v3";
    CoinGeckoConnector = class {
      marketsCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      priceCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      chartCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      trendingCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      globalCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      coinListCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      ohlcCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      pendingRefreshes = /* @__PURE__ */ new Set();
      getApiKey() {
        return process.env.COINGECKO_API_KEY;
      }
      async fetchWithL1Cache(url, endpoint, cacheKey, cache2) {
        const cached = cache2.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("CoinGecko", `L1 cache HIT (fresh) for ${cacheKey}`);
          return cached.data;
        }
        if (cached && !cached.isFresh) {
          if (!this.pendingRefreshes.has(cacheKey)) {
            this.pendingRefreshes.add(cacheKey);
            this.backgroundRefresh(url, endpoint, cacheKey, cache2);
          }
          log.debug(
            "CoinGecko",
            `Serving stale L1 data for ${cacheKey}, refreshing in background`
          );
          return cached.data;
        }
        return this.doFetch(url, endpoint, cacheKey, cache2);
      }
      async backgroundRefresh(url, endpoint, cacheKey, cache2) {
        try {
          await this.doFetch(url, endpoint, cacheKey, cache2);
        } catch (error) {
          log.warn("CoinGecko", `Background refresh failed for ${cacheKey}`);
        } finally {
          this.pendingRefreshes.delete(cacheKey);
        }
      }
      async doFetch(url, endpoint, cacheKey, cache2) {
        const apiKey2 = this.getApiKey();
        const separator = url.includes("?") ? "&" : "?";
        const fullUrl = apiKey2 ? `${url}${separator}x_cg_demo_api_key=${apiKey2}` : url;
        const externalCacheKey = buildCacheKey("coingecko", endpoint, cacheKey);
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "coingecko",
            endpoint,
            cacheKey: externalCacheKey,
            headers: { Accept: "application/json" }
          });
          cache2.set(cacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = cache2.getStale(cacheKey);
          if (stale) {
            log.debug(
              "CoinGecko",
              `Error fetching, serving stale L1 data for ${cacheKey}`
            );
            return stale;
          }
          throw error;
        }
      }
      async getMarkets(vsCurrency = "usd", perPage = 20, page = 1, order = "market_cap_desc") {
        const cacheKey = buildCacheKey(
          "coingecko",
          "markets",
          vsCurrency,
          perPage,
          page,
          order
        );
        const url = `${COINGECKO_BASE_URL}/coins/markets?vs_currency=${vsCurrency}&order=${order}&per_page=${perPage}&page=${page}&sparkline=false`;
        return this.fetchWithL1Cache(
          url,
          "/coins/markets",
          cacheKey,
          this.marketsCache
        );
      }
      async getSimplePrice(coinIds, vsCurrencies = "usd", includeMarketCap = true, include24hVol = true, include24hChange = true) {
        const ids = coinIds.join(",");
        const cacheKey = buildCacheKey("coingecko", "simple", ids, vsCurrencies);
        const url = `${COINGECKO_BASE_URL}/simple/price?ids=${ids}&vs_currencies=${vsCurrencies}&include_market_cap=${includeMarketCap}&include_24hr_vol=${include24hVol}&include_24hr_change=${include24hChange}&include_last_updated_at=true`;
        return this.fetchWithL1Cache(
          url,
          "/simple/price",
          cacheKey,
          this.priceCache
        );
      }
      async getMarketChart(coinId, vsCurrency = "usd", days = 7) {
        const cacheKey = buildCacheKey(
          "coingecko",
          "chart",
          coinId,
          vsCurrency,
          days
        );
        const url = `${COINGECKO_BASE_URL}/coins/${coinId}/market_chart?vs_currency=${vsCurrency}&days=${days}`;
        return this.fetchWithL1Cache(
          url,
          `/coins/${coinId}/market_chart`,
          cacheKey,
          this.chartCache
        );
      }
      async getTrending() {
        const cacheKey = buildCacheKey("coingecko", "trending");
        const url = `${COINGECKO_BASE_URL}/search/trending`;
        return this.fetchWithL1Cache(
          url,
          "/search/trending",
          cacheKey,
          this.trendingCache
        );
      }
      async getGlobalData() {
        const cacheKey = buildCacheKey("coingecko", "global");
        const url = `${COINGECKO_BASE_URL}/global`;
        return this.fetchWithL1Cache(
          url,
          "/global",
          cacheKey,
          this.globalCache
        );
      }
      async getCoinList() {
        const cacheKey = buildCacheKey("coingecko", "coinlist");
        const url = `${COINGECKO_BASE_URL}/coins/list`;
        return this.fetchWithL1Cache(
          url,
          "/coins/list",
          cacheKey,
          this.coinListCache
        );
      }
      async searchCoins(query) {
        const cacheKey = buildCacheKey("coingecko", "search", query);
        const url = `${COINGECKO_BASE_URL}/search?query=${encodeURIComponent(query)}`;
        return this.fetchWithL1Cache(
          url,
          "/search",
          cacheKey,
          this.searchCache
        );
      }
      async getOHLC(coinId, vsCurrency = "usd", days = 7) {
        const cacheKey = buildCacheKey(
          "coingecko",
          "ohlc",
          coinId,
          vsCurrency,
          days
        );
        const url = `${COINGECKO_BASE_URL}/coins/${coinId}/ohlc?vs_currency=${vsCurrency}&days=${days}`;
        const rawData = await this.fetchWithL1Cache(
          url,
          `/coins/${coinId}/ohlc`,
          cacheKey,
          this.ohlcCache
        );
        return rawData.map(([timestamp18, open, high, low, close]) => ({
          timestamp: timestamp18,
          open,
          high,
          low,
          close
        }));
      }
      async getOHLCWithIndicators(coinId, days = 30) {
        const ohlc = await this.getOHLC(coinId, "usd", days);
        if (ohlc.length === 0) {
          return {
            candles: [],
            latestPrice: 0,
            priceChange24h: 0,
            volatility: 0,
            trend: "neutral",
            support: 0,
            resistance: 0
          };
        }
        const latestCandle = ohlc[ohlc.length - 1];
        const latestPrice = latestCandle.close;
        const firstCandle = ohlc[0];
        const priceChange24h = (latestPrice - firstCandle.close) / firstCandle.close * 100;
        const highs = ohlc.map((c) => c.high);
        const lows = ohlc.map((c) => c.low);
        const closes = ohlc.map((c) => c.close);
        const avgClose = closes.reduce((a, b) => a + b, 0) / closes.length;
        const variance4 = closes.reduce((sum, c) => sum + Math.pow(c - avgClose, 2), 0) / closes.length;
        const volatility = Math.sqrt(variance4) / avgClose * 100;
        const resistance = Math.max(...highs);
        const support = Math.min(...lows);
        const recentCandles = ohlc.slice(-5);
        const bullishCount = recentCandles.filter((c) => c.close > c.open).length;
        const trend = bullishCount >= 4 ? "bullish" : bullishCount <= 1 ? "bearish" : "neutral";
        return {
          candles: ohlc,
          latestPrice,
          priceChange24h,
          volatility,
          trend,
          support,
          resistance
        };
      }
      getConnectionStatus() {
        const totalCacheSize = this.marketsCache.size() + this.priceCache.size() + this.chartCache.size() + this.trendingCache.size() + this.globalCache.size() + this.coinListCache.size() + this.searchCache.size() + this.ohlcCache.size();
        return {
          connected: true,
          hasApiKey: !!this.getApiKey(),
          cacheSize: totalCacheSize
        };
      }
      clearCache() {
        this.marketsCache.clear();
        this.priceCache.clear();
        this.chartCache.clear();
        this.trendingCache.clear();
        this.globalCache.clear();
        this.coinListCache.clear();
        this.searchCache.clear();
        this.ohlcCache.clear();
      }
    };
    coingecko = new CoinGeckoConnector();
  }
});

// server/universe/fundamentalsService.ts
import { eq as eq5, and as and4 } from "drizzle-orm";
function safeParseNumeric(value) {
  if (value === null || value === void 0) return null;
  const num = typeof value === "string" ? parseFloat(value) : value;
  return isNaN(num) ? null : num;
}
function normalizeScore(value, min, max, invert = false) {
  if (value === null) return 0.5;
  const clamped = Math.max(min, Math.min(max, value));
  const normalized = (clamped - min) / (max - min);
  return invert ? 1 - normalized : normalized;
}
var DEFAULT_SCORE_WEIGHTS, FundamentalsService, fundamentalsService;
var init_fundamentalsService = __esm({
  "server/universe/fundamentalsService.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_finnhub();
    init_logger();
    DEFAULT_SCORE_WEIGHTS = {
      revenueGrowth: 0.35,
      margins: 0.3,
      leverage: 0.2,
      dilution: 0.15
    };
    FundamentalsService = class {
      calculateQualityGrowthScore(fundamentals) {
        const revenueCagr = safeParseNumeric(fundamentals.revenueCagr3y);
        const grossMargin = safeParseNumeric(fundamentals.grossMargin);
        const operatingMargin = safeParseNumeric(fundamentals.operatingMargin);
        const netMargin = safeParseNumeric(fundamentals.netMargin);
        const freeCashFlowMargin = safeParseNumeric(
          fundamentals.freeCashFlowMargin
        );
        const debtToEquity = safeParseNumeric(fundamentals.debtToEquity);
        const sharesDilution = safeParseNumeric(fundamentals.sharesDilution1y);
        const revenueGrowthScore = normalizeScore(revenueCagr, -0.1, 0.5);
        const avgMargin = [
          grossMargin,
          operatingMargin,
          netMargin,
          freeCashFlowMargin
        ].filter((m) => m !== null).reduce((sum, m, _, arr) => sum + m / arr.length, 0);
        const marginScore = normalizeScore(avgMargin, -0.1, 0.4);
        const leverageScore = normalizeScore(debtToEquity, 0, 3, true);
        const dilutionScore = normalizeScore(sharesDilution, -0.1, 0.15, true);
        const qualityScore = (marginScore + leverageScore) / 2;
        const growthScore = (revenueGrowthScore + (1 - dilutionScore)) / 2;
        const weights = DEFAULT_SCORE_WEIGHTS;
        const finalScore = revenueGrowthScore * weights.revenueGrowth + marginScore * weights.margins + leverageScore * weights.leverage + dilutionScore * weights.dilution;
        return {
          qualityScore: Math.round(qualityScore * 100) / 100,
          growthScore: Math.round(growthScore * 100) / 100,
          finalScore: Math.round(finalScore * 100) / 100,
          breakdown: {
            revenueGrowthScore: Math.round(revenueGrowthScore * 100) / 100,
            marginScore: Math.round(marginScore * 100) / 100,
            leverageScore: Math.round(leverageScore * 100) / 100,
            dilutionScore: Math.round(dilutionScore * 100) / 100
          }
        };
      }
      async fetchAndStoreFundamentals(options = {}) {
        const startTime = Date.now();
        const { symbols, batchSize = 10, traceId } = options;
        log.info("FundamentalsService", "Starting fundamentals fetch", { traceId });
        let targetSymbols;
        if (symbols && symbols.length > 0) {
          targetSymbols = symbols;
        } else {
          const assets = await db.select({ symbol: universeAssets.symbol }).from(universeAssets).where(
            and4(
              eq5(universeAssets.tradable, true),
              eq5(universeAssets.excluded, false)
            )
          );
          targetSymbols = assets.map((a) => a.symbol);
        }
        log.info("FundamentalsService", "Fetching fundamentals for symbols", {
          count: targetSymbols.length
        });
        let computed = 0;
        let failed = 0;
        for (let i = 0; i < targetSymbols.length; i += batchSize) {
          const batch = targetSymbols.slice(i, i + batchSize);
          for (const symbol of batch) {
            try {
              const [profile, basicFinancials] = await Promise.all([
                finnhub.getCompanyProfile(symbol),
                finnhub.getBasicFinancials(symbol)
              ]);
              const metric = basicFinancials?.metric || {};
              const fundamentalsData = {
                symbol,
                marketCap: profile?.marketCapitalization?.toString() || null,
                sector: profile?.finnhubIndustry || null,
                industry: profile?.finnhubIndustry || null,
                revenueTtm: metric.revenuePerShareTTM ? (metric.revenuePerShareTTM * (metric.sharesOutstanding || 1)).toString() : null,
                revenueCagr3y: metric.revenueGrowthTTMYoy ? (metric.revenueGrowthTTMYoy / 100).toString() : null,
                grossMargin: metric.grossMarginTTM ? (metric.grossMarginTTM / 100).toString() : null,
                operatingMargin: metric.operatingMarginTTM ? (metric.operatingMarginTTM / 100).toString() : null,
                netMargin: metric.netProfitMarginTTM ? (metric.netProfitMarginTTM / 100).toString() : null,
                freeCashFlowMargin: metric.freeCashFlowMarginTTM ? (metric.freeCashFlowMarginTTM / 100).toString() : null,
                debtToEquity: metric.totalDebtToEquity?.toString() || null,
                sharesDilution1y: null,
                source: "finnhub",
                rawJson: { profile, metric }
              };
              await this.upsertFundamentals(fundamentalsData);
              computed++;
            } catch (error) {
              log.error("FundamentalsService", "Failed to fetch fundamentals", {
                symbol,
                error: error instanceof Error ? error.message : String(error)
              });
              failed++;
            }
          }
          if (i + batchSize < targetSymbols.length) {
            await new Promise((r) => setTimeout(r, 1e3));
          }
        }
        const duration = Date.now() - startTime;
        log.info("FundamentalsService", "Fetch complete", {
          computed,
          failed,
          duration
        });
        return {
          success: true,
          computed,
          failed,
          duration,
          traceId
        };
      }
      async upsertFundamentals(data) {
        const existing = await db.select({ id: universeFundamentals.id }).from(universeFundamentals).where(eq5(universeFundamentals.symbol, data.symbol)).limit(1);
        if (existing.length > 0) {
          await db.update(universeFundamentals).set({
            ...data,
            lastUpdatedAt: /* @__PURE__ */ new Date()
          }).where(eq5(universeFundamentals.symbol, data.symbol));
        } else {
          await db.insert(universeFundamentals).values(data);
        }
      }
      async getFundamentalsBySymbol(symbol) {
        const result = await db.select().from(universeFundamentals).where(eq5(universeFundamentals.symbol, symbol.toUpperCase())).limit(1);
        return result[0] || null;
      }
      async getFundamentalsWithScores(limit4 = 100) {
        const fundamentals = await db.select().from(universeFundamentals).limit(limit4);
        return fundamentals.map((f) => ({
          ...f,
          ...this.calculateQualityGrowthScore(f)
        }));
      }
      async getTopByScore(limit4 = 50) {
        const fundamentals = await db.select().from(universeFundamentals).limit(500);
        const scored = fundamentals.map((f) => ({
          ...f,
          ...this.calculateQualityGrowthScore(f)
        }));
        return scored.sort((a, b) => b.finalScore - a.finalScore).slice(0, limit4);
      }
      async getStats() {
        const all = await db.select().from(universeFundamentals);
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
        const bySector = {};
        let stale = 0;
        let lastUpdatedAt = null;
        for (const f of all) {
          if (f.sector) {
            bySector[f.sector] = (bySector[f.sector] || 0) + 1;
          }
          if (f.lastUpdatedAt < oneDayAgo) stale++;
          if (!lastUpdatedAt || f.lastUpdatedAt > lastUpdatedAt) {
            lastUpdatedAt = f.lastUpdatedAt;
          }
        }
        return {
          total: all.length,
          bySector,
          stale,
          lastUpdatedAt
        };
      }
    };
    fundamentalsService = new FundamentalsService();
  }
});

// server/admin/settings.ts
import { eq as eq6, and as and5 } from "drizzle-orm";
async function getSetting(namespace, key) {
  const [result] = await db.select().from(adminSettings).where(
    and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))
  ).limit(1);
  if (!result) return void 0;
  return result.value;
}
async function getSettingFull(namespace, key) {
  const [result] = await db.select().from(adminSettings).where(
    and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))
  ).limit(1);
  return result || void 0;
}
async function setSetting(namespace, key, value, options) {
  const existing = await db.select().from(adminSettings).where(
    and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))
  ).limit(1);
  if (existing.length > 0) {
    if (existing[0].isReadOnly) {
      throw new Error(`Setting ${namespace}:${key} is read-only`);
    }
    const [updated] = await db.update(adminSettings).set({
      value,
      description: options?.description ?? existing[0].description,
      updatedBy: options?.userId,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(adminSettings.id, existing[0].id)).returning();
    return updated;
  }
  const [created] = await db.insert(adminSettings).values({
    namespace,
    key,
    value,
    description: options?.description,
    isSecret: options?.isSecret ?? false,
    isReadOnly: options?.isReadOnly ?? false,
    updatedBy: options?.userId
  }).returning();
  return created;
}
async function deleteSetting(namespace, key) {
  const existing = await db.select().from(adminSettings).where(
    and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))
  ).limit(1);
  if (existing.length === 0) return false;
  if (existing[0].isReadOnly) {
    throw new Error(`Setting ${namespace}:${key} is read-only`);
  }
  await db.delete(adminSettings).where(eq6(adminSettings.id, existing[0].id));
  return true;
}
async function listSettings(namespace) {
  if (namespace) {
    return db.select().from(adminSettings).where(eq6(adminSettings.namespace, namespace));
  }
  return db.select().from(adminSettings);
}
function sanitizeSettingForResponse(setting) {
  if (setting.isSecret) {
    return {
      ...setting,
      value: "[REDACTED]"
    };
  }
  return setting;
}
var init_settings = __esm({
  "server/admin/settings.ts"() {
    "use strict";
    init_db();
    init_schema2();
  }
});

// server/universe/liquidityService.ts
import { eq as eq7, and as and6, desc as desc3 } from "drizzle-orm";
var PENNY_STOCK_THRESHOLD, DEFAULT_THRESHOLDS, LiquidityService, liquidityService;
var init_liquidityService = __esm({
  "server/universe/liquidityService.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_alpaca();
    init_settings();
    init_logger();
    PENNY_STOCK_THRESHOLD = 5;
    DEFAULT_THRESHOLDS = {
      tierA: {
        minAdtvUsd: 5e7,
        maxSpreadPct: 0.25,
        minPrice: 5
      },
      tierB: {
        minAdtvUsd: 2e7,
        maxSpreadPct: 0.75,
        minPrice: 3
      }
    };
    LiquidityService = class {
      async getThresholds() {
        try {
          const setting = await getSetting(
            "universe",
            "liquidity_thresholds"
          );
          if (setting) {
            return setting;
          }
        } catch {
        }
        return DEFAULT_THRESHOLDS;
      }
      calculateLiquidityTier(adtvUsd, spreadPct, price, thresholds) {
        if (!adtvUsd || !price) return "C";
        const effectiveSpread = spreadPct ?? 0.5;
        if (adtvUsd >= thresholds.tierA.minAdtvUsd && effectiveSpread <= thresholds.tierA.maxSpreadPct && price >= thresholds.tierA.minPrice) {
          return "A";
        }
        if (adtvUsd >= thresholds.tierB.minAdtvUsd && effectiveSpread <= thresholds.tierB.maxSpreadPct && price >= thresholds.tierB.minPrice) {
          return "B";
        }
        return "C";
      }
      async computeLiquidityMetrics(options = {}) {
        const startTime = Date.now();
        const { symbols, batchSize = 50, traceId } = options;
        log.info("LiquidityService", "Starting liquidity computation", { traceId });
        const thresholds = await this.getThresholds();
        let targetSymbols;
        if (symbols && symbols.length > 0) {
          targetSymbols = symbols;
        } else {
          const assets = await db.select({ symbol: universeAssets.symbol }).from(universeAssets).where(
            and6(
              eq7(universeAssets.tradable, true),
              eq7(universeAssets.excluded, false)
            )
          );
          targetSymbols = assets.map((a) => a.symbol);
        }
        log.info("LiquidityService", "Computing metrics for symbols", {
          count: targetSymbols.length
        });
        let computed = 0;
        let tierACount = 0;
        let tierBCount = 0;
        let tierCCount = 0;
        const now = /* @__PURE__ */ new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
        const startDate = thirtyDaysAgo.toISOString().split("T")[0];
        const endDate = now.toISOString().split("T")[0];
        for (let i = 0; i < targetSymbols.length; i += batchSize) {
          const batch = targetSymbols.slice(i, i + batchSize);
          try {
            const barsResponse = await alpaca.getBars(
              batch,
              "1Day",
              startDate,
              endDate,
              1e3
            );
            for (const symbol of batch) {
              const bars = barsResponse.bars?.[symbol] || [];
              if (bars.length === 0) {
                const metrics2 = {
                  symbol,
                  avgDailyVolumeShares: null,
                  avgDailyTradedValueUsd: null,
                  avgBidAskSpreadPct: null,
                  latestPrice: null,
                  priceDataDays: 0,
                  liquidityTier: "C",
                  source: "alpaca",
                  rawJson: { noData: true }
                };
                await this.upsertLiquidityMetrics(metrics2);
                tierCCount++;
                computed++;
                continue;
              }
              let totalVolume = 0;
              let totalValue = 0;
              const latestPrice = bars[bars.length - 1]?.c || 0;
              for (const bar of bars) {
                totalVolume += bar.v;
                totalValue += bar.v * ((bar.h + bar.l) / 2);
              }
              const avgVolume = bars.length > 0 ? totalVolume / bars.length : 0;
              const avgTradedValue = bars.length > 0 ? totalValue / bars.length : 0;
              const tier = this.calculateLiquidityTier(
                avgTradedValue,
                null,
                latestPrice,
                thresholds
              );
              const metrics = {
                symbol,
                avgDailyVolumeShares: avgVolume.toString(),
                avgDailyTradedValueUsd: avgTradedValue.toString(),
                avgBidAskSpreadPct: null,
                latestPrice: latestPrice.toString(),
                priceDataDays: bars.length,
                liquidityTier: tier,
                source: "alpaca",
                rawJson: { barCount: bars.length, computed: now.toISOString() }
              };
              await this.upsertLiquidityMetrics(metrics);
              const isPennyStock = latestPrice < PENNY_STOCK_THRESHOLD && latestPrice > 0;
              await this.updatePennyStockFlag(symbol, isPennyStock, latestPrice);
              if (tier === "A") tierACount++;
              else if (tier === "B") tierBCount++;
              else tierCCount++;
              computed++;
            }
          } catch (error) {
            log.error("LiquidityService", "Failed to process batch", {
              batchStartIndex: i,
              error: error instanceof Error ? error.message : String(error)
            });
          }
          if (i + batchSize < targetSymbols.length) {
            await new Promise((r) => setTimeout(r, 500));
          }
        }
        const duration = Date.now() - startTime;
        log.info("LiquidityService", "Computation complete", {
          computed,
          tierA: tierACount,
          tierB: tierBCount,
          tierC: tierCCount,
          duration
        });
        return {
          success: true,
          computed,
          tierA: tierACount,
          tierB: tierBCount,
          tierC: tierCCount,
          duration,
          traceId
        };
      }
      async upsertLiquidityMetrics(metrics) {
        const existing = await db.select({ id: universeLiquidityMetrics.id }).from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.symbol, metrics.symbol)).limit(1);
        if (existing.length > 0) {
          await db.update(universeLiquidityMetrics).set({
            ...metrics,
            lastUpdatedAt: /* @__PURE__ */ new Date()
          }).where(eq7(universeLiquidityMetrics.symbol, metrics.symbol));
        } else {
          await db.insert(universeLiquidityMetrics).values(metrics);
        }
      }
      async getMetricsBySymbol(symbol) {
        const result = await db.select().from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.symbol, symbol.toUpperCase())).limit(1);
        return result[0] || null;
      }
      async getMetricsByTier(tier, limit4 = 100) {
        return db.select().from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.liquidityTier, tier)).orderBy(desc3(universeLiquidityMetrics.avgDailyTradedValueUsd)).limit(limit4);
      }
      async getTierStats() {
        const all = await db.select().from(universeLiquidityMetrics);
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
        let tierA = 0, tierB = 0, tierC = 0, stale = 0;
        for (const m of all) {
          if (m.liquidityTier === "A") tierA++;
          else if (m.liquidityTier === "B") tierB++;
          else tierC++;
          if (m.lastUpdatedAt < oneDayAgo) stale++;
        }
        return { tierA, tierB, tierC, stale, total: all.length };
      }
      async getTopLiquid(limit4 = 50) {
        return db.select().from(universeLiquidityMetrics).orderBy(desc3(universeLiquidityMetrics.avgDailyTradedValueUsd)).limit(limit4);
      }
      async getThresholdsForAdmin() {
        return this.getThresholds();
      }
      async updatePennyStockFlag(symbol, isPennyStock, latestPrice) {
        try {
          await db.update(universeAssets).set({
            isPennyStock,
            excluded: isPennyStock ? true : void 0,
            excludeReason: isPennyStock ? `Penny stock (price $${latestPrice.toFixed(2)} < $${PENNY_STOCK_THRESHOLD})` : void 0
          }).where(eq7(universeAssets.symbol, symbol));
        } catch (error) {
          log.error("LiquidityService", "Failed to update penny stock flag", {
            symbol,
            error: error instanceof Error ? error.message : String(error)
          });
        }
      }
    };
    liquidityService = new LiquidityService();
  }
});

// server/universe/candidatesService.ts
import { eq as eq8, desc as desc4, inArray as inArray2 } from "drizzle-orm";
var CandidatesService, candidatesService;
var init_candidatesService = __esm({
  "server/universe/candidatesService.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_fundamentalsService();
    init_liquidityService();
    init_logger();
    CandidatesService = class {
      async generateCandidates(options = {}) {
        const startTime = Date.now();
        const {
          minLiquidityTier = "B",
          minScore = 0.4,
          limit: limit4 = 100,
          traceId
        } = options;
        log.info("CandidatesService", "Generating candidates", {
          minLiquidityTier,
          minScore,
          traceId
        });
        const eligibleSymbols = await db.select({
          symbol: universeLiquidityMetrics.symbol,
          tier: universeLiquidityMetrics.liquidityTier
        }).from(universeLiquidityMetrics).where(
          inArray2(
            universeLiquidityMetrics.liquidityTier,
            minLiquidityTier === "A" ? ["A"] : ["A", "B"]
          )
        ).limit(limit4 * 2);
        log.info("CandidatesService", "Found symbols meeting liquidity criteria", {
          count: eligibleSymbols.length
        });
        let generated = 0;
        let updated = 0;
        for (const { symbol, tier } of eligibleSymbols) {
          const fundamentals = await fundamentalsService.getFundamentalsBySymbol(symbol);
          const liquidity = await liquidityService.getMetricsBySymbol(symbol);
          let qualityScore = 0.5;
          let growthScore = 0.5;
          let finalScore = 0.5;
          let rationale = "Insufficient data for scoring";
          if (fundamentals) {
            const scores = fundamentalsService.calculateQualityGrowthScore(fundamentals);
            qualityScore = scores.qualityScore;
            growthScore = scores.growthScore;
            finalScore = scores.finalScore;
            rationale = `Quality: ${(qualityScore * 100).toFixed(1)}%, Growth: ${(growthScore * 100).toFixed(1)}%`;
          }
          if (finalScore < minScore) {
            continue;
          }
          const liquidityScore = tier === "A" ? 1 : tier === "B" ? 0.7 : 0.4;
          const candidateData = {
            symbol,
            tier: tier || "C",
            liquidityScore: liquidityScore.toString(),
            qualityScore: qualityScore.toString(),
            growthScore: growthScore.toString(),
            finalScore: finalScore.toString(),
            rationale,
            traceId
          };
          const existing = await db.select({
            id: universeCandidates.id,
            status: universeCandidates.status
          }).from(universeCandidates).where(eq8(universeCandidates.symbol, symbol)).limit(1);
          if (existing.length > 0) {
            if (existing[0].status === "NEW" || existing[0].status === "WATCHLIST") {
              await db.update(universeCandidates).set({
                ...candidateData,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq8(universeCandidates.symbol, symbol));
              updated++;
            }
          } else {
            await db.insert(universeCandidates).values({
              ...candidateData,
              status: "NEW"
            });
            generated++;
          }
          if (generated + updated >= limit4) break;
        }
        const duration = Date.now() - startTime;
        log.info("CandidatesService", "Generation complete", {
          generated,
          updated,
          duration
        });
        return {
          success: true,
          generated,
          updated,
          duration,
          traceId
        };
      }
      async approveCandidate(symbol, userId) {
        return this.updateCandidateStatus(symbol, "APPROVED", userId);
      }
      async rejectCandidate(symbol) {
        return this.updateCandidateStatus(symbol, "REJECTED");
      }
      async watchlistCandidate(symbol) {
        return this.updateCandidateStatus(symbol, "WATCHLIST");
      }
      async updateCandidateStatus(symbol, newStatus, userId) {
        const existing = await db.select().from(universeCandidates).where(eq8(universeCandidates.symbol, symbol.toUpperCase())).limit(1);
        if (existing.length === 0) {
          throw new Error(`Candidate not found: ${symbol}`);
        }
        const previousStatus = existing[0].status;
        await db.update(universeCandidates).set({
          status: newStatus,
          approvedBy: newStatus === "APPROVED" ? userId : null,
          approvedAt: newStatus === "APPROVED" ? /* @__PURE__ */ new Date() : null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq8(universeCandidates.symbol, symbol.toUpperCase()));
        log.info("CandidatesService", "Status updated", {
          symbol,
          previousStatus,
          newStatus
        });
        return {
          success: true,
          symbol: symbol.toUpperCase(),
          previousStatus,
          newStatus
        };
      }
      async getCandidateBySymbol(symbol) {
        const result = await db.select().from(universeCandidates).where(eq8(universeCandidates.symbol, symbol.toUpperCase())).limit(1);
        return result[0] || null;
      }
      async getCandidatesByStatus(status, limit4 = 100) {
        return db.select().from(universeCandidates).where(eq8(universeCandidates.status, status)).orderBy(desc4(universeCandidates.finalScore)).limit(limit4);
      }
      async getApprovedSymbols() {
        const approved = await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates).where(eq8(universeCandidates.status, "APPROVED"));
        return approved.map((c) => c.symbol);
      }
      async getWatchlistSymbols() {
        const symbols = await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates).where(inArray2(universeCandidates.status, ["APPROVED", "WATCHLIST"]));
        const stocks = [];
        const crypto5 = [];
        for (const { symbol } of symbols) {
          if (symbol.includes("/USD") || [
            "BTC",
            "ETH",
            "SOL",
            "DOGE",
            "SHIB",
            "AVAX",
            "ADA",
            "XRP",
            "DOT",
            "MATIC"
          ].includes(symbol.toUpperCase())) {
            crypto5.push(symbol.replace("/USD", "").toUpperCase());
          } else {
            stocks.push(symbol.toUpperCase());
          }
        }
        return { stocks, crypto: crypto5 };
      }
      async isSymbolApproved(symbol) {
        const candidate = await this.getCandidateBySymbol(symbol);
        return candidate?.status === "APPROVED";
      }
      async getStats() {
        const all = await db.select().from(universeCandidates);
        let newCount = 0;
        let watchlistCount = 0;
        let approvedCount = 0;
        let rejectedCount = 0;
        let totalScore = 0;
        for (const c of all) {
          if (c.status === "NEW") newCount++;
          else if (c.status === "WATCHLIST") watchlistCount++;
          else if (c.status === "APPROVED") approvedCount++;
          else if (c.status === "REJECTED") rejectedCount++;
          const score = parseFloat(c.finalScore || "0");
          totalScore += isNaN(score) ? 0 : score;
        }
        return {
          total: all.length,
          new: newCount,
          watchlist: watchlistCount,
          approved: approvedCount,
          rejected: rejectedCount,
          avgScore: all.length > 0 ? Math.round(totalScore / all.length * 100) / 100 : 0
        };
      }
      async getTopCandidates(limit4 = 50) {
        return db.select().from(universeCandidates).where(
          inArray2(universeCandidates.status, ["NEW", "WATCHLIST", "APPROVED"])
        ).orderBy(desc4(universeCandidates.finalScore)).limit(limit4);
      }
      async bootstrapFromWatchlist(watchlist, traceId) {
        log.info("CandidatesService", "Bootstrapping symbols from watchlist", {
          count: watchlist.length,
          traceId
        });
        let added = 0;
        let existing = 0;
        let errors = 0;
        for (const symbol of watchlist) {
          try {
            const upperSymbol = symbol.toUpperCase();
            const exists = await db.select({ id: universeCandidates.id }).from(universeCandidates).where(eq8(universeCandidates.symbol, upperSymbol)).limit(1);
            if (exists.length > 0) {
              existing++;
              continue;
            }
            await db.insert(universeCandidates).values({
              symbol: upperSymbol,
              tier: "B",
              liquidityScore: "0.7",
              qualityScore: "0.6",
              growthScore: "0.6",
              finalScore: "0.65",
              rationale: "Auto-bootstrapped from orchestrator watchlist",
              status: "APPROVED",
              approvedAt: /* @__PURE__ */ new Date(),
              approvedBy: null,
              traceId
            });
            added++;
          } catch (error) {
            log.error("CandidatesService", "Error bootstrapping symbol", {
              symbol,
              error: error instanceof Error ? error.message : String(error)
            });
            errors++;
          }
        }
        log.info("CandidatesService", "Bootstrap complete", {
          added,
          existing,
          errors
        });
        return { added, existing, errors };
      }
      async ensureWatchlistApproved(watchlist, traceId) {
        const existingSymbols = new Set(
          (await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates)).map((r) => r.symbol.toUpperCase())
        );
        const missingSymbols = watchlist.map((s) => s.toUpperCase()).filter((s) => !existingSymbols.has(s));
        if (missingSymbols.length === 0) {
          log.info(
            "CandidatesService",
            "All watchlist symbols already in universe_candidates",
            { count: watchlist.length }
          );
          return;
        }
        log.info("CandidatesService", "Found missing symbols, bootstrapping", {
          count: missingSymbols.length
        });
        const result = await this.bootstrapFromWatchlist(missingSymbols, traceId);
        if (result.errors > 0) {
          log.warn("CandidatesService", "Bootstrap completed with errors", {
            errors: result.errors,
            totalSymbols: missingSymbols.length
          });
        }
      }
    };
    candidatesService = new CandidatesService();
  }
});

// server/lib/redis-cache.ts
import Redis from "ioredis";
async function initRedis() {
  try {
    if (redisClient) {
      log.info("Redis", "Already connected", { host: REDIS_CONFIG.host });
      return true;
    }
    redisClient = new Redis(REDIS_CONFIG);
    redisClient.on("connect", () => {
      log.info("Redis", "Connection established", {
        host: REDIS_CONFIG.host,
        port: REDIS_CONFIG.port
      });
    });
    redisClient.on("ready", () => {
      log.info("Redis", "Ready for commands");
    });
    redisClient.on("error", (error) => {
      log.error("Redis", "Connection error", {
        error: error.message,
        code: error.code
      });
    });
    redisClient.on("close", () => {
      log.warn("Redis", "Connection closed");
    });
    redisClient.on("reconnecting", () => {
      log.info("Redis", "Reconnecting...");
    });
    await redisClient.connect();
    const pong = await redisClient.ping();
    if (pong === "PONG") {
      log.info("Redis", "Health check passed", { pong });
      return true;
    }
    return false;
  } catch (error) {
    log.error("Redis", "Failed to initialize", {
      error: error instanceof Error ? error.message : String(error)
    });
    redisClient = null;
    return false;
  }
}
function isRedisAvailable() {
  return redisClient !== null && redisClient.status === "ready";
}
async function getCounter(key) {
  if (!isRedisAvailable()) {
    return null;
  }
  try {
    const value = await redisClient.get(key);
    if (value === null) {
      return null;
    }
    return parseInt(value, 10);
  } catch (error) {
    log.error("Redis", "Get counter failed", {
      key,
      error: error instanceof Error ? error.message : String(error)
    });
    return null;
  }
}
async function setCounter(key, value, ttlSeconds) {
  if (!isRedisAvailable()) {
    return false;
  }
  try {
    if (ttlSeconds) {
      await redisClient.setex(key, ttlSeconds, value.toString());
    } else {
      await redisClient.set(key, value.toString());
    }
    return true;
  } catch (error) {
    log.error("Redis", "Set counter failed", {
      key,
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}
async function closeRedis() {
  if (redisClient) {
    await redisClient.quit();
    redisClient = null;
    log.info("Redis", "Connection closed gracefully");
  }
}
async function acquireLock(lockKey, lockValue, ttlSeconds = 30) {
  if (!isRedisAvailable()) {
    return false;
  }
  try {
    const result = await redisClient.set(
      lockKey,
      lockValue,
      "EX",
      ttlSeconds,
      "NX"
    );
    const acquired = result === "OK";
    if (acquired) {
      log.debug("Redis", "Lock acquired", {
        lockKey,
        lockValue,
        ttl: ttlSeconds
      });
    } else {
      log.debug("Redis", "Lock already held", { lockKey });
    }
    return acquired;
  } catch (error) {
    log.error("Redis", "Acquire lock failed", {
      lockKey,
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}
async function releaseLock(lockKey, lockValue) {
  if (!isRedisAvailable()) {
    return false;
  }
  try {
    const script = `
      if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
      else
        return 0
      end
    `;
    const result = await redisClient.eval(
      script,
      1,
      lockKey,
      lockValue
    );
    if (result === 1) {
      log.debug("Redis", "Lock released", { lockKey, lockValue });
      return true;
    } else {
      log.debug("Redis", "Lock not owned by this holder", {
        lockKey,
        lockValue
      });
      return false;
    }
  } catch (error) {
    log.error("Redis", "Release lock failed", {
      lockKey,
      error: error instanceof Error ? error.message : String(error)
    });
    return false;
  }
}
async function withLock(lockKey, fn, ttlSeconds = 30) {
  const lockValue = `lock-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  const acquired = await acquireLock(lockKey, lockValue, ttlSeconds);
  if (!acquired) {
    log.debug("Redis", "Failed to acquire lock, skipping execution", {
      lockKey
    });
    return null;
  }
  try {
    const result = await fn();
    await releaseLock(lockKey, lockValue);
    return result;
  } catch (error) {
    await releaseLock(lockKey, lockValue);
    log.error("Redis", "Error while holding lock", {
      lockKey,
      error: error instanceof Error ? error.message : String(error)
    });
    throw error;
  }
}
var redisClient, REDIS_CONFIG;
var init_redis_cache = __esm({
  "server/lib/redis-cache.ts"() {
    "use strict";
    init_logger();
    redisClient = null;
    REDIS_CONFIG = {
      host: process.env.REDIS_HOST || "localhost",
      port: parseInt(process.env.REDIS_PORT || "6379", 10),
      password: process.env.REDIS_PASSWORD,
      db: parseInt(process.env.REDIS_DB || "0", 10),
      retryStrategy: (times) => {
        const delay = Math.min(times * 50, 2e3);
        return delay;
      },
      maxRetriesPerRequest: 3,
      enableOfflineQueue: false,
      lazyConnect: true
    };
  }
});

// server/trading/smart-order-router.ts
function transformOrderForExecution(order, currentPrice, sessionOverride) {
  return smartOrderRouter.transformOrderForExecution(
    order,
    currentPrice,
    sessionOverride
  );
}
function createPriceData(quote) {
  const bid = quote.bid || quote.last || 0;
  const ask = quote.ask || quote.last || 0;
  const last = quote.last || (bid + ask) / 2;
  const spread = ask && bid ? (ask - bid) / last : 0;
  return {
    bid,
    ask,
    last,
    spread
  };
}
var DEFAULT_CONFIG2, SmartOrderRouter, smartOrderRouter;
var init_smart_order_router = __esm({
  "server/trading/smart-order-router.ts"() {
    "use strict";
    init_logger();
    init_trading_session_manager();
    DEFAULT_CONFIG2 = {
      buyBufferPercent: 0.3,
      sellBufferPercent: 0.3,
      aggressiveLimitBufferPercent: 0.5,
      autoUpgradeMarketToLimit: true,
      forceExtendedHoursDayTIF: true,
      enablePriceValidation: true
    };
    SmartOrderRouter = class {
      config;
      constructor(config2) {
        this.config = { ...DEFAULT_CONFIG2, ...config2 };
      }
      /**
       * Main transformation function - ensures order will not be rejected
       */
      transformOrderForExecution(order, currentPrice, sessionOverride) {
        const transformations = [];
        const warnings = [];
        const isCrypto = this.isCryptoSymbol(order.symbol);
        const session = sessionOverride || this.detectMarketSession(order.symbol);
        log.debug("SmartOrderRouter", "Transforming order", {
          symbol: order.symbol,
          side: order.side,
          type: order.type,
          session,
          isCrypto
        });
        let transformedOrder = { ...order };
        const isExtendedHours = this.isExtendedHoursSession(session);
        const needsExtendedHours = isExtendedHours && !isCrypto;
        const orderType = this.selectOrderType(
          order,
          session,
          isCrypto,
          transformations
        );
        transformedOrder.type = orderType;
        if (this.needsLimitPrice(orderType, needsExtendedHours)) {
          const limitPrice = this.calculateLimitPrice(
            order,
            currentPrice,
            session,
            transformations,
            warnings
          );
          if (limitPrice) {
            transformedOrder.limitPrice = limitPrice;
          }
        }
        const timeInForce = this.selectTimeInForce(
          { ...transformedOrder, type: orderType },
          session,
          isCrypto,
          needsExtendedHours,
          transformations
        );
        transformedOrder.timeInForce = timeInForce;
        transformedOrder.extendedHours = needsExtendedHours;
        if (needsExtendedHours && !order.extendedHours) {
          transformations.push(`Set extended_hours=true for ${session} session`);
        }
        if (this.config.enablePriceValidation && transformedOrder.limitPrice) {
          this.validateLimitPrice(
            {
              ...transformedOrder,
              type: orderType,
              limitPrice: transformedOrder.limitPrice
            },
            currentPrice,
            warnings
          );
        }
        if (transformedOrder.orderClass === "bracket") {
          if (transformedOrder.timeInForce !== "day") {
            transformedOrder.timeInForce = "day";
            transformations.push(
              "Forced bracket order TIF to 'day' (Alpaca requirement)"
            );
          }
          if (session !== "regular" && !isCrypto) {
            warnings.push("Bracket orders only recommended during regular hours");
          }
        }
        this.finalValidation(
          { ...transformedOrder, type: orderType, timeInForce },
          session,
          isCrypto,
          warnings
        );
        return {
          ...transformedOrder,
          type: transformedOrder.type,
          timeInForce: transformedOrder.timeInForce,
          extendedHours: transformedOrder.extendedHours || false,
          transformations,
          warnings,
          session,
          isCrypto
        };
      }
      /**
       * Detect if symbol is cryptocurrency
       */
      isCryptoSymbol(symbol) {
        const upperSymbol = symbol.toUpperCase();
        const cryptoPatterns = [
          /BTC/,
          /ETH/,
          /DOGE/,
          /SOL/,
          /ADA/,
          /MATIC/,
          /AVAX/,
          /LTC/,
          /BCH/,
          /XRP/,
          /DOT/,
          /LINK/,
          /UNI/,
          /AAVE/,
          /\/USD$/,
          /\/USDT$/,
          /\/USDC$/
          // Trading pairs
        ];
        return cryptoPatterns.some((pattern) => pattern.test(upperSymbol));
      }
      /**
       * Detect current market session for a symbol
       */
      detectMarketSession(symbol) {
        const isCrypto = this.isCryptoSymbol(symbol);
        if (isCrypto) {
          return "regular";
        }
        const exchange = tradingSessionManager.detectExchange(symbol);
        const sessionInfo = tradingSessionManager.getCurrentSession(exchange);
        return sessionInfo.session;
      }
      /**
       * Check if session is extended hours
       */
      isExtendedHoursSession(session) {
        return session === "pre_market" || session === "after_hours";
      }
      /**
       * Auto-select the correct order type based on session and conditions
       */
      selectOrderType(order, session, isCrypto, transformations) {
        const requestedType = order.type || "market";
        if (session === "closed" && !isCrypto) {
          if (requestedType === "market") {
            transformations.push("Upgraded market order to limit (market closed)");
            return "limit";
          }
          return requestedType;
        }
        if (this.isExtendedHoursSession(session) && !isCrypto) {
          if (requestedType === "market" && this.config.autoUpgradeMarketToLimit) {
            transformations.push(`Upgraded market to limit order (${session})`);
            return "limit";
          }
          if (requestedType === "stop") {
            transformations.push(`Upgraded stop to stop_limit (${session})`);
            return "stop_limit";
          }
          if (requestedType === "trailing_stop") {
            transformations.push(
              `Changed trailing_stop to limit (not supported in ${session})`
            );
            return "limit";
          }
          if (!["limit", "stop_limit"].includes(requestedType)) {
            transformations.push(`Forced to limit order (${session} restriction)`);
            return "limit";
          }
        }
        return requestedType;
      }
      /**
       * Check if order needs a limit price
       */
      needsLimitPrice(orderType, needsExtendedHours) {
        if (orderType === "limit" || orderType === "stop_limit") {
          return true;
        }
        if (needsExtendedHours) {
          return true;
        }
        return false;
      }
      /**
       * Calculate appropriate limit price based on side and session
       */
      calculateLimitPrice(order, currentPrice, session, transformations, warnings) {
        if (order.limitPrice) {
          return order.limitPrice;
        }
        const { side } = order;
        const isExtendedHours = this.isExtendedHoursSession(session);
        let bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.buyBufferPercent;
        let calculatedPrice;
        let priceSource;
        if (side === "buy") {
          const basePrice = currentPrice.ask || currentPrice.last;
          bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.buyBufferPercent;
          calculatedPrice = basePrice * (1 + bufferPercent / 100);
          priceSource = currentPrice.ask ? "ask" : "last";
          transformations.push(
            `Auto-calculated buy limit: $${calculatedPrice.toFixed(2)} (${priceSource} + ${bufferPercent}% buffer)`
          );
        } else {
          const basePrice = currentPrice.bid || currentPrice.last;
          bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.sellBufferPercent;
          calculatedPrice = basePrice * (1 - bufferPercent / 100);
          priceSource = currentPrice.bid ? "bid" : "last";
          transformations.push(
            `Auto-calculated sell limit: $${calculatedPrice.toFixed(2)} (${priceSource} - ${bufferPercent}% buffer)`
          );
        }
        if (currentPrice.spread && currentPrice.spread > 0.02) {
          warnings.push(
            `Wide spread detected (${(currentPrice.spread * 100).toFixed(2)}%) - limit price may result in poor fill`
          );
        }
        const decimals = calculatedPrice < 1 ? 4 : 2;
        return calculatedPrice.toFixed(decimals);
      }
      /**
       * Select appropriate time-in-force
       */
      selectTimeInForce(order, session, isCrypto, needsExtendedHours, transformations) {
        const requestedTIF = order.timeInForce || "day";
        const orderType = order.type;
        if (orderType === "market" && requestedTIF === "gtc") {
          transformations.push(
            "Changed market order TIF from 'gtc' to 'day' (not allowed)"
          );
          return "day";
        }
        if (needsExtendedHours && this.config.forceExtendedHoursDayTIF) {
          if (requestedTIF !== "day") {
            transformations.push(
              `Forced TIF to 'day' for extended hours (${session})`
            );
          }
          return "day";
        }
        if (order.orderClass === "bracket" && requestedTIF !== "day") {
          transformations.push(
            "Forced bracket order TIF to 'day' (Alpaca requirement)"
          );
          return "day";
        }
        if (session === "closed" && !isCrypto) {
          if (requestedTIF === "ioc" || requestedTIF === "fok") {
            transformations.push(
              "Changed TIF from 'ioc'/'fok' to 'day' (market closed)"
            );
            return "day";
          }
        }
        if (isCrypto && orderType === "market") {
          if (requestedTIF === "gtc") {
            transformations.push(
              "Changed crypto market order TIF from 'gtc' to 'ioc'"
            );
            return "ioc";
          }
        }
        if ((orderType === "stop" || orderType === "trailing_stop") && !["day", "gtc"].includes(requestedTIF)) {
          transformations.push(
            `Changed ${orderType} TIF to 'day' (only day/gtc allowed)`
          );
          return "day";
        }
        return requestedTIF;
      }
      /**
       * Validate limit price to warn on potentially bad prices
       */
      validateLimitPrice(order, currentPrice, warnings) {
        const limitPrice = parseFloat(order.limitPrice);
        const marketPrice = currentPrice.last;
        const { side, type } = order;
        if (currentPrice.spread && currentPrice.spread > 0.02) {
          warnings.push(
            `Wide spread detected (${(currentPrice.spread * 100).toFixed(2)}%) - limit price may result in poor fill`
          );
        }
        if (type === "limit") {
          if (side === "buy") {
            if (limitPrice > marketPrice * 1.05) {
              warnings.push(
                `Buy limit $${limitPrice.toFixed(2)} is ${((limitPrice / marketPrice - 1) * 100).toFixed(1)}% above market $${marketPrice.toFixed(2)} - may fill at worse price`
              );
            }
            if (limitPrice < marketPrice * 0.95) {
              warnings.push(
                `Buy limit $${limitPrice.toFixed(2)} is ${((1 - limitPrice / marketPrice) * 100).toFixed(1)}% below market $${marketPrice.toFixed(2)} - may not fill`
              );
            }
          } else {
            if (limitPrice < marketPrice * 0.95) {
              warnings.push(
                `Sell limit $${limitPrice.toFixed(2)} is ${((1 - limitPrice / marketPrice) * 100).toFixed(1)}% below market $${marketPrice.toFixed(2)} - may fill at worse price`
              );
            }
            if (limitPrice > marketPrice * 1.05) {
              warnings.push(
                `Sell limit $${limitPrice.toFixed(2)} is ${((limitPrice / marketPrice - 1) * 100).toFixed(1)}% above market $${marketPrice.toFixed(2)} - may not fill`
              );
            }
          }
        }
      }
      /**
       * Final validation before returning
       */
      finalValidation(order, session, isCrypto, warnings) {
        if (session !== "regular" && !isCrypto && order.qty) {
          const qty = parseFloat(order.qty);
          if (qty < 1 || qty % 1 !== 0) {
            warnings.push(
              "Fractional shares not allowed in extended hours - order may be rejected"
            );
          }
        }
        if (session !== "regular" && !isCrypto && order.notional) {
          warnings.push(
            "Notional orders may not work in extended hours - consider using qty instead"
          );
        }
        if ((order.type === "stop" || order.type === "trailing_stop") && session !== "regular" && !isCrypto) {
          warnings.push(`${order.type} orders may not trigger in extended hours`);
        }
      }
      /**
       * Update configuration
       */
      updateConfig(config2) {
        this.config = { ...this.config, ...config2 };
        log.info("SmartOrderRouter", "Configuration updated", config2);
      }
      /**
       * Get current configuration
       */
      getConfig() {
        return { ...this.config };
      }
    };
    smartOrderRouter = new SmartOrderRouter();
  }
});

// server/universe/alpacaUniverse.ts
import { eq as eq11, and as and9 } from "drizzle-orm";
function isOtcExchange(exchange) {
  return OTC_EXCHANGES.includes(exchange.toUpperCase());
}
function isSpacName(name) {
  const spacPatterns = [
    /acquisition corp/i,
    /SPAC/i,
    /blank check/i,
    /special purpose/i
  ];
  return spacPatterns.some((pattern) => pattern.test(name));
}
var OTC_EXCHANGES, PENNY_STOCK_THRESHOLD2, AlpacaUniverseService, alpacaUniverseService;
var init_alpacaUniverse = __esm({
  "server/universe/alpacaUniverse.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_alpaca();
    init_logger();
    OTC_EXCHANGES = ["OTC", "OTCBB", "OTCQB", "OTCQX", "PINK"];
    PENNY_STOCK_THRESHOLD2 = 5;
    AlpacaUniverseService = class {
      async refreshAssets(options = {}) {
        const startTime = Date.now();
        const {
          status = "active",
          assetClass = "us_equity",
          includeOtc = false,
          includeSpac = false,
          includePennyStocks = false,
          traceId
        } = options;
        log.info("AlpacaUniverse", "Starting asset refresh", {
          assetClass,
          status,
          traceId
        });
        let alpacaAssets;
        try {
          alpacaAssets = await alpaca.getAssets(status, assetClass);
        } catch (error) {
          log.error("AlpacaUniverse", "Failed to fetch Alpaca assets", {
            error: error instanceof Error ? error.message : String(error)
          });
          throw new Error(`Failed to fetch Alpaca assets: ${error}`);
        }
        log.info("AlpacaUniverse", "Fetched assets from Alpaca", {
          count: alpacaAssets.length
        });
        let added = 0;
        let updated = 0;
        let excluded = 0;
        const existingSymbols = new Set(
          (await db.select({ symbol: universeAssets.symbol }).from(universeAssets)).map((a) => a.symbol)
        );
        for (const asset of alpacaAssets) {
          const isOtc = isOtcExchange(asset.exchange);
          const isSpac = isSpacName(asset.name);
          let shouldExclude = false;
          let excludeReason = null;
          if (isOtc && !includeOtc) {
            shouldExclude = true;
            excludeReason = "OTC excluded by policy";
          } else if (isSpac && !includeSpac) {
            shouldExclude = true;
            excludeReason = "SPAC excluded by policy";
          }
          const assetData = {
            symbol: asset.symbol,
            name: asset.name,
            exchange: asset.exchange,
            assetClass: asset.class,
            status: asset.status,
            tradable: asset.tradable,
            marginable: asset.marginable,
            shortable: asset.shortable,
            fractionable: asset.fractionable,
            easyToBorrow: asset.easy_to_borrow,
            isOtc,
            isSpac,
            isPennyStock: false,
            excluded: shouldExclude,
            excludeReason,
            rawJson: asset
          };
          try {
            if (existingSymbols.has(asset.symbol)) {
              await db.update(universeAssets).set({
                ...assetData,
                lastRefreshedAt: /* @__PURE__ */ new Date()
              }).where(eq11(universeAssets.symbol, asset.symbol));
              updated++;
            } else {
              await db.insert(universeAssets).values(assetData);
              added++;
            }
            if (shouldExclude) {
              excluded++;
            }
          } catch (error) {
            log.error("AlpacaUniverse", "Failed to upsert asset", {
              symbol: asset.symbol,
              error: error instanceof Error ? error.message : String(error)
            });
          }
        }
        const fetchedSymbols = new Set(alpacaAssets.map((a) => a.symbol));
        const symbolsToRemove = [...existingSymbols].filter(
          (s) => !fetchedSymbols.has(s)
        );
        for (const symbol of symbolsToRemove) {
          await db.update(universeAssets).set({
            tradable: false,
            status: "delisted",
            excluded: true,
            excludeReason: "No longer in Alpaca assets",
            lastRefreshedAt: /* @__PURE__ */ new Date()
          }).where(eq11(universeAssets.symbol, symbol));
          await db.delete(universeLiquidityMetrics).where(eq11(universeLiquidityMetrics.symbol, symbol));
        }
        log.info(
          "AlpacaUniverse",
          "Cleaned up delisted symbols from liquidity metrics",
          { count: symbolsToRemove.length }
        );
        const duration = Date.now() - startTime;
        log.info("AlpacaUniverse", "Refresh complete", {
          added,
          updated,
          removed: symbolsToRemove.length,
          excluded,
          duration
        });
        return {
          success: true,
          added,
          updated,
          removed: symbolsToRemove.length,
          excluded,
          duration,
          traceId
        };
      }
      async getStats() {
        const allAssets = await db.select().from(universeAssets);
        const byExchange = {};
        const byAssetClass = {};
        let activeTradable = 0;
        let excluded = 0;
        let otcCount = 0;
        let spacCount = 0;
        let pennyStockCount = 0;
        let lastRefreshedAt = null;
        for (const asset of allAssets) {
          byExchange[asset.exchange] = (byExchange[asset.exchange] || 0) + 1;
          byAssetClass[asset.assetClass] = (byAssetClass[asset.assetClass] || 0) + 1;
          if (asset.tradable && !asset.excluded) {
            activeTradable++;
          }
          if (asset.excluded) {
            excluded++;
          }
          if (asset.isOtc) {
            otcCount++;
          }
          if (asset.isSpac) {
            spacCount++;
          }
          if (asset.isPennyStock) {
            pennyStockCount++;
          }
          if (!lastRefreshedAt || asset.lastRefreshedAt > lastRefreshedAt) {
            lastRefreshedAt = asset.lastRefreshedAt;
          }
        }
        return {
          totalAssets: allAssets.length,
          activeTradable,
          excluded,
          byExchange,
          byAssetClass,
          otcCount,
          spacCount,
          pennyStockCount,
          lastRefreshedAt
        };
      }
      async getAssets(options = {}) {
        const {
          tradableOnly = true,
          excludeOtc = true,
          excludeSpac = true,
          excludePennyStocks = true,
          exchange,
          limit: limit4 = 1e3,
          offset = 0
        } = options;
        let query = db.select().from(universeAssets);
        const conditions = [];
        if (tradableOnly) {
          conditions.push(eq11(universeAssets.tradable, true));
          conditions.push(eq11(universeAssets.excluded, false));
        }
        if (excludeOtc) {
          conditions.push(eq11(universeAssets.isOtc, false));
        }
        if (excludeSpac) {
          conditions.push(eq11(universeAssets.isSpac, false));
        }
        if (excludePennyStocks) {
          conditions.push(eq11(universeAssets.isPennyStock, false));
        }
        if (exchange) {
          conditions.push(eq11(universeAssets.exchange, exchange));
        }
        if (conditions.length > 0) {
          query = query.where(and9(...conditions));
        }
        return query.limit(limit4).offset(offset);
      }
      async getAssetBySymbol(symbol) {
        const result = await db.select().from(universeAssets).where(eq11(universeAssets.symbol, symbol.toUpperCase())).limit(1);
        return result[0] || null;
      }
      async setExcluded(symbol, excluded, reason) {
        const result = await db.update(universeAssets).set({
          excluded,
          excludeReason: reason || null,
          lastRefreshedAt: /* @__PURE__ */ new Date()
        }).where(eq11(universeAssets.symbol, symbol.toUpperCase()));
        return true;
      }
      async markPennyStock(symbol, isPennyStock) {
        await db.update(universeAssets).set({
          isPennyStock,
          excluded: isPennyStock,
          excludeReason: isPennyStock ? "Penny stock (price < $5)" : null,
          lastRefreshedAt: /* @__PURE__ */ new Date()
        }).where(eq11(universeAssets.symbol, symbol.toUpperCase()));
        return true;
      }
      async updatePennyStockFlags(prices) {
        let updated = 0;
        for (const [symbol, price] of Object.entries(prices)) {
          const isPenny = price < PENNY_STOCK_THRESHOLD2;
          await this.markPennyStock(symbol, isPenny);
          if (isPenny) updated++;
        }
        return updated;
      }
      async getTradableSymbols() {
        const assets = await this.getAssets({ tradableOnly: true });
        return assets.map((a) => a.symbol);
      }
      async isSymbolTradable(symbol) {
        const asset = await this.getAssetBySymbol(symbol);
        if (!asset) return false;
        return asset.tradable && !asset.excluded;
      }
    };
    alpacaUniverseService = new AlpacaUniverseService();
  }
});

// server/universe/tradingEnforcement.ts
import { eq as eq12 } from "drizzle-orm";
var TradingEnforcementService, tradingEnforcementService;
var init_tradingEnforcement = __esm({
  "server/universe/tradingEnforcement.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_logger();
    TradingEnforcementService = class {
      rejectedAttempts = 0;
      lastCheckedAt = null;
      async canTradeSymbol(symbol, traceId) {
        this.lastCheckedAt = /* @__PURE__ */ new Date();
        const upperSymbol = symbol.toUpperCase();
        try {
          const candidate = await db.query.universeCandidates.findFirst({
            where: eq12(universeCandidates.symbol, upperSymbol)
          });
          if (!candidate) {
            this.rejectedAttempts++;
            log.info(
              "TradingEnforcement",
              "Symbol NOT in candidates - trade BLOCKED",
              { traceId, symbol: upperSymbol }
            );
            return {
              symbol: upperSymbol,
              eligible: false,
              reason: "Symbol not in approved candidates list",
              details: { status: "MISSING" }
            };
          }
          if (candidate.status !== "APPROVED") {
            this.rejectedAttempts++;
            log.info(
              "TradingEnforcement",
              "Symbol status not APPROVED - trade BLOCKED",
              { traceId, symbol: upperSymbol, status: candidate.status }
            );
            return {
              symbol: upperSymbol,
              eligible: false,
              reason: `Symbol status is ${candidate.status}, not APPROVED`,
              details: {
                status: candidate.status,
                liquidityTier: candidate.tier || void 0,
                approvedAt: null,
                approvedBy: null
              }
            };
          }
          const asset = await db.query.universeAssets.findFirst({
            where: eq12(universeAssets.symbol, upperSymbol)
          });
          if (asset && !asset.tradable) {
            this.rejectedAttempts++;
            log.info(
              "TradingEnforcement",
              "Symbol marked non-tradable by Alpaca - trade BLOCKED",
              { traceId, symbol: upperSymbol }
            );
            return {
              symbol: upperSymbol,
              eligible: false,
              reason: "Symbol is marked non-tradable by Alpaca",
              details: { status: candidate.status }
            };
          }
          const liquidity = await db.query.universeLiquidityMetrics.findFirst({
            where: eq12(universeLiquidityMetrics.symbol, upperSymbol)
          });
          const isPennyStock = liquidity?.latestPrice && parseFloat(liquidity.latestPrice) < 5;
          if (isPennyStock) {
            this.rejectedAttempts++;
            log.info(
              "TradingEnforcement",
              "Symbol is a penny stock - trade BLOCKED",
              { traceId, symbol: upperSymbol, price: liquidity?.latestPrice }
            );
            return {
              symbol: upperSymbol,
              eligible: false,
              reason: "Penny stocks (price < $5) are not tradable",
              details: {
                status: candidate.status,
                isPennyStock: true,
                liquidityTier: liquidity?.liquidityTier || void 0
              }
            };
          }
          log.info("TradingEnforcement", "Symbol APPROVED - trade ALLOWED", {
            traceId,
            symbol: upperSymbol
          });
          return {
            symbol: upperSymbol,
            eligible: true,
            reason: "Symbol is approved for trading",
            details: {
              status: candidate.status,
              liquidityTier: candidate.tier || void 0,
              approvedAt: candidate.approvedAt,
              approvedBy: candidate.approvedBy
            }
          };
        } catch (error) {
          log.error("TradingEnforcement", "Error checking symbol", {
            traceId,
            symbol: upperSymbol,
            error: error instanceof Error ? error.message : String(error)
          });
          this.rejectedAttempts++;
          return {
            symbol: upperSymbol,
            eligible: false,
            reason: "Error checking trading eligibility"
          };
        }
      }
      async canTradeMultiple(symbols, traceId) {
        const results = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          const result = await this.canTradeSymbol(symbol, traceId);
          results.set(symbol.toUpperCase(), result);
        }
        return results;
      }
      async getApprovedSymbolsSet(traceId) {
        try {
          const approved = await db.query.universeCandidates.findMany({
            where: eq12(universeCandidates.status, "APPROVED"),
            columns: { symbol: true }
          });
          log.info("TradingEnforcement", "Retrieved approved symbols", {
            traceId,
            count: approved.length
          });
          return new Set(approved.map((c) => c.symbol));
        } catch (error) {
          log.error("TradingEnforcement", "Error getting approved symbols", {
            traceId,
            error: error instanceof Error ? error.message : String(error)
          });
          return /* @__PURE__ */ new Set();
        }
      }
      async filterToApproved(symbols, traceId) {
        const approvedSet = await this.getApprovedSymbolsSet(traceId);
        return symbols.filter((s) => approvedSet.has(s.toUpperCase()));
      }
      async getStats() {
        const approved = await db.query.universeCandidates.findMany({
          where: eq12(universeCandidates.status, "APPROVED"),
          columns: { symbol: true }
        });
        return {
          approvedCount: approved.length,
          rejectedAttempts: this.rejectedAttempts,
          lastCheckedAt: this.lastCheckedAt
        };
      }
      resetStats() {
        this.rejectedAttempts = 0;
        this.lastCheckedAt = null;
      }
    };
    tradingEnforcementService = new TradingEnforcementService();
  }
});

// server/universe/allocationService.ts
import { eq as eq13, and as and11, desc as desc7, sql as sql24 } from "drizzle-orm";
var AllocationService, allocationService;
var init_allocationService = __esm({
  "server/universe/allocationService.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_alpaca();
    init_logger();
    AllocationService = class {
      async getActivePolicy() {
        const policy = await db.query.allocationPolicies.findFirst({
          where: eq13(allocationPolicies.isActive, true)
        });
        return policy ?? null;
      }
      async getPolicyById(id) {
        const policy = await db.query.allocationPolicies.findFirst({
          where: eq13(allocationPolicies.id, id)
        });
        return policy ?? null;
      }
      async listPolicies() {
        return db.query.allocationPolicies.findMany({
          orderBy: [desc7(allocationPolicies.createdAt)]
        });
      }
      async createPolicy(data) {
        if (data.isActive) {
          await db.update(allocationPolicies).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq13(allocationPolicies.isActive, true));
        }
        const [policy] = await db.insert(allocationPolicies).values(data).returning();
        return policy;
      }
      async updatePolicy(id, data) {
        if (data.isActive === true) {
          await db.update(allocationPolicies).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(
            and11(
              eq13(allocationPolicies.isActive, true),
              sql24`${allocationPolicies.id} != ${id}`
            )
          );
        }
        const [updated] = await db.update(allocationPolicies).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).returning().where(eq13(allocationPolicies.id, id));
        return updated || null;
      }
      async activatePolicy(id) {
        return this.updatePolicy(id, { isActive: true });
      }
      async deactivatePolicy(id) {
        return this.updatePolicy(id, { isActive: false });
      }
      async analyzeRebalance(traceId) {
        const policy = await this.getActivePolicy();
        if (!policy) {
          log.info("Allocation", "No active policy found", { traceId });
          return null;
        }
        const [account, positions2] = await Promise.all([
          alpaca.getAccount(),
          alpaca.getPositions()
        ]);
        const portfolioValue = parseFloat(account.equity);
        log.info("Allocation", "Portfolio value calculated", {
          traceId,
          portfolioValue: portfolioValue.toFixed(2)
        });
        const currentPositions = /* @__PURE__ */ new Map();
        for (const pos of positions2) {
          const marketValue = parseFloat(pos.market_value);
          currentPositions.set(pos.symbol, {
            qty: parseFloat(pos.qty),
            marketValue,
            weightPct: marketValue / portfolioValue * 100
          });
        }
        const approved = await db.query.universeCandidates.findMany({
          where: eq13(universeCandidates.status, "APPROVED")
        });
        const approvedSymbols = approved.map((c) => c.symbol);
        const minTier = policy.minLiquidityTier || "B";
        const tierOrder = ["A", "B", "C"];
        const eligibleSymbols = [];
        for (const candidate of approved) {
          if (!candidate.tier) continue;
          const candidateTierIdx = tierOrder.indexOf(candidate.tier);
          const minTierIdx = tierOrder.indexOf(minTier);
          if (candidateTierIdx <= minTierIdx) {
            eligibleSymbols.push(candidate.symbol);
          }
        }
        const maxWeight = parseFloat(policy.maxPositionWeightPct || "8");
        const rotationTopN = policy.rotationTopN || 10;
        const profitThreshold = parseFloat(policy.profitTakingThresholdPct || "20") / 100;
        const overweightThreshold = parseFloat(policy.overweightThresholdPct || "50") / 100;
        const profitTakingCandidates = [];
        const overweightPositions = [];
        for (const [symbol, pos] of currentPositions) {
          if (pos.weightPct > maxWeight * (1 + overweightThreshold)) {
            overweightPositions.push(symbol);
          }
        }
        const targetPositions = [];
        const numPositions = Math.min(eligibleSymbols.length, rotationTopN);
        const equalWeight = numPositions > 0 ? Math.min(100 / numPositions, maxWeight) : 0;
        for (const symbol of eligibleSymbols.slice(0, rotationTopN)) {
          const current = currentPositions.get(symbol);
          targetPositions.push({
            symbol,
            targetWeightPct: equalWeight,
            currentWeightPct: current?.weightPct || 0,
            reason: "Approved high-quality candidate"
          });
        }
        const intents = [];
        for (const target of targetPositions) {
          const delta = target.targetWeightPct - target.currentWeightPct;
          const notionalDelta = delta / 100 * portfolioValue;
          if (Math.abs(delta) < 0.5) {
            intents.push({
              symbol: target.symbol,
              action: "HOLD",
              targetWeightPct: target.targetWeightPct,
              currentWeightPct: target.currentWeightPct,
              notionalDelta: 0,
              reason: "Within tolerance"
            });
          } else if (delta > 0) {
            intents.push({
              symbol: target.symbol,
              action: "BUY",
              targetWeightPct: target.targetWeightPct,
              currentWeightPct: target.currentWeightPct,
              notionalDelta,
              reason: "Underweight vs target"
            });
          } else {
            intents.push({
              symbol: target.symbol,
              action: "TRIM",
              targetWeightPct: target.targetWeightPct,
              currentWeightPct: target.currentWeightPct,
              notionalDelta,
              reason: "Overweight vs target"
            });
          }
        }
        for (const [symbol, pos] of currentPositions) {
          if (!approvedSymbols.includes(symbol)) {
            intents.push({
              symbol,
              action: "SELL",
              targetWeightPct: 0,
              currentWeightPct: pos.weightPct,
              notionalDelta: -pos.marketValue,
              reason: "Position not in approved list - sell to exit"
            });
          }
        }
        log.info("Allocation", "Analysis complete", {
          traceId,
          intentsCount: intents.length
        });
        return {
          policy,
          portfolioValue,
          approvedSymbols,
          currentPositions,
          targetPositions,
          intents,
          profitTakingCandidates,
          rotationCandidates: eligibleSymbols.slice(0, rotationTopN)
        };
      }
      async createRebalanceRun(data) {
        const [run] = await db.insert(rebalanceRuns).values(data).returning();
        return run;
      }
      async getRebalanceRuns(limit4 = 20) {
        return db.query.rebalanceRuns.findMany({
          orderBy: [desc7(rebalanceRuns.startedAt)],
          limit: limit4
        });
      }
      async getRebalanceRunById(id) {
        const run = await db.query.rebalanceRuns.findFirst({
          where: eq13(rebalanceRuns.id, id)
        });
        return run ?? null;
      }
      async updateRebalanceRun(id, data) {
        const [updated] = await db.update(rebalanceRuns).set(data).returning().where(eq13(rebalanceRuns.id, id));
        return updated || null;
      }
      async getStats() {
        const [policies, activePolicy, runs] = await Promise.all([
          db.query.allocationPolicies.findMany(),
          this.getActivePolicy(),
          db.query.rebalanceRuns.findMany({
            orderBy: [desc7(rebalanceRuns.startedAt)],
            limit: 10
          })
        ]);
        return {
          totalPolicies: policies.length,
          activePolicyId: activePolicy?.id || null,
          activePolicyName: activePolicy?.name || null,
          recentRuns: runs.length,
          lastRunAt: runs[0]?.startedAt || null
        };
      }
    };
    allocationService = new AllocationService();
  }
});

// server/universe/rebalancerService.ts
import { desc as desc8 } from "drizzle-orm";
var RebalancerService, rebalancerService;
var init_rebalancerService = __esm({
  "server/universe/rebalancerService.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_allocationService();
    init_tradingEnforcement();
    init_work_queue();
    init_alpaca();
    init_logger();
    RebalancerService = class {
      async executeDryRun(traceId) {
        log.info("RebalancerService", "Starting dry run analysis", { traceId });
        const analysis = await allocationService.analyzeRebalance(traceId);
        if (!analysis) {
          log.info("RebalancerService", "No active policy - cannot analyze", {
            traceId
          });
          return null;
        }
        const profitTaking = await this.analyzeProfitTaking(
          analysis.policy,
          traceId
        );
        let wouldSubmit = 0;
        let wouldSkip = 0;
        for (const intent of analysis.intents) {
          if (intent.action === "HOLD") {
            wouldSkip++;
            continue;
          }
          const enforcement = await tradingEnforcementService.canTradeSymbol(
            intent.symbol,
            traceId
          );
          if (intent.action === "SELL" || enforcement.eligible) {
            wouldSubmit++;
          } else {
            wouldSkip++;
          }
        }
        log.info("RebalancerService", "Dry run complete", {
          traceId,
          wouldSubmit,
          wouldSkip
        });
        return {
          analysis,
          profitTaking,
          wouldSubmit,
          wouldSkip
        };
      }
      async executeRebalance(traceId, dryRun = false) {
        const startTime = Date.now();
        log.info("RebalancerService", "Starting rebalance execution", {
          traceId,
          dryRun
        });
        const analysis = await allocationService.analyzeRebalance(traceId);
        if (!analysis) {
          return {
            runId: "",
            traceId,
            success: false,
            intentsGenerated: 0,
            ordersSubmitted: 0,
            ordersSkipped: 0,
            errors: ["No active allocation policy configured"],
            duration: Date.now() - startTime
          };
        }
        const run = await allocationService.createRebalanceRun({
          policyId: analysis.policy.id,
          traceId,
          status: "pending",
          triggerType: dryRun ? "manual_dry_run" : "manual",
          inputSnapshot: {
            portfolioValue: analysis.portfolioValue,
            approvedSymbolCount: analysis.approvedSymbols.length,
            currentPositionCount: analysis.currentPositions.size
          },
          orderIntents: analysis.intents
        });
        if (dryRun) {
          await allocationService.updateRebalanceRun(run.id, {
            status: "dry_run_complete",
            completedAt: /* @__PURE__ */ new Date(),
            rationale: `Dry run: ${analysis.intents.length} intents generated, no orders submitted`
          });
          return {
            runId: run.id,
            traceId,
            success: true,
            intentsGenerated: analysis.intents.length,
            ordersSubmitted: 0,
            ordersSkipped: analysis.intents.length,
            errors: [],
            duration: Date.now() - startTime
          };
        }
        await allocationService.updateRebalanceRun(run.id, { status: "executing" });
        const errors = [];
        let ordersSubmitted = 0;
        let ordersSkipped = 0;
        const executedOrders = [];
        const sellIntents = analysis.intents.filter(
          (i) => i.action === "SELL" || i.action === "TRIM"
        );
        const buyIntents = analysis.intents.filter((i) => i.action === "BUY");
        for (const intent of sellIntents) {
          if (Math.abs(intent.notionalDelta) < 10) {
            ordersSkipped++;
            continue;
          }
          try {
            const enforcement = await tradingEnforcementService.canTradeSymbol(
              intent.symbol,
              traceId
            );
            if (intent.action === "SELL" || enforcement.eligible) {
              const currentPos = analysis.currentPositions.get(intent.symbol);
              if (!currentPos) {
                ordersSkipped++;
                continue;
              }
              const sellValue = Math.abs(intent.notionalDelta);
              let price = 0;
              try {
                const snapshots = await alpaca.getSnapshots([intent.symbol]);
                const snapshot = snapshots?.[intent.symbol];
                price = snapshot?.latestTrade?.p || snapshot?.latestQuote?.ap || 0;
              } catch (e) {
                log.warn("RebalancerService", "Failed to get snapshot", {
                  traceId,
                  symbol: intent.symbol
                });
              }
              if (!price || price <= 0 || !isFinite(price)) {
                errors.push(`${intent.symbol}: Could not get valid price`);
                ordersSkipped++;
                continue;
              }
              const rawQtyToSell = Math.floor(sellValue / price);
              const qtyToSell = Math.min(rawQtyToSell, currentPos.qty);
              if (qtyToSell < 1) {
                ordersSkipped++;
                continue;
              }
              const idempotencyKey = generateIdempotencyKey({
                strategyId: `rebalance-${run.id}`,
                symbol: intent.symbol,
                side: "sell"
              });
              const workItem = await workQueue.enqueue({
                type: "ORDER_SUBMIT",
                symbol: intent.symbol,
                idempotencyKey,
                payload: JSON.stringify({
                  symbol: intent.symbol,
                  side: "sell",
                  qty: qtyToSell.toString(),
                  type: "market",
                  time_in_force: "day",
                  traceId
                }),
                maxAttempts: 3
              });
              executedOrders.push({
                symbol: intent.symbol,
                workItemId: workItem.id,
                side: "sell"
              });
              ordersSubmitted++;
            } else {
              ordersSkipped++;
            }
          } catch (error) {
            const msg = error instanceof Error ? error.message : String(error);
            errors.push(`${intent.symbol}: ${msg}`);
            ordersSkipped++;
          }
        }
        for (const intent of buyIntents) {
          if (!intent.notionalDelta || !isFinite(intent.notionalDelta) || intent.notionalDelta < 10) {
            ordersSkipped++;
            continue;
          }
          try {
            const enforcement = await tradingEnforcementService.canTradeSymbol(
              intent.symbol,
              traceId
            );
            if (!enforcement.eligible) {
              log.info("RebalancerService", "Skipping BUY", {
                traceId,
                symbol: intent.symbol,
                reason: enforcement.reason
              });
              ordersSkipped++;
              continue;
            }
            const idempotencyKey = generateIdempotencyKey({
              strategyId: `rebalance-${run.id}`,
              symbol: intent.symbol,
              side: "buy"
            });
            const workItem = await workQueue.enqueue({
              type: "ORDER_SUBMIT",
              symbol: intent.symbol,
              idempotencyKey,
              payload: JSON.stringify({
                symbol: intent.symbol,
                side: "buy",
                notional: intent.notionalDelta.toFixed(2),
                type: "market",
                time_in_force: "day",
                traceId
              }),
              maxAttempts: 3
            });
            executedOrders.push({
              symbol: intent.symbol,
              workItemId: workItem.id,
              side: "buy"
            });
            ordersSubmitted++;
          } catch (error) {
            const msg = error instanceof Error ? error.message : String(error);
            errors.push(`${intent.symbol}: ${msg}`);
            ordersSkipped++;
          }
        }
        const holdIntents = analysis.intents.filter(
          (i) => i.action === "HOLD"
        ).length;
        ordersSkipped += holdIntents;
        const finalStatus = errors.length > 0 ? "completed_with_errors" : "completed";
        await allocationService.updateRebalanceRun(run.id, {
          status: finalStatus,
          completedAt: /* @__PURE__ */ new Date(),
          executedOrders,
          rationale: `Submitted ${ordersSubmitted} orders, skipped ${ordersSkipped}. ${errors.length} errors.`
        });
        log.info("RebalancerService", "Execution complete", {
          traceId,
          ordersSubmitted,
          errorCount: errors.length
        });
        return {
          runId: run.id,
          traceId,
          success: errors.length === 0,
          intentsGenerated: analysis.intents.length,
          ordersSubmitted,
          ordersSkipped,
          errors,
          duration: Date.now() - startTime
        };
      }
      async analyzeProfitTaking(policy, traceId) {
        if (!policy) return [];
        const profitThreshold = parseFloat(policy.profitTakingThresholdPct || "20") / 100;
        const positions2 = await alpaca.getPositions();
        const results = [];
        for (const pos of positions2) {
          const costBasis = parseFloat(pos.cost_basis);
          const currentValue = parseFloat(pos.market_value);
          const unrealizedPnlPct = (currentValue - costBasis) / costBasis;
          if (unrealizedPnlPct >= profitThreshold) {
            const excessGain = unrealizedPnlPct - profitThreshold;
            const recommendedTrimPct = Math.min(excessGain * 50, 25);
            results.push({
              symbol: pos.symbol,
              costBasis,
              currentValue,
              unrealizedPnlPct: unrealizedPnlPct * 100,
              recommendedTrimPct,
              reason: `Gain of ${(unrealizedPnlPct * 100).toFixed(1)}% exceeds ${(profitThreshold * 100).toFixed(0)}% threshold`
            });
          }
        }
        log.info("RebalancerService", "Profit-taking analysis", {
          traceId,
          candidateCount: results.length
        });
        return results;
      }
      async getStats() {
        const runs = await db.query.rebalanceRuns.findMany({
          orderBy: [desc8(rebalanceRuns.startedAt)],
          limit: 20
        });
        const successfulRuns = runs.filter((r) => r.status === "completed").length;
        const totalOrders = runs.reduce((sum, r) => {
          const orders2 = r.executedOrders;
          return sum + (Array.isArray(orders2) ? orders2.length : 0);
        }, 0);
        return {
          recentRuns: runs.length,
          successfulRuns,
          totalOrdersSubmitted: totalOrders,
          lastRunAt: runs[0]?.startedAt || null,
          lastRunStatus: runs[0]?.status || null
        };
      }
    };
    rebalancerService = new RebalancerService();
  }
});

// server/universe/index.ts
var universe_exports = {};
__export(universe_exports, {
  allocationService: () => allocationService,
  alpacaUniverseService: () => alpacaUniverseService,
  candidatesService: () => candidatesService,
  fundamentalsService: () => fundamentalsService,
  liquidityService: () => liquidityService,
  rebalancerService: () => rebalancerService,
  tradingEnforcementService: () => tradingEnforcementService
});
var init_universe2 = __esm({
  "server/universe/index.ts"() {
    "use strict";
    init_alpacaUniverse();
    init_liquidityService();
    init_fundamentalsService();
    init_candidatesService();
    init_tradingEnforcement();
    init_allocationService();
    init_rebalancerService();
  }
});

// server/lib/work-queue.ts
var work_queue_exports = {};
__export(work_queue_exports, {
  calculateNextRunAt: () => calculateNextRunAt,
  classifyError: () => classifyError2,
  generateIdempotencyKey: () => generateIdempotencyKey,
  workQueue: () => workQueue
});
import crypto2 from "crypto";
async function getAdminUserId() {
  if (cachedAdminUserId) return cachedAdminUserId;
  const adminUser = await storage.getAdminUser();
  if (!adminUser) {
    throw new Error("No admin user found - cannot process work items");
  }
  cachedAdminUserId = adminUser.id;
  return cachedAdminUserId;
}
function generateIdempotencyKey(params) {
  const bucket = params.timeframeBucket || Math.floor(Date.now() / 6e4).toString();
  const data = `${params.strategyId}:${params.symbol}:${params.side}:${params.signalHash || ""}:${bucket}`;
  return crypto2.createHash("sha256").update(data).digest("hex").substring(0, 32);
}
function classifyError2(error) {
  const errorStr = error instanceof Error ? error.message : String(error);
  if (PERMANENT_ERROR_PATTERNS.some((p) => p.test(errorStr))) {
    return "permanent";
  }
  if (TRANSIENT_ERROR_PATTERNS.some((p) => p.test(errorStr))) {
    return "transient";
  }
  return "unknown";
}
function calculateNextRunAt(type, attempts) {
  const delays = RETRY_DELAYS_MS[type] || [5e3, 15e3, 6e4];
  const delayIndex = Math.min(attempts, delays.length - 1);
  const baseDelay = delays[delayIndex];
  const jitter = Math.random() * baseDelay * 0.2;
  return new Date(Date.now() + baseDelay + jitter);
}
var getTradingEnforcementService, cachedAdminUserId, RETRY_DELAYS_MS, TRANSIENT_ERROR_PATTERNS, PERMANENT_ERROR_PATTERNS, WorkQueueServiceImpl, workQueue;
var init_work_queue = __esm({
  "server/lib/work-queue.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_logger();
    init_tradability_service();
    init_redis_cache();
    init_smart_order_router();
    getTradingEnforcementService = async () => {
      const { tradingEnforcementService: tradingEnforcementService2 } = await Promise.resolve().then(() => (init_universe2(), universe_exports));
      return tradingEnforcementService2;
    };
    cachedAdminUserId = null;
    RETRY_DELAYS_MS = {
      ORDER_SUBMIT: [1e3, 5e3, 15e3],
      ORDER_CANCEL: [1e3, 3e3, 1e4],
      ORDER_SYNC: [5e3, 15e3, 6e4],
      POSITION_CLOSE: [1e3, 5e3, 15e3],
      KILL_SWITCH: [500, 2e3, 5e3],
      DECISION_EVALUATION: [2e3, 1e4, 3e4],
      ASSET_UNIVERSE_SYNC: [6e4, 3e5, 6e5]
    };
    TRANSIENT_ERROR_PATTERNS = [
      /timeout/i,
      /network/i,
      /ECONNREFUSED/i,
      /ETIMEDOUT/i,
      /rate.?limit/i,
      /429/,
      /5\d\d/,
      /temporary/i,
      /unavailable/i
    ];
    PERMANENT_ERROR_PATTERNS = [
      /invalid.*symbol/i,
      /insufficient.*buying/i,
      /account.*blocked/i,
      /not.*tradable/i,
      /market.*closed/i,
      /invalid.*quantity/i,
      /rejected/i,
      /client_order_id.*unique/i,
      // 422 duplicate client_order_id
      /4[0-3]\d/
    ];
    WorkQueueServiceImpl = class {
      workerInterval = null;
      processing = false;
      async enqueue(item) {
        if (item.idempotencyKey) {
          const existing = await this.getByIdempotencyKey(item.idempotencyKey);
          if (existing) {
            log.info(
              "work-queue",
              `Duplicate work item detected: ${item.idempotencyKey}`
            );
            return existing;
          }
        }
        return storage.createWorkItem(item);
      }
      async claimNext(types) {
        const lockKey = "work_queue:claim";
        const result = await withLock(
          lockKey,
          async () => {
            return storage.claimNextWorkItem(types);
          },
          10
        );
        return result;
      }
      async markSucceeded(id, result) {
        await storage.updateWorkItem(id, {
          status: "SUCCEEDED",
          result: result || null,
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async markFailed(id, error, retryable = true) {
        const item = await storage.getWorkItem(id);
        if (!item) return;
        const newAttempts = item.attempts + 1;
        const maxAttempts = item.maxAttempts || 3;
        if (!retryable || newAttempts >= maxAttempts) {
          await storage.updateWorkItem(id, {
            status: "DEAD_LETTER",
            lastError: error,
            attempts: newAttempts,
            updatedAt: /* @__PURE__ */ new Date()
          });
        } else {
          const nextRunAt = calculateNextRunAt(
            item.type,
            newAttempts
          );
          await storage.updateWorkItem(id, {
            status: "PENDING",
            lastError: error,
            attempts: newAttempts,
            nextRunAt,
            updatedAt: /* @__PURE__ */ new Date()
          });
        }
      }
      async markDeadLetter(id, reason) {
        await storage.updateWorkItem(id, {
          status: "DEAD_LETTER",
          lastError: reason,
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async invalidateWorkItem(id, reason) {
        const item = await storage.getWorkItem(id);
        if (!item) {
          log.warn("work-queue", `Cannot invalidate work item ${id}: not found`);
          return;
        }
        log.info("work-queue", `Invalidating work item ${id}: ${reason}`, {
          originalStatus: item.status,
          symbol: item.symbol,
          idempotencyKey: item.idempotencyKey
        });
        await storage.updateWorkItem(id, {
          status: "DEAD_LETTER",
          lastError: `INVALIDATED: ${reason}`,
          idempotencyKey: `invalidated-${id}-${Date.now()}`,
          // Change the key so new orders don't match
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async getById(id) {
        const item = await storage.getWorkItem(id);
        return item || null;
      }
      async getByIdempotencyKey(key) {
        return storage.getWorkItemByIdempotencyKey(key);
      }
      async getPendingCount(type) {
        return storage.getWorkItemCount("PENDING", type);
      }
      async getRecentItems(limit4 = 50, status) {
        return storage.getWorkItems(limit4, status);
      }
      async retryDeadLetter(id) {
        const item = await storage.getWorkItem(id);
        if (!item || item.status !== "DEAD_LETTER") return null;
        await storage.updateWorkItem(id, {
          status: "PENDING",
          attempts: 0,
          nextRunAt: /* @__PURE__ */ new Date(),
          lastError: null,
          updatedAt: /* @__PURE__ */ new Date()
        });
        const updated = await storage.getWorkItem(id);
        return updated || null;
      }
      async processOrderSubmit(item) {
        const payload = JSON.parse(item.payload || "{}");
        const {
          symbol,
          side,
          qty,
          notional,
          type,
          time_in_force,
          limit_price,
          stop_price,
          extended_hours,
          order_class,
          take_profit_limit_price,
          stop_loss_stop_price,
          // Also extract nested objects for bracket orders (orchestrator sends nested format)
          take_profit,
          stop_loss,
          traceId
        } = payload;
        const agentStatus2 = await storage.getAgentStatus();
        if (agentStatus2?.killSwitchActive) {
          log.warn(
            "work-queue",
            `ORDER_BLOCKED: Kill switch is active - rejecting order for ${symbol}`,
            {
              traceId,
              workItemId: item.id,
              symbol,
              side,
              reason: "KILL_SWITCH_ACTIVE"
            }
          );
          await this.markFailed(
            item.id,
            "Kill switch is active - all trading halted",
            false
          );
          return;
        }
        const effectiveTakeProfitLimitPrice = take_profit_limit_price || take_profit?.limit_price;
        const effectiveStopLossStopPrice = stop_loss_stop_price || stop_loss?.stop_price;
        log.info("work-queue", `Processing ORDER_SUBMIT for ${symbol} ${side}`, {
          traceId,
          workItemId: item.id,
          symbol,
          side
        });
        if (side !== "sell") {
          const enforcementService = await getTradingEnforcementService();
          const enforcementCheck = await enforcementService.canTradeSymbol(
            symbol,
            traceId
          );
          if (!enforcementCheck.eligible) {
            log.warn(
              "work-queue",
              `ORDER_BLOCKED: ${symbol} - Trading enforcement rejected`,
              {
                traceId,
                workItemId: item.id,
                symbol,
                side,
                qty,
                notional,
                orderType: type,
                reason: "TRADING_ENFORCEMENT_BLOCKED",
                enforcementReason: enforcementCheck.reason,
                blockCategory: "SYMBOL_NOT_APPROVED",
                suggestion: "Add symbol to approved candidates list or ensure it passes universe eligibility"
              }
            );
            await this.markFailed(
              item.id,
              `Symbol ${symbol} blocked by trading enforcement: ${enforcementCheck.reason}`,
              false
            );
            return;
          }
        } else {
          log.info(
            "work-queue",
            `Bypassing enforcement check for SELL order on ${symbol}`,
            { traceId }
          );
        }
        const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
        if (!tradabilityCheck.tradable) {
          log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - Symbol not tradable`, {
            traceId,
            workItemId: item.id,
            symbol,
            side,
            qty,
            notional,
            orderType: type,
            reason: "SYMBOL_NOT_TRADABLE",
            tradabilityReason: tradabilityCheck.reason,
            blockCategory: "BROKER_UNIVERSE",
            suggestion: "Symbol may not be in Alpaca universe or may be a penny stock (<$5)"
          });
          await this.markFailed(
            item.id,
            `Symbol ${symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}`,
            false
          );
          return;
        }
        const isCrypto = symbol.includes("/") || ["BTC", "ETH", "SOL", "DOGE", "SHIB", "AVAX"].some(
          (c) => symbol.toUpperCase().startsWith(c)
        );
        let currentPriceData = { bid: 0, ask: 0, last: 0, spread: 0 };
        try {
          if (!isCrypto) {
            const snapshots = await alpaca.getSnapshots([symbol]);
            const snapshot = snapshots[symbol];
            if (snapshot?.latestTrade?.p) {
              const lastPrice = snapshot.latestTrade.p;
              const bidPrice = snapshot.latestQuote?.bp || lastPrice * 0.999;
              const askPrice = snapshot.latestQuote?.ap || lastPrice * 1.001;
              currentPriceData = createPriceData({
                bid: bidPrice,
                ask: askPrice,
                last: lastPrice
              });
            }
          } else {
            const cryptoSnapshots = await alpaca.getCryptoSnapshots([symbol]);
            const snapshot = cryptoSnapshots[symbol];
            if (snapshot?.latestTrade?.p) {
              const lastPrice = snapshot.latestTrade.p;
              currentPriceData = createPriceData({
                bid: lastPrice * 0.999,
                ask: lastPrice * 1.001,
                last: lastPrice
              });
            }
          }
        } catch (priceError) {
          log.warn(
            "work-queue",
            `Failed to fetch price for ${symbol}, using market order if possible`,
            { traceId, error: String(priceError) }
          );
        }
        const orderInput = {
          symbol,
          side,
          qty,
          notional,
          type: type || "market",
          timeInForce: time_in_force || "day",
          limitPrice: limit_price?.toString(),
          stopPrice: stop_price?.toString(),
          extendedHours: extended_hours,
          orderClass: order_class,
          takeProfitLimitPrice: effectiveTakeProfitLimitPrice?.toString(),
          stopLossStopPrice: effectiveStopLossStopPrice?.toString()
        };
        const transformedOrder = transformOrderForExecution(
          orderInput,
          currentPriceData
        );
        if (transformedOrder.transformations.length > 0) {
          log.info(
            "work-queue",
            `ORDER_TRANSFORMED: ${symbol} - ${transformedOrder.transformations.length} changes applied`,
            {
              traceId,
              workItemId: item.id,
              symbol,
              side,
              originalType: type || "market",
              newType: transformedOrder.type,
              originalTIF: time_in_force || "day",
              newTIF: transformedOrder.timeInForce,
              limitPrice: transformedOrder.limitPrice,
              extendedHours: transformedOrder.extendedHours,
              session: transformedOrder.session,
              transformations: transformedOrder.transformations
            }
          );
        }
        if (transformedOrder.warnings.length > 0) {
          log.warn(
            "work-queue",
            `ORDER_WARNINGS: ${symbol} - ${transformedOrder.warnings.length} warnings`,
            {
              traceId,
              workItemId: item.id,
              symbol,
              warnings: transformedOrder.warnings
            }
          );
        }
        const baseClientOrderId = item.idempotencyKey || item.id;
        const clientOrderId = item.attempts > 0 ? `${baseClientOrderId.substring(0, 24)}-r${item.attempts}` : baseClientOrderId.substring(0, 32);
        const existingOrders = await alpaca.getOrders("all", 200);
        const existingOrder = existingOrders.find(
          (o) => o.client_order_id === clientOrderId || o.client_order_id === baseClientOrderId || o.client_order_id?.startsWith(baseClientOrderId.substring(0, 20))
        );
        if (existingOrder) {
          log.info(
            "work-queue",
            `Order already exists for client_order_id ${clientOrderId}: ${existingOrder.id}`,
            { traceId }
          );
          await storage.updateWorkItem(item.id, {
            brokerOrderId: existingOrder.id,
            result: JSON.stringify({
              orderId: existingOrder.id,
              status: existingOrder.status
            })
          });
          await this.markSucceeded(
            item.id,
            JSON.stringify({ orderId: existingOrder.id, deduplicated: true })
          );
          return;
        }
        let validatedQty = transformedOrder.qty;
        let validatedNotional = transformedOrder.notional;
        if (side === "sell" && validatedQty) {
          try {
            const positions2 = await alpaca.getPositions();
            const position = positions2.find((p) => p.symbol === symbol);
            if (!position) {
              log.warn(
                "work-queue",
                `ORDER_BLOCKED: ${symbol} - No position found to sell`,
                {
                  traceId,
                  workItemId: item.id,
                  requestedQty: validatedQty
                }
              );
              await this.markFailed(
                item.id,
                `No position found for ${symbol} - cannot sell`,
                false
              );
              return;
            }
            const availableQty = parseFloat(
              position.qty_available || position.qty || "0"
            );
            const requestedQty = parseFloat(validatedQty);
            const heldForOrders = parseFloat(position.qty) - availableQty;
            log.info("work-queue", `Position validation for ${symbol}`, {
              traceId,
              requestedQty,
              availableQty,
              totalQty: position.qty,
              heldForOrders: heldForOrders.toString()
            });
            if (availableQty <= 0) {
              log.warn(
                "work-queue",
                `ORDER_BLOCKED: ${symbol} - No available shares (all held for other orders)`,
                {
                  traceId,
                  workItemId: item.id,
                  availableQty,
                  heldForOrders: heldForOrders.toString()
                }
              );
              await this.markFailed(
                item.id,
                `No available shares for ${symbol} (${availableQty} available, rest held for orders)`,
                false
              );
              return;
            }
            if (requestedQty > availableQty) {
              log.warn(
                "work-queue",
                `ORDER_QTY_ADJUSTED: ${symbol} - Clamping qty from ${requestedQty} to ${availableQty}`,
                {
                  traceId,
                  workItemId: item.id,
                  originalQty: requestedQty,
                  clampedQty: availableQty
                }
              );
            }
            let finalQty = Math.min(requestedQty, availableQty);
            if (transformedOrder.extendedHours) {
              const wholeQty = Math.floor(finalQty);
              if (wholeQty <= 0) {
                log.warn(
                  "work-queue",
                  `ORDER_BLOCKED: ${symbol} - Fractional shares cannot trade in extended hours`,
                  {
                    traceId,
                    workItemId: item.id,
                    availableQty: finalQty,
                    session: transformedOrder.session
                  }
                );
                await this.markFailed(
                  item.id,
                  `Cannot sell fractional shares (${finalQty}) during extended hours`,
                  false
                );
                return;
              }
              if (wholeQty < finalQty) {
                log.info(
                  "work-queue",
                  `ORDER_QTY_ROUNDED: ${symbol} - Rounding down from ${finalQty} to ${wholeQty} for extended hours`,
                  {
                    traceId,
                    workItemId: item.id
                  }
                );
              }
              finalQty = wholeQty;
            }
            validatedQty = finalQty.toString();
          } catch (posError) {
            const errorMessage = posError instanceof Error ? posError.message : String(posError);
            log.error(
              "work-queue",
              `Position validation failed for ${symbol}: ${errorMessage}`,
              { traceId }
            );
          }
        }
        if (side === "buy" && validatedNotional && transformedOrder.extendedHours && currentPriceData.last > 0) {
          try {
            const requestedNotional = parseFloat(validatedNotional);
            const estimatedShares = requestedNotional / currentPriceData.last;
            if (estimatedShares < 1) {
              log.warn(
                "work-queue",
                `ORDER_BLOCKED: ${symbol} - Notional too small for whole share in extended hours`,
                {
                  traceId,
                  workItemId: item.id,
                  notional: requestedNotional,
                  estimatedShares,
                  price: currentPriceData.last
                }
              );
              await this.markFailed(
                item.id,
                `Notional $${requestedNotional} too small for 1 share at $${currentPriceData.last}`,
                false
              );
              return;
            }
          } catch (validationError4) {
            const errorMessage = validationError4 instanceof Error ? validationError4.message : String(validationError4);
            log.warn(
              "work-queue",
              `Extended hours validation failed: ${errorMessage}`,
              { traceId }
            );
          }
        }
        const orderParams = {
          symbol,
          side,
          type: transformedOrder.type,
          time_in_force: transformedOrder.timeInForce,
          client_order_id: clientOrderId
        };
        if (validatedQty) orderParams.qty = validatedQty;
        if (validatedNotional) orderParams.notional = validatedNotional;
        if (transformedOrder.limitPrice)
          orderParams.limit_price = transformedOrder.limitPrice;
        if (stop_price) orderParams.stop_price = stop_price;
        if (transformedOrder.extendedHours)
          orderParams.extended_hours = transformedOrder.extendedHours;
        if (transformedOrder.orderClass) {
          orderParams.order_class = transformedOrder.orderClass;
          if (transformedOrder.orderClass === "bracket") {
            if (transformedOrder.takeProfitLimitPrice) {
              orderParams.take_profit = {
                limit_price: transformedOrder.takeProfitLimitPrice
              };
            }
            if (transformedOrder.stopLossStopPrice) {
              orderParams.stop_loss = {
                stop_price: transformedOrder.stopLossStopPrice
              };
            }
          }
        }
        log.info("work-queue", `Submitting order to Alpaca`, {
          traceId,
          workItemId: item.id,
          symbol,
          type: orderParams.type,
          timeInForce: orderParams.time_in_force,
          limitPrice: orderParams.limit_price,
          extendedHours: orderParams.extended_hours,
          session: transformedOrder.session
        });
        const order = await alpaca.createOrder(orderParams);
        log.info("work-queue", `ORDER_SUBMIT succeeded: ${order.id}`, {
          traceId,
          workItemId: item.id,
          orderId: order.id,
          status: order.status
        });
        const userId = await getAdminUserId();
        const orderData = {
          userId,
          broker: "alpaca",
          brokerOrderId: order.id,
          clientOrderId,
          symbol,
          side,
          // Use VALIDATED values that were actually submitted
          type: transformedOrder.type,
          timeInForce: transformedOrder.timeInForce,
          qty: validatedQty?.toString(),
          notional: validatedNotional?.toString(),
          limitPrice: transformedOrder.limitPrice?.toString(),
          stopPrice: stop_price?.toString(),
          status: order.status,
          // Capture extended_hours and order_class from Alpaca response
          extendedHours: order.extended_hours || transformedOrder.extendedHours || false,
          orderClass: order.order_class || transformedOrder.orderClass || "simple",
          submittedAt: new Date(order.submitted_at || Date.now()),
          updatedAt: /* @__PURE__ */ new Date(),
          filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
          expiredAt: order.expired_at ? new Date(order.expired_at) : void 0,
          canceledAt: order.canceled_at ? new Date(order.canceled_at) : void 0,
          failedAt: order.failed_at ? new Date(order.failed_at) : void 0,
          filledQty: order.filled_qty?.toString(),
          filledAvgPrice: order.filled_avg_price?.toString(),
          traceId,
          workItemId: item.id,
          rawJson: order
        };
        await storage.upsertOrderByBrokerOrderId(order.id, orderData);
        await storage.updateWorkItem(item.id, { brokerOrderId: order.id });
        await this.markSucceeded(
          item.id,
          JSON.stringify({ orderId: order.id, status: order.status })
        );
      }
      async processOrderCancel(item) {
        const payload = JSON.parse(item.payload || "{}");
        const { orderId } = payload;
        if (!orderId) {
          await this.markFailed(item.id, "Missing orderId in payload", false);
          return;
        }
        await alpaca.cancelOrder(orderId);
        await this.markSucceeded(
          item.id,
          JSON.stringify({ canceledOrderId: orderId })
        );
      }
      async processOrderSync(item) {
        const payload = JSON.parse(item.payload || "{}");
        const traceId = payload.traceId || `sync-${Date.now()}`;
        log.info("work-queue", "Starting order sync", {
          traceId,
          workItemId: item.id
        });
        const [openOrders, recentOrders] = await Promise.all([
          alpaca.getOrders("open", 100),
          alpaca.getOrders("closed", 50)
        ]);
        const allOrders = [...openOrders, ...recentOrders];
        let ordersUpserted = 0;
        let fillsCreated = 0;
        for (const alpacaOrder of allOrders) {
          try {
            let workItemId;
            if (alpacaOrder.client_order_id) {
              const workItem = await storage.getWorkItemByIdempotencyKey(
                alpacaOrder.client_order_id
              );
              if (workItem) {
                workItemId = workItem.id;
              }
            }
            const orderData = {
              broker: "alpaca",
              brokerOrderId: alpacaOrder.id,
              clientOrderId: alpacaOrder.client_order_id || void 0,
              symbol: alpacaOrder.symbol,
              side: alpacaOrder.side,
              type: alpacaOrder.type || alpacaOrder.order_type || "market",
              timeInForce: alpacaOrder.time_in_force,
              qty: alpacaOrder.qty,
              notional: alpacaOrder.notional || void 0,
              limitPrice: alpacaOrder.limit_price || void 0,
              stopPrice: alpacaOrder.stop_price || void 0,
              status: alpacaOrder.status,
              // ADDED: Capture all Alpaca order metadata for complete tracking
              extendedHours: alpacaOrder.extended_hours || false,
              orderClass: alpacaOrder.order_class || "simple",
              submittedAt: new Date(alpacaOrder.submitted_at),
              updatedAt: new Date(alpacaOrder.updated_at || Date.now()),
              filledAt: alpacaOrder.filled_at ? new Date(alpacaOrder.filled_at) : void 0,
              expiredAt: alpacaOrder.expired_at ? new Date(alpacaOrder.expired_at) : void 0,
              canceledAt: alpacaOrder.canceled_at ? new Date(alpacaOrder.canceled_at) : void 0,
              failedAt: alpacaOrder.failed_at ? new Date(alpacaOrder.failed_at) : void 0,
              filledQty: alpacaOrder.filled_qty,
              filledAvgPrice: alpacaOrder.filled_avg_price || void 0,
              traceId,
              workItemId,
              rawJson: alpacaOrder
            };
            await storage.upsertOrderByBrokerOrderId(alpacaOrder.id, orderData);
            ordersUpserted++;
            if (alpacaOrder.filled_at && parseFloat(alpacaOrder.filled_qty) > 0) {
              const existingFills = await storage.getFillsByBrokerOrderId(
                alpacaOrder.id
              );
              if (existingFills.length === 0) {
                const dbOrder = await storage.getOrderByBrokerOrderId(
                  alpacaOrder.id
                );
                const fillData = {
                  broker: "alpaca",
                  brokerOrderId: alpacaOrder.id,
                  orderId: dbOrder?.id,
                  symbol: alpacaOrder.symbol,
                  side: alpacaOrder.side,
                  qty: alpacaOrder.filled_qty,
                  price: alpacaOrder.filled_avg_price || "0",
                  occurredAt: new Date(alpacaOrder.filled_at),
                  traceId,
                  rawJson: {
                    filled_qty: alpacaOrder.filled_qty,
                    filled_avg_price: alpacaOrder.filled_avg_price,
                    filled_at: alpacaOrder.filled_at
                  }
                };
                await storage.createFill(fillData);
                fillsCreated++;
              }
            }
          } catch (error) {
            log.warn(
              "work-queue",
              `Failed to sync order ${alpacaOrder.id}: ${error}`,
              { traceId }
            );
          }
        }
        log.info("work-queue", `Order sync completed`, {
          traceId,
          ordersUpserted,
          fillsCreated,
          openOrders: openOrders.length,
          recentOrders: recentOrders.length
        });
        await this.markSucceeded(
          item.id,
          JSON.stringify({
            ordersUpserted,
            fillsCreated,
            openOrders: openOrders.length,
            recentOrders: recentOrders.length,
            syncedAt: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
      }
      async processKillSwitch(item) {
        await alpaca.cancelAllOrders();
        const payload = JSON.parse(item.payload || "{}");
        if (payload.closePositions) {
          const positions2 = await alpaca.getPositions();
          for (const pos of positions2) {
            try {
              await alpaca.closePosition(pos.symbol);
            } catch (e) {
              log.warn(
                "work-queue",
                `Failed to close position ${pos.symbol}: ${e}`
              );
            }
          }
        }
        await storage.updateAgentStatus({
          killSwitchActive: true,
          updatedAt: /* @__PURE__ */ new Date()
        });
        await this.markSucceeded(
          item.id,
          JSON.stringify({
            canceledOrders: true,
            closedPositions: payload.closePositions || false,
            executedAt: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
      }
      async processAssetUniverseSync(item) {
        const payload = JSON.parse(item.payload || "{}");
        const assetClass = payload.assetClass || "us_equity";
        log.info("work-queue", `Starting asset universe sync for ${assetClass}`);
        const result = await tradabilityService.syncAssetUniverse(assetClass);
        if (result.errors.length > 0) {
          throw new Error(result.errors.join("; "));
        }
        tradabilityService.clearMemoryCache();
        await this.markSucceeded(
          item.id,
          JSON.stringify({
            assetClass,
            synced: result.synced,
            tradable: result.tradable,
            syncedAt: (/* @__PURE__ */ new Date()).toISOString()
          })
        );
      }
      async processItem(item) {
        const startTime = Date.now();
        await storage.createWorkItemRun({
          workItemId: item.id,
          attemptNumber: item.attempts + 1,
          status: "RUNNING"
        });
        try {
          switch (item.type) {
            case "ORDER_SUBMIT":
              await this.processOrderSubmit(item);
              break;
            case "ORDER_CANCEL":
              await this.processOrderCancel(item);
              break;
            case "ORDER_SYNC":
              await this.processOrderSync(item);
              break;
            case "KILL_SWITCH":
              await this.processKillSwitch(item);
              break;
            case "ASSET_UNIVERSE_SYNC":
              await this.processAssetUniverseSync(item);
              break;
            default:
              log.warn("work-queue", `Unknown work item type: ${item.type}`);
              await this.markFailed(item.id, `Unknown type: ${item.type}`, false);
          }
        } catch (error) {
          const errorClass = classifyError2(error);
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error(
            "work-queue",
            `Work item ${item.id} failed (${errorClass}): ${errorMsg}`
          );
          await this.markFailed(item.id, errorMsg, errorClass === "transient");
        }
      }
      async runWorkerCycle() {
        if (this.processing) return;
        this.processing = true;
        try {
          const item = await this.claimNext();
          if (item) {
            await this.processItem(item);
          }
        } catch (error) {
          log.error("work-queue", `Worker cycle error: ${error}`);
        } finally {
          this.processing = false;
        }
      }
      startWorker(intervalMs = 5e3) {
        if (this.workerInterval) return;
        log.info(
          "work-queue",
          `Starting work queue worker with ${intervalMs}ms interval`
        );
        this.workerInterval = setInterval(() => this.runWorkerCycle(), intervalMs);
      }
      stopWorker() {
        if (this.workerInterval) {
          clearInterval(this.workerInterval);
          this.workerInterval = null;
          log.info("work-queue", "Work queue worker stopped");
        }
      }
      async drain() {
        this.stopWorker();
        const maxWaitMs = 3e4;
        const startTime = Date.now();
        while (this.processing && Date.now() - startTime < maxWaitMs) {
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
        if (this.processing) {
          log.warn("work-queue", "Drain timeout - work item still processing");
        } else {
          log.info("work-queue", "Work queue drained successfully");
        }
      }
    };
    workQueue = new WorkQueueServiceImpl();
  }
});

// server/fusion/data-fusion-engine.ts
var DataFusionEngine, dataFusionEngine;
var init_data_fusion_engine2 = __esm({
  "server/fusion/data-fusion-engine.ts"() {
    "use strict";
    init_coingecko();
    init_finnhub();
    init_logger();
    DataFusionEngine = class {
      cache = /* @__PURE__ */ new Map();
      cacheDuration = 30 * 1e3;
      lastFusionTime = 0;
      getCached(key) {
        const entry = this.cache.get(key);
        if (entry && Date.now() - entry.timestamp < this.cacheDuration) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async getMarketIntelligence() {
        const cacheKey = "market_intelligence";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const signals = [];
        let activeSources = 0;
        const totalSources = 4;
        let cryptoMomentum = 0.5;
        let cryptoVolatility = 0.5;
        let cryptoSentiment = 0.5;
        let cryptoVolume = 0.5;
        let stockMomentum = 0.5;
        let stockSentiment = 0.5;
        let hasCryptoData = false;
        let hasStockData = false;
        let hasNewsData = false;
        let hasGlobalData = false;
        try {
          const cryptoMarkets = await coingecko.getMarkets(
            "usd",
            20,
            1,
            "market_cap_desc"
          );
          if (cryptoMarkets && cryptoMarkets.length > 0) {
            hasCryptoData = true;
            activeSources++;
            const avgChange = cryptoMarkets.reduce(
              (sum, c) => sum + (c.price_change_percentage_24h || 0),
              0
            ) / cryptoMarkets.length;
            const positiveCoins = cryptoMarkets.filter(
              (c) => (c.price_change_percentage_24h || 0) > 0
            ).length;
            const marketBreadth = positiveCoins / cryptoMarkets.length;
            cryptoMomentum = this.normalizeScore((avgChange + 10) / 20);
            cryptoSentiment = marketBreadth;
            const volatility = cryptoMarkets.reduce((sum, c) => {
              const range = c.high_24h && c.low_24h ? (c.high_24h - c.low_24h) / c.low_24h : 0;
              return sum + range;
            }, 0) / cryptoMarkets.length;
            cryptoVolatility = this.normalizeScore(1 - volatility * 5);
            const avgVolume = cryptoMarkets.reduce((sum, c) => sum + (c.total_volume || 0), 0) / cryptoMarkets.length;
            const avgMarketCap = cryptoMarkets.reduce((sum, c) => sum + (c.market_cap || 0), 0) / cryptoMarkets.length;
            const volumeRatio = avgVolume / avgMarketCap;
            cryptoVolume = this.normalizeScore(volumeRatio * 10);
            if (avgChange > 5) {
              signals.push({
                type: "bullish",
                source: "CoinGecko",
                message: `Crypto market up ${avgChange.toFixed(1)}% in 24h`,
                strength: Math.min(avgChange / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (avgChange < -5) {
              signals.push({
                type: "bearish",
                source: "CoinGecko",
                message: `Crypto market down ${Math.abs(avgChange).toFixed(1)}% in 24h`,
                strength: Math.min(Math.abs(avgChange) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
            if (marketBreadth > 0.7) {
              signals.push({
                type: "bullish",
                source: "CoinGecko",
                message: `${(marketBreadth * 100).toFixed(0)}% of top 20 coins are positive`,
                strength: marketBreadth,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (marketBreadth < 0.3) {
              signals.push({
                type: "bearish",
                source: "CoinGecko",
                message: `Only ${(marketBreadth * 100).toFixed(0)}% of top 20 coins are positive`,
                strength: 1 - marketBreadth,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch crypto data for fusion", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        try {
          const globalData = await coingecko.getGlobalData();
          if (globalData?.data) {
            hasGlobalData = true;
            activeSources++;
            const mcChange = globalData.data.market_cap_change_percentage_24h_usd;
            if (mcChange > 3) {
              signals.push({
                type: "bullish",
                source: "CoinGecko Global",
                message: `Total crypto market cap up ${mcChange.toFixed(1)}%`,
                strength: Math.min(mcChange / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (mcChange < -3) {
              signals.push({
                type: "bearish",
                source: "CoinGecko Global",
                message: `Total crypto market cap down ${Math.abs(mcChange).toFixed(1)}%`,
                strength: Math.min(Math.abs(mcChange) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch global data for fusion", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        try {
          const stockSymbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"];
          const quotes = await finnhub.getMultipleQuotes(stockSymbols);
          if (quotes.size > 0) {
            const changes = [];
            quotes.forEach((quote) => {
              if (quote.dp !== void 0 && !isNaN(quote.dp)) {
                changes.push(quote.dp);
              }
            });
            if (changes.length > 0) {
              hasStockData = true;
              activeSources++;
              const avgChange = changes.reduce((sum, c) => sum + c, 0) / changes.length;
              if (!isNaN(avgChange)) {
                const positiveStocks = changes.filter((c) => c > 0).length;
                const stockBreadth = positiveStocks / changes.length;
                stockMomentum = this.normalizeScore((avgChange + 5) / 10);
                stockSentiment = isNaN(stockBreadth) ? 0.5 : stockBreadth;
                if (avgChange > 2) {
                  signals.push({
                    type: "bullish",
                    source: "Finnhub",
                    message: `Tech stocks up ${avgChange.toFixed(1)}% average`,
                    strength: Math.min(avgChange / 5, 1),
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  });
                } else if (avgChange < -2) {
                  signals.push({
                    type: "bearish",
                    source: "Finnhub",
                    message: `Tech stocks down ${Math.abs(avgChange).toFixed(1)}% average`,
                    strength: Math.min(Math.abs(avgChange) / 5, 1),
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  });
                }
              }
            }
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch stock data for fusion", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        try {
          const news = await finnhub.getMarketNews("general");
          if (news && news.length > 0) {
            hasNewsData = true;
            activeSources++;
            const recentNews = news.slice(0, 10);
            const sentimentKeywords = {
              bullish: [
                "surge",
                "rally",
                "gains",
                "bullish",
                "record",
                "soar",
                "jump",
                "breakthrough",
                "growth",
                "strong"
              ],
              bearish: [
                "crash",
                "plunge",
                "bearish",
                "decline",
                "fall",
                "drop",
                "slump",
                "weak",
                "fear",
                "concern"
              ]
            };
            let bullishCount = 0;
            let bearishCount = 0;
            recentNews.forEach((article) => {
              const text17 = (article.headline + " " + article.summary).toLowerCase();
              sentimentKeywords.bullish.forEach((kw) => {
                if (text17.includes(kw)) bullishCount++;
              });
              sentimentKeywords.bearish.forEach((kw) => {
                if (text17.includes(kw)) bearishCount++;
              });
            });
            if (bullishCount > bearishCount + 3) {
              signals.push({
                type: "bullish",
                source: "Finnhub News",
                message: `News sentiment is predominantly positive`,
                strength: Math.min((bullishCount - bearishCount) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (bearishCount > bullishCount + 3) {
              signals.push({
                type: "bearish",
                source: "Finnhub News",
                message: `News sentiment is predominantly negative`,
                strength: Math.min((bearishCount - bullishCount) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch news for fusion", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        const momentumScore = hasCryptoData && hasStockData ? cryptoMomentum * 0.5 + stockMomentum * 0.5 : hasCryptoData ? cryptoMomentum : hasStockData ? stockMomentum : 0.5;
        const volatilityScore = hasCryptoData ? cryptoVolatility : 0.5;
        const volumeScore = hasCryptoData ? cryptoVolume : 0.5;
        const sentimentScore = hasCryptoData && hasStockData ? cryptoSentiment * 0.5 + stockSentiment * 0.5 : hasCryptoData ? cryptoSentiment : hasStockData ? stockSentiment : 0.5;
        const weights = {
          momentum: 0.35,
          volatility: 0.15,
          sentiment: 0.35,
          volume: 0.15
        };
        const overall = momentumScore * weights.momentum + volatilityScore * weights.volatility + sentimentScore * weights.sentiment + volumeScore * weights.volume;
        let dataQuality;
        if (activeSources >= 4) dataQuality = "excellent";
        else if (activeSources >= 3) dataQuality = "good";
        else if (activeSources >= 2) dataQuality = "fair";
        else dataQuality = "poor";
        const result = {
          overall: this.normalizeScore(overall),
          components: {
            momentum: this.normalizeScore(momentumScore),
            volatility: this.normalizeScore(volatilityScore),
            sentiment: this.normalizeScore(sentimentScore),
            volume: this.normalizeScore(volumeScore)
          },
          signals: signals.slice(0, 5),
          dataQuality,
          activeSources,
          totalSources,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
        this.setCache(cacheKey, result);
        this.lastFusionTime = Date.now();
        return result;
      }
      async getFusedMarketData() {
        const cacheKey = "fused_market_data";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        let topCoins = [];
        let globalData = null;
        let marketCapChange24h = 0;
        let dominanceBTC = 0;
        let totalMarketCap = 0;
        try {
          topCoins = await coingecko.getMarkets("usd", 10, 1, "market_cap_desc");
        } catch (error) {
          log.error("DataFusion", "Failed to fetch top coins", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        try {
          const global2 = await coingecko.getGlobalData();
          if (global2?.data) {
            globalData = global2.data;
            marketCapChange24h = global2.data.market_cap_change_percentage_24h_usd || 0;
            dominanceBTC = global2.data.market_cap_percentage?.btc || 0;
            totalMarketCap = global2.data.total_market_cap?.usd || 0;
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch global data", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        let stockQuotes = {};
        let stockNews = [];
        let stockAvgChange = 0;
        let stockMarketSentiment = "neutral";
        try {
          const quotesMap = await finnhub.getMultipleQuotes([
            "AAPL",
            "GOOGL",
            "MSFT",
            "AMZN",
            "TSLA"
          ]);
          const changes = [];
          quotesMap.forEach((quote, symbol) => {
            stockQuotes[symbol] = quote;
            if (quote.dp !== void 0 && !isNaN(quote.dp)) {
              changes.push(quote.dp);
            }
          });
          if (changes.length > 0) {
            const avgChange = changes.reduce((sum, c) => sum + c, 0) / changes.length;
            stockAvgChange = isNaN(avgChange) ? 0 : avgChange;
            stockMarketSentiment = stockAvgChange > 1 ? "bullish" : stockAvgChange < -1 ? "bearish" : "neutral";
          }
        } catch (error) {
          log.error("DataFusion", "Failed to fetch stock quotes", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        try {
          stockNews = await finnhub.getMarketNews("general");
        } catch (error) {
          log.error("DataFusion", "Failed to fetch stock news", {
            error: error instanceof Error ? error.message : String(error)
          });
        }
        const intelligence = await this.getMarketIntelligence();
        const result = {
          crypto: {
            topCoins,
            globalData,
            marketCapChange24h,
            dominanceBTC,
            totalMarketCap
          },
          stocks: {
            quotes: stockQuotes,
            news: stockNews.slice(0, 10),
            avgChange: stockAvgChange,
            marketSentiment: stockMarketSentiment
          },
          intelligence
        };
        this.setCache(cacheKey, result);
        return result;
      }
      normalizeScore(value) {
        return Math.max(0, Math.min(1, value));
      }
      getStatus() {
        return {
          available: true,
          lastFusionTime: this.lastFusionTime,
          cacheSize: this.cache.size
        };
      }
      clearCache() {
        this.cache.clear();
      }
    };
    dataFusionEngine = new DataFusionEngine();
  }
});

// server/strategies/adaptive-risk-service.ts
var adaptive_risk_service_exports = {};
__export(adaptive_risk_service_exports, {
  ADAPTIVE_THRESHOLDS: () => ADAPTIVE_THRESHOLDS,
  choosePresetFromMarket: () => choosePresetFromMarket,
  getAdaptiveRiskStatus: () => getAdaptiveRiskStatus,
  updateStrategyRiskIfNeeded: () => updateStrategyRiskIfNeeded
});
function getPresetIndex(preset) {
  return PRESET_ORDER.indexOf(preset);
}
function stepPreset(current, direction, basePresetId) {
  const currentIdx = getPresetIndex(current);
  if (direction === "conservative") {
    const newIdx = Math.max(0, currentIdx - 1);
    return PRESET_ORDER[newIdx];
  }
  if (direction === "aggressive") {
    const newIdx = Math.min(PRESET_ORDER.length - 1, currentIdx + 1);
    return PRESET_ORDER[newIdx];
  }
  if (direction === "toward" && basePresetId) {
    const baseIdx = getPresetIndex(basePresetId);
    if (currentIdx === baseIdx) return current;
    const step = currentIdx > baseIdx ? -1 : 1;
    return PRESET_ORDER[currentIdx + step];
  }
  return current;
}
function choosePresetFromMarket(intelligence, basePresetId, currentPresetId) {
  const { overall, components } = intelligence;
  const { volatility, sentiment, momentum } = components;
  const isStressed = overall <= ADAPTIVE_THRESHOLDS.conservative.overall || volatility <= ADAPTIVE_THRESHOLDS.conservative.volatility || sentiment <= ADAPTIVE_THRESHOLDS.conservative.sentiment;
  if (isStressed) {
    return stepPreset(currentPresetId, "conservative");
  }
  const isStrong = overall >= ADAPTIVE_THRESHOLDS.aggressive.overall && momentum >= ADAPTIVE_THRESHOLDS.aggressive.momentum && volatility >= ADAPTIVE_THRESHOLDS.aggressive.volatility && sentiment >= ADAPTIVE_THRESHOLDS.aggressive.sentiment;
  if (isStrong) {
    return stepPreset(currentPresetId, "aggressive");
  }
  return stepPreset(currentPresetId, "toward", basePresetId);
}
function shouldRunAdaptiveUpdate(config2) {
  if (config2.lastAdaptiveUpdateAt === null || config2.lastAdaptiveUpdateAt === void 0)
    return true;
  const intervalMs = (config2.adaptiveRiskIntervalMinutes || 15) * 60 * 1e3;
  const lastUpdate = new Date(config2.lastAdaptiveUpdateAt).getTime();
  const now = Date.now();
  return now - lastUpdate >= intervalMs;
}
async function updateStrategyRiskIfNeeded(config2) {
  if (!config2.adaptiveRiskEnabled) {
    return {
      updated: false,
      previousPreset: config2.currentPresetId,
      newPreset: config2.currentPresetId || "balanced",
      reason: "Adaptive risk mode disabled",
      config: config2
    };
  }
  if (!shouldRunAdaptiveUpdate(config2)) {
    const currentPreset2 = config2.currentPresetId || config2.basePresetId || "balanced";
    return {
      updated: false,
      previousPreset: currentPreset2,
      newPreset: currentPreset2,
      reason: "Adaptive update interval not reached",
      config: config2
    };
  }
  const intelligence = await dataFusionEngine.getMarketIntelligence();
  const currentPreset = config2.currentPresetId || config2.basePresetId || "balanced";
  const basePreset = config2.basePresetId || "balanced";
  const configWithTimestamp = {
    ...config2,
    lastAdaptiveUpdateAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (intelligence.dataQuality === "poor" || intelligence.activeSources < ADAPTIVE_THRESHOLDS.dataQuality.minimumSources) {
    if (currentPreset !== basePreset) {
      const reason2 = intelligence.dataQuality === "poor" ? "Data quality is poor. Reverting to base preset." : `Only ${intelligence.activeSources} data sources active. Reverting to base preset.`;
      const updatedConfig2 = applyPresetToConfig(
        configWithTimestamp,
        basePreset,
        reason2
      );
      log.info(
        "AdaptiveRisk",
        `Preset change: ${currentPreset} -> ${basePreset}`,
        {
          symbol: config2.symbol,
          reason: reason2,
          dataQuality: intelligence.dataQuality,
          activeSources: intelligence.activeSources
        }
      );
      return {
        updated: true,
        previousPreset: currentPreset,
        newPreset: basePreset,
        reason: reason2,
        config: updatedConfig2
      };
    }
    return {
      updated: true,
      previousPreset: currentPreset,
      newPreset: currentPreset,
      reason: "Insufficient data quality. Maintaining base preset.",
      config: configWithTimestamp
    };
  }
  const newPreset = choosePresetFromMarket(
    intelligence,
    basePreset,
    currentPreset
  );
  if (newPreset === currentPreset) {
    return {
      updated: true,
      previousPreset: currentPreset,
      newPreset: currentPreset,
      reason: `Maintaining ${currentPreset} preset after evaluation`,
      config: configWithTimestamp
    };
  }
  const reasons = [];
  if (newPreset === "conservative") {
    const { overall, components } = intelligence;
    if (overall <= ADAPTIVE_THRESHOLDS.conservative.overall)
      reasons.push(`overall=${overall.toFixed(2)}`);
    if (components.volatility <= ADAPTIVE_THRESHOLDS.conservative.volatility)
      reasons.push(`volatility=${components.volatility.toFixed(2)}`);
    if (components.sentiment <= ADAPTIVE_THRESHOLDS.conservative.sentiment)
      reasons.push(`sentiment=${components.sentiment.toFixed(2)}`);
  } else if (newPreset === "aggressive") {
    reasons.push("Strong market conditions");
  } else {
    reasons.push("Moving toward base preset");
  }
  const reason = `Market conditions: ${reasons.join(", ")}`;
  const updatedConfig = applyPresetToConfig(
    configWithTimestamp,
    newPreset,
    reason
  );
  log.info("AdaptiveRisk", `Preset change: ${currentPreset} -> ${newPreset}`, {
    symbol: config2.symbol,
    reason,
    overall: intelligence.overall,
    components: intelligence.components
  });
  return {
    updated: true,
    previousPreset: currentPreset,
    newPreset,
    reason,
    config: updatedConfig
  };
}
function getAdaptiveRiskStatus(config2) {
  if (!config2.adaptiveRiskEnabled) {
    const preset = config2.currentPresetId || config2.basePresetId || "balanced";
    return {
      enabled: false,
      mode: "Fixed",
      currentPreset: preset.charAt(0).toUpperCase() + preset.slice(1),
      basePreset: preset.charAt(0).toUpperCase() + preset.slice(1),
      lastUpdate: null
    };
  }
  const current = config2.currentPresetId || config2.basePresetId || "balanced";
  const base = config2.basePresetId || "balanced";
  return {
    enabled: true,
    mode: "Adaptive",
    currentPreset: current.charAt(0).toUpperCase() + current.slice(1),
    basePreset: base.charAt(0).toUpperCase() + base.slice(1),
    lastUpdate: config2.lastAdaptiveUpdateAt || null
  };
}
var ADAPTIVE_THRESHOLDS, PRESET_ORDER;
var init_adaptive_risk_service = __esm({
  "server/strategies/adaptive-risk-service.ts"() {
    "use strict";
    init_logger();
    init_data_fusion_engine2();
    init_moving_average_crossover();
    ADAPTIVE_THRESHOLDS = {
      conservative: {
        overall: -0.2,
        volatility: -0.4,
        sentiment: -0.3
      },
      aggressive: {
        overall: 0.6,
        momentum: 0.4,
        volatility: 0.3,
        sentiment: 0
      },
      dataQuality: {
        minimumSources: 2
      }
    };
    PRESET_ORDER = ["conservative", "balanced", "aggressive"];
  }
});

// server/strategies/moving-average-crossover.ts
var moving_average_crossover_exports = {};
__export(moving_average_crossover_exports, {
  ADAPTIVE_DEFAULTS: () => ADAPTIVE_DEFAULTS,
  MOVING_AVERAGE_PRESETS: () => MOVING_AVERAGE_PRESETS2,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA,
  applyPresetToConfig: () => applyPresetToConfig,
  backtestMovingAverageStrategy: () => backtestMovingAverageStrategy,
  normalizeMovingAverageConfig: () => normalizeMovingAverageConfig
});
function normalizeMovingAverageConfig(input) {
  const adaptiveRiskEnabled = input.adaptiveRiskEnabled ?? false;
  const basePresetId = input.basePresetId;
  const currentPresetId = input.currentPresetId ?? basePresetId;
  const preset = MOVING_AVERAGE_PRESETS2.find(
    (p) => p.id === (currentPresetId || "balanced")
  );
  let fastPeriod = input.fastPeriod ?? preset.fastPeriod;
  let slowPeriod = input.slowPeriod ?? preset.slowPeriod;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  fastPeriod = Math.max(
    PARAMETER_BOUNDS.fastPeriod.min,
    Math.min(PARAMETER_BOUNDS.fastPeriod.max, Math.round(fastPeriod))
  );
  slowPeriod = Math.max(
    PARAMETER_BOUNDS.slowPeriod.min,
    Math.min(PARAMETER_BOUNDS.slowPeriod.max, Math.round(slowPeriod))
  );
  allocationPct = Math.max(
    PARAMETER_BOUNDS.allocationPct.min,
    Math.min(PARAMETER_BOUNDS.allocationPct.max, allocationPct)
  );
  riskLimitPct = Math.max(
    PARAMETER_BOUNDS.riskLimitPct.min,
    Math.min(PARAMETER_BOUNDS.riskLimitPct.max, riskLimitPct)
  );
  if (fastPeriod >= slowPeriod) {
    fastPeriod = Math.max(PARAMETER_BOUNDS.fastPeriod.min, slowPeriod - 5);
  }
  const effectiveBasePresetId = basePresetId || "balanced";
  const effectiveCurrentPresetId = currentPresetId || effectiveBasePresetId;
  const config2 = {
    id: input.id || `ma_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    fastPeriod,
    slowPeriod,
    allocationPct,
    riskLimitPct,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
    adaptiveRiskEnabled,
    basePresetId: effectiveBasePresetId,
    currentPresetId: effectiveCurrentPresetId,
    adaptiveRiskIntervalMinutes: input.adaptiveRiskIntervalMinutes ?? ADAPTIVE_DEFAULTS.intervalMinutes,
    lastAdaptiveUpdateAt: input.lastAdaptiveUpdateAt ?? null,
    lastPresetChangeAt: input.lastPresetChangeAt ?? null,
    lastPresetChangeReason: input.lastPresetChangeReason ?? null
  };
  return config2;
}
function applyPresetToConfig(config2, presetId, reason) {
  const preset = MOVING_AVERAGE_PRESETS2.find((p) => p.id === presetId);
  if (!preset) {
    return config2;
  }
  return {
    ...config2,
    fastPeriod: preset.fastPeriod,
    slowPeriod: preset.slowPeriod,
    allocationPct: preset.allocationPct,
    riskLimitPct: preset.riskLimitPct,
    currentPresetId: presetId,
    lastPresetChangeAt: (/* @__PURE__ */ new Date()).toISOString(),
    lastPresetChangeReason: reason
  };
}
function calculateSMA(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function detectCrossovers(fastSMA, slowSMA) {
  const crossovers = [];
  for (let i = 1; i < fastSMA.length; i++) {
    const prevFast = fastSMA[i - 1];
    const currFast = fastSMA[i];
    const prevSlow = slowSMA[i - 1];
    const currSlow = slowSMA[i];
    if (prevFast === null || currFast === null || prevSlow === null || currSlow === null) {
      continue;
    }
    if (prevFast <= prevSlow && currFast > currSlow) {
      crossovers.push({ index: i, type: "bullish" });
    } else if (prevFast >= prevSlow && currFast < currSlow) {
      crossovers.push({ index: i, type: "bearish" });
    }
  }
  return crossovers;
}
async function backtestMovingAverageStrategy(config2, lookbackDays = 365) {
  let normalizedConfig = normalizeMovingAverageConfig(config2);
  const { updateStrategyRiskIfNeeded: updateStrategyRiskIfNeeded2 } = await Promise.resolve().then(() => (init_adaptive_risk_service(), adaptive_risk_service_exports));
  const adaptiveResult = await updateStrategyRiskIfNeeded2(normalizedConfig);
  normalizedConfig = adaptiveResult.config;
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(
      `Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`
    );
  }
  if (!bars || bars.length < normalizedConfig.slowPeriod + 10) {
    throw new Error(
      `Insufficient historical data for ${normalizedConfig.symbol}. Need at least ${normalizedConfig.slowPeriod + 10} days of data.`
    );
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map(
    (bar) => Math.floor(new Date(bar.t).getTime() / 1e3)
  );
  const fastSMA = calculateSMA(closePrices, normalizedConfig.fastPeriod);
  const slowSMA = calculateSMA(closePrices, normalizedConfig.slowPeriod);
  const crossovers = detectCrossovers(fastSMA, slowSMA);
  const trades3 = [];
  const smaCrossoverPoints = [];
  let position = null;
  for (const crossover of crossovers) {
    const date = new Date(timestamps[crossover.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[crossover.index];
    smaCrossoverPoints.push({ date, type: crossover.type, price });
    if (crossover.type === "bullish" && !position) {
      position = { entryIndex: crossover.index, entryPrice: price };
    } else if (crossover.type === "bearish" && position) {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long"
      });
      position = null;
    }
  }
  if (position && closePrices.length > position.entryIndex) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: "long"
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const crossover = crossovers.find((c) => c.index === i);
    if (crossover?.type === "bullish" && !inPosition) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
    } else if (crossover?.type === "bearish" && inPosition) {
      const returnPct = (price - entryPrice) / entryPrice;
      equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct * 10);
      inPosition = false;
    } else if (inPosition) {
      const unrealizedPct = (price - entryPrice) / entryPrice;
      const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct * 10);
      equity = currentEquity;
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? mean(dailyReturns).toNumber() : 0;
  const returnVariance = dailyReturns.length > 0 ? variance(dailyReturns).toNumber() : 0;
  const stdDev2 = Math.sqrt(returnVariance);
  const sharpeRatioValue = dailyReturns.length > 0 ? sharpeRatio(dailyReturns, 0, 252).toNumber() : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? variance(negativeReturns).toNumber() : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(
    losingTrades.reduce((sum, t) => sum + t.pnlPct, 0)
  );
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatioValue * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100
    },
    equityCurve,
    smaCrossoverPoints
  };
}
var ADAPTIVE_DEFAULTS, MOVING_AVERAGE_PRESETS2, PARAMETER_BOUNDS, STRATEGY_SCHEMA;
var init_moving_average_crossover = __esm({
  "server/strategies/moving-average-crossover.ts"() {
    "use strict";
    init_alpaca();
    init_money();
    ADAPTIVE_DEFAULTS = {
      intervalMinutes: 15
    };
    MOVING_AVERAGE_PRESETS2 = [
      {
        id: "conservative",
        name: "Conservative",
        fastPeriod: 10,
        slowPeriod: 30,
        allocationPct: 0.05,
        riskLimitPct: 0.05,
        description: "Lower risk with wider SMA gaps, smaller positions. Best for beginners."
      },
      {
        id: "balanced",
        name: "Balanced",
        fastPeriod: 7,
        slowPeriod: 20,
        allocationPct: 0.1,
        riskLimitPct: 0.1,
        description: "Classic 7/20 SMA crossover. Good balance of signals and reliability."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        fastPeriod: 5,
        slowPeriod: 15,
        allocationPct: 0.15,
        riskLimitPct: 0.15,
        description: "Faster signals with tighter SMAs. More trades, higher volatility."
      }
    ];
    PARAMETER_BOUNDS = {
      fastPeriod: { min: 3, max: 20, default: 7 },
      slowPeriod: { min: 10, max: 60, default: 20 },
      allocationPct: { min: 0.01, max: 0.25, default: 0.1 },
      riskLimitPct: { min: 0.02, max: 0.3, default: 0.1 }
    };
    STRATEGY_SCHEMA = {
      id: "moving_average_crossover",
      name: "Moving Average Crossover (SMA)",
      description: "A simple trend-following strategy that generates buy signals when a short-term moving average crosses above a longer-term moving average, and sell signals when it crosses below. The classic 7/20 SMA version has historically shown ~21% annualized returns in backtests.",
      presets: MOVING_AVERAGE_PRESETS2,
      parameterBounds: PARAMETER_BOUNDS,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
  }
});

// server/strategies/mean-reversion-scalper.ts
var mean_reversion_scalper_exports = {};
__export(mean_reversion_scalper_exports, {
  MEAN_REVERSION_PRESETS: () => MEAN_REVERSION_PRESETS,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS2,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA2,
  backtestMeanReversionStrategy: () => backtestMeanReversionStrategy,
  generateMeanReversionSignal: () => generateMeanReversionSignal,
  normalizeMeanReversionConfig: () => normalizeMeanReversionConfig
});
function normalizeMeanReversionConfig(input) {
  const preset = MEAN_REVERSION_PRESETS.find((p) => p.id === "balanced");
  let lookbackPeriod = input.lookbackPeriod ?? preset.lookbackPeriod;
  let deviationThreshold = input.deviationThreshold ?? preset.deviationThreshold;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  let maxHoldingPeriod = input.maxHoldingPeriod ?? preset.maxHoldingPeriod;
  lookbackPeriod = Math.max(
    PARAMETER_BOUNDS2.lookbackPeriod.min,
    Math.min(PARAMETER_BOUNDS2.lookbackPeriod.max, Math.round(lookbackPeriod))
  );
  deviationThreshold = Math.max(
    PARAMETER_BOUNDS2.deviationThreshold.min,
    Math.min(PARAMETER_BOUNDS2.deviationThreshold.max, deviationThreshold)
  );
  allocationPct = Math.max(
    PARAMETER_BOUNDS2.allocationPct.min,
    Math.min(PARAMETER_BOUNDS2.allocationPct.max, allocationPct)
  );
  riskLimitPct = Math.max(
    PARAMETER_BOUNDS2.riskLimitPct.min,
    Math.min(PARAMETER_BOUNDS2.riskLimitPct.max, riskLimitPct)
  );
  maxHoldingPeriod = Math.max(
    PARAMETER_BOUNDS2.maxHoldingPeriod.min,
    Math.min(
      PARAMETER_BOUNDS2.maxHoldingPeriod.max,
      Math.round(maxHoldingPeriod)
    )
  );
  return {
    id: input.id || `mrs_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    lookbackPeriod,
    deviationThreshold,
    allocationPct,
    riskLimitPct,
    maxHoldingPeriod,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString()
  };
}
function calculateSMA2(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function calculateStdDev(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      result.push(stdDev(slice).toNumber());
    }
  }
  return result;
}
function calculateZScore(prices, sma, stdDevValues) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    const avg = sma[i];
    const std = stdDevValues[i];
    if (avg === null || std === null || std === 0) {
      result.push(null);
    } else {
      result.push(zScore(prices[i], avg, std).toNumber());
    }
  }
  return result;
}
function detectBandCrossings(zScores, threshold) {
  const crossings = [];
  for (let i = 1; i < zScores.length; i++) {
    const prevZ = zScores[i - 1];
    const currZ = zScores[i];
    if (prevZ === null || currZ === null) continue;
    if (prevZ > -threshold && currZ <= -threshold) {
      crossings.push({ index: i, type: "oversold" });
    } else if (prevZ < threshold && currZ >= threshold) {
      crossings.push({ index: i, type: "overbought" });
    }
  }
  return crossings;
}
async function backtestMeanReversionStrategy(config2, lookbackDays = 365) {
  const normalizedConfig = normalizeMeanReversionConfig(config2);
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(
      `Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`
    );
  }
  if (!bars || bars.length < normalizedConfig.lookbackPeriod + 10) {
    throw new Error(
      `Insufficient historical data for ${normalizedConfig.symbol}. Need at least ${normalizedConfig.lookbackPeriod + 10} days of data.`
    );
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map(
    (bar) => Math.floor(new Date(bar.t).getTime() / 1e3)
  );
  const sma = calculateSMA2(closePrices, normalizedConfig.lookbackPeriod);
  const stdDev2 = calculateStdDev(closePrices, normalizedConfig.lookbackPeriod);
  const zScores = calculateZScore(closePrices, sma, stdDev2);
  const crossings = detectBandCrossings(
    zScores,
    normalizedConfig.deviationThreshold
  );
  const trades3 = [];
  const bandCrossings = [];
  let position = null;
  for (const crossing of crossings) {
    const date = new Date(timestamps[crossing.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[crossing.index];
    const zScore2 = zScores[crossing.index] || 0;
    bandCrossings.push({ date, type: crossing.type, price, zScore: zScore2 });
    if (crossing.type === "oversold" && !position) {
      position = {
        entryIndex: crossing.index,
        entryPrice: price,
        side: "long"
      };
    } else if (crossing.type === "overbought" && position?.side === "long") {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long",
        exitReason: "reversion"
      });
      position = null;
    }
  }
  if (position) {
    for (let i = position.entryIndex + 1; i < closePrices.length; i++) {
      const holdingDays2 = i - position.entryIndex;
      if (holdingDays2 >= normalizedConfig.maxHoldingPeriod) {
        const exitPrice = closePrices[i];
        const pnlPct = position.side === "long" ? (exitPrice - position.entryPrice) / position.entryPrice * 100 : (position.entryPrice - exitPrice) / position.entryPrice * 100;
        const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
        const exitDate = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
        trades3.push({
          entryDate,
          exitDate,
          entryPrice: position.entryPrice,
          exitPrice,
          pnlPct,
          side: position.side,
          exitReason: "timeout"
        });
        position = null;
        break;
      }
    }
  }
  if (position) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = position.side === "long" ? (exitPrice - position.entryPrice) / position.entryPrice * 100 : (position.entryPrice - exitPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: position.side,
      exitReason: "timeout"
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let positionSide = "long";
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  let holdingDays = 0;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const z12 = zScores[i];
    if (!inPosition && z12 !== null && z12 <= -normalizedConfig.deviationThreshold) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
      positionSide = "long";
      holdingDays = 0;
    } else if (inPosition) {
      holdingDays++;
      const shouldExit = positionSide === "long" && z12 !== null && z12 >= 0 || holdingDays >= normalizedConfig.maxHoldingPeriod;
      if (shouldExit) {
        const returnPct = positionSide === "long" ? (price - entryPrice) / entryPrice : (entryPrice - price) / entryPrice;
        equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct);
        inPosition = false;
      } else {
        const unrealizedPct = positionSide === "long" ? (price - entryPrice) / entryPrice : (entryPrice - price) / entryPrice;
        const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct);
        equity = currentEquity;
      }
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? mean(dailyReturns).toNumber() : 0;
  const returnVariance = dailyReturns.length > 0 ? variance(dailyReturns).toNumber() : 0;
  const stdDevReturns = Math.sqrt(returnVariance);
  const sharpeRatioValue = dailyReturns.length > 0 ? sharpeRatio(dailyReturns, 0, 252).toNumber() : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? variance(negativeReturns).toNumber() : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(
    losingTrades.reduce((sum, t) => sum + t.pnlPct, 0)
  );
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  const avgHoldingPeriod = trades3.length > 0 ? trades3.reduce((sum, t) => {
    const entry = new Date(t.entryDate).getTime();
    const exit = new Date(t.exitDate).getTime();
    return sum + (exit - entry) / (1e3 * 60 * 60 * 24);
  }, 0) / trades3.length : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatioValue * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100,
      avgHoldingPeriod: Math.round(avgHoldingPeriod * 100) / 100
    },
    equityCurve,
    bandCrossings
  };
}
function generateMeanReversionSignal(prices, config2) {
  if (prices.length < config2.lookbackPeriod) {
    return null;
  }
  const recentPrices = prices.slice(-config2.lookbackPeriod);
  const meanValue = mean(recentPrices).toNumber();
  const stdDevValue = stdDev(recentPrices).toNumber();
  const currentPrice = prices[prices.length - 1];
  const zScoreValue = stdDevValue > 0 ? zScore(currentPrice, meanValue, stdDevValue).toNumber() : 0;
  const upperBand = meanValue + config2.deviationThreshold * stdDevValue;
  const lowerBand = meanValue - config2.deviationThreshold * stdDevValue;
  let signal = "hold";
  let strength = 0;
  if (zScoreValue <= -config2.deviationThreshold) {
    signal = "buy";
    strength = Math.min(
      1,
      Math.abs(zScoreValue) / (config2.deviationThreshold * 2)
    );
  } else if (zScoreValue >= config2.deviationThreshold) {
    signal = "sell";
    strength = Math.min(
      1,
      Math.abs(zScoreValue) / (config2.deviationThreshold * 2)
    );
  }
  return {
    symbol: config2.symbol,
    timestamp: /* @__PURE__ */ new Date(),
    price: currentPrice,
    zScore: Math.round(zScoreValue * 100) / 100,
    signal,
    strength: Math.round(strength * 100) / 100,
    upperBand: Math.round(upperBand * 100) / 100,
    lowerBand: Math.round(lowerBand * 100) / 100,
    mean: Math.round(meanValue * 100) / 100
  };
}
var MEAN_REVERSION_PRESETS, PARAMETER_BOUNDS2, STRATEGY_SCHEMA2;
var init_mean_reversion_scalper = __esm({
  "server/strategies/mean-reversion-scalper.ts"() {
    "use strict";
    init_alpaca();
    init_money();
    MEAN_REVERSION_PRESETS = [
      {
        id: "conservative",
        name: "Conservative",
        lookbackPeriod: 20,
        deviationThreshold: 2.5,
        allocationPct: 0.03,
        riskLimitPct: 0.02,
        maxHoldingPeriod: 5,
        description: "Wider deviation bands, smaller positions. Fewer but higher-probability trades."
      },
      {
        id: "balanced",
        name: "Balanced",
        lookbackPeriod: 14,
        deviationThreshold: 2,
        allocationPct: 0.05,
        riskLimitPct: 0.03,
        maxHoldingPeriod: 3,
        description: "Classic 14-period mean reversion with 2 std dev bands. Good balance of frequency and quality."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        lookbackPeriod: 10,
        deviationThreshold: 1.5,
        allocationPct: 0.08,
        riskLimitPct: 0.05,
        maxHoldingPeriod: 2,
        description: "Tighter bands for more frequent scalping. Higher trade frequency, smaller profits per trade."
      }
    ];
    PARAMETER_BOUNDS2 = {
      lookbackPeriod: { min: 5, max: 50, default: 14 },
      deviationThreshold: { min: 1, max: 4, default: 2 },
      allocationPct: { min: 0.01, max: 0.15, default: 0.05 },
      riskLimitPct: { min: 0.01, max: 0.1, default: 0.03 },
      maxHoldingPeriod: { min: 1, max: 10, default: 3 }
    };
    STRATEGY_SCHEMA2 = {
      id: "mean_reversion_scalper",
      name: "Mean Reversion Scalper",
      description: "A high-frequency strategy that identifies when price deviates significantly from its mean and trades the expected reversion. Buys when price falls below the lower band and sells when it rises above the upper band. Best for range-bound markets.",
      presets: MEAN_REVERSION_PRESETS,
      parameterBounds: PARAMETER_BOUNDS2,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
  }
});

// server/lib/technical-indicators.ts
function calculateSMA3(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function calculateEMA(prices, period) {
  const result = [];
  const multiplier = 2 / (period + 1);
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      const sma = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
      result.push(sma);
    } else {
      const prevEma = result[i - 1];
      if (prevEma !== null) {
        const ema = (prices[i] - prevEma) * multiplier + prevEma;
        result.push(ema);
      } else {
        result.push(null);
      }
    }
  }
  return result;
}
function calculateRSI(prices, period = 14) {
  const result = [];
  if (prices.length < period + 1) {
    return prices.map(() => null);
  }
  let avgGain = 0;
  let avgLoss = 0;
  for (let i = 0; i < prices.length; i++) {
    if (i === 0) {
      result.push(null);
      continue;
    }
    const change = prices[i] - prices[i - 1];
    const gain = change > 0 ? change : 0;
    const loss = change < 0 ? -change : 0;
    if (i < period) {
      avgGain += gain;
      avgLoss += loss;
      result.push(null);
    } else if (i === period) {
      avgGain = (avgGain + gain) / period;
      avgLoss = (avgLoss + loss) / period;
      if (avgLoss === 0) {
        result.push(100);
      } else {
        const rs = avgGain / avgLoss;
        result.push(100 - 100 / (1 + rs));
      }
    } else {
      avgGain = (avgGain * (period - 1) + gain) / period;
      avgLoss = (avgLoss * (period - 1) + loss) / period;
      if (avgLoss === 0) {
        result.push(100);
      } else {
        const rs = avgGain / avgLoss;
        result.push(100 - 100 / (1 + rs));
      }
    }
  }
  return result;
}
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const emaFast = calculateEMA(prices, fastPeriod);
  const emaSlow = calculateEMA(prices, slowPeriod);
  const macdLine = [];
  for (let i = 0; i < prices.length; i++) {
    if (emaFast[i] !== null && emaSlow[i] !== null) {
      macdLine.push(emaFast[i] - emaSlow[i]);
    } else {
      macdLine.push(null);
    }
  }
  const validMacd = macdLine.filter((v) => v !== null);
  const signalLine = calculateEMA(validMacd, signalPeriod);
  const signal = [];
  const histogram = [];
  let signalIdx = 0;
  for (let i = 0; i < prices.length; i++) {
    if (macdLine[i] !== null) {
      const sig = signalLine[signalIdx] ?? null;
      signal.push(sig);
      histogram.push(sig !== null ? macdLine[i] - sig : null);
      signalIdx++;
    } else {
      signal.push(null);
      histogram.push(null);
    }
  }
  return { macd: macdLine, signal, histogram };
}
function calculateBollingerBands(prices, period = 20, stdDevMultiplier = 2) {
  const middle = calculateSMA3(prices, period);
  const upper = [];
  const lower = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1 || middle[i] === null) {
      upper.push(null);
      lower.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const meanValue = middle[i];
      const stdDevValue = stdDev(slice).toNumber();
      upper.push(meanValue + stdDevMultiplier * stdDevValue);
      lower.push(meanValue - stdDevMultiplier * stdDevValue);
    }
  }
  return { upper, middle, lower };
}
function calculateATR(highs, lows, closes, period = 14) {
  const trueRanges = [];
  for (let i = 0; i < highs.length; i++) {
    if (i === 0) {
      trueRanges.push(highs[i] - lows[i]);
    } else {
      const highLow = highs[i] - lows[i];
      const highPrevClose = Math.abs(highs[i] - closes[i - 1]);
      const lowPrevClose = Math.abs(lows[i] - closes[i - 1]);
      trueRanges.push(Math.max(highLow, highPrevClose, lowPrevClose));
    }
  }
  const result = [];
  for (let i = 0; i < trueRanges.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      const atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;
      result.push(atr);
    } else {
      const prevAtr = result[i - 1];
      if (prevAtr !== null) {
        const atr = (prevAtr * (period - 1) + trueRanges[i]) / period;
        result.push(atr);
      } else {
        result.push(null);
      }
    }
  }
  return result;
}
function calculateROC(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period) {
      result.push(null);
    } else {
      const roc = (prices[i] - prices[i - period]) / prices[i - period];
      result.push(roc);
    }
  }
  return result;
}
function computeAllIndicators(bars) {
  if (bars.length < 200) {
    return null;
  }
  const closes = bars.map((b) => b.close);
  const highs = bars.map((b) => b.high);
  const lows = bars.map((b) => b.low);
  const lastIdx = closes.length - 1;
  const sma20 = calculateSMA3(closes, 20);
  const sma50 = calculateSMA3(closes, 50);
  const sma200 = calculateSMA3(closes, 200);
  const ema12 = calculateEMA(closes, 12);
  const ema26 = calculateEMA(closes, 26);
  const rsi14 = calculateRSI(closes, 14);
  const macdResult = calculateMACD(closes, 12, 26, 9);
  const atr14 = calculateATR(highs, lows, closes, 14);
  const bollingerBands = calculateBollingerBands(closes, 20, 2);
  return {
    sma20: sma20[lastIdx],
    sma50: sma50[lastIdx],
    sma200: sma200[lastIdx],
    ema12: ema12[lastIdx],
    ema26: ema26[lastIdx],
    rsi14: rsi14[lastIdx],
    macd: macdResult.macd[lastIdx],
    macdSignal: macdResult.signal[lastIdx],
    macdHistogram: macdResult.histogram[lastIdx],
    atr14: atr14[lastIdx],
    bollingerUpper: bollingerBands.upper[lastIdx],
    bollingerLower: bollingerBands.lower[lastIdx],
    adx14: null
  };
}
var init_technical_indicators = __esm({
  "server/lib/technical-indicators.ts"() {
    "use strict";
    init_money();
  }
});

// server/strategies/momentum-strategy.ts
var momentum_strategy_exports = {};
__export(momentum_strategy_exports, {
  MOMENTUM_PRESETS: () => MOMENTUM_PRESETS,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS3,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA3,
  backtestMomentumStrategy: () => backtestMomentumStrategy,
  generateMomentumSignal: () => generateMomentumSignal,
  normalizeMomentumConfig: () => normalizeMomentumConfig
});
function normalizeMomentumConfig(input) {
  const preset = MOMENTUM_PRESETS.find((p) => p.id === "balanced");
  let lookbackPeriod = input.lookbackPeriod ?? preset.lookbackPeriod;
  let momentumThreshold = input.momentumThreshold ?? preset.momentumThreshold;
  let rsiPeriod = input.rsiPeriod ?? preset.rsiPeriod;
  let rsiOverbought = input.rsiOverbought ?? preset.rsiOverbought;
  let rsiOversold = input.rsiOversold ?? preset.rsiOversold;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  lookbackPeriod = Math.max(
    PARAMETER_BOUNDS3.lookbackPeriod.min,
    Math.min(PARAMETER_BOUNDS3.lookbackPeriod.max, Math.round(lookbackPeriod))
  );
  momentumThreshold = Math.max(
    PARAMETER_BOUNDS3.momentumThreshold.min,
    Math.min(PARAMETER_BOUNDS3.momentumThreshold.max, momentumThreshold)
  );
  rsiPeriod = Math.max(
    PARAMETER_BOUNDS3.rsiPeriod.min,
    Math.min(PARAMETER_BOUNDS3.rsiPeriod.max, Math.round(rsiPeriod))
  );
  rsiOverbought = Math.max(
    PARAMETER_BOUNDS3.rsiOverbought.min,
    Math.min(PARAMETER_BOUNDS3.rsiOverbought.max, Math.round(rsiOverbought))
  );
  rsiOversold = Math.max(
    PARAMETER_BOUNDS3.rsiOversold.min,
    Math.min(PARAMETER_BOUNDS3.rsiOversold.max, Math.round(rsiOversold))
  );
  allocationPct = Math.max(
    PARAMETER_BOUNDS3.allocationPct.min,
    Math.min(PARAMETER_BOUNDS3.allocationPct.max, allocationPct)
  );
  riskLimitPct = Math.max(
    PARAMETER_BOUNDS3.riskLimitPct.min,
    Math.min(PARAMETER_BOUNDS3.riskLimitPct.max, riskLimitPct)
  );
  if (rsiOversold >= rsiOverbought) {
    rsiOversold = rsiOverbought - 20;
  }
  return {
    id: input.id || `mom_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    lookbackPeriod,
    momentumThreshold,
    rsiPeriod,
    rsiOverbought,
    rsiOversold,
    allocationPct,
    riskLimitPct,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString()
  };
}
function detectMomentumSignals(momentum, rsi, config2) {
  const signals = [];
  for (let i = 1; i < momentum.length; i++) {
    const prevMom = momentum[i - 1];
    const currMom = momentum[i];
    const currRsi = rsi[i];
    if (prevMom === null || currMom === null || currRsi === null) continue;
    if (currMom > config2.momentumThreshold && currRsi > config2.rsiOversold && currRsi < config2.rsiOverbought) {
      if (prevMom <= config2.momentumThreshold) {
        signals.push({ index: i, type: "buy" });
      }
    } else if (currMom < -config2.momentumThreshold || currRsi >= config2.rsiOverbought) {
      if (prevMom >= -config2.momentumThreshold && (momentum[i - 1] === null || rsi[i - 1] === null || rsi[i - 1] !== null && rsi[i - 1] < config2.rsiOverbought)) {
        signals.push({ index: i, type: "sell" });
      }
    }
  }
  return signals;
}
async function backtestMomentumStrategy(config2, lookbackDays = 365) {
  const normalizedConfig = normalizeMomentumConfig(config2);
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(
      `Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`
    );
  }
  if (!bars || bars.length < Math.max(normalizedConfig.lookbackPeriod, normalizedConfig.rsiPeriod) + 10) {
    throw new Error(
      `Insufficient historical data for ${normalizedConfig.symbol}.`
    );
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map(
    (bar) => Math.floor(new Date(bar.t).getTime() / 1e3)
  );
  const momentum = calculateROC2(closePrices, normalizedConfig.lookbackPeriod);
  const rsi = calculateRSI2(closePrices, normalizedConfig.rsiPeriod);
  const signals = detectMomentumSignals(momentum, rsi, normalizedConfig);
  const trades3 = [];
  const momentumSignals = [];
  let position = null;
  for (let i = 0; i < closePrices.length; i++) {
    const m = momentum[i];
    const r = rsi[i];
    if (m !== null && r !== null) {
      const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
      let signal = "hold";
      const matchingSignal = signals.find((s) => s.index === i);
      if (matchingSignal) {
        signal = matchingSignal.type;
      }
      momentumSignals.push({
        date,
        momentum: Math.round(m * 1e4) / 100,
        rsi: Math.round(r * 100) / 100,
        signal
      });
    }
  }
  for (const signal of signals) {
    const date = new Date(timestamps[signal.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[signal.index];
    const m = momentum[signal.index] || 0;
    const r = rsi[signal.index] || 50;
    if (signal.type === "buy" && !position) {
      position = {
        entryIndex: signal.index,
        entryPrice: price,
        entryMomentum: m,
        entryRsi: r
      };
    } else if (signal.type === "sell" && position) {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long",
        entryMomentum: position.entryMomentum,
        entryRsi: position.entryRsi
      });
      position = null;
    }
  }
  if (position && closePrices.length > position.entryIndex) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: "long",
      entryMomentum: position.entryMomentum,
      entryRsi: position.entryRsi
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const signal = signals.find((s) => s.index === i);
    if (signal?.type === "buy" && !inPosition) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
    } else if (signal?.type === "sell" && inPosition) {
      const returnPct = (price - entryPrice) / entryPrice;
      equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct);
      inPosition = false;
    } else if (inPosition) {
      const unrealizedPct = (price - entryPrice) / entryPrice;
      const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct);
      equity = currentEquity;
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? mean(dailyReturns).toNumber() : 0;
  const returnVariance = dailyReturns.length > 0 ? variance(dailyReturns).toNumber() : 0;
  const stdDev2 = Math.sqrt(returnVariance);
  const sharpeRatioValue = dailyReturns.length > 0 ? sharpeRatio(dailyReturns, 0, 252).toNumber() : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? variance(negativeReturns).toNumber() : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(
    losingTrades.reduce((sum, t) => sum + t.pnlPct, 0)
  );
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  const avgMomentum = trades3.length > 0 ? trades3.reduce((sum, t) => sum + t.entryMomentum, 0) / trades3.length : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatioValue * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100,
      avgMomentum: Math.round(avgMomentum * 1e4) / 100
    },
    equityCurve,
    momentumSignals
  };
}
function generateMomentumSignal(prices, config2) {
  const requiredLength = Math.max(config2.lookbackPeriod, config2.rsiPeriod) + 1;
  if (prices.length < requiredLength) {
    return null;
  }
  const currentPrice = prices[prices.length - 1];
  const previousPrice = prices[prices.length - 1 - config2.lookbackPeriod];
  const momentum = (currentPrice - previousPrice) / previousPrice;
  const rsi = calculateRSI2(prices, config2.rsiPeriod);
  const currentRsi = rsi[rsi.length - 1] || 50;
  let signal = "hold";
  let strength = 0;
  let trend = "neutral";
  if (momentum > config2.momentumThreshold) {
    trend = "bullish";
    if (currentRsi > config2.rsiOversold && currentRsi < config2.rsiOverbought) {
      signal = "buy";
      strength = Math.min(1, momentum / (config2.momentumThreshold * 3));
    }
  } else if (momentum < -config2.momentumThreshold) {
    trend = "bearish";
    if (currentRsi >= config2.rsiOverbought) {
      signal = "sell";
      strength = Math.min(
        1,
        Math.abs(momentum) / (config2.momentumThreshold * 3)
      );
    }
  }
  if (currentRsi >= config2.rsiOverbought) {
    signal = "sell";
    strength = Math.max(
      strength,
      (currentRsi - config2.rsiOverbought) / (100 - config2.rsiOverbought)
    );
  }
  return {
    symbol: config2.symbol,
    timestamp: /* @__PURE__ */ new Date(),
    price: currentPrice,
    momentum: Math.round(momentum * 1e4) / 100,
    rsi: Math.round(currentRsi * 100) / 100,
    signal,
    strength: Math.round(strength * 100) / 100,
    trend
  };
}
var MOMENTUM_PRESETS, PARAMETER_BOUNDS3, STRATEGY_SCHEMA3, calculateROC2, calculateRSI2;
var init_momentum_strategy = __esm({
  "server/strategies/momentum-strategy.ts"() {
    "use strict";
    init_alpaca();
    init_technical_indicators();
    init_money();
    MOMENTUM_PRESETS = [
      {
        id: "conservative",
        name: "Conservative",
        lookbackPeriod: 20,
        momentumThreshold: 0.03,
        rsiPeriod: 14,
        rsiOverbought: 75,
        rsiOversold: 25,
        allocationPct: 0.05,
        riskLimitPct: 0.03,
        description: "Longer lookback with stricter RSI filters. Fewer but higher-conviction trades."
      },
      {
        id: "balanced",
        name: "Balanced",
        lookbackPeriod: 14,
        momentumThreshold: 0.02,
        rsiPeriod: 14,
        rsiOverbought: 70,
        rsiOversold: 30,
        allocationPct: 0.08,
        riskLimitPct: 0.05,
        description: "Classic momentum with RSI confirmation. Good balance of signal quality and frequency."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        lookbackPeriod: 10,
        momentumThreshold: 0.015,
        rsiPeriod: 10,
        rsiOverbought: 65,
        rsiOversold: 35,
        allocationPct: 0.12,
        riskLimitPct: 0.08,
        description: "Faster signals with looser filters. More trades, captures quick momentum moves."
      }
    ];
    PARAMETER_BOUNDS3 = {
      lookbackPeriod: { min: 5, max: 30, default: 14 },
      momentumThreshold: { min: 5e-3, max: 0.1, default: 0.02 },
      rsiPeriod: { min: 5, max: 21, default: 14 },
      rsiOverbought: { min: 60, max: 85, default: 70 },
      rsiOversold: { min: 15, max: 40, default: 30 },
      allocationPct: { min: 0.02, max: 0.2, default: 0.08 },
      riskLimitPct: { min: 0.02, max: 0.15, default: 0.05 }
    };
    STRATEGY_SCHEMA3 = {
      id: "momentum_strategy",
      name: "Momentum Strategy",
      description: "A trend-following strategy that trades in the direction of price momentum. Uses rate of change and RSI indicators to identify strong momentum moves. Buys when momentum is positive and RSI confirms, sells when momentum reverses.",
      presets: MOMENTUM_PRESETS,
      parameterBounds: PARAMETER_BOUNDS3,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
    calculateROC2 = calculateROC;
    calculateRSI2 = calculateRSI;
  }
});

// server/strategies/index.ts
var strategies_exports = {};
__export(strategies_exports, {
  ADAPTIVE_DEFAULTS: () => ADAPTIVE_DEFAULTS,
  ADAPTIVE_THRESHOLDS: () => ADAPTIVE_THRESHOLDS,
  ALL_STRATEGIES: () => ALL_STRATEGIES,
  MA_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS,
  MA_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA,
  MEAN_REVERSION_PRESETS: () => MEAN_REVERSION_PRESETS,
  MOMENTUM_PRESETS: () => MOMENTUM_PRESETS,
  MOM_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS3,
  MOM_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA3,
  MOVING_AVERAGE_PRESETS: () => MOVING_AVERAGE_PRESETS2,
  MRS_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS2,
  MRS_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA2,
  STRATEGY_TYPES: () => STRATEGY_TYPES,
  applyPresetToConfig: () => applyPresetToConfig,
  backtestMeanReversionStrategy: () => backtestMeanReversionStrategy,
  backtestMomentumStrategy: () => backtestMomentumStrategy,
  backtestMovingAverageStrategy: () => backtestMovingAverageStrategy,
  choosePresetFromMarket: () => choosePresetFromMarket,
  generateMeanReversionSignal: () => generateMeanReversionSignal,
  generateMomentumSignal: () => generateMomentumSignal,
  getAdaptiveRiskStatus: () => getAdaptiveRiskStatus,
  getStrategySchema: () => getStrategySchema,
  normalizeMeanReversionConfig: () => normalizeMeanReversionConfig,
  normalizeMomentumConfig: () => normalizeMomentumConfig,
  normalizeMovingAverageConfig: () => normalizeMovingAverageConfig,
  updateStrategyRiskIfNeeded: () => updateStrategyRiskIfNeeded
});
function getStrategySchema(type) {
  switch (type) {
    case STRATEGY_TYPES.MOVING_AVERAGE_CROSSOVER:
      return STRATEGY_SCHEMA;
    case STRATEGY_TYPES.MEAN_REVERSION_SCALPER:
      return STRATEGY_SCHEMA2;
    case STRATEGY_TYPES.MOMENTUM_STRATEGY:
      return STRATEGY_SCHEMA3;
    default:
      return null;
  }
}
var ALL_STRATEGIES, STRATEGY_TYPES;
var init_strategies = __esm({
  "server/strategies/index.ts"() {
    "use strict";
    init_moving_average_crossover();
    init_adaptive_risk_service();
    init_mean_reversion_scalper();
    init_momentum_strategy();
    init_moving_average_crossover();
    init_mean_reversion_scalper();
    init_momentum_strategy();
    ALL_STRATEGIES = [STRATEGY_SCHEMA, STRATEGY_SCHEMA2, STRATEGY_SCHEMA3];
    STRATEGY_TYPES = {
      MOVING_AVERAGE_CROSSOVER: "moving_average_crossover",
      MEAN_REVERSION_SCALPER: "mean_reversion_scalper",
      MOMENTUM_STRATEGY: "momentum_strategy"
    };
  }
});

// server/ai/ai-strategy-validator.ts
var ai_strategy_validator_exports = {};
__export(ai_strategy_validator_exports, {
  getValidatorStatus: () => getValidatorStatus,
  validateMovingAverageConfig: () => validateMovingAverageConfig
});
import pLimit3 from "p-limit";
import pRetry2 from "p-retry";
function isRateLimitError(error) {
  const errorMsg = error?.message || String(error);
  return errorMsg.includes("429") || errorMsg.includes("RATELIMIT_EXCEEDED") || errorMsg.toLowerCase().includes("quota") || errorMsg.toLowerCase().includes("rate limit");
}
async function validateMovingAverageConfig(config2, marketIntelligence) {
  const systemPrompt = `You are an AI trading agent evaluating a Moving Average Crossover strategy for a retail user inside a paper-trading environment.

Voice and rules:
- Write with the precision and restraint of an AI model, not a human analyst.
- Keep every answer concise and signal-focused.
- No paragraphs longer than one sentence.
- No filler, no storytelling, no disclaimers.
- Insights should read as if they were derived directly from data.

Your tasks:
1. Describe the strategy behavior in exactly ONE short, clear sentence.
2. Give a risk assessment in exactly ONE sentence.
3. Provide 2 bullet points of parameter feedback. Each bullet must be:
   - specific,
   - no longer than one sentence,
   - describing either a strength or a risk in the configuration.
4. Use MARKET INTELLIGENCE when provided (trend, volatility, sentiment):
   - Include ONE sentence giving a strategy adjustment or caution that logically follows from the market conditions.
5. Do not include any flair lines, taglines, or meta statements. The tone alone must feel like AI-curated insight.

Output format:
Return a JSON object with EXACT fields:
- summary: one concise sentence.
- riskAssessment: one concise sentence.
- parameterFeedback: array of 2 short, precise bullet points.
- marketSuggestion: one sentence reflecting market intelligence.
- suitability: "retail_friendly" | "borderline" | "advanced_only"
- confidence: number between 0 and 1

Keep the output tight, data-driven, and free of unnecessary explanation.
`;
  const userPrompt = buildValidationPrompt(config2, marketIntelligence);
  return limit3(
    () => pRetry2(
      async () => {
        try {
          const response = await callLLM({
            role: "risk_manager",
            criticality: "medium",
            purpose: "strategy_validation",
            traceId: generateTraceId(),
            system: systemPrompt,
            messages: [{ role: "user", content: userPrompt }],
            responseFormat: { type: "json_object" },
            maxTokens: 1024
          });
          const content = response.text;
          if (!content) {
            throw new Error("Empty response from AI");
          }
          const parsed = JSON.parse(content);
          return validateResult(parsed);
        } catch (error) {
          if (isRateLimitError(error)) {
            throw error;
          }
          const abortError = new Error(error.message);
          abortError.name = "AbortError";
          throw abortError;
        }
      },
      {
        retries: 3,
        minTimeout: 1e3,
        maxTimeout: 1e4,
        factor: 2
      }
    )
  );
}
function buildValidationPrompt(config2, marketIntelligence) {
  let prompt = `Please review this Moving Average Crossover strategy configuration:

## Configuration
- Symbol: ${config2.symbol}
- Fast SMA Period: ${config2.fastPeriod} days
- Slow SMA Period: ${config2.slowPeriod} days
- Position Allocation: ${(config2.allocationPct * 100).toFixed(1)}% of portfolio
- Risk Limit: ${(config2.riskLimitPct * 100).toFixed(1)}% max loss

## Strategy Explanation
This strategy generates buy signals when the ${config2.fastPeriod}-day moving average crosses above the ${config2.slowPeriod}-day moving average (golden cross), and sell signals when it crosses below (death cross).`;
  if (marketIntelligence) {
    prompt += `

## Current Market Context`;
    if (marketIntelligence.currentTrend) {
      prompt += `
- Market Trend: ${marketIntelligence.currentTrend}`;
    }
    if (marketIntelligence.volatility) {
      prompt += `
- Volatility Level: ${marketIntelligence.volatility}`;
    }
    if (marketIntelligence.recentNews && marketIntelligence.recentNews.length > 0) {
      prompt += `
- Recent News:
${marketIntelligence.recentNews.slice(0, 3).map((n) => `  - ${n}`).join("\n")}`;
    }
  }
  prompt += `

Provide your assessment as a JSON object.`;
  return prompt;
}
function validateResult(result) {
  const validSuitability = [
    "retail_friendly",
    "borderline",
    "advanced_only"
  ];
  const suitability = validSuitability.includes(
    result.suitability
  ) ? result.suitability : "borderline";
  let confidence = Number(result.confidence);
  if (isNaN(confidence) || confidence < 0 || confidence > 1) {
    confidence = 0.7;
  }
  return {
    summary: result.summary || "This moving average crossover strategy follows price trends by tracking when short-term momentum crosses long-term averages.",
    riskAssessment: result.riskAssessment || "Risk assessment pending. Please review parameters carefully.",
    parameterFeedback: Array.isArray(result.parameterFeedback) ? result.parameterFeedback : [],
    suitability,
    confidence
  };
}
function getValidatorStatus() {
  return {
    available: !!(process.env.AI_INTEGRATIONS_OPENAI_BASE_URL && process.env.AI_INTEGRATIONS_OPENAI_API_KEY),
    model: MODEL
  };
}
var MODEL, limit3;
var init_ai_strategy_validator = __esm({
  "server/ai/ai-strategy-validator.ts"() {
    "use strict";
    init_llmGateway();
    MODEL = "gpt-4o";
    limit3 = pLimit3(2);
  }
});

// server/services/position-reconciler.ts
var position_reconciler_exports = {};
__export(position_reconciler_exports, {
  positionReconciler: () => positionReconciler
});
var PositionReconciler, positionReconciler;
var init_position_reconciler = __esm({
  "server/services/position-reconciler.ts"() {
    "use strict";
    init_alpaca();
    init_storage();
    init_logger();
    PositionReconciler = class {
      lastReconciliation = null;
      reconciliationInterval = 5 * 60 * 1e3;
      // 5 minutes
      isReconciling = false;
      async reconcile(force = false) {
        if (this.isReconciling) {
          log.info(
            "PositionReconciler",
            "Reconciliation already in progress, skipping"
          );
          return this.createSkippedResult("Already reconciling");
        }
        if (!force && this.lastReconciliation) {
          const elapsed = Date.now() - this.lastReconciliation.getTime();
          if (elapsed < this.reconciliationInterval) {
            log.info(
              "PositionReconciler",
              `Skipping reconciliation, last run ${Math.round(elapsed / 1e3)}s ago`
            );
            return this.createSkippedResult(
              `Last run ${Math.round(elapsed / 1e3)}s ago`
            );
          }
        }
        this.isReconciling = true;
        const startTime = Date.now();
        log.info("PositionReconciler", "Starting position reconciliation...");
        try {
          const [brokerPositions, dbPositions] = await Promise.all([
            this.fetchBrokerPositions(),
            this.fetchDBPositions()
          ]);
          const result = await this.performReconciliation(
            brokerPositions,
            dbPositions
          );
          result.duration_ms = Date.now() - startTime;
          this.lastReconciliation = /* @__PURE__ */ new Date();
          log.info(
            "PositionReconciler",
            `Reconciliation completed in ${result.duration_ms}ms`,
            {
              synced: result.synced,
              added: result.added,
              removed: result.removed,
              conflicts: result.conflicts.length,
              brokerPositions: result.brokerPositions,
              dbPositions: result.dbPositions,
              totalValue: result.totalValue
            }
          );
          return result;
        } catch (error) {
          log.error("PositionReconciler", "Reconciliation failed", { error });
          return {
            timestamp: /* @__PURE__ */ new Date(),
            status: "failed",
            brokerPositions: 0,
            dbPositions: 0,
            synced: 0,
            added: 0,
            removed: 0,
            conflicts: [],
            totalValue: 0,
            duration_ms: Date.now() - startTime
          };
        } finally {
          this.isReconciling = false;
        }
      }
      async fetchBrokerPositions() {
        try {
          const positions2 = await alpaca.getPositions();
          return positions2.map((p) => ({
            symbol: p.symbol,
            qty: parseFloat(p.qty),
            side: parseFloat(p.qty) >= 0 ? "long" : "short",
            marketValue: parseFloat(p.market_value),
            avgEntryPrice: parseFloat(p.avg_entry_price),
            currentPrice: parseFloat(p.current_price),
            unrealizedPL: parseFloat(p.unrealized_pl),
            unrealizedPLPercent: parseFloat(p.unrealized_plpc) * 100
          }));
        } catch (error) {
          log.error("PositionReconciler", "Failed to fetch broker positions", {
            error
          });
          throw error;
        }
      }
      async fetchDBPositions() {
        try {
          const positions2 = await storage.getPositions();
          return positions2;
        } catch (error) {
          log.error("PositionReconciler", "Failed to fetch DB positions", {
            error
          });
          throw error;
        }
      }
      async performReconciliation(brokerPositions, dbPositions) {
        const conflicts = [];
        let synced = 0;
        let added = 0;
        let removed = 0;
        const brokerSymbols = new Set(brokerPositions.map((p) => p.symbol));
        const dbSymbols = new Set(dbPositions.map((p) => p.symbol));
        for (const brokerPos of brokerPositions) {
          const dbPos = dbPositions.find((p) => p.symbol === brokerPos.symbol);
          if (!dbPos) {
            await this.addPositionToDB(brokerPos);
            added++;
            log.info(
              "PositionReconciler",
              `Added missing position: ${brokerPos.symbol} x ${brokerPos.qty}`,
              {
                symbol: brokerPos.symbol,
                qty: brokerPos.qty,
                source: "broker_not_in_db"
              }
            );
          } else if (Math.abs(parseFloat(dbPos.quantity) - brokerPos.qty) > 1e-4) {
            const dbQty = parseFloat(dbPos.quantity);
            const conflict = {
              symbol: brokerPos.symbol,
              brokerQty: brokerPos.qty,
              dbQty,
              brokerValue: brokerPos.marketValue,
              dbValue: dbQty * brokerPos.currentPrice,
              resolution: "use_broker",
              // Broker is source of truth
              resolved: false
            };
            await this.updateDBPosition(dbPos.id, brokerPos);
            conflict.resolved = true;
            conflicts.push(conflict);
            synced++;
            log.warn(
              "PositionReconciler",
              `Resolved quantity conflict for ${brokerPos.symbol}`,
              {
                symbol: brokerPos.symbol,
                brokerQty: brokerPos.qty,
                dbQty: dbPos.quantity,
                resolution: "use_broker"
              }
            );
          } else {
            await this.updateDBPositionPrices(dbPos.id, brokerPos);
            synced++;
          }
        }
        for (const dbPos of dbPositions) {
          if (!brokerSymbols.has(dbPos.symbol)) {
            await this.closeDBPosition(dbPos.id);
            removed++;
            log.info(
              "PositionReconciler",
              `Closed stale position: ${dbPos.symbol}`,
              {
                symbol: dbPos.symbol,
                positionId: dbPos.id,
                source: "db_not_in_broker"
              }
            );
          }
        }
        const totalValue = brokerPositions.reduce(
          (sum, p) => sum + p.marketValue,
          0
        );
        return {
          timestamp: /* @__PURE__ */ new Date(),
          status: conflicts.length > 0 ? "partial" : "success",
          brokerPositions: brokerPositions.length,
          dbPositions: dbPositions.length,
          synced,
          added,
          removed,
          conflicts,
          totalValue,
          duration_ms: 0
          // Will be set by caller
        };
      }
      async addPositionToDB(brokerPos) {
        const adminUser = await storage.getAdminUser();
        const userId = adminUser?.id || "system";
        const newPosition = {
          userId,
          symbol: brokerPos.symbol,
          quantity: brokerPos.qty.toString(),
          side: brokerPos.side,
          entryPrice: brokerPos.avgEntryPrice.toString(),
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString(),
          strategyId: null
          // Unknown strategy - came from external trade or reconciliation
        };
        await storage.createPosition(newPosition);
      }
      async updateDBPosition(positionId, brokerPos) {
        await storage.updatePosition(positionId, {
          quantity: brokerPos.qty.toString(),
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString()
        });
      }
      async updateDBPositionPrices(positionId, brokerPos) {
        await storage.updatePosition(positionId, {
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString()
        });
      }
      async closeDBPosition(positionId) {
        log.info(
          "PositionReconciler",
          `Position ${positionId} marked for closure (external)`
        );
      }
      createSkippedResult(reason) {
        return {
          timestamp: /* @__PURE__ */ new Date(),
          status: "skipped",
          brokerPositions: 0,
          dbPositions: 0,
          synced: 0,
          added: 0,
          removed: 0,
          conflicts: [],
          totalValue: 0,
          duration_ms: 0
        };
      }
      // Get reconciliation status
      getStatus() {
        const nextRunIn = this.lastReconciliation ? Math.max(
          0,
          this.reconciliationInterval - (Date.now() - this.lastReconciliation.getTime())
        ) : null;
        return {
          lastRun: this.lastReconciliation,
          interval: this.reconciliationInterval,
          isReconciling: this.isReconciling,
          nextRunIn
        };
      }
      // Force immediate reconciliation
      async forceReconcile() {
        return this.reconcile(true);
      }
      // Set reconciliation interval (in ms)
      setInterval(intervalMs) {
        this.reconciliationInterval = intervalMs;
        log.info(
          "PositionReconciler",
          `Reconciliation interval set to ${intervalMs}ms`
        );
      }
    };
    positionReconciler = new PositionReconciler();
  }
});

// server/lib/valyuBudget.ts
var valyuBudget_exports = {};
__export(valyuBudget_exports, {
  checkValyuBudget: () => checkValyuBudget,
  classifySourceTier: () => classifySourceTier,
  getMaxPriceForTier: () => getMaxPriceForTier,
  getValyuBudgetConfig: () => getValyuBudgetConfig,
  getValyuBudgetStatus: () => getValyuBudgetStatus,
  recordValyuRetrievals: () => recordValyuRetrievals,
  resetValyuBudget: () => resetValyuBudget,
  updateValyuBudgetConfig: () => updateValyuBudgetConfig
});
import { eq as eq25, and as and18 } from "drizzle-orm";
function getCurrentMonthKey() {
  const now = /* @__PURE__ */ new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
}
function getNextMonthResetDate() {
  const now = /* @__PURE__ */ new Date();
  return new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0);
}
function getLimitForTier(tier) {
  switch (tier) {
    case "web":
      return currentConfig.webRetrievalsPerMonth;
    case "finance":
      return currentConfig.financeRetrievalsPerMonth;
    case "proprietary":
      return currentConfig.proprietaryRetrievalsPerMonth;
  }
}
function classifySourceTier(sources) {
  if (!sources || sources.length === 0) {
    return "web";
  }
  for (const source of sources) {
    const lowerSource = source.toLowerCase();
    if (lowerSource.includes("proprietary")) {
      return "proprietary";
    }
  }
  for (const source of sources) {
    if (source.startsWith("valyu/")) {
      return "finance";
    }
  }
  return "web";
}
function getMaxPriceForTier(tier) {
  return MAX_PRICE_BY_TIER[tier];
}
async function getOrCreateCounter(tier, monthKey) {
  try {
    const existing = await db.select().from(valyuRetrievalCounters).where(
      and18(
        eq25(valyuRetrievalCounters.sourceTier, tier),
        eq25(valyuRetrievalCounters.monthKey, monthKey)
      )
    ).limit(1);
    if (existing.length > 0) {
      return { id: existing[0].id, retrievalCount: existing[0].retrievalCount };
    }
    const inserted = await db.insert(valyuRetrievalCounters).values({
      sourceTier: tier,
      monthKey,
      retrievalCount: 0
    }).returning();
    return { id: inserted[0].id, retrievalCount: 0 };
  } catch (error) {
    log.error("ValyuBudget", "Failed to get/create counter", {
      tier,
      monthKey,
      error
    });
    return { id: "", retrievalCount: 0 };
  }
}
async function checkValyuBudget(tier) {
  const monthKey = getCurrentMonthKey();
  const limit4 = getLimitForTier(tier);
  try {
    const counter = await getOrCreateCounter(tier, monthKey);
    const used = counter.retrievalCount;
    const remaining = Math.max(0, limit4 - used);
    if (used >= limit4) {
      return {
        allowed: false,
        tier,
        reason: `Valyu ${tier} tier budget exhausted: ${used}/${limit4} retrievals this month`,
        used,
        limit: limit4,
        remaining: 0
      };
    }
    return {
      allowed: true,
      tier,
      used,
      limit: limit4,
      remaining
    };
  } catch (error) {
    log.warn("ValyuBudget", "Budget check failed, allowing request", {
      tier,
      error
    });
    return {
      allowed: true,
      tier,
      used: 0,
      limit: limit4,
      remaining: limit4
    };
  }
}
async function recordValyuRetrievals(tier, retrievalCount) {
  if (retrievalCount <= 0) return;
  const monthKey = getCurrentMonthKey();
  lastCallTimeByTier.set(tier, Date.now());
  try {
    const existing = await db.select().from(valyuRetrievalCounters).where(
      and18(
        eq25(valyuRetrievalCounters.sourceTier, tier),
        eq25(valyuRetrievalCounters.monthKey, monthKey)
      )
    ).limit(1);
    if (existing.length > 0) {
      await db.update(valyuRetrievalCounters).set({
        retrievalCount: existing[0].retrievalCount + retrievalCount,
        lastUpdated: /* @__PURE__ */ new Date()
      }).where(eq25(valyuRetrievalCounters.id, existing[0].id));
    } else {
      await db.insert(valyuRetrievalCounters).values({
        sourceTier: tier,
        monthKey,
        retrievalCount
      });
    }
    log.info("ValyuBudget", "Recorded retrievals", {
      tier,
      count: retrievalCount,
      monthKey
    });
  } catch (error) {
    log.error("ValyuBudget", "Failed to record retrievals", {
      tier,
      retrievalCount,
      error
    });
  }
}
async function getValyuBudgetStatus() {
  const monthKey = getCurrentMonthKey();
  const resetDate = getNextMonthResetDate();
  const tiers = ["web", "finance", "proprietary"];
  const statuses = [];
  for (const tier of tiers) {
    const limit4 = getLimitForTier(tier);
    let used = 0;
    try {
      const counter = await getOrCreateCounter(tier, monthKey);
      used = counter.retrievalCount;
    } catch (error) {
      log.warn("ValyuBudget", "Failed to get usage for tier", { tier, error });
    }
    statuses.push({
      tier,
      used,
      limit: limit4,
      remaining: Math.max(0, limit4 - used),
      resetDate,
      lastCallTime: lastCallTimeByTier.get(tier) ?? null
    });
  }
  return statuses;
}
function getValyuBudgetConfig() {
  return { ...currentConfig };
}
function updateValyuBudgetConfig(updates) {
  if (updates.webRetrievalsPerMonth !== void 0) {
    currentConfig.webRetrievalsPerMonth = Math.max(
      0,
      updates.webRetrievalsPerMonth
    );
  }
  if (updates.financeRetrievalsPerMonth !== void 0) {
    currentConfig.financeRetrievalsPerMonth = Math.max(
      0,
      updates.financeRetrievalsPerMonth
    );
  }
  if (updates.proprietaryRetrievalsPerMonth !== void 0) {
    currentConfig.proprietaryRetrievalsPerMonth = Math.max(
      0,
      updates.proprietaryRetrievalsPerMonth
    );
  }
  log.info("ValyuBudget", "Config updated", currentConfig);
  return { ...currentConfig };
}
async function resetValyuBudget(tier) {
  const monthKey = getCurrentMonthKey();
  try {
    if (tier) {
      await db.update(valyuRetrievalCounters).set({ retrievalCount: 0, lastUpdated: /* @__PURE__ */ new Date() }).where(
        and18(
          eq25(valyuRetrievalCounters.sourceTier, tier),
          eq25(valyuRetrievalCounters.monthKey, monthKey)
        )
      );
      log.info("ValyuBudget", "Reset budget for tier", { tier });
    } else {
      await db.update(valyuRetrievalCounters).set({ retrievalCount: 0, lastUpdated: /* @__PURE__ */ new Date() }).where(eq25(valyuRetrievalCounters.monthKey, monthKey));
      log.info("ValyuBudget", "Reset all budgets for month", { monthKey });
    }
  } catch (error) {
    log.error("ValyuBudget", "Failed to reset budget", { tier, error });
  }
}
var DEFAULT_CONFIG5, MAX_PRICE_BY_TIER, currentConfig, lastCallTimeByTier;
var init_valyuBudget = __esm({
  "server/lib/valyuBudget.ts"() {
    "use strict";
    init_db();
    init_schema2();
    init_logger();
    DEFAULT_CONFIG5 = {
      webRetrievalsPerMonth: 2e3,
      financeRetrievalsPerMonth: 500,
      proprietaryRetrievalsPerMonth: 100
    };
    MAX_PRICE_BY_TIER = {
      web: 6,
      finance: 12,
      proprietary: 15
    };
    currentConfig = { ...DEFAULT_CONFIG5 };
    lastCallTimeByTier = /* @__PURE__ */ new Map();
  }
});

// server/ai/index.ts
var ai_exports = {};
__export(ai_exports, {
  AIMLClient: () => AIMLClient,
  ClaudeClient: () => ClaudeClient,
  CloudflareClient: () => CloudflareClient,
  GeminiClient: () => GeminiClient,
  GroqClient: () => GroqClient,
  HuggingFaceClient: () => HuggingFaceClient,
  OpenAIClient: () => OpenAIClient,
  OpenRouterClient: () => OpenRouterClient,
  TogetherClient: () => TogetherClient,
  aimlClient: () => aimlClient,
  claudeClient: () => claudeClient,
  cloudflareClient: () => cloudflareClient,
  createLLMError: () => createLLMError,
  geminiClient: () => geminiClient,
  getAllAvailableProviders: () => getAllAvailableProviders,
  getLLMStatus: () => getLLMStatus,
  groqClient: () => groqClient,
  huggingfaceClient: () => huggingfaceClient,
  llm: () => llm,
  openaiClient: () => openaiClient,
  openrouterClient: () => openrouterClient,
  togetherClient: () => togetherClient
});
function getConfiguredProvider() {
  const provider = process.env.AI_PROVIDER?.toLowerCase();
  if (provider === "openrouter") return "openrouter";
  if (provider === "groq") return "groq";
  if (provider === "together") return "together";
  if (provider === "aimlapi") return "aimlapi";
  if (provider === "claude") return "claude";
  if (provider === "gemini") return "gemini";
  if (provider === "cloudflare") return "cloudflare";
  if (provider === "huggingface") return "huggingface";
  return "openai";
}
function selectClient() {
  const provider = getConfiguredProvider();
  const clientMap = {
    openai: openaiClient,
    openrouter: openrouterClient,
    groq: groqClient,
    together: togetherClient,
    aimlapi: aimlClient,
    claude: claudeClient,
    gemini: geminiClient,
    cloudflare: cloudflareClient,
    huggingface: huggingfaceClient
  };
  const preferredClient = clientMap[provider];
  if (preferredClient?.isAvailable()) {
    return preferredClient;
  }
  if (openaiClient.isAvailable()) return openaiClient;
  if (groqClient.isAvailable()) return groqClient;
  if (togetherClient.isAvailable()) return togetherClient;
  if (aimlClient.isAvailable()) return aimlClient;
  if (claudeClient.isAvailable()) return claudeClient;
  if (geminiClient.isAvailable()) return geminiClient;
  if (cloudflareClient.isAvailable()) return cloudflareClient;
  if (huggingfaceClient.isAvailable()) return huggingfaceClient;
  if (openrouterClient.isAvailable()) return openrouterClient;
  return openaiClient;
}
function getLLMStatus() {
  const client = selectClient();
  return {
    provider: client.getProviderName(),
    available: client.isAvailable(),
    providers: {
      openai: openaiClient.isAvailable(),
      openrouter: openrouterClient.isAvailable(),
      groq: groqClient.isAvailable(),
      together: togetherClient.isAvailable(),
      aimlapi: aimlClient.isAvailable(),
      claude: claudeClient.isAvailable(),
      gemini: geminiClient.isAvailable(),
      cloudflare: cloudflareClient.isAvailable(),
      huggingface: huggingfaceClient.isAvailable()
    }
  };
}
function getAllAvailableProviders() {
  const available = [];
  if (openaiClient.isAvailable()) available.push("openai");
  if (groqClient.isAvailable()) available.push("groq");
  if (togetherClient.isAvailable()) available.push("together");
  if (aimlClient.isAvailable()) available.push("aimlapi");
  if (claudeClient.isAvailable()) available.push("claude");
  if (geminiClient.isAvailable()) available.push("gemini");
  if (cloudflareClient.isAvailable()) available.push("cloudflare");
  if (huggingfaceClient.isAvailable()) available.push("huggingface");
  if (openrouterClient.isAvailable()) available.push("openrouter");
  return available;
}
var llm;
var init_ai = __esm({
  "server/ai/index.ts"() {
    "use strict";
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    init_claudeClient();
    init_geminiClient();
    init_cloudflareClient();
    init_huggingfaceClient();
    init_llmClient();
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    init_claudeClient();
    init_geminiClient();
    init_cloudflareClient();
    init_huggingfaceClient();
    llm = selectClient();
  }
});

// server/middleware/audit-logger.ts
var audit_logger_exports = {};
__export(audit_logger_exports, {
  auditLogger: () => auditLogger,
  getAuditLogs: () => getAuditLogs,
  getAuditStats: () => getAuditStats,
  getRecentAuditLogs: () => getRecentAuditLogs,
  getResourceAuditLogs: () => getResourceAuditLogs,
  getUserAuditLogs: () => getUserAuditLogs
});
function sanitizeRequestBody(body) {
  if (!body || typeof body !== "object") {
    return body;
  }
  const sanitized = { ...body };
  for (const field of SENSITIVE_FIELDS) {
    if (field in sanitized) {
      sanitized[field] = "[REDACTED]";
    }
  }
  for (const key in sanitized) {
    if (typeof sanitized[key] === "object" && sanitized[key] !== null) {
      sanitized[key] = sanitizeRequestBody(sanitized[key]);
    }
  }
  return sanitized;
}
function getActionName(method, path2) {
  const pathSegments = path2.split("/").filter(Boolean);
  let resource = "unknown";
  if (pathSegments.length >= 2 && pathSegments[0] === "api") {
    resource = pathSegments[1];
  }
  const actionMap = {
    POST: "create",
    PUT: "update",
    PATCH: "update",
    DELETE: "delete"
  };
  const verb = actionMap[method] || method.toLowerCase();
  return `${verb}_${resource}`;
}
function extractResourceId(req) {
  if (req.params.id) {
    return req.params.id;
  }
  for (const param of [
    "userId",
    "strategyId",
    "orderId",
    "tradeId",
    "backtestId"
  ]) {
    if (req.params[param]) {
      return req.params[param];
    }
  }
  if (req.body?.id) {
    return req.body.id;
  }
  return void 0;
}
function getClientIp(req) {
  return req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.headers["x-real-ip"] || req.socket.remoteAddress || "unknown";
}
async function auditLogger(req, res, next) {
  const startTime = Date.now();
  if (!["POST", "PUT", "PATCH", "DELETE"].includes(req.method)) {
    return next();
  }
  if (req.path.startsWith("/health") || !req.path.startsWith("/api")) {
    return next();
  }
  const userId = req.userId || null;
  let username = null;
  if (userId) {
    try {
      const user = await storage.getUser(userId);
      username = user?.username || null;
    } catch (error) {
      const err = error;
      log.error("AuditLogger", "Failed to get username", {
        error: err.message
      });
    }
  }
  const auditLog = {
    userId,
    username,
    action: getActionName(req.method, req.path),
    resource: req.path.split("/")[2] || "unknown",
    // Extract from /api/resource/...
    resourceId: extractResourceId(req),
    method: req.method,
    path: req.path,
    ipAddress: getClientIp(req),
    userAgent: req.headers["user-agent"] || null,
    requestBody: sanitizeRequestBody(req.body),
    responseStatus: null,
    errorMessage: null
  };
  const originalSend = res.send;
  const originalJson = res.json;
  let responseBody;
  res.send = function(body) {
    responseBody = body;
    return originalSend.call(this, body);
  };
  res.json = function(body) {
    responseBody = body;
    return originalJson.call(this, body);
  };
  res.on("finish", async () => {
    try {
      auditLog.responseStatus = res.statusCode;
      if (res.statusCode >= 400) {
        if (typeof responseBody === "string") {
          try {
            const parsed = JSON.parse(responseBody);
            auditLog.errorMessage = parsed.error || parsed.message || "Unknown error";
          } catch {
            auditLog.errorMessage = responseBody.substring(0, 500);
          }
        } else if (typeof responseBody === "object" && responseBody !== null && !Buffer.isBuffer(responseBody)) {
          const errBody = responseBody;
          if (errBody.error || errBody.message) {
            auditLog.errorMessage = errBody.error || errBody.message || null;
          }
        }
      }
      await storage.createAuditLog(auditLog);
      const duration = Date.now() - startTime;
      log.info("Audit", "Request logged", {
        method: auditLog.method,
        path: auditLog.path,
        status: auditLog.responseStatus,
        durationMs: duration,
        user: username || "anonymous"
      });
    } catch (error) {
      const err = error;
      log.error("AuditLogger", "Failed to save audit log", {
        error: err.message
      });
    }
  });
  next();
}
async function getUserAuditLogs(userId, limit4 = 100, offset = 0) {
  return storage.getUserAuditLogs(userId, limit4, offset);
}
async function getResourceAuditLogs(resource, resourceId, limit4 = 50) {
  return storage.getResourceAuditLogs(resource, resourceId, limit4);
}
async function getRecentAuditLogs(limit4 = 100, offset = 0) {
  return storage.getRecentAuditLogs(limit4, offset);
}
async function getAuditLogs(limit4 = 100, offset = 0) {
  return storage.getRecentAuditLogs(limit4, offset);
}
async function getAuditStats() {
  try {
    const recentLogs = await storage.getRecentAuditLogs(1e3, 0);
    const logs = recentLogs || [];
    const now = /* @__PURE__ */ new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const thisWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1e3);
    const todayLogs = logs.filter(
      (l) => new Date(l.timestamp) >= today
    );
    const weekLogs = logs.filter(
      (l) => new Date(l.timestamp) >= thisWeek
    );
    const errorLogs = logs.filter(
      (l) => l.responseStatus && l.responseStatus >= 400
    );
    const actionCounts = {};
    logs.forEach((l) => {
      actionCounts[l.action] = (actionCounts[l.action] || 0) + 1;
    });
    return {
      totalLogs: logs.length,
      todayCount: todayLogs.length,
      weekCount: weekLogs.length,
      errorCount: errorLogs.length,
      topActions: Object.entries(actionCounts).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([action, count3]) => ({ action, count: count3 }))
    };
  } catch (error) {
    const err = error;
    log.error("AuditLogger", "Failed to get audit stats", {
      error: err.message
    });
    return {
      totalLogs: 0,
      todayCount: 0,
      weekCount: 0,
      errorCount: 0,
      topActions: []
    };
  }
}
var SENSITIVE_FIELDS;
var init_audit_logger = __esm({
  "server/middleware/audit-logger.ts"() {
    "use strict";
    init_storage();
    init_logger();
    SENSITIVE_FIELDS = [
      "password",
      "token",
      "apiKey",
      "secret",
      "authorization",
      "cookie",
      "session"
    ];
  }
});

// server/index.ts
import * as dotenv from "dotenv";
import express from "express";
import cookieParser from "cookie-parser";
import helmet from "helmet";

// server/routes.ts
import { createServer } from "node:http";
import bcrypt3 from "bcryptjs";

// server/lib/session.ts
init_db();
init_schema2();
init_logger();
import { randomBytes } from "node:crypto";
import { eq, lt } from "drizzle-orm";
var SESSION_DURATION = 7 * 24 * 60 * 60 * 1e3;
async function createSession(userId) {
  const sessionId = randomBytes(32).toString("hex");
  const expiresAt = new Date(Date.now() + SESSION_DURATION);
  await db.insert(sessions).values({
    id: sessionId,
    userId,
    expiresAt
  });
  return sessionId;
}
async function getSession(sessionId) {
  const [session] = await db.select().from(sessions).where(eq(sessions.id, sessionId));
  if (!session) {
    return null;
  }
  if (session.expiresAt < /* @__PURE__ */ new Date()) {
    await deleteSession(sessionId);
    return null;
  }
  return {
    userId: session.userId,
    expiresAt: session.expiresAt.getTime()
  };
}
async function deleteSession(sessionId) {
  await db.delete(sessions).where(eq(sessions.id, sessionId));
}
async function cleanupExpiredSessions() {
  const result = await db.delete(sessions).where(lt(sessions.expiresAt, /* @__PURE__ */ new Date()));
  log.info("SessionCleanup", "Cleaned up expired sessions");
}

// server/routes.ts
init_storage();
init_alpaca();
init_alpaca_trading_engine();

// server/trading/alpaca-stream.ts
init_logger();
init_storage();
import WebSocket2 from "ws";

// server/trading/order-retry-handler.ts
init_alpaca();
init_storage();
init_logger();
init_trading_config();
init_money();
var VALID_ORDER_TYPES = [
  "market",
  "limit",
  "stop",
  "stop_limit",
  "trailing_stop"
];
var VALID_TIME_IN_FORCE = [
  "day",
  "gtc",
  "opg",
  "cls",
  "ioc",
  "fok"
];
function toOrderType(value, fallback = "limit") {
  if (value && VALID_ORDER_TYPES.includes(value)) {
    return value;
  }
  return fallback;
}
function toTimeInForce(value, fallback = "day") {
  if (value && VALID_TIME_IN_FORCE.includes(value)) {
    return value;
  }
  return fallback;
}
var MAX_RETRIES_PER_ORDER = tradingConfig.orderRetry.maxRetriesPerOrder;
var RETRY_BACKOFF_BASE_MS = tradingConfig.orderRetry.retryBackoffBaseMs;
var CIRCUIT_BREAKER_THRESHOLD = tradingConfig.orderRetry.circuitBreakerThreshold;
var CIRCUIT_BREAKER_WINDOW_MS = tradingConfig.orderRetry.circuitBreakerWindowMs;
var CIRCUIT_BREAKER_RESET_MS = tradingConfig.orderRetry.circuitBreakerResetMs;
var retryTracker = /* @__PURE__ */ new Map();
var circuitBreaker = {
  failures: 0,
  lastFailureTime: null,
  isOpen: false,
  resetTime: null
};
var rejectionHandlers = [
  // Market Hours Issues
  {
    pattern: /market.*(?:closed|extended|hours)/i,
    category: "market_hours",
    description: "Market order rejected during extended hours",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const direction = order.order.side === "buy" ? 1 : -1;
      const limitPrice = roundPrice(
        priceWithBuffer(currentPrice, 5e-3, direction),
        2
      ).toNumber();
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "day",
          limit_price: limitPrice.toFixed(2),
          extended_hours: true
        },
        explanation: `Converted market order to limit order at $${limitPrice.toFixed(2)} for extended hours trading`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /day.*(?:trading|closed)/i,
    category: "market_hours",
    description: "Day order attempted when market closed",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const direction = order.order.side === "buy" ? 1 : -1;
      const limitPrice = roundPrice(
        priceWithBuffer(currentPrice, 5e-3, direction),
        2
      ).toNumber();
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "gtc",
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Converted to GTC limit order at $${limitPrice.toFixed(2)} to execute when market opens`,
        confidence: "high"
      };
    }
  },
  // Price Validation Issues
  {
    pattern: /price.*(?:aggressive|outside|collar|range)/i,
    category: "price_validation",
    description: "Limit price too aggressive or outside allowed range",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const direction = order.order.side === "buy" ? 1 : -1;
      const limitPrice = roundPrice(
        priceWithBuffer(currentPrice, 5e-3, direction),
        2
      ).toNumber();
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Adjusted limit price to $${limitPrice.toFixed(2)} (0.5% from market) to meet broker requirements`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /notional.*(?:below|minimum|threshold)/i,
    category: "price_validation",
    description: "Order value too small",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const minNotional = 5;
      const requiredQty = toDecimal(minNotional).dividedBy(currentPrice).ceil().toNumber();
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: requiredQty.toString(),
          type: toOrderType(order.order.type),
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Increased quantity to ${requiredQty} shares to meet minimum order value ($${minNotional})`,
        confidence: "medium"
      };
    }
  },
  // Insufficient Funds
  {
    pattern: /insufficient.*(?:buying|funds|balance|capital)/i,
    category: "insufficient_funds",
    description: "Not enough buying power",
    fix: async (order, reason) => {
      const account = await alpaca.getAccount();
      const buyingPower = toDecimal(account.buying_power);
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice || buyingPower.lessThanOrEqualTo(0)) return null;
      const affordableValue = buyingPower.times(0.95);
      const affordableQty = calculateWholeShares(
        affordableValue,
        currentPrice
      ).toNumber();
      if (affordableQty < 1) {
        return null;
      }
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: affordableQty.toString(),
          type: toOrderType(order.order.type),
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Reduced quantity to ${affordableQty} shares to fit within buying power ($${buyingPower.toFixed(2)})`,
        confidence: "high"
      };
    }
  },
  // Position Limits
  {
    pattern: /(?:max|maximum).*positions/i,
    category: "position_limits",
    description: "Maximum position count exceeded",
    fix: async (order, reason) => {
      log.warn(
        "OrderRetry",
        `Max positions limit - manual intervention required for ${order.order.symbol}`
      );
      return null;
    }
  },
  // Fractional Shares Issues
  {
    pattern: /fractional.*(?:not.*supported|shares)/i,
    category: "order_type",
    description: "Fractional shares not allowed",
    fix: async (order, reason) => {
      const qty = parseFloat(order.order.qty);
      const wholeShares = Math.floor(qty);
      if (wholeShares < 1) {
        return null;
      }
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: wholeShares.toString(),
          type: toOrderType(order.order.type),
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: order.order.limit_price || void 0,
          extended_hours: order.order.extended_hours
        },
        explanation: `Rounded down to ${wholeShares} whole shares (fractional not supported for this symbol)`,
        confidence: "high"
      };
    }
  },
  // Order Type Issues
  {
    pattern: /(?:gtc|time.*force).*(?:not.*supported|invalid)/i,
    category: "order_type",
    description: "Time-in-force not supported",
    fix: async (order, reason) => {
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: toOrderType(order.order.type),
          time_in_force: "day",
          // Safest default
          limit_price: order.order.limit_price || void 0,
          stop_price: order.order.stop_price || void 0
        },
        explanation: `Changed time-in-force to 'day' (most compatible option)`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /market.*order.*(?:not.*allowed|invalid)/i,
    category: "order_type",
    description: "Market orders not allowed",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.01 : 0.99;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "day",
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Converted to limit order at $${limitPrice.toFixed(2)} (1% buffer from market)`,
        confidence: "high"
      };
    }
  },
  // Bracket Order Issues
  {
    pattern: /bracket.*(?:not.*supported|invalid)/i,
    category: "order_type",
    description: "Bracket orders not supported",
    fix: async (order, reason) => {
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: toOrderType(order.order.type),
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: order.order.limit_price || void 0,
          order_class: "simple"
          // Remove bracket
        },
        explanation: `Converted to simple order (bracket orders not supported for this symbol/session)`,
        confidence: "medium"
      };
    }
  },
  // Symbol Issues
  {
    pattern: /symbol.*(?:not.*found|invalid|unknown)/i,
    category: "symbol_invalid",
    description: "Symbol not found or invalid",
    fix: async (order, reason) => {
      log.error(
        "OrderRetry",
        `Invalid symbol ${order.order.symbol} - cannot retry`
      );
      return null;
    }
  },
  // Regulatory/Account Issues
  {
    pattern: /pattern.*day.*trad(?:er|ing)/i,
    category: "regulatory",
    description: "Pattern day trader restriction",
    fix: async (order, reason) => {
      log.warn(
        "OrderRetry",
        `PDT restriction for ${order.order.symbol} - cannot retry`
      );
      return null;
    }
  },
  {
    pattern: /account.*(?:blocked|suspended|restricted)/i,
    category: "regulatory",
    description: "Account restricted",
    fix: async (order, reason) => {
      log.error("OrderRetry", `Account restricted - cannot retry orders`);
      return null;
    }
  },
  // Short Sale Issues
  {
    pattern: /short.*(?:not.*available|restricted|locate)/i,
    category: "position_limits",
    description: "Short selling not available",
    fix: async (order, reason) => {
      if (order.order.side === "sell") {
        log.warn(
          "OrderRetry",
          `Short selling restricted for ${order.order.symbol} - cannot retry`
        );
        return null;
      }
      return null;
    }
  },
  // Wash Trade Prevention
  {
    pattern: /wash.*trade/i,
    category: "regulatory",
    description: "Potential wash trade detected",
    fix: async (order, reason) => {
      log.warn(
        "OrderRetry",
        `Wash trade rule for ${order.order.symbol} - delaying retry`
      );
      await new Promise((resolve2) => setTimeout(resolve2, 3e4));
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: toOrderType(order.order.type),
          time_in_force: toTimeInForce(order.order.time_in_force),
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Delayed retry by 30 seconds to avoid wash trade rule`,
        confidence: "low"
      };
    }
  },
  // Order Canceled (generic - often due to market session issues)
  {
    pattern: /order.*cancel/i,
    category: "market_hours",
    description: "Order canceled by broker (usually session-related)",
    fix: async (order, reason) => {
      const { tradingSessionManager: tradingSessionManager2 } = await Promise.resolve().then(() => (init_trading_session_manager(), trading_session_manager_exports));
      const sessionInfo = tradingSessionManager2.getCurrentSession("US_EQUITIES");
      const isRegularHours = sessionInfo.session === "regular" && sessionInfo.isOpen;
      const isExtendedHours = sessionInfo.session === "pre_market" || sessionInfo.session === "after_hours";
      if (isRegularHours) {
        if (order.order.qty) {
          return {
            params: {
              symbol: order.order.symbol,
              side: order.order.side,
              qty: order.order.qty,
              type: "market",
              time_in_force: "day"
            },
            explanation: `Retrying as MARKET order during regular hours (qty=${order.order.qty})`,
            confidence: "high"
          };
        }
        if (order.order.notional) {
          return {
            params: {
              symbol: order.order.symbol,
              side: order.order.side,
              notional: order.order.notional,
              type: "market",
              time_in_force: "day"
            },
            explanation: `Retrying as MARKET order during regular hours (notional=${order.order.notional})`,
            confidence: "high"
          };
        }
      }
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.01 : 0.99;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      if (order.order.qty) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: order.order.qty,
            type: "limit",
            time_in_force: "day",
            limit_price: limitPrice.toFixed(2),
            extended_hours: isExtendedHours
          },
          explanation: `Converted to limit order at $${limitPrice.toFixed(2)} (extended_hours=${isExtendedHours}, qty=${order.order.qty})`,
          confidence: "medium"
        };
      }
      if (order.order.notional) {
        const estimatedQty = Math.floor(
          parseFloat(order.order.notional) / currentPrice
        );
        if (estimatedQty < 1) {
          log.warn(
            "OrderRetry",
            `Notional ${order.order.notional} too small for whole shares at $${currentPrice}`
          );
          return null;
        }
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: estimatedQty.toString(),
            type: "limit",
            time_in_force: "day",
            limit_price: limitPrice.toFixed(2),
            extended_hours: isExtendedHours
          },
          explanation: `Converted notional=${order.order.notional} to qty=${estimatedQty} limit order at $${limitPrice.toFixed(2)} (extended_hours=${isExtendedHours})`,
          confidence: "medium"
        };
      }
      log.warn(
        "OrderRetry",
        `Order ${order.order.symbol} has no qty or notional - cannot retry`
      );
      return null;
    }
  },
  // Missing qty or notional (validation error)
  {
    pattern: /qty.*(?:or|and).*notional.*required/i,
    category: "order_type",
    description: "Order missing qty or notional parameter",
    fix: async (order, reason) => {
      if (order.order.qty) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: order.order.qty,
            type: toOrderType(order.order.type || "limit"),
            time_in_force: toTimeInForce(order.order.time_in_force || "day"),
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Retried with explicit qty=${order.order.qty}`,
          confidence: "high"
        };
      }
      if (order.order.notional) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            notional: order.order.notional,
            type: toOrderType(order.order.type || "limit"),
            time_in_force: toTimeInForce(order.order.time_in_force || "day"),
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Retried with explicit notional=${order.order.notional}`,
          confidence: "high"
        };
      }
      if (order.order.side === "sell") {
        try {
          const positions2 = await alpaca.getPositions();
          const position = positions2.find(
            (p) => p.symbol === order.order.symbol
          );
          if (position) {
            const availableQty = Math.floor(
              parseFloat(position.qty_available || position.qty || "0")
            );
            if (availableQty >= 1) {
              return {
                params: {
                  symbol: order.order.symbol,
                  side: "sell",
                  qty: availableQty.toString(),
                  type: toOrderType(order.order.type || "limit"),
                  time_in_force: toTimeInForce(
                    order.order.time_in_force || "day"
                  ),
                  limit_price: order.order.limit_price || void 0,
                  extended_hours: order.order.extended_hours
                },
                explanation: `Sell order: Using available position qty=${availableQty}`,
                confidence: "medium"
              };
            }
          }
        } catch (e) {
          log.warn(
            "OrderRetry",
            `Failed to get position for ${order.order.symbol}`
          );
        }
      }
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (currentPrice) {
        const minNotional = 10;
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            notional: minNotional.toString(),
            type: toOrderType(order.order.type || "limit"),
            time_in_force: toTimeInForce(order.order.time_in_force || "day"),
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Using minimum notional=$${minNotional} as fallback`,
          confidence: "low"
        };
      }
      return null;
    }
  },
  // Insufficient Quantity Available (position mismatch)
  {
    pattern: /insufficient.*qty.*available/i,
    category: "position_limits",
    description: "Requested quantity exceeds available shares",
    fix: async (order, reason) => {
      try {
        const positions2 = await alpaca.getPositions();
        const position = positions2.find(
          (p) => p.symbol === order.order.symbol
        );
        if (!position) {
          log.warn(
            "OrderRetry",
            `No position found for ${order.order.symbol} - cannot retry sell`
          );
          return null;
        }
        const availableQty = parseFloat(
          position.qty_available || position.qty || "0"
        );
        const wholeQty = Math.floor(availableQty);
        if (wholeQty < 1) {
          log.warn(
            "OrderRetry",
            `No whole shares available for ${order.order.symbol} (${availableQty} available)`
          );
          return null;
        }
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: wholeQty.toString(),
            type: toOrderType(order.order.type),
            time_in_force: toTimeInForce(order.order.time_in_force),
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Reduced quantity to ${wholeQty} shares (actual available from position)`,
          confidence: "high"
        };
      } catch (error) {
        log.error(
          "OrderRetry",
          `Failed to get position for ${order.order.symbol}`,
          { error }
        );
        return null;
      }
    }
  }
];
async function getCurrentPrice(symbol) {
  try {
    const snapshot = await alpaca.getSnapshots([symbol]);
    const data = snapshot[symbol];
    if (!data) return null;
    return data.latestTrade?.p || data.latestQuote?.ap || data.dailyBar?.c || null;
  } catch (error) {
    log.error("OrderRetry", `Failed to get price for ${symbol}`, { error });
    return null;
  }
}
function extractRejectionReason(update) {
  if (update.order.status === "rejected" || update.order.failed_at) {
    const reasons = [];
    if (update.order.extended_hours && update.order.type === "market") {
      reasons.push("market orders not allowed during extended hours");
    }
    if (update.order.order_class === "bracket" && update.order.extended_hours) {
      reasons.push("bracket orders not supported during extended hours");
    }
    if (reasons.length === 0) {
      reasons.push("order rejected by broker");
    }
    return reasons.join("; ");
  }
  if (update.order.status === "canceled" || update.order.canceled_at) {
    return "order canceled";
  }
  return "unknown rejection reason";
}
function findHandler(reason) {
  for (const handler of rejectionHandlers) {
    if (handler.pattern.test(reason)) {
      return handler;
    }
  }
  return null;
}
function checkCircuitBreaker() {
  const now = Date.now();
  if (circuitBreaker.resetTime && now >= circuitBreaker.resetTime.getTime()) {
    circuitBreaker.failures = 0;
    circuitBreaker.isOpen = false;
    circuitBreaker.resetTime = null;
    circuitBreaker.lastFailureTime = null;
    log.info("OrderRetry", "Circuit breaker reset");
  }
  if (circuitBreaker.lastFailureTime) {
    const timeSinceLastFailure = now - circuitBreaker.lastFailureTime.getTime();
    if (timeSinceLastFailure > CIRCUIT_BREAKER_WINDOW_MS) {
      circuitBreaker.failures = 0;
    }
  }
  return circuitBreaker.isOpen;
}
function recordFailure() {
  circuitBreaker.failures++;
  circuitBreaker.lastFailureTime = /* @__PURE__ */ new Date();
  if (circuitBreaker.failures >= CIRCUIT_BREAKER_THRESHOLD) {
    circuitBreaker.isOpen = true;
    circuitBreaker.resetTime = new Date(Date.now() + CIRCUIT_BREAKER_RESET_MS);
    log.error(
      "OrderRetry",
      `Circuit breaker OPENED after ${circuitBreaker.failures} failures. Will reset at ${circuitBreaker.resetTime.toISOString()}`
    );
  }
}
function calculateBackoff(attemptNumber) {
  return RETRY_BACKOFF_BASE_MS * Math.pow(2, attemptNumber - 1);
}
async function handleOrderRejection(update, reason) {
  const orderId = update.order.id;
  const symbol = update.order.symbol;
  const rejectionReason = reason || extractRejectionReason(update);
  log.warn(
    "OrderRetry",
    `Order ${orderId} for ${symbol} ${update.order.status}`,
    {
      reason: rejectionReason,
      orderType: update.order.type,
      timeInForce: update.order.time_in_force
    }
  );
  if (!retryTracker.has(orderId)) {
    retryTracker.set(orderId, []);
  }
  const attempts = retryTracker.get(orderId);
  if (attempts.length >= MAX_RETRIES_PER_ORDER) {
    log.error(
      "OrderRetry",
      `Max retries (${MAX_RETRIES_PER_ORDER}) exceeded for order ${orderId}`
    );
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "max_retries_exceeded",
      error: `Exceeded maximum retry attempts (${MAX_RETRIES_PER_ORDER})`
    };
  }
  if (checkCircuitBreaker()) {
    log.error(
      "OrderRetry",
      `Circuit breaker is OPEN - rejecting retry for ${orderId}`
    );
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "permanent_failure",
      error: "Circuit breaker is open - too many failures recently"
    };
  }
  const handler = findHandler(rejectionReason);
  if (!handler) {
    log.warn(
      "OrderRetry",
      `No handler found for rejection reason: ${rejectionReason}`
    );
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "no_fix_available",
      error: `No automated fix available for: ${rejectionReason}`
    };
  }
  log.info(
    "OrderRetry",
    `Found handler: ${handler.description} (${handler.category})`
  );
  let fixedParams;
  try {
    fixedParams = await handler.fix(update, rejectionReason);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log.error("OrderRetry", `Fix function failed for ${orderId}`, {
      error: errorMsg
    });
    recordFailure();
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: handler.description,
      success: false,
      error: `Fix function error: ${errorMsg}`
    };
    attempts.push(attempt);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "permanent_failure",
      error: errorMsg
    };
  }
  if (!fixedParams) {
    log.warn("OrderRetry", `Handler could not generate fix for ${orderId}`);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "no_fix_available",
      error: `Handler could not generate fix: ${handler.description}`
    };
  }
  const backoffMs = calculateBackoff(attempts.length + 1);
  log.info(
    "OrderRetry",
    `Waiting ${backoffMs}ms before retry (attempt ${attempts.length + 1}/${MAX_RETRIES_PER_ORDER})`
  );
  await new Promise((resolve2) => setTimeout(resolve2, backoffMs));
  const newClientOrderId = `retry-${orderId}-${attempts.length + 1}-${Date.now()}`;
  fixedParams.params.client_order_id = newClientOrderId;
  log.info(
    "OrderRetry",
    `Retrying order ${orderId} with fix: ${fixedParams.explanation}`
  );
  try {
    const newOrder = await alpaca.createOrder(fixedParams.params);
    log.info(
      "OrderRetry",
      `Retry successful! New order ${newOrder.id} created for ${symbol}`,
      {
        status: newOrder.status,
        fix: fixedParams.explanation
      }
    );
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: fixedParams.explanation,
      success: true
    };
    attempts.push(attempt);
    await storage.upsertOrderByBrokerOrderId(newOrder.id, {
      broker: "alpaca",
      brokerOrderId: newOrder.id,
      clientOrderId: newClientOrderId,
      symbol: newOrder.symbol,
      side: newOrder.side,
      type: newOrder.type,
      timeInForce: newOrder.time_in_force,
      qty: newOrder.qty,
      notional: newOrder.notional,
      limitPrice: newOrder.limit_price,
      stopPrice: newOrder.stop_price,
      status: newOrder.status,
      submittedAt: new Date(newOrder.submitted_at || Date.now()),
      updatedAt: /* @__PURE__ */ new Date(),
      filledQty: newOrder.filled_qty,
      filledAvgPrice: newOrder.filled_avg_price,
      traceId: `retry-${orderId}`,
      rawJson: {
        ...newOrder,
        retryMetadata: {
          originalOrderId: orderId,
          attemptNumber: attempts.length,
          rejectionReason,
          fix: fixedParams.explanation
        }
      }
    });
    return {
      success: true,
      originalOrderId: orderId,
      newOrderId: newOrder.id,
      attempts,
      finalStatus: "retried_successfully"
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log.error("OrderRetry", `Retry failed for ${orderId}`, { error: errorMsg });
    recordFailure();
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: fixedParams.explanation,
      success: false,
      error: errorMsg
    };
    attempts.push(attempt);
    if (attempts.length < MAX_RETRIES_PER_ORDER) {
      log.info(
        "OrderRetry",
        `Retry failed, will attempt again (${attempts.length}/${MAX_RETRIES_PER_ORDER})`
      );
      return handleOrderRejection(update, errorMsg);
    }
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "max_retries_exceeded",
      error: errorMsg
    };
  }
}
function hookIntoTradeUpdates(update) {
  const status = update.order.status;
  if (status === "rejected" || status === "canceled") {
    handleOrderRejection(update).catch((error) => {
      log.error("OrderRetry", "Unhandled error in rejection handler", {
        error
      });
    });
  }
}
log.info(
  "OrderRetry",
  `Order Retry Handler initialized with ${rejectionHandlers.length} handlers`
);

// server/trading/alpaca-stream.ts
init_money();
init_trading_config();

// server/lib/websocket-server.ts
init_logger();
import { WebSocketServer, WebSocket } from "ws";
var WebSocketBroadcastServer = class {
  wss = null;
  clients = /* @__PURE__ */ new Map();
  heartbeatInterval = null;
  isRunning = false;
  /**
   * Initialize WebSocket server attached to HTTP server
   */
  initialize(httpServer) {
    if (this.wss) {
      log.warn("WebSocketServer", "Already initialized");
      return;
    }
    this.wss = new WebSocketServer({
      server: httpServer,
      path: "/ws",
      verifyClient: async (info, callback) => {
        try {
          const cookies = this.parseCookies(info.req.headers.cookie || "");
          const sessionId = cookies.session;
          if (!sessionId) {
            log.debug("WebSocketServer", "No session cookie, rejecting");
            callback(false, 401, "Unauthorized");
            return;
          }
          const session = await getSession(sessionId);
          if (!session) {
            log.debug("WebSocketServer", "Invalid session, rejecting");
            callback(false, 401, "Unauthorized");
            return;
          }
          info.req.userId = session.userId;
          callback(true);
        } catch (error) {
          log.error("WebSocketServer", "Auth error", { error });
          callback(false, 500, "Internal Server Error");
        }
      }
    });
    this.wss.on("connection", (ws, req) => {
      const userId = req.userId;
      if (!userId) {
        ws.close(1008, "Unauthorized");
        return;
      }
      this.handleConnection(ws, userId);
    });
    this.wss.on("error", (error) => {
      log.error("WebSocketServer", "Server error", { error });
    });
    this.startHeartbeat();
    this.isRunning = true;
    log.info("WebSocketServer", "Initialized on /ws path");
  }
  /**
   * Handle new WebSocket connection
   */
  handleConnection(ws, userId) {
    const client = {
      ws,
      userId,
      subscribedChannels: /* @__PURE__ */ new Set([
        "trade_update",
        "ai_decision",
        "portfolio_update"
      ]),
      lastPing: Date.now()
    };
    this.clients.set(ws, client);
    log.info("WebSocketServer", "Client connected", {
      userId,
      totalClients: this.clients.size
    });
    this.sendToClient(ws, {
      type: "ping",
      data: { message: "Connected to AlphaFlow real-time updates" },
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    ws.on("message", (data) => {
      this.handleMessage(ws, data.toString());
    });
    ws.on("close", () => {
      this.clients.delete(ws);
      log.info("WebSocketServer", "Client disconnected", {
        userId,
        totalClients: this.clients.size
      });
    });
    ws.on("error", (error) => {
      log.error("WebSocketServer", "Client error", { userId, error });
      this.clients.delete(ws);
    });
    ws.on("pong", () => {
      const client2 = this.clients.get(ws);
      if (client2) {
        client2.lastPing = Date.now();
      }
    });
  }
  /**
   * Handle incoming message from client
   */
  handleMessage(ws, message) {
    try {
      const parsed = JSON.parse(message);
      const client = this.clients.get(ws);
      if (!client) return;
      switch (parsed.type) {
        case "subscribe":
          if (Array.isArray(parsed.channels)) {
            parsed.channels.forEach((ch) => {
              client.subscribedChannels.add(ch);
            });
          }
          break;
        case "unsubscribe":
          if (Array.isArray(parsed.channels)) {
            parsed.channels.forEach((ch) => {
              client.subscribedChannels.delete(ch);
            });
          }
          break;
        case "ping":
          this.sendToClient(ws, {
            type: "ping",
            data: { pong: true },
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
          break;
      }
    } catch {
    }
  }
  /**
   * Broadcast event to all connected clients
   */
  broadcast(event) {
    if (!this.isRunning) return;
    let sentCount = 0;
    for (const [ws, client] of this.clients.entries()) {
      if (ws.readyState === WebSocket.OPEN && client.subscribedChannels.has(event.type)) {
        this.sendToClient(ws, event);
        sentCount++;
      }
    }
    log.debug("WebSocketServer", "Broadcast sent", {
      type: event.type,
      recipients: sentCount
    });
  }
  /**
   * Broadcast to specific user
   */
  broadcastToUser(userId, event) {
    if (!this.isRunning) return;
    for (const [ws, client] of this.clients.entries()) {
      if (client.userId === userId && ws.readyState === WebSocket.OPEN && client.subscribedChannels.has(event.type)) {
        this.sendToClient(ws, event);
      }
    }
  }
  /**
   * Send message to specific client
   */
  sendToClient(ws, event) {
    try {
      ws.send(JSON.stringify(event));
    } catch (error) {
      log.error("WebSocketServer", "Failed to send to client", { error });
    }
  }
  /**
   * Parse cookies from header string
   */
  parseCookies(cookieHeader) {
    const cookies = {};
    if (!cookieHeader) return cookies;
    cookieHeader.split(";").forEach((cookie) => {
      const [name, value] = cookie.trim().split("=");
      if (name && value) {
        cookies[name] = decodeURIComponent(value);
      }
    });
    return cookies;
  }
  /**
   * Start heartbeat to detect dead connections
   */
  startHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      const now = Date.now();
      const timeout = 6e4;
      for (const [ws, client] of this.clients.entries()) {
        if (now - client.lastPing > timeout) {
          log.debug("WebSocketServer", "Terminating stale connection", {
            userId: client.userId
          });
          ws.terminate();
          this.clients.delete(ws);
        } else if (ws.readyState === WebSocket.OPEN) {
          ws.ping();
        }
      }
    }, 3e4);
  }
  /**
   * Get connected client count
   */
  getClientCount() {
    return this.clients.size;
  }
  /**
   * Get clients by user
   */
  getClientsByUser(userId) {
    let count3 = 0;
    for (const client of this.clients.values()) {
      if (client.userId === userId) count3++;
    }
    return count3;
  }
  /**
   * Shutdown WebSocket server
   */
  shutdown() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
    if (this.wss) {
      for (const ws of this.clients.keys()) {
        ws.close(1001, "Server shutting down");
      }
      this.clients.clear();
      this.wss.close();
      this.wss = null;
    }
    this.isRunning = false;
    log.info("WebSocketServer", "Shutdown complete");
  }
};
var wsServer = new WebSocketBroadcastServer();
function broadcastTradeUpdate(data) {
  wsServer.broadcast({
    type: "trade_update",
    data,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  });
}

// server/trading/alpaca-stream.ts
var ALPACA_STREAM_URL2 = tradingConfig.alpaca.tradingMode === "live" ? "wss://api.alpaca.markets/stream" : "wss://paper-api.alpaca.markets/stream";
function mapAlpacaStatusToOrderStatus(alpacaStatus) {
  const statusMap = {
    new: "new",
    accepted: "accepted",
    pending_new: "pending_new",
    accepted_for_bidding: "accepted",
    stopped: "stopped",
    rejected: "rejected",
    suspended: "suspended",
    calculated: "calculated",
    partially_filled: "partially_filled",
    filled: "filled",
    done_for_day: "done_for_day",
    canceled: "canceled",
    expired: "expired",
    replaced: "replaced",
    pending_cancel: "pending_cancel",
    pending_replace: "pending_replace"
  };
  return statusMap[alpacaStatus.toLowerCase()] || "new";
}
var AlpacaStreamManager = class {
  ws = null;
  reconnectAttempts = 0;
  maxReconnectAttempts = 10;
  reconnectDelay = 1e3;
  isConnecting = false;
  isAuthenticated = false;
  heartbeatInterval = null;
  lastPongTime = Date.now();
  getCredentials() {
    const apiKey2 = process.env.ALPACA_API_KEY;
    const secretKey = process.env.ALPACA_SECRET_KEY;
    if (!apiKey2 || !secretKey) return null;
    return { apiKey: apiKey2, secretKey };
  }
  async connect() {
    if (this.isConnecting || this.ws && this.ws.readyState === WebSocket2.OPEN) {
      log.debug("AlpacaStream", "Already connected or connecting");
      return;
    }
    const credentials2 = this.getCredentials();
    if (!credentials2) {
      log.warn(
        "AlpacaStream",
        "Alpaca credentials not configured, skipping stream connection"
      );
      return;
    }
    this.isConnecting = true;
    log.info("AlpacaStream", "Connecting to Alpaca trade updates stream...");
    try {
      this.ws = new WebSocket2(ALPACA_STREAM_URL2);
      this.ws.on("open", () => {
        log.info("AlpacaStream", "WebSocket connected, authenticating...");
        this.authenticate(credentials2);
      });
      this.ws.on("message", (data) => {
        this.handleMessage(data);
      });
      this.ws.on("close", (code, reason) => {
        log.warn(
          "AlpacaStream",
          `WebSocket closed: ${code} - ${reason.toString()}`
        );
        this.isAuthenticated = false;
        this.isConnecting = false;
        this.stopHeartbeat();
        this.scheduleReconnect();
      });
      this.ws.on("error", (error) => {
        log.error("AlpacaStream", `WebSocket error: ${error.message}`);
        this.isConnecting = false;
      });
      this.ws.on("pong", () => {
        this.lastPongTime = Date.now();
      });
    } catch (error) {
      log.error("AlpacaStream", `Failed to connect: ${error}`);
      this.isConnecting = false;
      this.scheduleReconnect();
    }
  }
  authenticate(credentials2) {
    if (!this.ws || this.ws.readyState !== WebSocket2.OPEN) return;
    const authMessage = {
      action: "auth",
      key: credentials2.apiKey,
      secret: credentials2.secretKey
    };
    this.ws.send(JSON.stringify(authMessage));
  }
  subscribeToTradeUpdates() {
    if (!this.ws || this.ws.readyState !== WebSocket2.OPEN) return;
    const subscribeMessage = {
      action: "listen",
      data: {
        streams: ["trade_updates"]
      }
    };
    this.ws.send(JSON.stringify(subscribeMessage));
    log.info("AlpacaStream", "Subscribed to trade_updates stream");
    this.startHeartbeat();
  }
  startHeartbeat() {
    this.stopHeartbeat();
    this.heartbeatInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket2.OPEN) {
        this.ws.ping();
        if (Date.now() - this.lastPongTime > 6e4) {
          log.warn("AlpacaStream", "No pong received in 60s, reconnecting...");
          this.ws.terminate();
        }
      }
    }, 3e4);
  }
  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
  async handleMessage(data) {
    try {
      const message = JSON.parse(data.toString());
      if (message.stream === "authorization") {
        if (message.data?.status === "authorized") {
          log.info("AlpacaStream", "Authentication successful");
          this.isAuthenticated = true;
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          this.subscribeToTradeUpdates();
        } else {
          log.error(
            "AlpacaStream",
            `Authentication failed: ${JSON.stringify(message.data)}`
          );
          this.isConnecting = false;
        }
        return;
      }
      if (message.stream === "listening") {
        log.info(
          "AlpacaStream",
          `Now listening to: ${message.data?.streams?.join(", ")}`
        );
        return;
      }
      if (message.stream === "trade_updates") {
        await this.handleTradeUpdate(message.data);
      }
    } catch (error) {
      log.error("AlpacaStream", `Failed to parse message: ${error}`);
    }
  }
  async handleTradeUpdate(update) {
    const { event, order, timestamp: timestamp18, price, qty, execution_id } = update;
    const brokerOrderId = order.id;
    log.info(
      "AlpacaStream",
      `Trade update: ${event} for order ${brokerOrderId} (${order.symbol})`
    );
    try {
      const existingOrder = await storage.getOrderByBrokerOrderId(brokerOrderId);
      const traceId = existingOrder?.traceId || `stream-${Date.now()}`;
      let userId = existingOrder?.userId;
      if (!userId) {
        const adminUser = await storage.getAdminUser();
        userId = adminUser?.id;
        if (!userId) {
          log.error(
            "AlpacaStream",
            `No userId available for order ${brokerOrderId}, skipping update`
          );
          return;
        }
      }
      const newStatus = mapAlpacaStatusToOrderStatus(order.status);
      await storage.upsertOrderByBrokerOrderId(brokerOrderId, {
        userId,
        broker: "alpaca",
        brokerOrderId,
        clientOrderId: order.client_order_id,
        symbol: order.symbol,
        side: order.side,
        type: order.type,
        timeInForce: order.time_in_force,
        qty: order.qty,
        notional: order.notional,
        limitPrice: order.limit_price,
        stopPrice: order.stop_price,
        status: newStatus,
        submittedAt: order.submitted_at ? new Date(order.submitted_at) : /* @__PURE__ */ new Date(),
        updatedAt: new Date(order.updated_at),
        filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
        filledQty: order.filled_qty,
        filledAvgPrice: order.filled_avg_price,
        traceId,
        rawJson: order
      });
      broadcastTradeUpdate({
        orderId: brokerOrderId,
        symbol: order.symbol,
        side: order.side,
        status: newStatus,
        filledQty: order.filled_qty,
        filledPrice: order.filled_avg_price || void 0
      });
      if ((event === "fill" || event === "partial_fill") && price && qty) {
        const fillId = execution_id || `${brokerOrderId}-${qty}-${price}-${Math.floor(new Date(timestamp18).getTime() / 1e3)}`;
        try {
          await storage.createFill({
            broker: "alpaca",
            brokerOrderId,
            brokerFillId: fillId,
            orderId: existingOrder?.id,
            symbol: order.symbol,
            side: order.side,
            qty,
            price,
            occurredAt: new Date(timestamp18),
            traceId,
            rawJson: update
          });
          log.info(
            "AlpacaStream",
            `Created fill record: ${fillId} for ${qty} @ ${price}`
          );
          if (event === "fill" && existingOrder?.id) {
            try {
              let pnl = null;
              const positions2 = await storage.getPositions(userId);
              const position = positions2.find((p) => p.symbol === order.symbol);
              if (position && order.side !== position.side) {
                const side = order.side === "sell" ? "long" : "short";
                pnl = formatPrice(
                  calculatePnL(position.entryPrice, price, qty, side),
                  2
                );
              }
              await storage.createTrade({
                userId,
                orderId: existingOrder.id,
                symbol: order.symbol,
                side: order.side,
                quantity: qty,
                price,
                pnl,
                status: "completed",
                traceId,
                notes: `Auto-created from fill ${fillId}`
              });
              log.info(
                "AlpacaStream",
                `Auto-created trade record for filled order ${brokerOrderId}, symbol: ${order.symbol}, qty: ${qty}, price: ${price}${pnl ? `, pnl: ${pnl}` : ""}`
              );
            } catch (tradeError) {
              log.error(
                "AlpacaStream",
                `Failed to auto-create trade record: ${tradeError.message}`
              );
            }
          }
        } catch (fillError) {
          if (fillError.message?.includes("duplicate") || fillError.code === "23505") {
            log.debug("AlpacaStream", `Fill already exists: ${fillId}`);
          } else {
            throw fillError;
          }
        }
      }
      log.debug(
        "AlpacaStream",
        `Order ${brokerOrderId} updated to status: ${newStatus}`
      );
      try {
        const {
          emitOrderUpdate: emitOrderUpdate2,
          emitOrderFill: emitOrderFill2
        } = (init_sse_emitter(), __toCommonJS(sse_emitter_exports));
        emitOrderUpdate2(brokerOrderId, {
          status: newStatus,
          symbol: order.symbol,
          side: order.side,
          qty: order.qty,
          filledQty: order.filled_qty,
          filledAvgPrice: order.filled_avg_price,
          type: order.type,
          timeInForce: order.time_in_force
        });
        if (event === "fill" || event === "partial_fill") {
          emitOrderFill2(brokerOrderId, {
            symbol: order.symbol,
            side: order.side,
            qty,
            price,
            filledQty: order.filled_qty,
            filledAvgPrice: order.filled_avg_price,
            partial: event === "partial_fill"
          });
        }
      } catch (sseError) {
        log.error("AlpacaStream", `Failed to emit SSE event: ${sseError}`);
      }
      if (newStatus === "rejected" || newStatus === "canceled") {
        hookIntoTradeUpdates(update);
      }
    } catch (error) {
      log.error("AlpacaStream", `Failed to process trade update: ${error}`);
    }
  }
  scheduleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      log.error("AlpacaStream", "Max reconnection attempts reached, giving up");
      return;
    }
    const delay = Math.min(
      this.reconnectDelay * Math.pow(2, this.reconnectAttempts),
      6e4
    );
    this.reconnectAttempts++;
    log.info(
      "AlpacaStream",
      `Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`
    );
    setTimeout(() => {
      this.connect();
    }, delay);
  }
  disconnect() {
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isAuthenticated = false;
    this.isConnecting = false;
    log.info("AlpacaStream", "Disconnected from Alpaca stream");
  }
  isConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket2.OPEN && this.isAuthenticated;
  }
  getStatus() {
    return {
      connected: this.ws?.readyState === WebSocket2.OPEN,
      authenticated: this.isAuthenticated,
      reconnectAttempts: this.reconnectAttempts
    };
  }
};
var alpacaStream = new AlpacaStreamManager();

// server/autonomous/orchestrator.ts
init_decision_engine();
init_storage();
init_money();

// server/ai/market-condition-analyzer.ts
init_storage();
init_finnhub();
init_coingecko();
init_alpaca();
init_numeric();
init_llmGateway();
init_candidatesService();
init_logger();
var MIN_ORDER_LIMIT = 10;
var MAX_ORDER_LIMIT = 50;
var ANALYSIS_INTERVAL_MS = 5 * 60 * 1e3;
var MarketConditionAnalyzer = class {
  lastAnalysis = null;
  lastAnalysisTime = null;
  isAnalyzing = false;
  analysisTimer = null;
  async initialize() {
    log.info("MarketAnalyzer", "Initializing market condition analyzer...");
    this.runAnalysis().catch((err) => {
      log.error("MarketAnalyzer", "Initial analysis failed", {
        error: err instanceof Error ? err.message : String(err)
      });
    });
    this.startPeriodicAnalysis();
  }
  startPeriodicAnalysis() {
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
    }
    this.analysisTimer = setInterval(() => {
      this.runAnalysis().catch((err) => {
        log.error("MarketAnalyzer", "Periodic analysis error", {
          error: err instanceof Error ? err.message : String(err)
        });
      });
    }, ANALYSIS_INTERVAL_MS);
    log.info("MarketAnalyzer", "Periodic analysis started", {
      intervalSeconds: ANALYSIS_INTERVAL_MS / 1e3
    });
  }
  stop() {
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
      this.analysisTimer = null;
    }
  }
  async runAnalysis() {
    if (this.isAnalyzing) {
      return this.lastAnalysis || this.getDefaultAnalysis();
    }
    this.isAnalyzing = true;
    try {
      log.info("MarketAnalyzer", "Running market condition analysis...");
      const snapshot = await this.fetchMarketSnapshot();
      const analysis = await this.analyzeWithAI(snapshot);
      this.lastAnalysis = analysis;
      this.lastAnalysisTime = /* @__PURE__ */ new Date();
      await this.updateAgentOrderLimit(analysis);
      log.info("MarketAnalyzer", "Analysis complete", {
        condition: analysis.condition,
        orderLimit: analysis.recommendedOrderLimit
      });
      return analysis;
    } catch (error) {
      log.error("MarketAnalyzer", "Analysis failed", {
        error: error instanceof Error ? error.message : String(error)
      });
      return this.lastAnalysis || this.getDefaultAnalysis();
    } finally {
      this.isAnalyzing = false;
    }
  }
  async fetchMarketSnapshot() {
    const snapshot = {
      stocks: /* @__PURE__ */ new Map(),
      crypto: /* @__PURE__ */ new Map(),
      portfolioValue: 0,
      // Will be fetched from Alpaca
      openPositions: 0,
      dailyPnl: 0
    };
    let watchlistStocks = ["SPY", "QQQ", "AAPL", "MSFT", "NVDA"];
    let watchlistCrypto = ["btc", "eth", "sol"];
    try {
      const dynamicWatchlist = await candidatesService.getWatchlistSymbols();
      if (dynamicWatchlist.stocks.length > 0) {
        watchlistStocks = dynamicWatchlist.stocks.slice(0, 15);
      }
      if (dynamicWatchlist.crypto.length > 0) {
        watchlistCrypto = dynamicWatchlist.crypto.map((c) => c.toLowerCase());
      }
    } catch (error) {
      log.warn(
        "MarketAnalyzer",
        "Failed to load watchlist from database, using fallback",
        { error: error instanceof Error ? error.message : String(error) }
      );
    }
    try {
      const stockQuotes = await finnhub.getMultipleQuotes(watchlistStocks);
      for (const [symbol, quote] of stockQuotes.entries()) {
        if (quote.c > 0) {
          snapshot.stocks.set(symbol, {
            price: quote.c,
            change: quote.d,
            changePercent: quote.dp
          });
        }
      }
    } catch (error) {
      log.error("MarketAnalyzer", "Failed to fetch stock data", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
    try {
      const cryptoMarkets = await coingecko.getMarkets();
      const watchedCrypto = cryptoMarkets.filter(
        (c) => watchlistCrypto.includes(c.symbol.toLowerCase())
      );
      for (const coin of watchedCrypto) {
        snapshot.crypto.set(coin.symbol.toUpperCase(), {
          price: coin.current_price,
          change: coin.price_change_24h || 0,
          changePercent: coin.price_change_percentage_24h || 0
        });
      }
    } catch (error) {
      log.error("MarketAnalyzer", "Failed to fetch crypto data", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
    try {
      const account = await alpaca.getAccount();
      snapshot.portfolioValue = safeParseFloat(account.portfolio_value);
      const positions2 = await alpaca.getPositions();
      snapshot.openPositions = positions2.length;
      let totalPnl = 0;
      for (const pos of positions2) {
        totalPnl += safeParseFloat(pos.unrealized_pl);
      }
      snapshot.dailyPnl = totalPnl;
    } catch (error) {
      log.error("MarketAnalyzer", "Failed to fetch portfolio data", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
    return snapshot;
  }
  async analyzeWithAI(snapshot) {
    const stockSummary = Array.from(snapshot.stocks.entries()).map(
      ([symbol, data]) => `${symbol}: $${data.price.toFixed(2)} (${data.changePercent >= 0 ? "+" : ""}${data.changePercent.toFixed(2)}%)`
    ).join(", ");
    const cryptoSummary = Array.from(snapshot.crypto.entries()).map(
      ([symbol, data]) => `${symbol}: $${data.price.toFixed(2)} (${data.changePercent >= 0 ? "+" : ""}${data.changePercent.toFixed(2)}%)`
    ).join(", ");
    const avgStockChange = this.calculateAverageChange(snapshot.stocks);
    const avgCryptoChange = this.calculateAverageChange(snapshot.crypto);
    const volatility = this.calculateVolatility(
      snapshot.stocks,
      snapshot.crypto
    );
    const prompt = `You are an expert market analyst AI. Analyze the following market snapshot and determine the optimal trading aggressiveness.

CURRENT MARKET DATA:
Stocks: ${stockSummary || "No data"}
Crypto: ${cryptoSummary || "No data"}

MARKET METRICS:
- Average stock change: ${avgStockChange.toFixed(2)}%
- Average crypto change: ${avgCryptoChange.toFixed(2)}%
- Volatility indicator: ${volatility.toFixed(2)}

PORTFOLIO STATUS:
- Portfolio value: $${snapshot.portfolioValue.toFixed(2)}
- Open positions: ${snapshot.openPositions}
- Unrealized P&L: $${snapshot.dailyPnl.toFixed(2)}

TASK:
Determine the optimal number of active orders (between ${MIN_ORDER_LIMIT} and ${MAX_ORDER_LIMIT}) based on:
1. Market conditions - bullish markets allow more orders, bearish markets require caution
2. Volatility - high volatility means higher risk, reduce orders
3. Portfolio health - significant losses mean reduce exposure
4. Opportunity assessment - more opportunities = more orders

RESPOND WITH VALID JSON ONLY:
{
  "condition": "bullish" | "bearish" | "neutral" | "volatile" | "uncertain",
  "confidenceScore": 0.0-1.0,
  "recommendedOrderLimit": ${MIN_ORDER_LIMIT}-${MAX_ORDER_LIMIT},
  "reasoning": "brief explanation",
  "riskLevel": "low" | "medium" | "high",
  "marketIndicators": {
    "overallTrend": "up/down/sideways",
    "volatilityLevel": "low/medium/high",
    "sentimentScore": -1.0 to 1.0,
    "majorMovers": ["symbol1", "symbol2"]
  }
}`;
    try {
      const response = await callLLM({
        role: "risk_manager",
        criticality: "medium",
        purpose: "market_condition_analysis",
        traceId: generateTraceId(),
        system: "You are a market analyst AI. Respond only with valid JSON. No markdown, no explanations outside the JSON.",
        messages: [{ role: "user", content: prompt }],
        responseFormat: { type: "json_object" },
        temperature: 0.3,
        maxTokens: 500
      });
      const content = response.text;
      if (!content) {
        throw new Error("Empty AI response");
      }
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("No JSON found in response");
      }
      const parsed = JSON.parse(jsonMatch[0]);
      parsed.recommendedOrderLimit = Math.max(
        MIN_ORDER_LIMIT,
        Math.min(MAX_ORDER_LIMIT, parsed.recommendedOrderLimit)
      );
      return parsed;
    } catch (error) {
      log.error("MarketAnalyzer", "AI analysis failed", {
        error: error instanceof Error ? error.message : String(error)
      });
      return this.calculateFallbackAnalysis(
        snapshot,
        avgStockChange,
        avgCryptoChange,
        volatility
      );
    }
  }
  calculateAverageChange(data) {
    if (data.size === 0) return 0;
    let total = 0;
    for (const item of data.values()) {
      total += item.changePercent;
    }
    return total / data.size;
  }
  calculateVolatility(stocks, crypto5) {
    const allChanges = [];
    for (const item of stocks.values()) {
      allChanges.push(Math.abs(item.changePercent));
    }
    for (const item of crypto5.values()) {
      allChanges.push(Math.abs(item.changePercent));
    }
    if (allChanges.length === 0) return 0;
    const avg = allChanges.reduce((a, b) => a + b, 0) / allChanges.length;
    const variance4 = allChanges.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / allChanges.length;
    return Math.sqrt(variance4);
  }
  calculateFallbackAnalysis(snapshot, avgStockChange, avgCryptoChange, volatility) {
    const overallChange = (avgStockChange + avgCryptoChange) / 2;
    let condition = "neutral";
    let riskLevel = "medium";
    let recommendedOrderLimit = 20;
    if (volatility > 3) {
      condition = "volatile";
      riskLevel = "high";
      recommendedOrderLimit = MIN_ORDER_LIMIT;
    } else if (overallChange > 1) {
      condition = "bullish";
      riskLevel = "low";
      recommendedOrderLimit = Math.min(MAX_ORDER_LIMIT, 35);
    } else if (overallChange < -1) {
      condition = "bearish";
      riskLevel = "high";
      recommendedOrderLimit = Math.min(15, MIN_ORDER_LIMIT + 5);
    } else {
      condition = "neutral";
      riskLevel = "medium";
      recommendedOrderLimit = 20;
    }
    if (snapshot.dailyPnl < -snapshot.portfolioValue * 0.02) {
      recommendedOrderLimit = Math.max(
        MIN_ORDER_LIMIT,
        recommendedOrderLimit - 10
      );
      riskLevel = "high";
    }
    const majorMovers = this.identifyMajorMovers(snapshot);
    return {
      condition,
      confidenceScore: 0.6,
      recommendedOrderLimit,
      reasoning: `Fallback analysis: ${condition} market with ${volatility.toFixed(1)}% volatility`,
      riskLevel,
      marketIndicators: {
        overallTrend: overallChange > 0.5 ? "up" : overallChange < -0.5 ? "down" : "sideways",
        volatilityLevel: volatility > 3 ? "high" : volatility > 1.5 ? "medium" : "low",
        sentimentScore: Math.max(-1, Math.min(1, overallChange / 5)),
        majorMovers
      }
    };
  }
  identifyMajorMovers(snapshot) {
    const allAssets = [];
    for (const [symbol, data] of snapshot.stocks.entries()) {
      allAssets.push({ symbol, change: Math.abs(data.changePercent) });
    }
    for (const [symbol, data] of snapshot.crypto.entries()) {
      allAssets.push({ symbol, change: Math.abs(data.changePercent) });
    }
    return allAssets.sort((a, b) => b.change - a.change).slice(0, 3).map((a) => a.symbol);
  }
  async updateAgentOrderLimit(analysis) {
    try {
      await storage.updateAgentStatus({
        dynamicOrderLimit: analysis.recommendedOrderLimit,
        marketCondition: analysis.condition,
        aiConfidenceScore: analysis.confidenceScore.toString(),
        lastMarketAnalysis: /* @__PURE__ */ new Date(),
        maxPositionsCount: analysis.recommendedOrderLimit
      });
    } catch (error) {
      log.error("MarketAnalyzer", "Failed to update agent status", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }
  getDefaultAnalysis() {
    return {
      condition: "neutral",
      confidenceScore: 0.5,
      recommendedOrderLimit: 15,
      reasoning: "Default conservative analysis - no market data available",
      riskLevel: "medium",
      marketIndicators: {
        overallTrend: "sideways",
        volatilityLevel: "medium",
        sentimentScore: 0,
        majorMovers: []
      }
    };
  }
  getLastAnalysis() {
    return this.lastAnalysis;
  }
  getLastAnalysisTime() {
    return this.lastAnalysisTime;
  }
  getCurrentOrderLimit() {
    return this.lastAnalysis?.recommendedOrderLimit || 15;
  }
  getStatus() {
    return {
      isRunning: !!this.analysisTimer,
      lastAnalysis: this.lastAnalysis,
      lastAnalysisTime: this.lastAnalysisTime,
      currentOrderLimit: this.getCurrentOrderLimit()
    };
  }
};
var marketConditionAnalyzer = new MarketConditionAnalyzer();

// server/autonomous/orchestrator.ts
init_logger();
init_order_execution_flow();

// server/ai/learning-service.ts
init_db();
init_schema2();
init_logger();
init_money();
import { eq as eq9, desc as desc5, and as and8, gte as gte4, sql as sql22 } from "drizzle-orm";
async function recordDecisionFeatures(decisionId, symbol, features) {
  try {
    const featureVectorJson = JSON.stringify(features);
    await db.insert(aiDecisionFeatures).values({
      decisionId,
      symbol,
      volatility: features.volatility?.toString(),
      trendStrength: features.trendStrength?.toString(),
      signalAgreement: features.signalAgreement?.toString(),
      sentimentScore: features.sentimentScore?.toString(),
      peRatio: features.peRatio?.toString(),
      pbRatio: features.pbRatio?.toString(),
      rsi: features.rsi?.toString(),
      macdSignal: features.macdSignal,
      volumeRatio: features.volumeRatio?.toString(),
      priceChangePercent: features.priceChangePercent?.toString(),
      marketCondition: features.marketCondition,
      dataQuality: features.dataQuality?.toString(),
      activeSources: features.activeSources,
      featureVector: featureVectorJson
    });
    log.debug("AILearning", `Recorded features for decision ${decisionId}`);
  } catch (error) {
    log.error("AILearning", `Failed to record features: ${error}`);
  }
}
async function recordTradeOutcome(input) {
  try {
    await db.insert(aiTradeOutcomes).values({
      decisionId: input.decisionId,
      tradeId: input.tradeId,
      symbol: input.symbol,
      action: input.action,
      predictionConfidence: input.predictionConfidence?.toString(),
      entryPrice: input.entryPrice?.toString(),
      exitPrice: input.exitPrice?.toString(),
      quantity: input.quantity?.toString(),
      realizedPnl: input.realizedPnl?.toString(),
      realizedPnlPercent: input.realizedPnlPercent?.toString(),
      holdingTimeMs: input.holdingTimeMs,
      isWin: input.isWin,
      slippagePercent: input.slippagePercent?.toString(),
      targetPriceHit: input.targetPriceHit,
      stopLossHit: input.stopLossHit,
      maxDrawdown: input.maxDrawdown?.toString(),
      maxGain: input.maxGain?.toString(),
      marketSessionAtEntry: input.marketSessionAtEntry,
      marketSessionAtExit: input.marketSessionAtExit,
      strategyId: input.strategyId,
      exitReason: input.exitReason,
      closedAt: input.exitPrice ? /* @__PURE__ */ new Date() : null
    });
    log.debug(
      "AILearning",
      `Recorded outcome for decision ${input.decisionId}`
    );
  } catch (error) {
    log.error("AILearning", `Failed to record outcome: ${error}`);
  }
}
async function updateTradeOutcomeOnClose(decisionId, exitPrice, exitReason, marketSession) {
  try {
    const existingOutcome = await db.select().from(aiTradeOutcomes).where(eq9(aiTradeOutcomes.decisionId, decisionId)).limit(1);
    if (existingOutcome.length === 0) {
      log.warn(
        "AILearning",
        `No outcome record found for decision ${decisionId}`
      );
      return;
    }
    const outcome = existingOutcome[0];
    const entryPrice = parseFloat(outcome.entryPrice || "0");
    const quantity = parseFloat(outcome.quantity || "0");
    const realizedPnl = calculatePnL(
      entryPrice,
      exitPrice,
      quantity,
      "long"
    ).toNumber();
    const realizedPnlPercent = entryPrice > 0 ? percentChange(exitPrice, entryPrice).toNumber() : 0;
    const isWin = realizedPnl > 0;
    const holdingTimeMs = outcome.createdAt ? Date.now() - outcome.createdAt.getTime() : 0;
    await db.update(aiTradeOutcomes).set({
      exitPrice: exitPrice.toString(),
      realizedPnl: realizedPnl.toString(),
      realizedPnlPercent: realizedPnlPercent.toString(),
      isWin,
      holdingTimeMs,
      exitReason,
      marketSessionAtExit: marketSession,
      closedAt: /* @__PURE__ */ new Date()
    }).where(eq9(aiTradeOutcomes.decisionId, decisionId));
    log.info(
      "AILearning",
      `Updated outcome for ${decisionId}: PnL=$${realizedPnl.toFixed(2)} (${isWin ? "WIN" : "LOSS"})`
    );
  } catch (error) {
    log.error("AILearning", `Failed to update outcome: ${error}`);
  }
}
async function runCalibrationAnalysis(windowDays = 30) {
  try {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - windowDays);
    const outcomes = await db.select().from(aiTradeOutcomes).where(
      and8(
        gte4(aiTradeOutcomes.createdAt, startDate),
        sql22`${aiTradeOutcomes.isWin} IS NOT NULL`
      )
    );
    if (outcomes.length === 0) {
      log.info("AILearning", "No closed trades in window for calibration");
      return;
    }
    const wins = outcomes.filter((o) => o.isWin === true);
    const losses = outcomes.filter((o) => o.isWin === false);
    const avgConfidenceWins = wins.length > 0 ? wins.reduce(
      (sum, o) => sum + parseFloat(o.predictionConfidence || "0"),
      0
    ) / wins.length : 0;
    const avgConfidenceLosses = losses.length > 0 ? losses.reduce(
      (sum, o) => sum + parseFloat(o.predictionConfidence || "0"),
      0
    ) / losses.length : 0;
    const avgHoldingTimeWins = wins.length > 0 ? Math.round(
      wins.reduce((sum, o) => sum + (o.holdingTimeMs || 0), 0) / wins.length
    ) : 0;
    const avgHoldingTimeLosses = losses.length > 0 ? Math.round(
      losses.reduce((sum, o) => sum + (o.holdingTimeMs || 0), 0) / losses.length
    ) : 0;
    const symbolWins = {};
    const symbolLosses = {};
    for (const o of outcomes) {
      if (o.isWin) {
        symbolWins[o.symbol] = (symbolWins[o.symbol] || 0) + 1;
      } else {
        symbolLosses[o.symbol] = (symbolLosses[o.symbol] || 0) + 1;
      }
    }
    const topWinningSymbols = Object.entries(symbolWins).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([s, c]) => `${s}:${c}`).join(",");
    const topLosingSymbols = Object.entries(symbolLosses).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([s, c]) => `${s}:${c}`).join(",");
    const adjustments = [];
    if (avgConfidenceLosses > 0.6) {
      adjustments.push(
        "High confidence losses detected - consider raising confidence threshold"
      );
    }
    if (avgHoldingTimeLosses < avgHoldingTimeWins / 2) {
      adjustments.push("Losses happen quickly - consider tighter stop losses");
    }
    if (losses.length > wins.length * 2) {
      adjustments.push(
        "Low win rate - consider more conservative position sizing"
      );
    }
    await db.insert(aiCalibrationLog).values({
      calibrationType: "periodic",
      dataWindowDays: windowDays,
      totalDecisions: outcomes.length,
      winCount: wins.length,
      lossCount: losses.length,
      avgConfidenceOnWins: avgConfidenceWins.toString(),
      avgConfidenceOnLosses: avgConfidenceLosses.toString(),
      avgHoldingTimeWins,
      avgHoldingTimeLosses,
      topWinningSymbols,
      topLosingSymbols,
      recommendedAdjustments: adjustments.join("; "),
      modelVersion: "v1.0"
    });
    log.info(
      "AILearning",
      `Calibration complete: ${wins.length} wins, ${losses.length} losses, win rate ${(wins.length / outcomes.length * 100).toFixed(1)}%`
    );
  } catch (error) {
    log.error("AILearning", `Calibration analysis failed: ${error}`);
  }
}

// server/autonomous/orchestrator.ts
init_candidatesService();
init_alpaca_trading_engine();
init_trading_session_manager();

// server/autonomous/strategy-execution-context.ts
init_logger();
var DEFAULT_ENTRY_RULES = {
  minConfidence: 0.7,
  maxPositions: 10,
  excludeSymbols: [],
  includeSymbols: []
};
var DEFAULT_POSITION_SIZING = {
  type: "percent",
  value: 5,
  // 5% of portfolio
  maxNotional: 5e4,
  minNotional: 100
};
var DEFAULT_BRACKET_ORDERS = {
  enabled: false,
  takeProfitPercent: 10,
  stopLossPercent: 5,
  useTrailingStop: false
};
var DEFAULT_ORDER_EXECUTION = {
  timeInForce: "day",
  orderType: "market",
  limitOffsetPercent: 0.1,
  extendedHours: false
};
var DEFAULT_EXIT_RULES = {
  maxHoldingPeriodHours: void 0,
  profitTargetPercent: void 0,
  lossLimitPercent: void 0
};
function parseStrategyParams(config2) {
  if (!config2) {
    return {
      entryRules: DEFAULT_ENTRY_RULES,
      positionSizing: DEFAULT_POSITION_SIZING,
      bracketOrders: DEFAULT_BRACKET_ORDERS,
      orderExecution: DEFAULT_ORDER_EXECUTION,
      exitRules: DEFAULT_EXIT_RULES
    };
  }
  return {
    entryRules: {
      minConfidence: config2.entryRules?.minConfidence ?? DEFAULT_ENTRY_RULES.minConfidence,
      maxPositions: config2.entryRules?.maxPositions ?? DEFAULT_ENTRY_RULES.maxPositions,
      excludeSymbols: config2.entryRules?.excludeSymbols ?? DEFAULT_ENTRY_RULES.excludeSymbols,
      includeSymbols: config2.entryRules?.includeSymbols ?? DEFAULT_ENTRY_RULES.includeSymbols
    },
    positionSizing: {
      type: config2.positionSizing?.type ?? DEFAULT_POSITION_SIZING.type,
      value: config2.positionSizing?.value ?? DEFAULT_POSITION_SIZING.value,
      maxNotional: config2.positionSizing?.maxNotional ?? DEFAULT_POSITION_SIZING.maxNotional,
      minNotional: config2.positionSizing?.minNotional ?? DEFAULT_POSITION_SIZING.minNotional
    },
    bracketOrders: {
      enabled: config2.bracketOrders?.enabled ?? DEFAULT_BRACKET_ORDERS.enabled,
      takeProfitPercent: config2.bracketOrders?.takeProfitPercent ?? DEFAULT_BRACKET_ORDERS.takeProfitPercent,
      stopLossPercent: config2.bracketOrders?.stopLossPercent ?? DEFAULT_BRACKET_ORDERS.stopLossPercent,
      trailingStopPercent: config2.bracketOrders?.trailingStopPercent,
      useTrailingStop: config2.bracketOrders?.useTrailingStop ?? DEFAULT_BRACKET_ORDERS.useTrailingStop
    },
    orderExecution: {
      timeInForce: config2.orderExecution?.timeInForce ?? DEFAULT_ORDER_EXECUTION.timeInForce,
      orderType: config2.orderExecution?.orderType ?? DEFAULT_ORDER_EXECUTION.orderType,
      limitOffsetPercent: config2.orderExecution?.limitOffsetPercent ?? DEFAULT_ORDER_EXECUTION.limitOffsetPercent,
      extendedHours: config2.orderExecution?.extendedHours ?? DEFAULT_ORDER_EXECUTION.extendedHours
    },
    exitRules: {
      maxHoldingPeriodHours: config2.exitRules?.maxHoldingPeriodHours,
      profitTargetPercent: config2.exitRules?.profitTargetPercent,
      lossLimitPercent: config2.exitRules?.lossLimitPercent
    }
  };
}
function parseStrategyContext(strategy) {
  const config2 = strategy.config;
  return {
    strategyId: strategy.id,
    strategyName: strategy.name,
    strategyType: strategy.type,
    mode: strategy.mode || null,
    params: parseStrategyParams(config2)
  };
}
function validateDecision(decision, context, currentPositionCount) {
  const warnings = [];
  const rules = context.params.entryRules;
  if (rules.excludeSymbols.length > 0 && rules.excludeSymbols.includes(decision.symbol)) {
    return {
      valid: false,
      reason: `Symbol ${decision.symbol} is in the exclude list`
    };
  }
  if (rules.includeSymbols.length > 0 && !rules.includeSymbols.includes(decision.symbol)) {
    return {
      valid: false,
      reason: `Symbol ${decision.symbol} is not in the include list`
    };
  }
  if (decision.action === "buy" && currentPositionCount >= rules.maxPositions) {
    return {
      valid: false,
      reason: `Maximum positions (${rules.maxPositions}) reached`
    };
  }
  if (decision.confidence < rules.minConfidence) {
    return {
      valid: false,
      reason: `Confidence ${(decision.confidence * 100).toFixed(1)}% is below minimum ${(rules.minConfidence * 100).toFixed(1)}%`
    };
  }
  if (decision.confidence < rules.minConfidence + 0.1) {
    warnings.push(`Confidence is just above minimum threshold`);
  }
  if (decision.action === "buy" && currentPositionCount >= rules.maxPositions - 2) {
    warnings.push(
      `Approaching maximum positions (${currentPositionCount}/${rules.maxPositions})`
    );
  }
  return {
    valid: true,
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function calculatePositionSize(context, portfolioValue, currentPrice) {
  const sizing = context.params.positionSizing;
  const warnings = [];
  let notional;
  switch (sizing.type) {
    case "percent":
      notional = portfolioValue * (sizing.value / 100);
      break;
    case "fixed":
      notional = sizing.value;
      break;
    case "risk_based":
      const riskAmount = portfolioValue * (sizing.value / 100);
      const assumedStopLossPct = context.params.bracketOrders.stopLossPercent / 100;
      notional = riskAmount / assumedStopLossPct;
      break;
    default:
      notional = portfolioValue * 0.05;
  }
  if (notional > sizing.maxNotional) {
    warnings.push(`Position capped at max notional $${sizing.maxNotional}`);
    notional = sizing.maxNotional;
  }
  if (notional < sizing.minNotional) {
    warnings.push(`Position below min notional $${sizing.minNotional}`);
    notional = sizing.minNotional;
  }
  const quantity = Math.floor(notional / currentPrice);
  if (quantity < 1) {
    return {
      notional: 0,
      quantity: 0,
      warnings: [`Cannot afford 1 share at $${currentPrice.toFixed(2)}`]
    };
  }
  const actualNotional = quantity * currentPrice;
  return {
    notional: actualNotional,
    quantity,
    warnings: warnings.length > 0 ? warnings : void 0
  };
}
function calculateBracketOrderParams(context, entryPrice, side) {
  const bracket = context.params.bracketOrders;
  if (!bracket.enabled) {
    return null;
  }
  let takeProfitPrice;
  let stopLossPrice;
  if (side === "buy") {
    takeProfitPrice = entryPrice * (1 + bracket.takeProfitPercent / 100);
    stopLossPrice = entryPrice * (1 - bracket.stopLossPercent / 100);
  } else {
    takeProfitPrice = entryPrice * (1 - bracket.takeProfitPercent / 100);
    stopLossPrice = entryPrice * (1 + bracket.stopLossPercent / 100);
  }
  return {
    takeProfitPrice: Math.round(takeProfitPrice * 100) / 100,
    stopLossPrice: Math.round(stopLossPrice * 100) / 100,
    trailingStopPercent: bracket.useTrailingStop ? bracket.trailingStopPercent : void 0
  };
}
function getTimeInForce(context) {
  return context.params.orderExecution.timeInForce;
}
function getOrderType(context) {
  return context.params.orderExecution.orderType;
}
function calculateLimitPrice(context, currentPrice, side) {
  const offsetPct = context.params.orderExecution.limitOffsetPercent / 100;
  if (side === "buy") {
    return Math.round(currentPrice * (1 + offsetPct) * 100) / 100;
  } else {
    return Math.round(currentPrice * (1 - offsetPct) * 100) / 100;
  }
}
function logExecutionContext(context) {
  log.debug("ExecutionContext", "Strategy execution context", {
    strategyId: context.strategyId,
    strategyName: context.strategyName,
    mode: context.mode,
    entryRules: {
      minConfidence: context.params.entryRules.minConfidence,
      maxPositions: context.params.entryRules.maxPositions,
      excludeCount: context.params.entryRules.excludeSymbols.length,
      includeCount: context.params.entryRules.includeSymbols.length
    },
    positionSizing: context.params.positionSizing,
    bracketOrders: {
      enabled: context.params.bracketOrders.enabled,
      takeProfit: context.params.bracketOrders.takeProfitPercent,
      stopLoss: context.params.bracketOrders.stopLossPercent
    },
    orderExecution: context.params.orderExecution
  });
}

// server/autonomous/types.ts
init_trading_config();
var DEFAULT_HARD_STOP_LOSS_PERCENT = tradingConfig.riskManagement.defaultHardStopLossPercent;
var DEFAULT_TAKE_PROFIT_PERCENT = tradingConfig.riskManagement.defaultTakeProfitPercent;
var MAX_STOCK_SYMBOLS_PER_CYCLE = tradingConfig.universe.maxStockSymbolsPerCycle;
var MAX_CRYPTO_SYMBOLS_PER_CYCLE = tradingConfig.universe.maxCryptoSymbolsPerCycle;
var ALPACA_SNAPSHOT_CHUNK_SIZE = tradingConfig.universe.alpacaSnapshotChunkSize;
var MIN_CONFIDENCE_FOR_UNIVERSE = tradingConfig.universe.minConfidenceForUniverse;
var DEFAULT_CONFIG = {
  analysisIntervalMs: 6e4,
  positionCheckIntervalMs: 3e4,
  enabled: true
};
var DEFAULT_RISK_LIMITS = {
  maxPositionSizePercent: tradingConfig.riskManagement.defaultMaxPositionSizePercent,
  maxTotalExposurePercent: tradingConfig.riskManagement.defaultMaxExposurePercent,
  maxPositionsCount: 100,
  // AGGRESSIVE: Increased from 10 to enterprise-level 100 positions
  dailyLossLimitPercent: 5,
  // Keep same for safety
  killSwitchActive: false
};

// server/autonomous/watchlist-cache.ts
init_candidatesService();
init_logger();
var FALLBACK_WATCHLIST = {
  stocks: [
    "SPY",
    "QQQ",
    "AAPL",
    "MSFT",
    "GOOGL",
    "AMZN",
    "NVDA",
    "META",
    "TSLA",
    "JPM"
  ],
  crypto: ["BTC", "ETH", "SOL"]
};
var cachedWatchlist = null;
var watchlistCacheTime = 0;
var WATCHLIST_CACHE_TTL_MS = 5 * 60 * 1e3;
async function getWatchlist() {
  const now = Date.now();
  if (cachedWatchlist && now - watchlistCacheTime < WATCHLIST_CACHE_TTL_MS) {
    return cachedWatchlist;
  }
  try {
    const dynamicWatchlist = await candidatesService.getWatchlistSymbols();
    if (dynamicWatchlist.stocks.length > 0 || dynamicWatchlist.crypto.length > 0) {
      cachedWatchlist = dynamicWatchlist;
      watchlistCacheTime = now;
      log.info(
        "WatchlistCache",
        `Loaded ${dynamicWatchlist.stocks.length} stocks and ${dynamicWatchlist.crypto.length} crypto from database`
      );
      return dynamicWatchlist;
    }
  } catch (error) {
    log.warn(
      "WatchlistCache",
      "Failed to load watchlist from database, using fallback",
      { error: String(error) }
    );
  }
  cachedWatchlist = FALLBACK_WATCHLIST;
  watchlistCacheTime = now;
  return FALLBACK_WATCHLIST;
}

// server/autonomous/universe-builder.ts
init_storage();
init_candidatesService();
init_logger();

// server/trading/crypto-trading-config.ts
var SUPPORTED_CRYPTO = [
  // Major cryptocurrencies (large cap, high liquidity)
  "BTC/USD",
  "ETH/USD",
  "SOL/USD",
  // DeFi tokens (decentralized finance)
  "AVAX/USD",
  "LINK/USD",
  "UNI/USD",
  "AAVE/USD",
  "MKR/USD",
  // Layer 2 scaling solutions
  "MATIC/USD",
  "ARB/USD",
  "OP/USD",
  // Meme coins (high volatility, speculative)
  "DOGE/USD",
  "SHIB/USD",
  // Other established cryptocurrencies
  "DOT/USD",
  "ATOM/USD",
  "LTC/USD",
  "BCH/USD",
  "XLM/USD"
];
var STABLECOINS = [
  "USDC/USD",
  "USDT/USD",
  "DAI/USD",
  "BUSD/USD",
  "USDD/USD"
];
function isCryptoSymbol2(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (SUPPORTED_CRYPTO.includes(upperSymbol)) {
    return true;
  }
  if (STABLECOINS.includes(upperSymbol)) {
    return true;
  }
  const hasSlash = upperSymbol.includes("/");
  const endsWithUSD = upperSymbol.endsWith("USD");
  if (hasSlash && endsWithUSD) {
    return true;
  }
  if (!hasSlash && endsWithUSD && upperSymbol.length >= 6) {
    return true;
  }
  return false;
}
function normalizeCryptoSymbol3(symbol) {
  const upperSymbol = symbol.toUpperCase();
  if (upperSymbol.includes("/")) {
    return upperSymbol;
  }
  const knownConversions = {
    BTCUSD: "BTC/USD",
    ETHUSD: "ETH/USD",
    SOLUSD: "SOL/USD",
    AVAXUSD: "AVAX/USD",
    LINKUSD: "LINK/USD",
    UNIUSD: "UNI/USD",
    AAVEUSD: "AAVE/USD",
    MKRUSD: "MKR/USD",
    MATICUSD: "MATIC/USD",
    ARBUSD: "ARB/USD",
    OPUSD: "OP/USD",
    DOGEUSD: "DOGE/USD",
    SHIBUSD: "SHIB/USD",
    DOTUSD: "DOT/USD",
    ATOMUSD: "ATOM/USD",
    LTCUSD: "LTC/USD",
    BCHUSD: "BCH/USD",
    XLMUSD: "XLM/USD",
    USDCUSD: "USDC/USD",
    USDTUSD: "USDT/USD",
    DAIUSD: "DAI/USD"
  };
  if (knownConversions[upperSymbol]) {
    return knownConversions[upperSymbol];
  }
  if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
    const base = upperSymbol.slice(0, -3);
    return `${base}/USD`;
  }
  return upperSymbol;
}

// server/autonomous/universe-builder.ts
init_trading_config();
var MAX_STOCK_SYMBOLS_PER_CYCLE2 = tradingConfig.universe.maxStockSymbolsPerCycle;
var MAX_CRYPTO_SYMBOLS_PER_CYCLE2 = tradingConfig.universe.maxCryptoSymbolsPerCycle;
var RECENT_DECISIONS_LOOKBACK = 500;
var MIN_CONFIDENCE_FOR_UNIVERSE2 = tradingConfig.universe.minConfidenceForUniverse;
var universeRotationState = {
  stockRotationOffset: 0,
  cryptoRotationOffset: 0,
  lastRotationTime: /* @__PURE__ */ new Date()
};
async function getAnalysisUniverseSymbols() {
  const sources = {
    watchlist: 0,
    candidates: 0,
    recentDecisions: 0,
    executedTrades: 0
  };
  const watchlist = await getWatchlist();
  const stockSet = new Set(
    watchlist.stocks.map((s) => s.toUpperCase())
  );
  const cryptoSet = new Set(
    watchlist.crypto.map((c) => c.toUpperCase())
  );
  sources.watchlist = stockSet.size + cryptoSet.size;
  try {
    const approvedSymbols = await candidatesService.getApprovedSymbols();
    for (const symbol of approvedSymbols) {
      const upper = symbol.toUpperCase();
      if (isCryptoSymbol2(upper)) {
        cryptoSet.add(upper.replace("/USD", ""));
      } else {
        stockSet.add(upper);
      }
    }
    sources.candidates = approvedSymbols.length;
  } catch (error) {
    log.warn("UniverseBuilder", "Failed to get approved candidates", {
      error: String(error)
    });
  }
  try {
    const recentDecisions = await storage.getAiDecisions(
      void 0,
      RECENT_DECISIONS_LOOKBACK
    );
    const highConfDecisions = recentDecisions.filter((d) => {
      const confidence = parseFloat(d.confidence || "0");
      return confidence >= MIN_CONFIDENCE_FOR_UNIVERSE2 && d.action !== "hold";
    });
    for (const decision of highConfDecisions) {
      const upper = decision.symbol.toUpperCase();
      if (isCryptoSymbol2(upper)) {
        cryptoSet.add(upper.replace("/USD", ""));
      } else {
        stockSet.add(upper);
      }
      if (decision.executedTradeId) {
        sources.executedTrades++;
      }
    }
    sources.recentDecisions = highConfDecisions.length;
  } catch (error) {
    log.warn(
      "UniverseBuilder",
      "Failed to get recent AI decisions for universe",
      { error: String(error) }
    );
  }
  let stocks = Array.from(stockSet);
  let crypto5 = Array.from(cryptoSet);
  if (stocks.length > MAX_STOCK_SYMBOLS_PER_CYCLE2) {
    const now = Date.now();
    const hoursSinceLastRotation = (now - universeRotationState.lastRotationTime.getTime()) / (1e3 * 60 * 60);
    if (hoursSinceLastRotation >= 1) {
      universeRotationState.stockRotationOffset = (universeRotationState.stockRotationOffset + MAX_STOCK_SYMBOLS_PER_CYCLE2 / 2) % stocks.length;
      universeRotationState.lastRotationTime = /* @__PURE__ */ new Date();
    }
    const offset = universeRotationState.stockRotationOffset;
    const rotated = [...stocks.slice(offset), ...stocks.slice(0, offset)];
    stocks = rotated.slice(0, MAX_STOCK_SYMBOLS_PER_CYCLE2);
  }
  if (crypto5.length > MAX_CRYPTO_SYMBOLS_PER_CYCLE2) {
    const offset = universeRotationState.cryptoRotationOffset;
    const rotated = [...crypto5.slice(offset), ...crypto5.slice(0, offset)];
    crypto5 = rotated.slice(0, MAX_CRYPTO_SYMBOLS_PER_CYCLE2);
  }
  log.info(
    "UniverseBuilder",
    `Universe built: ${stocks.length} stocks, ${crypto5.length} crypto`,
    {
      sources,
      totalStockPool: stockSet.size,
      totalCryptoPool: cryptoSet.size
    }
  );
  return { stocks, crypto: crypto5, sources };
}

// server/autonomous/market-data-fetcher.ts
init_alpaca();
init_finnhub();
init_coingecko();
init_logger();
init_trading_config();
var ALPACA_SNAPSHOT_CHUNK_SIZE2 = tradingConfig.universe.alpacaSnapshotChunkSize;
async function fetchMarketData(universe) {
  const marketData = /* @__PURE__ */ new Map();
  try {
    const fetchedFromAlpaca = /* @__PURE__ */ new Set();
    for (let i = 0; i < universe.stocks.length; i += ALPACA_SNAPSHOT_CHUNK_SIZE2) {
      const chunk = universe.stocks.slice(i, i + ALPACA_SNAPSHOT_CHUNK_SIZE2);
      try {
        const snapshots = await alpaca.getSnapshots(chunk);
        for (const [symbol, snapshot] of Object.entries(snapshots)) {
          if (snapshot?.latestTrade?.p || snapshot?.dailyBar?.c) {
            const price = snapshot.latestTrade?.p || snapshot.dailyBar?.c || 0;
            const prevClose = snapshot.prevDailyBar?.c || price;
            const change = price - prevClose;
            const changePercent = prevClose > 0 ? change / prevClose * 100 : 0;
            marketData.set(symbol, {
              symbol,
              currentPrice: price,
              priceChange24h: change,
              priceChangePercent24h: changePercent,
              high24h: snapshot.dailyBar?.h,
              low24h: snapshot.dailyBar?.l,
              volume: snapshot.dailyBar?.v
            });
            fetchedFromAlpaca.add(symbol);
          }
        }
      } catch (chunkError) {
        log.warn(
          "MarketDataFetcher",
          `Alpaca snapshot chunk failed, will use Finnhub fallback`,
          {
            chunkStart: i,
            error: String(chunkError)
          }
        );
      }
    }
    const missingSymbols = universe.stocks.filter(
      (s) => !fetchedFromAlpaca.has(s)
    );
    if (missingSymbols.length > 0 && missingSymbols.length <= 30) {
      try {
        const finnhubPrices = await finnhub.getMultipleQuotes(missingSymbols);
        for (const [symbol, quote] of finnhubPrices.entries()) {
          if (quote.c > 0) {
            marketData.set(symbol, {
              symbol,
              currentPrice: quote.c,
              priceChange24h: quote.d,
              priceChangePercent24h: quote.dp,
              high24h: quote.h,
              low24h: quote.l
            });
          }
        }
        log.info(
          "MarketDataFetcher",
          `Finnhub fallback fetched ${finnhubPrices.size}/${missingSymbols.length} symbols`
        );
      } catch (finnhubError) {
        log.warn("MarketDataFetcher", `Finnhub fallback also failed`, {
          error: String(finnhubError)
        });
      }
    }
    log.info(
      "MarketDataFetcher",
      `Stock data fetched: ${marketData.size}/${universe.stocks.length} symbols via Alpaca+Finnhub`
    );
  } catch (error) {
    log.error("MarketDataFetcher", "Failed to fetch stock data", {
      error: String(error)
    });
  }
  try {
    const cryptoSymbols = universe.crypto.map((c) => normalizeCryptoSymbol3(c));
    if (cryptoSymbols.length > 0) {
      try {
        const cryptoSnapshots = await alpaca.getCryptoSnapshots(cryptoSymbols);
        for (const [symbol, snapshot] of Object.entries(cryptoSnapshots)) {
          if (snapshot?.latestTrade?.p) {
            const price = snapshot.latestTrade.p;
            const prevClose = snapshot.prevDailyBar?.c || price;
            const change = price - prevClose;
            const changePercent = prevClose > 0 ? change / prevClose * 100 : 0;
            const bareSymbol = symbol.replace("/USD", "").toUpperCase();
            marketData.set(bareSymbol, {
              symbol: bareSymbol,
              currentPrice: price,
              priceChange24h: change,
              priceChangePercent24h: changePercent,
              high24h: snapshot.dailyBar?.h,
              low24h: snapshot.dailyBar?.l,
              volume: snapshot.dailyBar?.v
            });
          }
        }
        log.info(
          "MarketDataFetcher",
          `Crypto data fetched via Alpaca: ${Object.keys(cryptoSnapshots).length} symbols`
        );
      } catch (alpacaCryptoError) {
        log.warn(
          "MarketDataFetcher",
          "Alpaca crypto failed, falling back to CoinGecko",
          { error: String(alpacaCryptoError) }
        );
        const cryptoPrices = await coingecko.getMarkets();
        const watchedCrypto = cryptoPrices.filter(
          (c) => universe.crypto.includes(c.symbol.toUpperCase())
        );
        for (const price of watchedCrypto) {
          marketData.set(price.symbol.toUpperCase(), {
            symbol: price.symbol.toUpperCase(),
            currentPrice: price.current_price,
            priceChange24h: price.price_change_24h || 0,
            priceChangePercent24h: price.price_change_percentage_24h || 0,
            high24h: price.high_24h,
            low24h: price.low_24h,
            volume: price.total_volume,
            marketCap: price.market_cap
          });
        }
      }
    }
  } catch (error) {
    log.error("MarketDataFetcher", "Failed to fetch crypto data", {
      error: String(error)
    });
  }
  return marketData;
}

// server/autonomous/position-sync.ts
init_alpaca();
init_storage();
init_logger();
init_numeric();
init_money();
async function syncPositionsFromBroker(state, userId) {
  try {
    const positions2 = await alpaca.getPositions();
    const existingPositions = new Map(state.activePositions);
    state.activePositions.clear();
    try {
      if (userId) {
        await storage.syncPositionsFromAlpaca(userId, positions2);
        log.info(
          "PositionSync",
          `Synced ${positions2.length} positions to database`
        );
      }
    } catch (dbError) {
      log.error("PositionSync", "Failed to sync positions to database", {
        error: String(dbError)
      });
    }
    for (const pos of positions2) {
      const entryPrice = safeParseFloat(pos.avg_entry_price);
      const currentPrice = safeParseFloat(pos.current_price);
      const existingPos = existingPositions.get(pos.symbol);
      let stopLossPrice = existingPos?.stopLossPrice;
      let takeProfitPrice = existingPos?.takeProfitPrice;
      const trailingStopPercent = existingPos?.trailingStopPercent;
      const hardStopLoss = entryPrice * (1 - DEFAULT_HARD_STOP_LOSS_PERCENT / 100);
      const defaultTakeProfit = entryPrice * (1 + DEFAULT_TAKE_PROFIT_PERCENT / 100);
      if (!stopLossPrice && entryPrice > 0) {
        stopLossPrice = hardStopLoss;
      }
      if (!takeProfitPrice && entryPrice > 0) {
        takeProfitPrice = defaultTakeProfit;
      }
      if (stopLossPrice && stopLossPrice < hardStopLoss && entryPrice > 0) {
        log.info(
          "PositionSync",
          `Enforcing hard stop-loss for ${pos.symbol}: $${stopLossPrice.toFixed(2)} -> $${hardStopLoss.toFixed(2)}`
        );
        stopLossPrice = hardStopLoss;
      }
      if (existingPos?.trailingStopPercent && currentPrice > entryPrice) {
        const profitPercent = percentChange(
          currentPrice,
          entryPrice
        ).toNumber();
        if (profitPercent > 5) {
          const newStopLoss = trailingStopPrice(
            currentPrice,
            existingPos.trailingStopPercent
          ).toNumber();
          if (!stopLossPrice || newStopLoss > stopLossPrice) {
            stopLossPrice = newStopLoss;
            log.info(
              "PositionSync",
              `Trailing stop updated for ${pos.symbol}: $${stopLossPrice.toFixed(2)}`
            );
          }
        }
      }
      const totalQty = safeParseFloat(pos.qty);
      const availableQty = safeParseFloat(pos.qty_available);
      const positionWithRules = {
        symbol: pos.symbol,
        quantity: totalQty,
        availableQuantity: availableQty,
        entryPrice,
        currentPrice,
        unrealizedPnl: safeParseFloat(pos.unrealized_pl),
        unrealizedPnlPercent: safeParseFloat(pos.unrealized_plpc) * 100,
        openedAt: existingPos?.openedAt || /* @__PURE__ */ new Date(),
        stopLossPrice,
        takeProfitPrice,
        trailingStopPercent,
        strategyId: existingPos?.strategyId
      };
      state.activePositions.set(pos.symbol, positionWithRules);
    }
    log.info(
      "PositionSync",
      `Synced ${positions2.length} positions from broker`
    );
  } catch (error) {
    log.error("PositionSync", "Failed to sync positions", {
      error: String(error)
    });
    state.errors.push(`Position sync failed: ${error}`);
  }
}

// server/autonomous/lifecycle-manager.ts
init_storage();
init_logger();
var HEARTBEAT_INTERVAL_MS = 3e4;
var STALE_HEARTBEAT_THRESHOLD_MS = 12e4;
var AUTO_RESTART_DELAY_MS = 5e3;
var MAX_CONSECUTIVE_ERRORS = 5;
var LifecycleManager = class {
  orchestrator;
  heartbeatTimer = null;
  consecutiveErrors = 0;
  lastHeartbeat = null;
  autoStartEnabled = true;
  isAutoStarting = false;
  constructor(orchestrator2) {
    this.orchestrator = orchestrator2;
  }
  /**
   * Auto-initialization with dependency resolution
   *
   * Performs a complete initialization sequence including dependency resolution,
   * setting validation, and orchestrator startup. This is the primary entry point
   * for starting the autonomous trading system.
   *
   * @async
   * @returns {Promise<void>}
   *
   * @throws {Error} If critical initialization steps fail (re-throws after logging)
   *
   * @process
   * 1. Check if auto-start is already in progress (prevents concurrent starts)
   * 2. Resolve admin user from database for permissions
   * 3. Check agent status settings (autoStartEnabled, killSwitchActive)
   * 4. Initialize market condition analyzer
   * 5. Start orchestrator main loop
   * 6. Start heartbeat monitoring
   * 7. On failure: Schedule retry after 5 seconds
   *
   * @example
   * ```typescript
   * const lifecycleManager = new LifecycleManager(orchestrator);
   * await lifecycleManager.autoStart();
   * // Orchestrator is now running with health monitoring active
   * ```
   */
  async autoStart() {
    if (this.isAutoStarting) {
      log.info("LifecycleManager", "Auto-start already in progress");
      return;
    }
    this.isAutoStarting = true;
    try {
      log.info("LifecycleManager", "Auto-start initializing...");
      const adminUser = await storage.getAdminUser();
      if (adminUser) {
        this.orchestrator.setUserId(adminUser.id);
        log.info("LifecycleManager", `Resolved admin user: ${adminUser.id}`);
      } else {
        log.warn(
          "LifecycleManager",
          "No admin user found - database operations may fail"
        );
      }
      const agentStatus2 = await storage.getAgentStatus();
      this.autoStartEnabled = agentStatus2?.autoStartEnabled ?? true;
      if (!this.autoStartEnabled) {
        log.info("LifecycleManager", "Auto-start is disabled in settings");
        this.isAutoStarting = false;
        return;
      }
      if (agentStatus2?.killSwitchActive) {
        log.warn(
          "LifecycleManager",
          "Auto-start blocked: Kill switch is active"
        );
        this.isAutoStarting = false;
        return;
      }
      await marketConditionAnalyzer.initialize();
      await this.orchestrator.start();
      this.startHeartbeat();
      log.info(
        "LifecycleManager",
        "Auto-start complete - Agent is now running persistently"
      );
    } catch (error) {
      log.error("LifecycleManager", "Auto-start failed", {
        error: String(error)
      });
      const state = this.orchestrator.getState();
      state.errors.push(`Auto-start failed: ${error}`);
      setTimeout(() => {
        this.isAutoStarting = false;
        this.autoStart().catch((err) => {
          log.error("LifecycleManager", "Auto-restart retry failed", {
            error: String(err)
          });
        });
      }, AUTO_RESTART_DELAY_MS);
    } finally {
      this.isAutoStarting = false;
    }
  }
  /**
   * Begin health monitoring loop
   *
   * Starts a periodic heartbeat that runs every 30 seconds to monitor orchestrator
   * health, detect stale state, and track error accumulation.
   *
   * @returns {void}
   *
   * @heartbeat-cycle
   * - Updates last heartbeat timestamp
   * - Persists heartbeat to database (agent_status table)
   * - Checks for stale state (no analysis in 120+ seconds)
   * - Decrements consecutive error count on success
   * - Increments error count on failure
   * - Triggers self-healing if errors reach threshold (5)
   *
   * @example
   * ```typescript
   * lifecycleManager.startHeartbeat();
   * // Heartbeat now runs every 30 seconds
   * ```
   */
  startHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
    this.lastHeartbeat = /* @__PURE__ */ new Date();
    this.heartbeatTimer = setInterval(async () => {
      await this.performHeartbeat();
    }, HEARTBEAT_INTERVAL_MS);
    log.info("LifecycleManager", "Heartbeat started");
  }
  /**
   * Stop health monitoring
   *
   * Clears the heartbeat timer to stop health monitoring. Called when the
   * orchestrator is being shut down or when resetting health monitoring.
   *
   * @returns {void}
   *
   * @example
   * ```typescript
   * lifecycleManager.stopHeartbeat();
   * // Heartbeat monitoring is now stopped
   * ```
   */
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  /**
   * Periodic health check & error tracking
   *
   * Core heartbeat logic that runs every 30 seconds to monitor orchestrator health.
   * This is the internal implementation called by the heartbeat timer.
   *
   * @async
   * @returns {Promise<void>}
   *
   * @process
   * 1. Update last heartbeat timestamp
   * 2. Persist heartbeat to database
   * 3. Check for stale state
   * 4. Decrement error count on success
   * 5. Increment error count on failure
   * 6. Trigger self-healing if errors >= 5
   *
   * @example
   * ```typescript
   * // Called automatically by heartbeat timer
   * await lifecycleManager.performHeartbeat();
   * ```
   */
  async performHeartbeat() {
    try {
      const now = /* @__PURE__ */ new Date();
      this.lastHeartbeat = now;
      await storage.updateAgentStatus({
        lastHeartbeat: now
      });
      await this.checkAndRecoverIfStale();
      if (this.consecutiveErrors > 0) {
        this.consecutiveErrors = Math.max(0, this.consecutiveErrors - 1);
      }
    } catch (error) {
      log.error("LifecycleManager", "Heartbeat error", {
        error: String(error)
      });
      this.consecutiveErrors++;
      if (this.consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
        log.warn(
          "LifecycleManager",
          "Too many consecutive errors, triggering self-healing"
        );
        await this.selfHeal();
      }
    }
  }
  /**
   * Detect stale state & trigger recovery
   *
   * Monitors the time since the last analysis cycle and triggers self-healing
   * if the orchestrator appears to be frozen (no analysis in 120+ seconds).
   *
   * @async
   * @returns {Promise<void>}
   *
   * @stale-detection-criteria
   * - Orchestrator is marked as running
   * - Last analysis time exists
   * - Time since last analysis > 120 seconds (STALE_HEARTBEAT_THRESHOLD_MS)
   *
   * @example
   * ```typescript
   * // Called automatically by performHeartbeat()
   * await lifecycleManager.checkAndRecoverIfStale();
   * ```
   */
  async checkAndRecoverIfStale() {
    const state = this.orchestrator.getState();
    if (!state.isRunning) return;
    const now = Date.now();
    const lastAnalysis = state.lastAnalysisTime?.getTime() || 0;
    const timeSinceAnalysis = now - lastAnalysis;
    if (timeSinceAnalysis > STALE_HEARTBEAT_THRESHOLD_MS && lastAnalysis > 0) {
      log.warn(
        "LifecycleManager",
        `Stale state detected (${Math.round(timeSinceAnalysis / 1e3)}s since last analysis)`
      );
      await this.selfHeal();
    }
  }
  /**
   * Self-recovery mechanism
   *
   * Performs a complete restart of the orchestrator to recover from errors or
   * stale state. This is the core self-healing logic that allows the system to
   * recover automatically without manual intervention.
   *
   * @async
   * @returns {Promise<void>}
   *
   * @throws {Error} If self-healing fails (caught and logged)
   *
   * @recovery-process
   * 1. Log self-healing initiation
   * 2. Preserve current auto-start setting
   * 3. Stop orchestrator gracefully (preserve auto-start flag)
   * 4. Wait 5 seconds for cleanup (AUTO_RESTART_DELAY_MS)
   * 5. Reset consecutive error count to 0
   * 6. Clear error state
   * 7. Restart orchestrator if auto-start was enabled
   * 8. Restart heartbeat monitoring
   *
   * @example
   * ```typescript
   * // Manually trigger self-healing
   * await lifecycleManager.selfHeal();
   *
   * // Or let it trigger automatically when errors >= 5
   * ```
   */
  async selfHeal() {
    log.info("LifecycleManager", "Initiating self-healing...");
    const wasAutoStartEnabled = this.autoStartEnabled;
    try {
      await this.orchestrator.stop(true);
      await new Promise(
        (resolve2) => setTimeout(resolve2, AUTO_RESTART_DELAY_MS)
      );
      this.consecutiveErrors = 0;
      this.orchestrator.setState({ errors: [] });
      if (wasAutoStartEnabled) {
        await this.orchestrator.start();
        this.startHeartbeat();
        log.info("LifecycleManager", "Self-healing complete - Agent restarted");
      }
    } catch (error) {
      log.error("LifecycleManager", "Self-healing failed", {
        error: String(error)
      });
      const state = this.orchestrator.getState();
      state.errors.push(`Self-healing failed: ${error}`);
    }
  }
  /**
   * Toggle auto-start setting
   *
   * Updates the auto-start flag both in memory and in the database. When disabled,
   * the orchestrator will not automatically restart after self-healing or failures.
   *
   * @async
   * @param {boolean} enabled - Whether to enable auto-start
   * @returns {Promise<void>}
   *
   * @example
   * ```typescript
   * // Disable auto-start temporarily
   * await lifecycleManager.setAutoStartEnabled(false);
   *
   * // Re-enable auto-start
   * await lifecycleManager.setAutoStartEnabled(true);
   * ```
   */
  async setAutoStartEnabled(enabled) {
    this.autoStartEnabled = enabled;
    await storage.updateAgentStatus({ autoStartEnabled: enabled });
    log.info(
      "LifecycleManager",
      `Auto-start ${enabled ? "enabled" : "disabled"}`
    );
  }
  /**
   * Query auto-start status
   *
   * @returns {boolean} Whether auto-start is currently enabled
   *
   * @example
   * ```typescript
   * if (lifecycleManager.isAutoStartEnabledFlag()) {
   *   console.log('Auto-start is enabled');
   * }
   * ```
   */
  isAutoStartEnabledFlag() {
    return this.autoStartEnabled;
  }
  /**
   * Return health metrics
   *
   * Provides a comprehensive snapshot of the orchestrator's health including error
   * counts, heartbeat status, and market condition information.
   *
   * @returns {HealthStatus} Complete health status object
   *
   * @health-criteria
   * - isHealthy: false if consecutiveErrors >= 5 OR orchestrator not running
   * - lastHeartbeat: null if heartbeat never ran
   * - consecutiveErrors: triggers self-healing at 5
   * - marketCondition: from market-condition-analyzer (bullish/bearish/neutral/volatile)
   * - dynamicOrderLimit: order limit adjusted for market conditions
   *
   * @example
   * ```typescript
   * const health = lifecycleManager.getHealthStatus();
   * if (!health.isHealthy) {
   *   console.log(`Unhealthy: ${health.consecutiveErrors} consecutive errors`);
   *   console.log(`Last heartbeat: ${health.lastHeartbeat}`);
   * }
   * ```
   */
  getHealthStatus() {
    const analyzerStatus = marketConditionAnalyzer.getStatus();
    const state = this.orchestrator.getState();
    return {
      isHealthy: this.consecutiveErrors < MAX_CONSECUTIVE_ERRORS && state.isRunning,
      lastHeartbeat: this.lastHeartbeat,
      consecutiveErrors: this.consecutiveErrors,
      autoStartEnabled: this.autoStartEnabled,
      marketCondition: analyzerStatus.lastAnalysis?.condition || null,
      dynamicOrderLimit: analyzerStatus.currentOrderLimit
    };
  }
  /**
   * Get the current consecutive error count
   *
   * @returns {number} Number of consecutive errors (triggers self-healing at 5)
   *
   * @example
   * ```typescript
   * const errorCount = lifecycleManager.getConsecutiveErrors();
   * if (errorCount >= 3) {
   *   console.warn('Error count rising, may trigger self-healing soon');
   * }
   * ```
   */
  getConsecutiveErrors() {
    return this.consecutiveErrors;
  }
  /**
   * Get the last heartbeat timestamp
   *
   * @returns {Date | null} Last successful heartbeat time, or null if never ran
   *
   * @example
   * ```typescript
   * const lastBeat = lifecycleManager.getLastHeartbeat();
   * if (lastBeat) {
   *   const secondsSince = (Date.now() - lastBeat.getTime()) / 1000;
   *   console.log(`Last heartbeat: ${secondsSince}s ago`);
   * }
   * ```
   */
  getLastHeartbeat() {
    return this.lastHeartbeat;
  }
  /**
   * Check if auto-start is currently in progress
   *
   * Prevents concurrent auto-start attempts which could cause race conditions.
   *
   * @returns {boolean} True if auto-start is currently running
   *
   * @example
   * ```typescript
   * if (lifecycleManager.isAutoStartInProgress()) {
   *   console.log('Auto-start already in progress, please wait');
   * }
   * ```
   */
  isAutoStartInProgress() {
    return this.isAutoStarting;
  }
  /**
   * Reset error count (useful after manual intervention)
   *
   * Clears the consecutive error count, preventing immediate self-healing.
   * Useful when you've manually fixed an issue and want to give the orchestrator
   * a fresh start.
   *
   * @returns {void}
   *
   * @example
   * ```typescript
   * // After manually fixing an issue
   * lifecycleManager.resetErrors();
   * console.log('Error count reset, orchestrator has a clean slate');
   * ```
   */
  resetErrors() {
    this.consecutiveErrors = 0;
  }
};

// server/autonomous/position-manager.ts
init_alpaca();
init_storage();
init_logger();
init_numeric();
init_money();
init_order_execution_flow();

// server/services/advanced-rebalancing-service.ts
init_db();
init_schema2();
init_logger();
init_money();
var DEFAULT_PARTIAL_TAKE_PROFITS = [
  { profitPercent: 10, closePercent: 25, executed: false },
  { profitPercent: 20, closePercent: 25, executed: false },
  { profitPercent: 35, closePercent: 25, executed: false },
  { profitPercent: 50, closePercent: 25, executed: false }
];
var DEFAULT_TRAILING_STOP = {
  enabled: true,
  trailPercent: 5,
  breakEvenTriggerPercent: 8,
  activationProfitPercent: 5,
  highWaterMark: 0
};
var DEFAULT_MARKET_REGIME_CONFIG = {
  bullishMultiplier: 1.25,
  bearishMultiplier: 0.5,
  sidewaysStrategy: "reduce",
  volatileMultiplier: 0.6
};
var positionProfitRules = /* @__PURE__ */ new Map();
var AdvancedRebalancingService = class {
  marketRegimeConfig = DEFAULT_MARKET_REGIME_CONFIG;
  lastRegimeAnalysis = null;
  kellyFraction = 0.25;
  registerPosition(symbol, entryPrice, customRules) {
    const rules = {
      symbol,
      entryPrice,
      partialTakeProfits: customRules?.partialTakeProfits || JSON.parse(JSON.stringify(DEFAULT_PARTIAL_TAKE_PROFITS)),
      trailingStop: customRules?.trailingStop || {
        ...DEFAULT_TRAILING_STOP,
        highWaterMark: entryPrice
      },
      maxHoldingPeriodHours: customRules?.maxHoldingPeriodHours || 168,
      createdAt: /* @__PURE__ */ new Date()
    };
    positionProfitRules.set(symbol, rules);
    log.info("AdvancedRebalancing", `Registered profit rules for ${symbol}`, {
      entryPrice,
      takeProfitLevels: rules.partialTakeProfits.length
    });
    return rules;
  }
  getPositionRules(symbol) {
    return positionProfitRules.get(symbol);
  }
  removePositionRules(symbol) {
    positionProfitRules.delete(symbol);
  }
  checkPartialTakeProfits(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules) return null;
    const currentProfitPercent = position.unrealizedPnlPercent;
    for (const level of rules.partialTakeProfits) {
      if (!level.executed && currentProfitPercent >= level.profitPercent) {
        level.executed = true;
        level.executedAt = /* @__PURE__ */ new Date();
        log.info(
          "AdvancedRebalancing",
          `Partial take-profit triggered for ${position.symbol}`,
          {
            profitLevel: level.profitPercent,
            closePercent: level.closePercent,
            currentProfit: currentProfitPercent.toFixed(2)
          }
        );
        return {
          shouldClose: true,
          closePercent: level.closePercent,
          reason: `Partial take-profit at ${level.profitPercent}% gain`
        };
      }
    }
    return null;
  }
  updateTrailingStop(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules || !rules.trailingStop.enabled) return null;
    const config2 = rules.trailingStop;
    const currentProfitPercent = position.unrealizedPnlPercent;
    if (currentProfitPercent < config2.activationProfitPercent) {
      return null;
    }
    if (position.currentPrice > config2.highWaterMark) {
      config2.highWaterMark = position.currentPrice;
    }
    let newStopLoss;
    let reason;
    if (currentProfitPercent >= config2.breakEvenTriggerPercent) {
      const breakEvenStop = toDecimal(rules.entryPrice).times(1.005).toNumber();
      const trailingStop = trailingStopPrice(
        config2.highWaterMark,
        config2.trailPercent
      ).toNumber();
      newStopLoss = Math.max(breakEvenStop, trailingStop);
      reason = currentProfitPercent >= config2.breakEvenTriggerPercent * 1.5 ? `Trailing stop at ${config2.trailPercent}% below high water mark ($${config2.highWaterMark.toFixed(2)})` : `Moved stop to breakeven + 0.5%`;
    } else {
      newStopLoss = trailingStopPrice(
        config2.highWaterMark,
        config2.trailPercent
      ).toNumber();
      reason = `Initial trailing stop at ${config2.trailPercent}% below current price`;
    }
    if (!position.stopLossPrice || newStopLoss > position.stopLossPrice) {
      log.info(
        "AdvancedRebalancing",
        `Trailing stop update for ${position.symbol}`,
        {
          oldStop: position.stopLossPrice?.toFixed(2),
          newStop: newStopLoss.toFixed(2),
          reason
        }
      );
      return { newStopLoss, reason };
    }
    return null;
  }
  async detectMarketRegime() {
    try {
      const indicators = await db.select().from(macroIndicators);
      if (indicators.length === 0) {
        return "unknown";
      }
      const vix = indicators.find((i) => i.indicatorId === "VIXCLS");
      const yieldSpread = indicators.find((i) => i.indicatorId === "T10Y2Y");
      const fedFundsRate = indicators.find((i) => i.indicatorId === "FEDFUNDS");
      const unemployment = indicators.find((i) => i.indicatorId === "UNRATE");
      const vixValue = vix?.latestValue ? parseFloat(vix.latestValue) : 20;
      const spreadValue = yieldSpread?.latestValue ? parseFloat(yieldSpread.latestValue) : 0;
      const unemploymentChange = unemployment?.changePercent ? parseFloat(unemployment.changePercent) : 0;
      let regime;
      if (vixValue > 30) {
        regime = "volatile";
      } else if (spreadValue < 0) {
        regime = "bearish";
      } else if (vixValue < 15 && spreadValue > 0.5 && unemploymentChange <= 0) {
        regime = "bullish";
      } else {
        regime = "sideways";
      }
      this.lastRegimeAnalysis = { regime, analyzedAt: /* @__PURE__ */ new Date() };
      log.info("AdvancedRebalancing", `Market regime detected: ${regime}`, {
        vix: vixValue,
        yieldSpread: spreadValue,
        unemploymentChange
      });
      return regime;
    } catch (error) {
      log.error("AdvancedRebalancing", "Failed to detect market regime", {
        error: String(error)
      });
      return "unknown";
    }
  }
  getRegimeAdjustedPositionSize(basePositionSizePercent, regime) {
    const currentRegime = regime || this.lastRegimeAnalysis?.regime || "unknown";
    let multiplier;
    switch (currentRegime) {
      case "bullish":
        multiplier = this.marketRegimeConfig.bullishMultiplier;
        break;
      case "bearish":
        multiplier = this.marketRegimeConfig.bearishMultiplier;
        break;
      case "volatile":
        multiplier = this.marketRegimeConfig.volatileMultiplier;
        break;
      case "sideways":
        multiplier = this.marketRegimeConfig.sidewaysStrategy === "reduce" ? 0.75 : 1;
        break;
      default:
        multiplier = 1;
    }
    const adjustedSize = toDecimal(basePositionSizePercent).times(multiplier).toNumber();
    log.debug("AdvancedRebalancing", `Regime-adjusted position size`, {
      regime: currentRegime,
      base: basePositionSizePercent,
      multiplier,
      adjusted: adjustedSize
    });
    return adjustedSize;
  }
  calculateKellyPositionSize(params) {
    const {
      confidence,
      targetProfit,
      stopLoss,
      entryPrice,
      portfolioValue,
      maxPositionSizePercent
    } = params;
    const winRate = toDecimal(confidence).dividedBy(100);
    const lossRate = toDecimal(1).minus(winRate);
    const avgWin = toDecimal(targetProfit).minus(entryPrice);
    const avgLoss = toDecimal(entryPrice).minus(stopLoss);
    if (avgLoss.lte(0) || avgWin.lte(0)) {
      return {
        symbol: "",
        rawKellyPercent: 0,
        adjustedKellyPercent: 0,
        suggestedPositionSize: 0,
        confidence,
        expectedReturn: 0,
        riskRatio: 0
      };
    }
    const winLossRatio = avgWin.dividedBy(avgLoss);
    const rawKellyDecimal = kellyFraction(winRate, avgWin, avgLoss);
    const rawKellyPercent = rawKellyDecimal.times(100).toNumber();
    const adjustedKellyDecimal = rawKellyDecimal.times(this.kellyFraction);
    const adjustedKellyPercent = adjustedKellyDecimal.times(100).toNumber();
    const suggestedSize = kellySuggestedSize(
      portfolioValue,
      rawKellyDecimal,
      this.kellyFraction,
      maxPositionSizePercent
    ).toNumber();
    const cappedKelly = Math.min(adjustedKellyPercent, maxPositionSizePercent);
    const expectedReturn = winRate.times(avgWin).minus(lossRate.times(avgLoss)).toNumber();
    log.debug("AdvancedRebalancing", `Kelly position size calculated`, {
      winRate: winRate.toNumber().toFixed(3),
      winLossRatio: winLossRatio.toNumber().toFixed(2),
      rawKelly: rawKellyPercent.toFixed(2) + "%",
      adjustedKelly: adjustedKellyPercent.toFixed(2) + "%",
      cappedKelly: cappedKelly.toFixed(2) + "%",
      suggestedSize: suggestedSize.toFixed(2)
    });
    return {
      symbol: "",
      rawKellyPercent,
      adjustedKellyPercent,
      suggestedPositionSize: suggestedSize,
      confidence,
      expectedReturn,
      riskRatio: winLossRatio.toNumber()
    };
  }
  setKellyFraction(fraction) {
    if (fraction < 0.1 || fraction > 1) {
      throw new Error("Kelly fraction must be between 0.1 and 1.0");
    }
    this.kellyFraction = fraction;
    log.info("AdvancedRebalancing", `Kelly fraction set to ${fraction}`);
  }
  setMarketRegimeConfig(config2) {
    this.marketRegimeConfig = { ...this.marketRegimeConfig, ...config2 };
    log.info("AdvancedRebalancing", "Market regime config updated", {
      bullishMultiplier: this.marketRegimeConfig.bullishMultiplier,
      bearishMultiplier: this.marketRegimeConfig.bearishMultiplier,
      sidewaysStrategy: this.marketRegimeConfig.sidewaysStrategy,
      volatileMultiplier: this.marketRegimeConfig.volatileMultiplier
    });
  }
  getMarketRegimeConfig() {
    return { ...this.marketRegimeConfig };
  }
  getLastRegimeAnalysis() {
    return this.lastRegimeAnalysis;
  }
  checkHoldingPeriod(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules) return null;
    const holdingMs = Date.now() - position.openedAt.getTime();
    const holdingHours = holdingMs / (1e3 * 60 * 60);
    return {
      exceeded: holdingHours > rules.maxHoldingPeriodHours,
      holdingHours,
      maxHours: rules.maxHoldingPeriodHours
    };
  }
  getAllPositionRules() {
    return new Map(positionProfitRules);
  }
  getStatus() {
    return {
      registeredPositions: positionProfitRules.size,
      lastRegime: this.lastRegimeAnalysis?.regime || null,
      lastRegimeAnalyzedAt: this.lastRegimeAnalysis?.analyzedAt || null,
      kellyFraction: this.kellyFraction,
      regimeConfig: this.marketRegimeConfig
    };
  }
};
var advancedRebalancingService = new AdvancedRebalancingService();

// server/services/sector-exposure-service.ts
init_db();
init_schema2();
init_logger();
import { eq as eq10 } from "drizzle-orm";
var DEFAULT_MAX_SECTOR_WEIGHT_PCT = 25;
var KNOWN_SECTOR_MAP = {
  // ETFs
  SPY: "ETF",
  QQQM: "ETF",
  QQQ: "ETF",
  IWM: "ETF",
  DIA: "ETF",
  // Technology
  AAPL: "Technology",
  MSFT: "Technology",
  GOOGL: "Technology",
  GOOG: "Technology",
  AMZN: "Technology",
  NVDA: "Technology",
  META: "Technology",
  TSLA: "Technology",
  AVGO: "Technology",
  ORCL: "Technology",
  CRM: "Technology",
  AMD: "Technology",
  INTC: "Technology",
  IBM: "Technology",
  CSCO: "Technology",
  ADBE: "Technology",
  NFLX: "Technology",
  PYPL: "Technology",
  NOW: "Technology",
  UBER: "Technology",
  // Financials
  JPM: "Financials",
  V: "Financials",
  MA: "Financials",
  BAC: "Financials",
  WFC: "Financials",
  GS: "Financials",
  MS: "Financials",
  BLK: "Financials",
  SCHW: "Financials",
  AXP: "Financials",
  // Healthcare
  UNH: "Healthcare",
  JNJ: "Healthcare",
  LLY: "Healthcare",
  PFE: "Healthcare",
  ABBV: "Healthcare",
  MRK: "Healthcare",
  TMO: "Healthcare",
  ABT: "Healthcare",
  // Consumer Discretionary
  HD: "Consumer Discretionary",
  NKE: "Consumer Discretionary",
  MCD: "Consumer Discretionary",
  SBUX: "Consumer Discretionary",
  LOW: "Consumer Discretionary",
  // Consumer Staples
  WMT: "Consumer Staples",
  PG: "Consumer Staples",
  KO: "Consumer Staples",
  PEP: "Consumer Staples",
  COST: "Consumer Staples",
  // Energy
  CVX: "Energy",
  XOM: "Energy",
  COP: "Energy",
  SLB: "Energy",
  // Industrials
  UPS: "Industrials",
  RTX: "Industrials",
  HON: "Industrials",
  BA: "Industrials",
  CAT: "Industrials",
  GE: "Industrials",
  DE: "Industrials",
  // Materials
  LIN: "Materials",
  APD: "Materials",
  SHW: "Materials",
  // Utilities
  NEE: "Utilities",
  DUK: "Utilities",
  SO: "Utilities",
  // Real Estate
  AMT: "Real Estate",
  PLD: "Real Estate",
  CCI: "Real Estate",
  // Communication Services
  DIS: "Communication Services",
  CMCSA: "Communication Services",
  VZ: "Communication Services",
  T: "Communication Services",
  TMUS: "Communication Services",
  // Crypto
  "BTC/USD": "Crypto",
  "ETH/USD": "Crypto",
  "SOL/USD": "Crypto",
  "DOGE/USD": "Crypto",
  "SHIB/USD": "Crypto",
  "AVAX/USD": "Crypto"
};
var SectorExposureService = class {
  sectorCache = /* @__PURE__ */ new Map();
  maxSectorWeightPct = DEFAULT_MAX_SECTOR_WEIGHT_PCT;
  lastConfigRefresh = null;
  configRefreshIntervalMs = 3e5;
  // 5 minutes
  /**
   * Get the sector for a symbol, using cache, database, or fallback mapping
   */
  async getSector(symbol) {
    const cached = this.sectorCache.get(symbol.toUpperCase());
    if (cached) return cached;
    try {
      const [fundamentals] = await db.select({ sector: universeFundamentals.sector }).from(universeFundamentals).where(eq10(universeFundamentals.symbol, symbol.toUpperCase())).limit(1);
      if (fundamentals?.sector) {
        this.sectorCache.set(symbol.toUpperCase(), fundamentals.sector);
        return fundamentals.sector;
      }
    } catch (error) {
      log.warn("SectorExposure", `Failed to fetch sector for ${symbol}`, {
        error: String(error)
      });
    }
    const fallback = KNOWN_SECTOR_MAP[symbol.toUpperCase()] || "Unknown";
    this.sectorCache.set(symbol.toUpperCase(), fallback);
    return fallback;
  }
  /**
   * Refresh max sector weight (uses default for now, can be extended to read from DB)
   */
  async refreshConfig() {
    const now = /* @__PURE__ */ new Date();
    if (this.lastConfigRefresh && now.getTime() - this.lastConfigRefresh.getTime() < this.configRefreshIntervalMs) {
      return;
    }
    const envValue = process.env.MAX_SECTOR_WEIGHT_PCT;
    if (envValue) {
      const parsed = parseFloat(envValue);
      if (!isNaN(parsed) && parsed >= 5 && parsed <= 100) {
        this.maxSectorWeightPct = parsed;
      }
    }
    this.lastConfigRefresh = now;
    log.debug(
      "SectorExposure",
      `Max sector weight: ${this.maxSectorWeightPct}%`
    );
  }
  /**
   * Calculate current sector exposure from active positions
   */
  async calculateExposure(positions2, portfolioValue) {
    await this.refreshConfig();
    const sectorMap = /* @__PURE__ */ new Map();
    let totalExposure = 0;
    const warnings = [];
    for (const [symbol, position] of positions2.entries()) {
      const sector = await this.getSector(symbol);
      const positionValue2 = position.currentPrice * position.quantity;
      totalExposure += positionValue2;
      const existing = sectorMap.get(sector) || {
        sector,
        totalValue: 0,
        positionCount: 0,
        percentOfPortfolio: 0,
        symbols: []
      };
      existing.totalValue += positionValue2;
      existing.positionCount++;
      existing.symbols.push(symbol);
      sectorMap.set(sector, existing);
    }
    let mostConcentrated = null;
    let maxConcentration = 0;
    for (const [sector, exposure] of sectorMap.entries()) {
      exposure.percentOfPortfolio = portfolioValue > 0 ? exposure.totalValue / portfolioValue * 100 : 0;
      if (exposure.percentOfPortfolio > maxConcentration) {
        maxConcentration = exposure.percentOfPortfolio;
        mostConcentrated = sector;
      }
      if (exposure.percentOfPortfolio > this.maxSectorWeightPct) {
        warnings.push(
          `${sector} exposure (${exposure.percentOfPortfolio.toFixed(1)}%) exceeds limit (${this.maxSectorWeightPct}%)`
        );
      }
    }
    const exposureBySector = Array.from(sectorMap.values()).sort(
      (a, b) => b.percentOfPortfolio - a.percentOfPortfolio
    );
    return {
      exposureBySector,
      totalExposure,
      portfolioValue,
      maxSectorWeight: this.maxSectorWeightPct,
      mostConcentratedSector: mostConcentrated,
      warnings
    };
  }
  /**
   * Check if adding a position would exceed sector limits
   */
  async checkExposure(symbol, proposedValue, positions2, portfolioValue) {
    await this.refreshConfig();
    const sector = await this.getSector(symbol);
    let currentSectorValue = 0;
    for (const [posSymbol, position] of positions2.entries()) {
      const posSector = await this.getSector(posSymbol);
      if (posSector === sector) {
        currentSectorValue += position.currentPrice * position.quantity;
      }
    }
    const currentExposure = portfolioValue > 0 ? currentSectorValue / portfolioValue * 100 : 0;
    const newExposure = portfolioValue > 0 ? (currentSectorValue + proposedValue) / portfolioValue * 100 : 0;
    if (newExposure > this.maxSectorWeightPct) {
      log.warn(
        "SectorExposure",
        `Trade blocked: ${symbol} would exceed ${sector} limit`,
        {
          symbol,
          sector,
          currentExposure: currentExposure.toFixed(1),
          newExposure: newExposure.toFixed(1),
          maxAllowed: this.maxSectorWeightPct
        }
      );
      return {
        canTrade: false,
        reason: `Would exceed ${sector} sector limit: ${newExposure.toFixed(1)}% > ${this.maxSectorWeightPct}%`,
        currentExposure,
        maxExposure: this.maxSectorWeightPct,
        sector
      };
    }
    return {
      canTrade: true,
      currentExposure,
      maxExposure: this.maxSectorWeightPct,
      sector
    };
  }
  /**
   * Set max sector weight (for runtime configuration)
   */
  setMaxSectorWeight(percent) {
    if (percent < 5 || percent > 100) {
      throw new Error("Max sector weight must be between 5% and 100%");
    }
    this.maxSectorWeightPct = percent;
    log.info("SectorExposure", `Max sector weight set to ${percent}%`);
  }
  /**
   * Clear the sector cache
   */
  clearCache() {
    this.sectorCache.clear();
    log.info("SectorExposure", "Sector cache cleared");
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return {
      maxSectorWeightPct: this.maxSectorWeightPct,
      cachedSymbols: this.sectorCache.size
    };
  }
};
var sectorExposureService = new SectorExposureService();

// server/autonomous/position-manager.ts
init_tradability_service();

// server/autonomous/order-queue.ts
init_alpaca();
init_work_queue();
init_logger();
var QUEUE_POLL_INTERVAL_MS = 2e3;
var QUEUE_POLL_TIMEOUT_MS = 6e4;
async function queueOrderExecution(params) {
  const { orderParams, traceId, strategyId, symbol, side, decisionId } = params;
  const timestampBucket = Math.floor(Date.now() / 3e5).toString();
  const idempotencyKey = generateIdempotencyKey({
    strategyId: strategyId || "autonomous",
    symbol,
    side,
    timeframeBucket: timestampBucket
  });
  log.info("Orchestrator", `Queuing ORDER_SUBMIT for ${symbol} ${side}`, {
    traceId,
    idempotencyKey,
    symbol,
    side
  });
  const normalizedOrderParams = {
    symbol: orderParams.symbol,
    side: orderParams.side,
    type: orderParams.type || "market",
    time_in_force: orderParams.time_in_force || "day",
    ...orderParams.qty && { qty: orderParams.qty },
    ...orderParams.notional && { notional: orderParams.notional },
    ...orderParams.limit_price && { limit_price: orderParams.limit_price },
    ...orderParams.stop_price && { stop_price: orderParams.stop_price },
    ...orderParams.extended_hours !== void 0 && {
      extended_hours: orderParams.extended_hours
    },
    ...orderParams.order_class && { order_class: orderParams.order_class },
    // Include both nested and flat formats for bracket order params
    // Work queue expects flat fields, direct API calls may use nested
    ...orderParams.take_profit && { take_profit: orderParams.take_profit },
    ...orderParams.stop_loss && { stop_loss: orderParams.stop_loss },
    ...orderParams.take_profit_limit_price && {
      take_profit_limit_price: orderParams.take_profit_limit_price
    },
    ...orderParams.stop_loss_stop_price && {
      stop_loss_stop_price: orderParams.stop_loss_stop_price
    }
  };
  const workItem = await workQueue.enqueue({
    type: "ORDER_SUBMIT",
    symbol,
    idempotencyKey,
    decisionId: decisionId || null,
    payload: JSON.stringify({
      ...normalizedOrderParams,
      traceId,
      strategyId
    }),
    maxAttempts: 3
  });
  log.info("Orchestrator", `Work item created: ${workItem.id}`, {
    traceId,
    workItemId: workItem.id,
    status: workItem.status
  });
  if (workItem.status === "SUCCEEDED" && workItem.result) {
    const result = JSON.parse(workItem.result);
    if (result.orderId) {
      try {
        const alpacaOrder = await alpaca.getOrder(result.orderId);
        const actualStatus = alpacaOrder.status?.toLowerCase() || "unknown";
        const terminalFailedStates = [
          "canceled",
          "rejected",
          "expired",
          "suspended"
        ];
        if (terminalFailedStates.includes(actualStatus)) {
          log.warn(
            "Orchestrator",
            `Duplicate order ${result.orderId} has terminal failed status: ${actualStatus}, invalidating work item`,
            { traceId }
          );
          await workQueue.invalidateWorkItem(
            workItem.id,
            `Order ${actualStatus} by broker`
          );
          throw new Error(
            `Previous order was ${actualStatus}, retry with new parameters`
          );
        }
        log.info(
          "Orchestrator",
          `Order already succeeded (duplicate): ${result.orderId}, current status: ${actualStatus}`,
          { traceId }
        );
      } catch (orderCheckError) {
        if (orderCheckError.message?.includes("not found") || orderCheckError.status === 404) {
          log.warn(
            "Orchestrator",
            `Duplicate order ${result.orderId} not found in Alpaca, invalidating work item`,
            { traceId }
          );
          await workQueue.invalidateWorkItem(
            workItem.id,
            "Order not found in broker"
          );
          throw new Error(
            "Previous order not found, retry with new parameters"
          );
        }
        if (orderCheckError.message?.includes("retry with new parameters")) {
          throw orderCheckError;
        }
        log.warn(
          "Orchestrator",
          `Could not verify duplicate order status: ${orderCheckError.message}`,
          { traceId }
        );
      }
    }
    return {
      orderId: result.orderId,
      status: result.status || "filled",
      workItemId: workItem.id
    };
  }
  const startTime = Date.now();
  while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS) {
    await new Promise((resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS));
    const updatedItem = await workQueue.getById(workItem.id);
    if (!updatedItem) {
      throw new Error(`Work item ${workItem.id} not found during polling`);
    }
    if (updatedItem.status === "SUCCEEDED") {
      const result = updatedItem.result ? JSON.parse(updatedItem.result) : {};
      const orderStatus = result.status || "accepted";
      const validSuccessStates = [
        "filled",
        "accepted",
        "new",
        "pending_new",
        "partially_filled",
        "queued"
      ];
      if (validSuccessStates.includes(orderStatus.toLowerCase()) || result.orderId || updatedItem.brokerOrderId) {
        log.info(
          "Orchestrator",
          `ORDER_SUBMIT succeeded: ${result.orderId || updatedItem.brokerOrderId}`,
          {
            traceId,
            workItemId: workItem.id,
            orderId: result.orderId,
            orderStatus
          }
        );
        return {
          orderId: result.orderId || updatedItem.brokerOrderId || "",
          status: orderStatus,
          workItemId: workItem.id
        };
      }
    }
    if (updatedItem.brokerOrderId && !updatedItem.result) {
      log.info(
        "Orchestrator",
        `ORDER_SUBMIT has broker order ID: ${updatedItem.brokerOrderId}`,
        {
          traceId,
          workItemId: workItem.id
        }
      );
      return {
        orderId: updatedItem.brokerOrderId,
        status: "accepted",
        workItemId: workItem.id
      };
    }
    if (updatedItem.status === "DEAD_LETTER") {
      log.error(
        "Orchestrator",
        `ORDER_SUBMIT failed permanently: ${updatedItem.lastError}`,
        {
          traceId,
          workItemId: workItem.id
        }
      );
      throw new Error(
        `Order submission failed: ${updatedItem.lastError || "Unknown error"}`
      );
    }
    log.info(
      "Orchestrator",
      `Polling work item ${workItem.id}: ${updatedItem.status}`,
      {
        traceId,
        attempts: updatedItem.attempts
      }
    );
  }
  throw new Error(
    `Order submission timed out after ${QUEUE_POLL_TIMEOUT_MS}ms`
  );
}
async function queueOrderCancellation(params) {
  const { orderId, traceId, symbol, strategyId } = params;
  const timestampBucket = Math.floor(Date.now() / 6e4).toString();
  const idempotencyKey = generateIdempotencyKey({
    strategyId: strategyId || "autonomous",
    symbol,
    side: `cancel-${orderId}`,
    timeframeBucket: timestampBucket
  });
  log.info("Orchestrator", `Queuing ORDER_CANCEL for order ${orderId}`, {
    traceId,
    orderId,
    symbol,
    idempotencyKey
  });
  const workItem = await workQueue.enqueue({
    type: "ORDER_CANCEL",
    symbol,
    idempotencyKey,
    payload: JSON.stringify({ orderId, traceId }),
    maxAttempts: 3
  });
  if (workItem.status === "SUCCEEDED") {
    log.info(
      "Orchestrator",
      `Order cancellation already succeeded (duplicate)`,
      { traceId, orderId }
    );
    return;
  }
  const startTime = Date.now();
  while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS) {
    await new Promise((resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS));
    const updatedItem = await workQueue.getById(workItem.id);
    if (!updatedItem) {
      throw new Error(
        `Cancel work item ${workItem.id} not found during polling`
      );
    }
    if (updatedItem.status === "SUCCEEDED") {
      log.info("Orchestrator", `ORDER_CANCEL succeeded for order ${orderId}`, {
        traceId
      });
      return;
    }
    if (updatedItem.status === "CANCELLED") {
      log.info(
        "Orchestrator",
        `ORDER_CANCEL completed with CANCELLED status for order ${orderId}`,
        { traceId }
      );
      return;
    }
    if (updatedItem.status === "DEAD_LETTER") {
      const errorLower = (updatedItem.lastError || "").toLowerCase();
      if (errorLower.includes("already") || errorLower.includes("cancel") || errorLower.includes("not found")) {
        log.info(
          "Orchestrator",
          `ORDER_CANCEL completed (order already cancelled or not found): ${orderId}`,
          { traceId }
        );
        return;
      }
      log.warn(
        "Orchestrator",
        `ORDER_CANCEL failed: ${updatedItem.lastError}`,
        {
          traceId,
          orderId
        }
      );
      return;
    }
  }
  log.warn("Orchestrator", `Order cancellation timed out for ${orderId}`, {
    traceId
  });
}

// server/autonomous/pre-trade-guard.ts
init_alpaca();
init_trading_session_manager();
init_numeric();
init_logger();
async function preTradeGuard(symbol, side, orderValue, isCrypto) {
  try {
    const account = await alpaca.getAccount();
    const availableBuyingPower = safeParseFloat(account.buying_power);
    const exchange = isCrypto ? "CRYPTO" : "US_EQUITIES";
    const sessionInfo = tradingSessionManager.getCurrentSession(exchange);
    const marketStatus = await alpaca.getMarketStatus();
    const result = {
      canTrade: false,
      marketSession: sessionInfo.session,
      availableBuyingPower,
      requiredBuyingPower: orderValue,
      useExtendedHours: false,
      useLimitOrder: false
    };
    if (side === "buy" && orderValue > availableBuyingPower) {
      result.reason = `Insufficient buying power ($${availableBuyingPower.toFixed(2)} available < $${orderValue.toFixed(2)} required)`;
      return result;
    }
    if (isCrypto) {
      result.canTrade = true;
      log.info(
        "PreTradeGuard",
        `Crypto market 24/7 - trading enabled for ${symbol}`
      );
      return result;
    }
    if (tradingSessionManager.isHoliday(exchange, /* @__PURE__ */ new Date())) {
      result.canTrade = false;
      result.reason = `Market is closed for holiday (next open: ${sessionInfo.nextOpen?.toISOString()})`;
      return result;
    }
    if (sessionInfo.session === "regular") {
      result.canTrade = true;
      log.info(
        "PreTradeGuard",
        `Regular hours - trading enabled for ${symbol}`
      );
      return result;
    }
    if (sessionInfo.isExtendedHours && (sessionInfo.session === "pre_market" || sessionInfo.session === "after_hours")) {
      result.useExtendedHours = true;
      result.useLimitOrder = true;
      try {
        const snapshots = await alpaca.getSnapshots([symbol]);
        const snapshot = snapshots[symbol];
        if (snapshot?.latestTrade?.p) {
          const basePrice = snapshot.latestTrade.p;
          const volatilityMultiplier = sessionInfo.volatilityMultiplier;
          result.limitPrice = Math.round(basePrice * 100) / 100;
          result.canTrade = true;
          log.info(
            "PreTradeGuard",
            `Extended hours (${sessionInfo.session}) trading enabled for ${symbol} at $${result.limitPrice} (volatility: ${volatilityMultiplier}x)`
          );
          return result;
        } else {
          result.reason = `Cannot get current price for ${symbol} during ${sessionInfo.session}`;
          return result;
        }
      } catch (error) {
        result.reason = `Failed to get market price for extended hours order: ${error}`;
        return result;
      }
    }
    if (sessionInfo.session === "closed") {
      result.canTrade = false;
      const nextOpenStr = sessionInfo.nextOpen ? sessionInfo.nextOpen.toLocaleString() : "unknown";
      result.reason = `Market is closed (next open: ${nextOpenStr})`;
      log.info(
        "PreTradeGuard",
        `Market closed for ${symbol} - next open: ${nextOpenStr}`
      );
      return result;
    }
    return result;
  } catch (error) {
    return {
      canTrade: false,
      reason: `Pre-trade check failed: ${error}`,
      marketSession: "closed",
      availableBuyingPower: 0,
      requiredBuyingPower: orderValue,
      useExtendedHours: false,
      useLimitOrder: false
    };
  }
}
async function isSymbolTradable(symbol, isCrypto) {
  try {
    if (isCrypto) {
      const normalizedSymbol = normalizeCryptoSymbol3(symbol);
      const assets = await alpaca.getAssets("active", "crypto");
      const found = assets.find(
        (a) => a.symbol === normalizedSymbol && a.tradable
      );
      if (!found) {
        return {
          tradable: false,
          reason: `Crypto ${normalizedSymbol} is not tradable on Alpaca`
        };
      }
      return { tradable: true };
    } else {
      const asset = await alpaca.getAsset(symbol);
      if (!asset.tradable) {
        return { tradable: false, reason: `Stock ${symbol} is not tradable` };
      }
      return { tradable: true };
    }
  } catch (error) {
    return { tradable: false, reason: `Symbol validation failed: ${error}` };
  }
}

// server/autonomous/crypto-utils.ts
init_candidatesService();
var FALLBACK_WATCHLIST2 = {
  stocks: [
    "SPY",
    "QQQ",
    "AAPL",
    "MSFT",
    "GOOGL",
    "AMZN",
    "NVDA",
    "META",
    "TSLA",
    "JPM"
  ],
  crypto: ["BTC", "ETH", "SOL"]
};
var cachedWatchlist2 = null;
var WATCHLIST_CACHE_TTL_MS2 = 5 * 60 * 1e3;
function getWatchlistSync() {
  return cachedWatchlist2 || FALLBACK_WATCHLIST2;
}
function isCryptoSymbol4(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const watchlist = getWatchlistSync();
  if (watchlist.crypto.includes(upperSymbol)) return true;
  const cryptoPairs = watchlist.crypto.flatMap((c) => [`${c}/USD`, `${c}USD`]);
  return cryptoPairs.includes(upperSymbol) || symbol.includes("/") && upperSymbol.endsWith("USD");
}
function normalizeCryptoSymbol4(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const watchlist = getWatchlistSync();
  if (upperSymbol.includes("/")) return upperSymbol;
  if (watchlist.crypto.includes(upperSymbol)) return `${upperSymbol}/USD`;
  if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
    const base = upperSymbol.slice(0, -3);
    return `${base}/USD`;
  }
  return upperSymbol;
}

// server/autonomous/position-manager.ts
var PositionManager2 = class {
  state;
  riskLimits;
  currentTraceId = null;
  userId = null;
  constructor(state, riskLimits, userId = null) {
    this.state = state;
    this.riskLimits = riskLimits;
    this.userId = userId;
  }
  /**
   * Update the trace ID for logging correlation
   */
  setTraceId(traceId) {
    this.currentTraceId = traceId;
  }
  /**
   * Update the user ID for database operations
   */
  setUserId(userId) {
    this.userId = userId;
  }
  /**
   * Update risk limits reference
   */
  updateRiskLimits(riskLimits) {
    this.riskLimits = riskLimits;
  }
  /**
   * Get current active positions
   */
  get activePositions() {
    return this.state.activePositions;
  }
  /**
   * Get current daily PnL
   */
  get dailyPnl() {
    return this.state.dailyPnl;
  }
  /**
   * Get current daily trade count
   */
  get dailyTradeCount() {
    return this.state.dailyTradeCount;
  }
  // ============================================================================
  // POSITION OPENING
  // ============================================================================
  /**
   * Open a new position based on an AI decision
   *
   * Complete position opening workflow with comprehensive validation and risk management.
   * Integrates with sector exposure limits, tradability checks, and advanced rebalancing
   * service for graduated take-profits.
   *
   * @async
   * @param {string} symbol - The symbol to buy (e.g., 'AAPL', 'BTC')
   * @param {AIDecision} decision - AI decision with confidence, reasoning, and suggested parameters
   * @returns {Promise<ExecutionResult>} Execution result with success/failure status
   *
   * @throws {Error} If userId not initialized
   *
   * @validation-steps
   * 1. Get current portfolio value from broker
   * 2. Calculate position size (min of suggested or max allowed)
   * 3. Validate total exposure doesn't exceed limit (default 80%)
   * 4. Check sector concentration limits (prevent overexposure to single sector)
   * 5. Validate symbol tradability (approved universe, fractionable, etc.)
   * 6. Perform pre-trade checks (buying power, market hours, order type)
   *
   * @order-execution
   * - Extended hours: Use limit orders with estimated quantity
   * - Bracket orders: Disabled temporarily due to work-queue format issues
   * - Standard orders: Market orders with notional value (fractional shares)
   *
   * @post-execution
   * - Records trade in database with AI decision linkage
   * - Updates daily trade count
   * - Registers position with advanced rebalancing (4-tier take-profits)
   * - Tracks trade outcome for AI learning
   *
   * @example
   * ```typescript
   * const result = await positionManager.openPosition('AAPL', {
   *   action: 'buy',
   *   confidence: 0.85,
   *   reasoning: 'Strong momentum after earnings',
   *   riskLevel: 'medium',
   *   suggestedQuantity: 0.05, // 5% of portfolio
   *   stopLoss: 150,
   *   targetPrice: 200
   * });
   *
   * if (result.success) {
   *   console.log(`Opened ${result.quantity} shares at $${result.price}`);
   * }
   * ```
   */
  async openPosition(symbol, decision, executionContext) {
    try {
      const account = await alpaca.getAccount();
      const portfolioValue = safeParseFloat(account.portfolio_value);
      this.state.portfolioValue = portfolioValue;
      let positionValue2;
      let positionSizePercent;
      if (executionContext) {
        const currentPrice = await this.fetchCurrentPrice(symbol);
        if (currentPrice <= 0) {
          return {
            success: false,
            action: "skip",
            reason: "Unable to fetch current price for position sizing",
            symbol
          };
        }
        const sizingResult = calculatePositionSize(
          executionContext,
          portfolioValue,
          currentPrice
        );
        if (sizingResult.quantity < 1) {
          return {
            success: false,
            action: "skip",
            reason: sizingResult.warnings?.[0] || "Position size too small",
            symbol
          };
        }
        positionValue2 = sizingResult.notional;
        positionSizePercent = positionValue2 / portfolioValue * 100;
        if (sizingResult.warnings && sizingResult.warnings.length > 0) {
          log.info(
            "PositionManager",
            `Position sizing warnings for ${symbol}`,
            {
              warnings: sizingResult.warnings,
              strategyId: executionContext.strategyId
            }
          );
        }
        log.info("PositionManager", `Using strategy-based position sizing`, {
          symbol,
          strategyId: executionContext.strategyId,
          strategyName: executionContext.strategyName,
          sizingType: executionContext.params.positionSizing.type,
          sizingValue: executionContext.params.positionSizing.value,
          calculatedNotional: positionValue2.toFixed(2),
          calculatedPercent: positionSizePercent.toFixed(2)
        });
      } else {
        positionSizePercent = Math.min(
          (decision.suggestedQuantity || 0.05) * 100,
          this.riskLimits.maxPositionSizePercent
        );
        positionValue2 = portfolioValue * (positionSizePercent / 100);
      }
      const totalExposure = this.calculateTotalExposure(portfolioValue);
      if (totalExposure + positionSizePercent > this.riskLimits.maxTotalExposurePercent) {
        return {
          success: false,
          action: "skip",
          reason: `Would exceed max exposure (${totalExposure.toFixed(1)}% + ${positionSizePercent.toFixed(1)}% > ${this.riskLimits.maxTotalExposurePercent}%)`,
          symbol
        };
      }
      const sectorCheck = await sectorExposureService.checkExposure(
        symbol,
        positionValue2,
        this.state.activePositions,
        portfolioValue
      );
      if (!sectorCheck.canTrade) {
        log.warn(
          "PositionManager",
          `Sector exposure check failed for ${symbol}`,
          {
            sector: sectorCheck.sector,
            currentExposure: sectorCheck.currentExposure.toFixed(1),
            maxExposure: sectorCheck.maxExposure
          }
        );
        return {
          success: false,
          action: "skip",
          reason: sectorCheck.reason || `Sector exposure limit exceeded for ${sectorCheck.sector}`,
          symbol
        };
      }
      const isCrypto = isCryptoSymbol4(symbol);
      const brokerSymbol = isCrypto ? normalizeCryptoSymbol4(symbol) : symbol;
      const tradableCheck = await isSymbolTradable(symbol, isCrypto);
      if (!tradableCheck.tradable) {
        log.warn(
          "PositionManager",
          `Symbol ${symbol} not tradable: ${tradableCheck.reason}`
        );
        return {
          success: false,
          action: "skip",
          reason: tradableCheck.reason || "Symbol not tradable",
          symbol
        };
      }
      const preCheck = await preTradeGuard(
        symbol,
        "buy",
        positionValue2,
        isCrypto
      );
      if (!preCheck.canTrade) {
        log.warn(
          "PositionManager",
          `Pre-trade check failed for ${symbol}: ${preCheck.reason}`
        );
        return {
          success: false,
          action: "skip",
          reason: preCheck.reason || "Pre-trade check failed",
          symbol
        };
      }
      const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
      if (!tradabilityCheck.tradable) {
        log.warn(
          "PositionManager",
          `Symbol ${symbol} not tradable: ${tradabilityCheck.reason}`
        );
        return {
          success: false,
          action: "skip",
          reason: `Symbol not tradable: ${tradabilityCheck.reason || "Not in broker universe"}`,
          symbol
        };
      }
      let queuedResult;
      let bracketParams = null;
      if (executionContext?.params.bracketOrders.enabled && !isCrypto) {
        const currentPrice = await this.fetchCurrentPrice(symbol);
        if (currentPrice > 0) {
          const strategyBracket = calculateBracketOrderParams(
            executionContext,
            currentPrice,
            "buy"
          );
          if (strategyBracket) {
            bracketParams = strategyBracket;
            log.info("PositionManager", `Using strategy-based bracket orders`, {
              symbol,
              strategyId: executionContext.strategyId,
              takeProfitPercent: executionContext.params.bracketOrders.takeProfitPercent,
              stopLossPercent: executionContext.params.bracketOrders.stopLossPercent,
              takeProfitPrice: bracketParams.takeProfitPrice,
              stopLossPrice: bracketParams.stopLossPrice
            });
          }
        }
      } else if (decision.targetPrice && decision.stopLoss && !isCrypto) {
        bracketParams = {
          takeProfitPrice: decision.targetPrice,
          stopLossPrice: decision.stopLoss
        };
      }
      const hasBracketParams = bracketParams?.takeProfitPrice && bracketParams?.stopLossPrice;
      if (preCheck.useExtendedHours && preCheck.useLimitOrder && preCheck.limitPrice) {
        log.info(
          "PositionManager",
          `Extended hours limit order for ${symbol} @ $${preCheck.limitPrice}`
        );
        const estimatedQty = Math.floor(positionValue2 / preCheck.limitPrice);
        if (estimatedQty < 1) {
          return {
            success: false,
            action: "skip",
            reason: `Position value too small for whole share order ($${positionValue2.toFixed(2)} at $${preCheck.limitPrice})`,
            symbol
          };
        }
        const orderParams = {
          symbol: brokerSymbol,
          qty: estimatedQty.toString(),
          side: "buy",
          type: "limit",
          time_in_force: "day",
          limit_price: preCheck.limitPrice.toFixed(2),
          extended_hours: true
        };
        queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "buy",
          decisionId: decision.aiDecisionId
        });
      } else if (hasBracketParams && bracketParams?.takeProfitPrice && bracketParams?.stopLossPrice) {
        log.info(
          "PositionManager",
          `Bracket order for ${symbol}: TP=$${bracketParams.takeProfitPrice.toFixed(2)}, SL=$${bracketParams.stopLossPrice.toFixed(2)}`
        );
        const currentPrice = await this.fetchCurrentPrice(symbol);
        if (currentPrice > 0 && positionValue2 > 0) {
          const estimatedQty = (positionValue2 / currentPrice).toFixed(6);
          const orderParams = {
            symbol: brokerSymbol,
            qty: estimatedQty,
            side: "buy",
            type: "market",
            time_in_force: "day",
            order_class: "bracket",
            take_profit: {
              limit_price: bracketParams.takeProfitPrice.toFixed(2)
            },
            stop_loss: { stop_price: bracketParams.stopLossPrice.toFixed(2) }
          };
          queuedResult = await queueOrderExecution({
            orderParams,
            traceId: this.currentTraceId,
            symbol,
            side: "buy",
            decisionId: decision.aiDecisionId
          });
        } else {
          log.warn(
            "PositionManager",
            `Bracket order fallback - invalid price/value for ${symbol}`
          );
          const orderParams = {
            symbol: brokerSymbol,
            notional: positionValue2.toFixed(2),
            side: "buy",
            type: "market",
            time_in_force: "day"
          };
          queuedResult = await queueOrderExecution({
            orderParams,
            traceId: this.currentTraceId,
            symbol,
            side: "buy",
            decisionId: decision.aiDecisionId
          });
        }
      } else {
        const orderExecution = executionContext?.params.orderExecution;
        const effectiveOrderType = orderExecution?.orderType || "market";
        const effectiveTIF = effectiveOrderType === "market" ? "day" : orderExecution?.timeInForce || "day";
        let orderParams;
        if (effectiveOrderType === "limit" && orderExecution) {
          const currentPrice = await this.fetchCurrentPrice(symbol);
          if (currentPrice <= 0) {
            return {
              success: false,
              action: "skip",
              reason: "Unable to fetch current price for limit order",
              symbol
            };
          }
          const offsetPct = orderExecution.limitOffsetPercent / 100;
          const limitPrice = Math.round(currentPrice * (1 + offsetPct) * 100) / 100;
          const estimatedQty = Math.floor(positionValue2 / currentPrice);
          if (estimatedQty < 1) {
            return {
              success: false,
              action: "skip",
              reason: `Position value too small for limit order ($${positionValue2.toFixed(2)} at $${currentPrice})`,
              symbol
            };
          }
          orderParams = {
            symbol: brokerSymbol,
            qty: estimatedQty.toString(),
            side: "buy",
            type: "limit",
            time_in_force: effectiveTIF,
            limit_price: limitPrice.toFixed(2),
            ...orderExecution.extendedHours && { extended_hours: true }
          };
          log.info("PositionManager", `Using strategy-based limit order`, {
            symbol,
            strategyId: executionContext?.strategyId,
            orderType: effectiveOrderType,
            timeInForce: effectiveTIF,
            limitPrice,
            extendedHours: orderExecution.extendedHours
          });
        } else {
          orderParams = {
            symbol: brokerSymbol,
            notional: positionValue2.toFixed(2),
            side: "buy",
            type: "market",
            time_in_force: "day"
          };
        }
        queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "buy",
          decisionId: decision.aiDecisionId
        });
      }
      const fillResult = await waitForAlpacaOrderFill(queuedResult.orderId);
      if (!fillResult.order) {
        log.error(
          "PositionManager",
          `Order ${queuedResult.orderId} - no order data received`
        );
        return {
          success: false,
          action: "buy",
          reason: "Order failed - no response from broker",
          symbol,
          orderId: queuedResult.orderId
        };
      }
      if (!fillResult.hasFillData) {
        log.error(
          "PositionManager",
          `Order ${queuedResult.orderId} has no fill data`
        );
        return {
          success: false,
          action: "buy",
          reason: fillResult.timedOut ? "Order fill timed out - position sync triggered" : "Order rejected or no fill data",
          symbol,
          orderId: queuedResult.orderId
        };
      }
      if (fillResult.timedOut && !fillResult.isFullyFilled) {
        log.warn(
          "PositionManager",
          `Order ${queuedResult.orderId} timed out with partial fill, using available data`
        );
      }
      const order = fillResult.order;
      let filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      if (filledPrice === 0) {
        filledPrice = await this.fetchCurrentPrice(symbol);
        if (filledPrice > 0) {
          log.info(
            "PositionManager",
            `Using market price ${filledPrice} for ${symbol}`
          );
        }
      }
      if (!this.userId) {
        throw new Error("Cannot create trade: userId not initialized");
      }
      const trade = await storage.createTrade({
        userId: this.userId,
        symbol,
        side: "buy",
        quantity: filledQty.toString(),
        price: filledPrice.toString(),
        status: "completed",
        notes: `AI autonomous: ${decision.reasoning}`,
        traceId: this.currentTraceId
      });
      if (decision.aiDecisionId) {
        const marketStatus = await alpaca.getMarketStatus();
        recordTradeOutcome({
          decisionId: decision.aiDecisionId,
          tradeId: trade.id,
          symbol,
          action: "buy",
          predictionConfidence: decision.confidence,
          entryPrice: filledPrice,
          quantity: filledQty,
          marketSessionAtEntry: marketStatus.session,
          strategyId: executionContext?.strategyId
        }).catch(
          (err) => log.error("PositionManager", `Failed to record trade outcome: ${err}`)
        );
      }
      this.state.dailyTradeCount++;
      const positionWithRules = {
        symbol,
        quantity: filledQty,
        availableQuantity: filledQty,
        entryPrice: filledPrice,
        currentPrice: filledPrice,
        unrealizedPnl: 0,
        unrealizedPnlPercent: 0,
        openedAt: /* @__PURE__ */ new Date(),
        stopLossPrice: bracketParams?.stopLossPrice ?? decision.stopLoss,
        takeProfitPrice: bracketParams?.takeProfitPrice ?? decision.targetPrice,
        trailingStopPercent: executionContext?.params.bracketOrders.trailingStopPercent ?? decision.trailingStopPercent,
        strategyId: executionContext?.strategyId
      };
      this.state.activePositions.set(symbol, positionWithRules);
      advancedRebalancingService.registerPosition(symbol, filledPrice);
      log.info(
        "PositionManager",
        `Registered ${symbol} with advanced rebalancing (4-tier take-profits, trailing stops)`
      );
      log.trade(`Opened position: ${symbol} $${positionValue2.toFixed(2)}`, {
        symbol,
        value: positionValue2
      });
      return {
        success: true,
        orderId: order.id,
        action: "buy",
        reason: decision.reasoning,
        symbol,
        quantity: positionWithRules.quantity,
        price: positionWithRules.entryPrice
      };
    } catch (error) {
      log.error("PositionManager", `Failed to open position ${symbol}`, {
        error: String(error)
      });
      return {
        success: false,
        action: "buy",
        reason: `Order failed: ${error}`,
        symbol,
        error: String(error)
      };
    }
  }
  // ============================================================================
  // POSITION CLOSING
  // ============================================================================
  /**
   * Close a position (fully or partially)
   *
   * Complete position closing workflow with loss protection and P&L tracking.
   * Implements critical loss protection logic to prevent premature exits at a loss
   * unless stop-loss or emergency stop conditions are met.
   *
   * @async
   * @param {string} symbol - The symbol to sell
   * @param {AIDecision} decision - AI decision with reasoning for the close
   * @param {PositionWithRules} position - Current position data with rules
   * @param {number} partialPercent - Percentage to close (default: 100 for full close)
   * @param {object} options - Additional control options
   * @param {boolean} options.isStopLossTriggered - Override loss protection (stop-loss hit)
   * @param {boolean} options.isEmergencyStop - Override loss protection (emergency -8% stop)
   * @returns {Promise<ExecutionResult>} Execution result with success/failure status
   *
   * @throws {Error} If userId not initialized
   *
   * @loss-protection
   * CRITICAL: Blocks closing positions at a loss UNLESS:
   * - isStopLossTriggered: true (stop-loss price hit)
   * - isEmergencyStop: true (emergency -8% stop triggered)
   *
   * This prevents the AI from closing positions during temporary dips,
   * forcing it to hold until stop-loss triggers or price recovers.
   *
   * @execution-steps
   * 1. Check loss protection (block close if at loss without override)
   * 2. Cancel any pending orders for the symbol
   * 3. Submit close order (full or partial)
   * 4. Wait for fill confirmation
   * 5. Calculate and record P&L
   * 6. Update learning service with trade outcome
   * 7. Update position tracking or remove if fully closed
   * 8. Clean up advanced rebalancing rules if fully closed
   *
   * @example
   * ```typescript
   * // Close at profit (allowed)
   * await positionManager.closePosition('AAPL', decision, position, 100);
   *
   * // Partial close (25%)
   * await positionManager.closePosition('AAPL', decision, position, 25);
   *
   * // Close at loss (blocked unless stop-loss triggered)
   * await positionManager.closePosition('AAPL', decision, position, 100, {
   *   isStopLossTriggered: true
   * });
   * ```
   */
  async closePosition(symbol, decision, position, partialPercent = 100, options = {}) {
    try {
      const isCrypto = isCryptoSymbol4(symbol);
      const brokerSymbol = isCrypto ? normalizeCryptoSymbol4(symbol) : symbol;
      const isAtLoss = position.currentPrice < position.entryPrice;
      const isProtectedClose = options.isStopLossTriggered || options.isEmergencyStop;
      if (isAtLoss && !isProtectedClose) {
        const lossPercent = ((position.entryPrice - position.currentPrice) / position.entryPrice * 100).toFixed(2);
        log.info(
          "PositionManager",
          `Blocking close of ${symbol} at ${lossPercent}% loss - stop loss not triggered`,
          {
            symbol,
            entryPrice: position.entryPrice,
            currentPrice: position.currentPrice,
            lossPercent
          }
        );
        return {
          success: false,
          action: "hold",
          reason: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`,
          symbol
        };
      }
      try {
        const openOrders = await alpaca.getOrders("open");
        const symbolOrders = openOrders.filter(
          (o) => o.symbol === brokerSymbol
        );
        for (const order2 of symbolOrders) {
          try {
            await queueOrderCancellation({
              orderId: order2.id,
              traceId: this.currentTraceId,
              symbol
            });
            log.info(
              "PositionManager",
              `Queued cancellation for pending order ${order2.id} for ${symbol} before closing`
            );
          } catch {
          }
        }
        if (symbolOrders.length > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, 500));
        }
      } catch (err) {
        log.warn(
          "PositionManager",
          `Failed to cancel orders for ${symbol}: ${err}`
        );
      }
      let orderId;
      if (partialPercent >= 100) {
        const initialOrder = await alpaca.closePosition(brokerSymbol);
        orderId = initialOrder.id;
      } else {
        const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
        if (!tradabilityCheck.tradable) {
          log.warn(
            "PositionManager",
            `Cannot partial close ${symbol}: not tradable`
          );
          return {
            success: false,
            action: "sell",
            reason: `Symbol not tradable: ${tradabilityCheck.reason || "Not in broker universe"}`,
            symbol
          };
        }
        const closeQty = partialQuantity(
          position.quantity,
          partialPercent
        ).toNumber();
        const orderParams = {
          symbol: brokerSymbol,
          qty: closeQty.toString(),
          side: "sell",
          type: "market",
          time_in_force: "day"
        };
        const queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "sell",
          decisionId: decision.aiDecisionId
        });
        orderId = queuedResult.orderId;
      }
      const fillResult = await waitForAlpacaOrderFill(orderId);
      if (!fillResult.order) {
        log.error(
          "PositionManager",
          `Close order ${orderId} - no order data received`
        );
        return {
          success: false,
          action: "sell",
          reason: "Close order failed - no response from broker",
          symbol,
          orderId
        };
      }
      if (!fillResult.hasFillData) {
        log.error("PositionManager", `Close order ${orderId} has no fill data`);
        return {
          success: false,
          action: "sell",
          reason: fillResult.timedOut ? "Close order fill timed out - position sync triggered" : "Close order rejected or no fill data",
          symbol,
          orderId
        };
      }
      if (fillResult.timedOut && !fillResult.isFullyFilled) {
        log.warn(
          "PositionManager",
          `Close order ${orderId} timed out with partial fill, using available data`
        );
      }
      const order = fillResult.order;
      let filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      if (filledPrice === 0) {
        filledPrice = await this.fetchCurrentPrice(symbol);
        if (filledPrice > 0) {
          log.info(
            "PositionManager",
            `Using market price ${filledPrice} for ${symbol}`
          );
        }
      }
      const pnl = calculatePnL(
        position.entryPrice,
        filledPrice,
        filledQty,
        "long"
      ).toNumber();
      const exitReason = decision.reasoning || (pnl > 0 ? "take_profit" : "stop_loss");
      if (!this.userId) {
        throw new Error("Cannot create trade: userId not initialized");
      }
      await storage.createTrade({
        userId: this.userId,
        symbol,
        side: "sell",
        quantity: filledQty.toString(),
        price: filledPrice.toString(),
        pnl: pnl.toString(),
        status: "completed",
        notes: `AI autonomous: ${decision.reasoning}`,
        traceId: this.currentTraceId
      });
      if (decision.aiDecisionId) {
        const marketStatus = await alpaca.getMarketStatus();
        updateTradeOutcomeOnClose(
          decision.aiDecisionId,
          filledPrice,
          exitReason,
          marketStatus.session
        ).catch(
          (err) => log.error("PositionManager", `Failed to update trade outcome: ${err}`)
        );
      }
      this.state.dailyPnl += pnl;
      this.state.dailyTradeCount++;
      if (partialPercent >= 100) {
        this.state.activePositions.delete(symbol);
        advancedRebalancingService.removePositionRules(symbol);
      } else {
        const remaining = toDecimal(position.quantity).minus(partialQuantity(position.quantity, partialPercent)).toNumber();
        position.quantity = remaining;
        this.state.activePositions.set(symbol, position);
      }
      log.trade(
        `Closed ${partialPercent}% of ${symbol}, P&L: $${pnl.toFixed(2)}`,
        { symbol, pnl, partialPercent }
      );
      return {
        success: true,
        orderId: order.id,
        action: "sell",
        reason: decision.reasoning,
        symbol,
        quantity: filledQty,
        price: filledPrice
      };
    } catch (error) {
      log.error("PositionManager", `Failed to close position ${symbol}`, {
        error: String(error)
      });
      return {
        success: false,
        action: "sell",
        reason: `Close failed: ${error}`,
        symbol,
        error: String(error)
      };
    }
  }
  // ============================================================================
  // POSITION REINFORCEMENT
  // ============================================================================
  /**
   * Reinforce an existing position by adding to it
   *
   * Scale-in buying strategy that adds to winning positions. Automatically
   * reduces position size to 50% of suggested quantity to manage risk when
   * pyramiding into existing positions.
   *
   * @async
   * @param {string} symbol - The symbol to reinforce
   * @param {AIDecision} decision - AI decision with reasoning for reinforcement
   * @param {PositionWithRules} existingPosition - Current position data (unused but kept for future enhancements)
   * @returns {Promise<ExecutionResult>} Execution result with success/failure status
   *
   * @risk-management
   * Automatically scales down buy size to 50% of suggested quantity to prevent
   * overexposure when adding to existing positions. This is a conservative approach
   * to pyramiding that limits downside if the position reverses.
   *
   * @example
   * ```typescript
   * const result = await positionManager.reinforcePosition('AAPL', {
   *   action: 'buy',
   *   confidence: 0.9,
   *   reasoning: 'Breakout confirmed, add to position',
   *   riskLevel: 'medium',
   *   suggestedQuantity: 0.04 // Will be scaled to 0.02 (50%)
   * }, existingPosition);
   * ```
   */
  async reinforcePosition(symbol, decision, existingPosition, executionContext) {
    log.info("PositionManager", `Reinforcing position: ${symbol}`, {
      strategyId: executionContext?.strategyId,
      strategyName: executionContext?.strategyName
    });
    const reinforceDecision = {
      ...decision,
      suggestedQuantity: (decision.suggestedQuantity || 0.05) * 0.5
    };
    return await this.openPosition(symbol, reinforceDecision, executionContext);
  }
  // ============================================================================
  // POSITION RULES CHECKING
  // ============================================================================
  /**
   * Check and apply position rules (stop-loss, take-profit, trailing stops)
   *
   * Comprehensive position rule checking system that evaluates all configured rules
   * in strict priority order. This is the core monitoring logic that runs periodically
   * to manage risk and lock in profits.
   *
   * @async
   * @param {string} symbol - The symbol to check
   * @param {PositionWithRules} position - Current position data with rules
   * @returns {Promise<void>}
   *
   * @rule-priority-order
   * Rules are checked in strict priority (highest to lowest):
   *
   * 1. STOP-LOSS (Highest Priority)
   *    - Triggers: currentPrice <= stopLossPrice
   *    - Action: Immediate 100% close with isStopLossTriggered flag
   *    - Purpose: Cut losses at predetermined level
   *
   * 2. EMERGENCY STOP
   *    - Triggers: unrealizedPnlPercent <= -8%
   *    - Action: Immediate 100% close with isEmergencyStop flag
   *    - Purpose: Hard stop to prevent catastrophic losses
   *
   * 3. GRADUATED TAKE-PROFITS (4-Tier System)
   *    - Tier 1: 10% profit  close 25%
   *    - Tier 2: 20% profit  close 25%
   *    - Tier 3: 35% profit  close 25%
   *    - Tier 4: 50% profit  close 25%
   *    - Purpose: Lock in profits progressively as position becomes more profitable
   *
   * 4. TRAILING STOP UPDATES
   *    - Dynamically adjusts stop-loss as position becomes profitable
   *    - Purpose: Protect profits while allowing position to run
   *
   * 5. MAX HOLDING PERIOD
   *    - Triggers: holding time > 168 hours (7 days)
   *    - Action: Close 100%
   *    - Purpose: Prevent stale positions, force capital rotation
   *
   * 6. LEGACY TAKE-PROFIT FALLBACK
   *    - Triggers: currentPrice >= takeProfitPrice
   *    - Action: Partial close (50%) if 10-15% profit, full close if >15%
   *    - Purpose: Backup exit logic if graduated system not registered
   *
   * @example
   * ```typescript
   * // Check rules for all positions
   * for (const [symbol, position] of positionManager.activePositions) {
   *   await positionManager.checkPositionRules(symbol, position);
   * }
   * ```
   */
  async checkPositionRules(symbol, position) {
    if (position.stopLossPrice && position.currentPrice <= position.stopLossPrice) {
      log.warn("PositionManager", `Stop-loss triggered for ${symbol}`);
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 1,
          reasoning: `Stop-loss triggered at $${position.stopLossPrice}`,
          riskLevel: "high"
        },
        position,
        100,
        { isStopLossTriggered: true }
      );
      return;
    }
    if (position.unrealizedPnlPercent <= -8) {
      log.warn(
        "PositionManager",
        `Emergency stop for ${symbol} at ${position.unrealizedPnlPercent.toFixed(1)}% loss`
      );
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 1,
          reasoning: `Emergency stop: ${position.unrealizedPnlPercent.toFixed(1)}% loss`,
          riskLevel: "high"
        },
        position,
        100,
        { isEmergencyStop: true }
      );
      return;
    }
    const partialTakeProfit = advancedRebalancingService.checkPartialTakeProfits(position);
    if (partialTakeProfit && partialTakeProfit.shouldClose) {
      log.info(
        "PositionManager",
        `Graduated take-profit for ${symbol}: ${partialTakeProfit.reason}`
      );
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 0.95,
          reasoning: partialTakeProfit.reason,
          riskLevel: "low"
        },
        position,
        partialTakeProfit.closePercent
      );
      return;
    }
    const trailingUpdate = advancedRebalancingService.updateTrailingStop(position);
    if (trailingUpdate) {
      log.info(
        "PositionManager",
        `Trailing stop update for ${symbol}: ${trailingUpdate.reason}`
      );
      position.stopLossPrice = trailingUpdate.newStopLoss;
      this.state.activePositions.set(symbol, position);
    }
    const holdingCheck = advancedRebalancingService.checkHoldingPeriod(position);
    if (holdingCheck && holdingCheck.exceeded) {
      log.warn(
        "PositionManager",
        `Max holding period exceeded for ${symbol}: ${holdingCheck.holdingHours.toFixed(1)}h > ${holdingCheck.maxHours}h`
      );
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 0.8,
          reasoning: `Max holding period exceeded (${holdingCheck.holdingHours.toFixed(1)} hours)`,
          riskLevel: "medium"
        },
        position,
        100
      );
      return;
    }
    if (position.takeProfitPrice && position.currentPrice >= position.takeProfitPrice) {
      log.info("PositionManager", `Legacy take-profit triggered for ${symbol}`);
      const pnlPercent = position.unrealizedPnlPercent;
      if (pnlPercent > 15) {
        await this.closePosition(
          symbol,
          {
            action: "sell",
            confidence: 1,
            reasoning: `Take-profit fully triggered at $${position.takeProfitPrice}`,
            riskLevel: "low"
          },
          position,
          100
        );
      } else if (pnlPercent > 10) {
        await this.closePosition(
          symbol,
          {
            action: "sell",
            confidence: 0.9,
            reasoning: `Partial take-profit at $${position.currentPrice}`,
            riskLevel: "low"
          },
          position,
          50
        );
      }
    }
  }
  // ============================================================================
  // POSITION RULES ADJUSTMENT
  // ============================================================================
  /**
   * Adjust stop-loss, take-profit, or trailing stop for a position
   *
   * @param symbol - The symbol to adjust
   * @param newStopLoss - New stop-loss price (optional)
   * @param newTakeProfit - New take-profit price (optional)
   * @param trailingStopPercent - New trailing stop percentage (optional)
   * @returns true if adjustment was successful
   */
  async adjustStopLossTakeProfit(symbol, newStopLoss, newTakeProfit, trailingStopPercent) {
    const position = this.state.activePositions.get(symbol);
    if (!position) {
      log.warn(
        "PositionManager",
        `Cannot adjust SL/TP: Position ${symbol} not found`
      );
      return false;
    }
    if (newStopLoss !== void 0) {
      if (newStopLoss >= position.currentPrice) {
        log.warn(
          "PositionManager",
          `Invalid stop loss: $${newStopLoss} >= current price $${position.currentPrice}`
        );
        return false;
      }
      position.stopLossPrice = newStopLoss;
    }
    if (newTakeProfit !== void 0) {
      if (newTakeProfit <= position.currentPrice) {
        log.warn(
          "PositionManager",
          `Invalid take profit: $${newTakeProfit} <= current price $${position.currentPrice}`
        );
        return false;
      }
      position.takeProfitPrice = newTakeProfit;
    }
    if (trailingStopPercent !== void 0) {
      if (trailingStopPercent <= 0 || trailingStopPercent >= 100) {
        log.warn(
          "PositionManager",
          `Invalid trailing stop percent: ${trailingStopPercent}`
        );
        return false;
      }
      position.trailingStopPercent = trailingStopPercent;
    }
    this.state.activePositions.set(symbol, position);
    log.info(
      "PositionManager",
      `Updated ${symbol} - SL: $${position.stopLossPrice?.toFixed(2)}, TP: $${position.takeProfitPrice?.toFixed(2)}, Trail: ${position.trailingStopPercent || "N/A"}%`
    );
    return true;
  }
  /**
   * Apply trailing stop to all profitable positions
   *
   * @param trailPercent - Trailing stop percentage (default: 5%)
   */
  async applyTrailingStopToAllPositions(trailPercent = 5) {
    for (const [symbol, position] of this.state.activePositions.entries()) {
      if (position.unrealizedPnlPercent > 0) {
        position.trailingStopPercent = trailPercent;
        this.state.activePositions.set(symbol, position);
        log.info(
          "PositionManager",
          `Applied ${trailPercent}% trailing stop to ${symbol}`
        );
      }
    }
  }
  // ============================================================================
  // HELPER METHODS
  // ============================================================================
  /**
   * Calculate total portfolio exposure as a percentage (using cached positions)
   */
  calculateTotalExposure(portfolioValue) {
    let totalValue = 0;
    for (const position of this.state.activePositions.values()) {
      totalValue += position.currentPrice * position.quantity;
    }
    return totalValue / portfolioValue * 100;
  }
  /**
   * Get real-time exposure from broker (not cached)
   *
   * Fetches current account and positions directly from Alpaca for accurate
   * exposure calculation before critical order decisions.
   *
   * @returns Promise with portfolioValue, currentExposure, and positionsCount
   */
  async getRealTimeExposure() {
    try {
      const [account, positions2] = await Promise.all([
        alpaca.getAccount(),
        alpaca.getPositions()
      ]);
      const portfolioValue = safeParseFloat(account.portfolio_value);
      const buyingPower = safeParseFloat(account.buying_power);
      let totalExposure = 0;
      const exposureDetails = [];
      for (const position of positions2) {
        const marketValue = safeParseFloat(position.market_value);
        const exposurePercent = marketValue / portfolioValue * 100;
        totalExposure += exposurePercent;
        exposureDetails.push({
          symbol: position.symbol,
          marketValue,
          exposurePercent
        });
      }
      log.debug("PositionManager", "Real-time exposure check", {
        portfolioValue,
        currentExposure: totalExposure.toFixed(2),
        positionsCount: positions2.length,
        buyingPower
      });
      return {
        portfolioValue,
        currentExposure: totalExposure,
        positionsCount: positions2.length,
        buyingPower,
        exposureDetails
      };
    } catch (error) {
      log.error("PositionManager", "Failed to get real-time exposure", {
        error: String(error)
      });
      throw error;
    }
  }
  /**
   * Validate exposure before opening a new position
   *
   * Performs a real-time broker check to ensure the new position won't exceed
   * exposure limits. This is more accurate than cached exposure calculations.
   *
   * @param positionSizePercent - Size of new position as percentage of portfolio
   * @returns Validation result with current exposure details
   */
  async validateExposureForNewPosition(positionSizePercent) {
    try {
      const exposure = await this.getRealTimeExposure();
      const projectedExposure = exposure.currentExposure + positionSizePercent;
      const maxExposure = this.riskLimits.maxTotalExposurePercent;
      if (projectedExposure > maxExposure) {
        return {
          canOpen: false,
          reason: `Would exceed max exposure: ${exposure.currentExposure.toFixed(1)}% + ${positionSizePercent.toFixed(1)}% = ${projectedExposure.toFixed(1)}% > ${maxExposure}%`,
          currentExposure: exposure.currentExposure,
          projectedExposure,
          maxExposure
        };
      }
      const account = await alpaca.getAccount();
      const buyingPower = safeParseFloat(account.buying_power);
      const portfolioValue = safeParseFloat(account.portfolio_value);
      const requiredCapital = portfolioValue * (positionSizePercent / 100);
      if (requiredCapital > buyingPower) {
        return {
          canOpen: false,
          reason: `Insufficient buying power: need $${requiredCapital.toFixed(2)} but only have $${buyingPower.toFixed(2)}`,
          currentExposure: exposure.currentExposure,
          projectedExposure,
          maxExposure
        };
      }
      return {
        canOpen: true,
        currentExposure: exposure.currentExposure,
        projectedExposure,
        maxExposure
      };
    } catch (error) {
      log.error("PositionManager", "Exposure validation failed", {
        error: String(error)
      });
      return {
        canOpen: false,
        reason: `Exposure check failed: ${error}`,
        currentExposure: 0,
        projectedExposure: 0,
        maxExposure: this.riskLimits.maxTotalExposurePercent
      };
    }
  }
  /**
   * Fetch current market price for a symbol
   */
  async fetchCurrentPrice(symbol) {
    try {
      const isCrypto = isCryptoSymbol4(symbol);
      if (isCrypto) {
        const normSymbol = normalizeCryptoSymbol4(symbol);
        const snapshots = await alpaca.getCryptoSnapshots([normSymbol]);
        const snapshot = snapshots[normSymbol];
        return snapshot?.latestTrade?.p || 0;
      } else {
        const snapshots = await alpaca.getSnapshots([symbol]);
        const snapshot = snapshots[symbol];
        return snapshot?.latestTrade?.p || 0;
      }
    } catch (error) {
      log.warn(
        "PositionManager",
        `Failed to fetch current price for ${symbol}`,
        { error: String(error) }
      );
      return 0;
    }
  }
};

// server/autonomous/rebalancing-manager.ts
init_alpaca();
init_logger();
init_candidatesService();
init_numeric();
init_money();
var ORDER_COOLDOWN_MS = 3e5;
var REBALANCE_THRESHOLD_PERCENT = 2;
var BUY_THE_DIP_THRESHOLD_PERCENT = 3;
var MIN_CASH_RESERVE_PERCENT = 10;
var MIN_BUY_VALUE = 50;
var MAX_BUY_PERCENT_OF_PORTFOLIO = 0.02;
var PYRAMID_MIN_PROFIT_PERCENT = 5;
var PYRAMID_MAX_PROFIT_PERCENT = 20;
var PYRAMID_POSITION_MULTIPLIER = 0.5;
var PYRAMID_MAX_PORTFOLIO_PERCENT = 0.05;
var RebalancingManager = class {
  orchestrator;
  riskLimits;
  orderCooldowns = /* @__PURE__ */ new Map();
  constructor(orchestrator2, riskLimits) {
    this.orchestrator = orchestrator2;
    this.riskLimits = riskLimits;
  }
  /**
   * Get the active positions from orchestrator state
   */
  get activePositions() {
    return this.orchestrator.state.activePositions;
  }
  /**
   * Get the current trace ID from orchestrator
   */
  get currentTraceId() {
    return this.orchestrator.currentTraceId;
  }
  /**
   * Main rebalancing method that coordinates all three strategies
   *
   * Orchestrates the complete rebalancing workflow, executing drift correction
   * and pyramid-up strategies. Syncs positions from broker first to ensure accuracy.
   *
   * @async
   * @returns {Promise<void>}
   *
   * @throws {Error} Caught and logged if rebalancing fails
   *
   * @execution-order
   * 1. Sync positions from broker (prevents quantity mismatches)
   * 2. Get account data (portfolio value, buying power, cash)
   * 3. Update orchestrator state with actual portfolio value
   * 4. Get approved symbols from candidatesService
   * 5. Execute drift rebalancing (sell overweight, buy underweight)
   * 6. Execute pyramid-up (add to winners in 5-20% profit zone)
   *
   * @example
   * ```typescript
   * await rebalancingManager.rebalancePositions();
   * // All three strategies have been evaluated and executed
   * ```
   */
  async rebalancePositions() {
    try {
      await this.orchestrator.syncPositionsFromBroker();
      const account = await alpaca.getAccount();
      const portfolioValue = parseFloat(account.portfolio_value);
      this.orchestrator.state.portfolioValue = portfolioValue;
      const buyingPower = safeParseFloat(account.buying_power);
      const availableCash = safeParseFloat(account.cash);
      if (portfolioValue <= 0) {
        log.warn(
          "RebalancingManager",
          "Cannot rebalance: invalid portfolio value"
        );
        return;
      }
      const targetAllocationPercent = this.riskLimits.maxPositionSizePercent;
      log.debug(
        "RebalancingManager",
        `Account status: cash=${availableCash.toFixed(2)}, buyingPower=${buyingPower.toFixed(2)}, portfolioValue=${portfolioValue.toFixed(2)}`
      );
      const approvedSymbols = await candidatesService.getApprovedSymbols();
      const approvedSet = new Set(approvedSymbols.map((s) => s.toUpperCase()));
      await this.executeDriftRebalancing(
        portfolioValue,
        buyingPower,
        availableCash,
        targetAllocationPercent,
        approvedSet
      );
      await this.executePyramidUp(portfolioValue, availableCash, approvedSet);
    } catch (error) {
      log.error("RebalancingManager", "Rebalancing error", {
        error: String(error)
      });
      this.orchestrator.state.errors.push(`Rebalancing failed: ${error}`);
    }
  }
  /**
   * Drift Rebalancing Strategy (lines 2277-2390)
   *
   * Handles two scenarios:
   * 1. Overweight positions (drift > +2%): Sell excess shares
   * 2. Underweight positions (drift < -3%): Buy-the-dip if at loss/breakeven
   */
  async executeDriftRebalancing(portfolioValue, buyingPower, availableCash, targetAllocationPercent, approvedSet) {
    for (const [symbol, position] of this.activePositions.entries()) {
      const positionValue2 = position.currentPrice * position.quantity;
      const currentAllocationPercent = positionValue2 / portfolioValue * 100;
      const drift = currentAllocationPercent - targetAllocationPercent;
      if (Math.abs(drift) > REBALANCE_THRESHOLD_PERCENT) {
        log.info(
          "RebalancingManager",
          `Position ${symbol} drifted by ${drift.toFixed(2)}%`
        );
        const cooldownUntil = this.orderCooldowns.get(symbol);
        if (cooldownUntil && Date.now() < cooldownUntil) {
          const remainingMs = cooldownUntil - Date.now();
          log.info(
            "RebalancingManager",
            `Skipping ${symbol}: on cooldown for ${Math.round(remainingMs / 1e3)}s after failed order`
          );
          continue;
        }
        if (drift > REBALANCE_THRESHOLD_PERCENT) {
          await this.handleOverweightPosition(
            symbol,
            position,
            portfolioValue,
            targetAllocationPercent,
            drift
          );
        } else if (drift < -BUY_THE_DIP_THRESHOLD_PERCENT) {
          await this.handleBuyTheDip(
            symbol,
            position,
            portfolioValue,
            buyingPower,
            targetAllocationPercent,
            approvedSet
          );
        }
      }
    }
  }
  /**
   * Handle overweight position by selling excess shares (lines 2293-2335)
   */
  async handleOverweightPosition(symbol, position, portfolioValue, targetAllocationPercent, drift) {
    const positionValue2 = position.currentPrice * position.quantity;
    const excessValue = positionValue2 - portfolioValue * targetAllocationPercent / 100;
    let sharesToSell = Math.floor(excessValue / position.currentPrice);
    const availableShares = Math.floor(position.availableQuantity);
    if (availableShares <= 0) {
      log.warn(
        "RebalancingManager",
        `Skipping rebalance for ${symbol}: no available shares (${position.availableQuantity} available, ${position.quantity - position.availableQuantity} held for orders)`
      );
      return;
    }
    if (sharesToSell > availableShares) {
      log.info(
        "RebalancingManager",
        `Limiting rebalance for ${symbol}: requested ${sharesToSell} but only ${availableShares} available`
      );
      sharesToSell = availableShares;
    }
    if (sharesToSell > 0 && sharesToSell < position.quantity) {
      log.info(
        "RebalancingManager",
        `Rebalancing: Selling ${sharesToSell} shares of ${symbol} (${availableShares} available)`
      );
      try {
        const result = await this.orchestrator.closePosition(
          symbol,
          {
            action: "sell",
            confidence: 0.8,
            reasoning: `Rebalancing: Position overweight by ${drift.toFixed(1)}%`,
            riskLevel: "low"
          },
          position,
          sharesToSell / position.quantity * 100
        );
        if (!result.success) {
          log.warn(
            "RebalancingManager",
            `Setting ${ORDER_COOLDOWN_MS / 1e3}s cooldown for ${symbol} after failed order: ${result.reason}`
          );
          this.orderCooldowns.set(symbol, Date.now() + ORDER_COOLDOWN_MS);
        } else {
          this.orderCooldowns.delete(symbol);
        }
      } catch (error) {
        log.error(
          "RebalancingManager",
          `Rebalance sell failed for ${symbol}: ${error.message}`
        );
        this.orderCooldowns.set(symbol, Date.now() + ORDER_COOLDOWN_MS);
      }
    }
  }
  /**
   * Handle buy-the-dip for underweight positions (lines 2336-2388)
   *
   * Requirements:
   * - Drift < -3%
   * - Symbol must be in approved candidates
   * - Min $50, Max 2% of portfolio
   * - Only buy at loss or breakeven (unrealizedPnlPercent <= 0)
   */
  async handleBuyTheDip(symbol, position, portfolioValue, buyingPower, targetAllocationPercent, approvedSet) {
    if (!approvedSet.has(symbol.toUpperCase())) {
      log.info(
        "RebalancingManager",
        `Skipping buy-the-dip for ${symbol}: not in approved candidates`
      );
      return;
    }
    const buyingPowerReserve = buyingPower * (MIN_CASH_RESERVE_PERCENT / 100);
    const availableForBuying = Math.max(0, buyingPower - buyingPowerReserve);
    if (availableForBuying <= 0 && buyingPower <= 0) {
      log.info(
        "RebalancingManager",
        `Skipping buy-the-dip for ${symbol}: no buying power (${buyingPower.toFixed(2)} available)`
      );
      return;
    }
    const positionValue2 = position.currentPrice * position.quantity;
    const deficitValue = portfolioValue * targetAllocationPercent / 100 - positionValue2;
    const buyValue = Math.min(
      deficitValue,
      Math.max(availableForBuying, buyingPower * 0.1),
      portfolioValue * MAX_BUY_PERCENT_OF_PORTFOLIO
    );
    if (buyValue >= MIN_BUY_VALUE && position.unrealizedPnlPercent <= 0) {
      log.info(
        "RebalancingManager",
        `Buy-the-dip: Adding $${buyValue.toFixed(2)} to underweight ${symbol} (at ${position.unrealizedPnlPercent.toFixed(1)}% loss)`
      );
      const isCrypto = isCryptoSymbol4(symbol);
      const brokerSymbol = isCrypto ? normalizeCryptoSymbol4(symbol) : symbol;
      try {
        const preCheck = await preTradeGuard(symbol, "buy", buyValue, isCrypto);
        if (!preCheck.canTrade) {
          log.warn(
            "RebalancingManager",
            `Buy-the-dip blocked for ${symbol}: ${preCheck.reason}`
          );
          return;
        }
        await queueOrderExecution({
          orderParams: {
            symbol: brokerSymbol,
            side: "buy",
            type: preCheck.useLimitOrder ? "limit" : "market",
            notional: buyValue.toFixed(2),
            time_in_force: "day",
            extended_hours: preCheck.useExtendedHours,
            ...preCheck.limitPrice && {
              limit_price: preCheck.limitPrice.toString()
            }
          },
          traceId: this.currentTraceId,
          symbol,
          side: "buy"
        });
        log.trade(`Buy-the-dip: ${symbol} $${buyValue.toFixed(2)}`, {
          symbol,
          value: buyValue
        });
      } catch (error) {
        log.error("RebalancingManager", `Buy-the-dip failed for ${symbol}`, {
          error: String(error)
        });
      }
    }
  }
  /**
   * Pyramid-Up Strategy (lines 2393-2463)
   *
   * Add to winning positions when:
   * - Position is at 5-20% profit (sweet spot)
   * - Symbol is in approved list
   * - Sufficient cash available
   * - Add 50% of original position value
   */
  async executePyramidUp(portfolioValue, availableCash, approvedSet) {
    const pyramidedThisCycle = /* @__PURE__ */ new Set();
    for (const [symbol, position] of this.activePositions.entries()) {
      if (pyramidedThisCycle.has(symbol) || !approvedSet.has(symbol.toUpperCase())) {
        continue;
      }
      if (position.unrealizedPnlPercent >= PYRAMID_MIN_PROFIT_PERCENT && position.unrealizedPnlPercent <= PYRAMID_MAX_PROFIT_PERCENT) {
        const cashReserve = portfolioValue * (MIN_CASH_RESERVE_PERCENT / 100);
        const availableForBuying = Math.max(0, availableCash - cashReserve);
        if (availableForBuying <= MIN_BUY_VALUE) {
          continue;
        }
        const originalPositionValue = toDecimal(position.quantity).times(position.entryPrice).toNumber();
        const pyramidValue = Math.min(
          originalPositionValue * PYRAMID_POSITION_MULTIPLIER,
          // 50% of original position
          availableForBuying,
          portfolioValue * PYRAMID_MAX_PORTFOLIO_PERCENT
          // Max 5% of portfolio per pyramid
        );
        if (pyramidValue >= MIN_BUY_VALUE) {
          log.info(
            "RebalancingManager",
            `Pyramid-up: Adding $${pyramidValue.toFixed(2)} (50% of original) to winning ${symbol} (at +${position.unrealizedPnlPercent.toFixed(1)}%)`
          );
          const isCrypto = isCryptoSymbol4(symbol);
          const brokerSymbol = isCrypto ? normalizeCryptoSymbol4(symbol) : symbol;
          try {
            const preCheck = await preTradeGuard(
              symbol,
              "buy",
              pyramidValue,
              isCrypto
            );
            if (!preCheck.canTrade) {
              log.warn(
                "RebalancingManager",
                `Pyramid-up blocked for ${symbol}: ${preCheck.reason}`
              );
              continue;
            }
            await queueOrderExecution({
              orderParams: {
                symbol: brokerSymbol,
                side: "buy",
                type: preCheck.useLimitOrder ? "limit" : "market",
                notional: pyramidValue.toFixed(2),
                time_in_force: "day",
                extended_hours: preCheck.useExtendedHours,
                ...preCheck.limitPrice && {
                  limit_price: preCheck.limitPrice.toString()
                }
              },
              traceId: this.currentTraceId,
              symbol,
              side: "buy"
            });
            pyramidedThisCycle.add(symbol);
            log.trade(
              `Pyramid-up: ${symbol} $${pyramidValue.toFixed(2)} (+${position.unrealizedPnlPercent.toFixed(1)}%)`,
              {
                symbol,
                value: pyramidValue,
                profitPercent: position.unrealizedPnlPercent
              }
            );
          } catch (error) {
            log.error("RebalancingManager", `Pyramid-up failed for ${symbol}`, {
              error: String(error)
            });
          }
        }
      }
    }
  }
  /**
   * Clear cooldown for a specific symbol
   */
  clearCooldown(symbol) {
    this.orderCooldowns.delete(symbol);
  }
  /**
   * Clear all cooldowns
   */
  clearAllCooldowns() {
    this.orderCooldowns.clear();
  }
  /**
   * Check if a symbol is on cooldown
   */
  isOnCooldown(symbol) {
    const cooldownUntil = this.orderCooldowns.get(symbol);
    if (!cooldownUntil) return false;
    return Date.now() < cooldownUntil;
  }
  /**
   * Get remaining cooldown time in milliseconds
   */
  getCooldownRemaining(symbol) {
    const cooldownUntil = this.orderCooldowns.get(symbol);
    if (!cooldownUntil) return 0;
    return Math.max(0, cooldownUntil - Date.now());
  }
};

// server/autonomous/orchestrator.ts
var AutonomousOrchestrator = class {
  state;
  config;
  riskLimits;
  analysisTimer = null;
  positionTimer = null;
  isProcessing = false;
  lastCalibrationDate = null;
  currentTraceId = null;
  userId = null;
  // Managers - initialized in constructor
  lifecycleManager;
  positionManager;
  rebalancingManager;
  constructor() {
    this.config = { ...DEFAULT_CONFIG };
    this.riskLimits = { ...DEFAULT_RISK_LIMITS };
    this.state = {
      isRunning: false,
      mode: "autonomous",
      lastAnalysisTime: null,
      lastPositionCheckTime: null,
      activePositions: /* @__PURE__ */ new Map(),
      pendingSignals: /* @__PURE__ */ new Map(),
      executionHistory: [],
      dailyPnl: 0,
      dailyTradeCount: 0,
      errors: []
    };
    this.lifecycleManager = new LifecycleManager(this);
    this.positionManager = new PositionManager2(
      this.state,
      this.riskLimits,
      this.userId
    );
    const orchestratorRef = {
      state: this.state,
      currentTraceId: this.currentTraceId,
      syncPositionsFromBroker: () => this.syncPositionsFromBroker(),
      closePosition: (symbol, decision, position, partialPercent) => this.positionManager.closePosition(
        symbol,
        decision,
        position,
        partialPercent
      )
    };
    this.rebalancingManager = new RebalancingManager(
      orchestratorRef,
      this.riskLimits
    );
  }
  // ============================================================================
  // ORCHESTRATOR INTERFACE (for LifecycleManager)
  // ============================================================================
  getState() {
    return { ...this.state };
  }
  setState(updates) {
    Object.assign(this.state, updates);
  }
  setUserId(userId) {
    this.userId = userId;
    this.positionManager.setUserId(userId);
  }
  // ============================================================================
  // LIFECYCLE DELEGATION
  // ============================================================================
  async autoStart() {
    return this.lifecycleManager.autoStart();
  }
  async setAutoStartEnabled(enabled) {
    return this.lifecycleManager.setAutoStartEnabled(enabled);
  }
  isAutoStartEnabledFlag() {
    return this.lifecycleManager.isAutoStartEnabledFlag();
  }
  getHealthStatus() {
    return this.lifecycleManager.getHealthStatus();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  async initialize() {
    await this.loadRiskLimitsFromDB();
    await this.syncPositionsFromBroker();
    const watchlist = await getWatchlist();
    const allSymbols = [
      ...watchlist.stocks,
      ...watchlist.crypto.map((c) => `${c}/USD`)
    ];
    await candidatesService.ensureWatchlistApproved(
      allSymbols,
      "orchestrator-init"
    );
    log.info("Orchestrator", "Initialized with risk limits", {
      ...this.riskLimits
    });
  }
  async loadRiskLimitsFromDB() {
    try {
      const agentStatus2 = await storage.getAgentStatus();
      const dynamicLimit = marketConditionAnalyzer.getCurrentOrderLimit();
      if (agentStatus2) {
        this.riskLimits = {
          maxPositionSizePercent: Number(agentStatus2.maxPositionSizePercent) || 10,
          maxTotalExposurePercent: Number(agentStatus2.maxTotalExposurePercent) || 50,
          maxPositionsCount: Number(agentStatus2.maxPositionsCount) || agentStatus2.dynamicOrderLimit || dynamicLimit || 10,
          dailyLossLimitPercent: Number(agentStatus2.dailyLossLimitPercent) || 5,
          killSwitchActive: agentStatus2.killSwitchActive || false
        };
        this.positionManager.updateRiskLimits(this.riskLimits);
        log.info("Orchestrator", "Loaded risk limits from DB", {
          maxPositionSizePercent: this.riskLimits.maxPositionSizePercent,
          maxTotalExposurePercent: this.riskLimits.maxTotalExposurePercent,
          maxPositionsCount: this.riskLimits.maxPositionsCount,
          dailyLossLimitPercent: this.riskLimits.dailyLossLimitPercent
        });
      }
    } catch (error) {
      log.error("Orchestrator", "Failed to load risk limits", {
        error: String(error)
      });
    }
  }
  // ============================================================================
  // POSITION SYNC (delegates to extracted module)
  // ============================================================================
  async syncPositionsFromBroker() {
    await syncPositionsFromBroker(this.state, this.userId);
  }
  // ============================================================================
  // START/STOP CONTROL
  // ============================================================================
  async start() {
    if (this.state.isRunning) {
      log.info("Orchestrator", "Already running");
      return;
    }
    await this.initialize();
    if (this.riskLimits.killSwitchActive) {
      log.warn("Orchestrator", "Kill switch is active - cannot start");
      throw new Error(
        "Kill switch is active. Disable it to start autonomous trading."
      );
    }
    alpacaTradingEngine.enableOrchestratorControl();
    log.info(
      "Orchestrator",
      "Enabled orchestrator control over AlpacaTradingEngine"
    );
    this.state.isRunning = true;
    this.state.mode = "autonomous";
    this.state.errors = [];
    await storage.updateAgentStatus({ isRunning: true });
    this.analysisTimer = setInterval(() => {
      this.runAnalysisCycle().catch((err) => {
        log.error("Orchestrator", "Analysis cycle error", {
          error: String(err)
        });
        this.state.errors.push(`Analysis error: ${err.message}`);
      });
    }, this.config.analysisIntervalMs);
    this.positionTimer = setInterval(() => {
      this.runPositionManagementCycle().catch((err) => {
        log.error("Orchestrator", "Position management error", {
          error: String(err)
        });
        this.state.errors.push(`Position mgmt error: ${err.message}`);
      });
    }, this.config.positionCheckIntervalMs);
    await this.runAnalysisCycle();
    await this.runPositionManagementCycle();
    log.info("Orchestrator", "Started autonomous trading mode");
  }
  async stop(preserveAutoStart = false) {
    if (!this.state.isRunning) {
      log.info("Orchestrator", "Not running");
      return;
    }
    this.state.isRunning = false;
    this.state.mode = "manual";
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
      this.analysisTimer = null;
    }
    if (this.positionTimer) {
      clearInterval(this.positionTimer);
      this.positionTimer = null;
    }
    this.lifecycleManager.stopHeartbeat();
    marketConditionAnalyzer.stop();
    alpacaTradingEngine.disableOrchestratorControl();
    log.info(
      "Orchestrator",
      "Disabled orchestrator control - AlpacaTradingEngine can now trade autonomously"
    );
    await storage.updateAgentStatus({ isRunning: false });
    log.info("Orchestrator", "Stopped autonomous trading mode");
  }
  // ============================================================================
  // KILL SWITCH
  // ============================================================================
  async activateKillSwitch(reason) {
    log.warn("Orchestrator", `KILL SWITCH ACTIVATED: ${reason}`);
    this.riskLimits.killSwitchActive = true;
    await this.stop();
    await storage.updateAgentStatus({ killSwitchActive: true });
    this.state.errors.push(`Kill switch activated: ${reason}`);
  }
  async deactivateKillSwitch() {
    this.riskLimits.killSwitchActive = false;
    await storage.updateAgentStatus({ killSwitchActive: false });
    log.info("Orchestrator", "Kill switch deactivated");
  }
  // ============================================================================
  // ANALYSIS CYCLE
  // ============================================================================
  async runAnalysisCycle() {
    if (this.isProcessing || !this.state.isRunning) return;
    this.isProcessing = true;
    const cycleId = log.generateCycleId();
    log.setCycleId(cycleId);
    this.currentTraceId = cycleId;
    this.positionManager.setTraceId(cycleId);
    try {
      const allSessions = tradingSessionManager.getAllSessionInfo();
      log.info("Orchestrator", "Running analysis cycle...", {
        cycleId,
        traceId: cycleId,
        marketSessions: {
          usEquities: allSessions.US_EQUITIES.session,
          crypto: allSessions.CRYPTO.session,
          usEquitiesOpen: allSessions.US_EQUITIES.isOpen,
          nextOpen: allSessions.US_EQUITIES.nextOpen?.toISOString()
        }
      });
      this.state.lastAnalysisTime = /* @__PURE__ */ new Date();
      await this.loadRiskLimitsFromDB();
      if (this.riskLimits.killSwitchActive) {
        log.info("Orchestrator", "Kill switch active - skipping analysis");
        return;
      }
      const canceledOrderCount = await cancelExpiredOrders();
      if (canceledOrderCount > 0) {
        log.info(
          "Orchestrator",
          `Analysis cycle: cleaned up ${canceledOrderCount} stale pending orders`
        );
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      if (this.lastCalibrationDate !== today) {
        this.lastCalibrationDate = today;
        runCalibrationAnalysis(30).catch(
          (err) => log.error("Orchestrator", `Calibration failed: ${err}`)
        );
        log.info("Orchestrator", "Daily AI calibration triggered");
      }
      if (this.checkDailyLossLimit()) {
        await this.activateKillSwitch("Daily loss limit exceeded");
        return;
      }
      const universe = await getAnalysisUniverseSymbols();
      const marketData = await fetchMarketData(universe);
      const allStrategies = await storage.getStrategies();
      const activeStrategies = allStrategies.filter(
        (s) => s.status === "paper" || s.status === "live"
      );
      for (const [symbol, data] of marketData.entries()) {
        const strategy = activeStrategies.find((s) => s.assets?.includes(symbol)) || activeStrategies[0];
        const executionContext = strategy ? parseStrategyContext(strategy) : null;
        try {
          const decision = await aiDecisionEngine.analyzeOpportunity(
            symbol,
            data,
            void 0,
            strategy ? {
              id: strategy.id,
              name: strategy.name,
              type: strategy.type,
              parameters: strategy.parameters ? JSON.parse(strategy.parameters) : void 0
            } : void 0,
            { traceId: this.currentTraceId || void 0 }
          );
          const minConfidence = executionContext?.params.entryRules.minConfidence ?? 0.7;
          if (decision.confidence >= minConfidence && decision.action !== "hold" && this.userId) {
            if (executionContext) {
              const validation = validateDecision(
                {
                  symbol,
                  action: decision.action,
                  confidence: decision.confidence,
                  reasoning: decision.reasoning
                },
                executionContext,
                this.state.activePositions.size
              );
              if (!validation.valid) {
                log.info("Orchestrator", `Decision blocked by strategy rules`, {
                  symbol,
                  action: decision.action,
                  reason: validation.reason,
                  strategyId: executionContext.strategyId
                });
                continue;
              }
              if (validation.warnings && validation.warnings.length > 0) {
                log.warn("Orchestrator", `Decision warnings`, {
                  symbol,
                  warnings: validation.warnings
                });
              }
            }
            const aiDecision = await storage.createAiDecision({
              userId: this.userId,
              strategyId: strategy?.id || null,
              symbol,
              action: decision.action,
              confidence: decision.confidence.toString(),
              reasoning: decision.reasoning,
              marketContext: JSON.stringify(data),
              status: "pending",
              traceId: this.currentTraceId
            });
            recordDecisionFeatures(aiDecision.id, symbol, {
              volatility: data.priceChangePercent24h ? Math.abs(data.priceChangePercent24h) / 10 : void 0,
              priceChangePercent: data.priceChangePercent24h,
              marketCondition: this.state.mode
            }).catch(
              (err) => log.error("Orchestrator", `Failed to record features: ${err}`)
            );
            if (decision.action === "buy" && decision.confidence >= minConfidence) {
              this.autoApproveSymbol(symbol).catch(
                (err) => log.warn(
                  "Orchestrator",
                  `Auto-approve failed for ${symbol}: ${err}`
                )
              );
            }
            this.state.pendingSignals.set(symbol, {
              ...decision,
              aiDecisionId: aiDecision.id,
              executionContext
            });
          }
        } catch (error) {
          log.error("Orchestrator", `Analysis failed for ${symbol}`, {
            error: String(error)
          });
        }
      }
      await this.processSignals();
    } finally {
      this.isProcessing = false;
    }
  }
  async autoApproveSymbol(symbol) {
    try {
      const upperSymbol = symbol.toUpperCase();
      const existing = await candidatesService.getCandidateBySymbol(upperSymbol);
      if (existing?.status === "APPROVED") {
        return;
      }
      if (existing) {
        await candidatesService.approveCandidate(
          upperSymbol,
          "ai-auto-approve"
        );
        log.info(
          "Orchestrator",
          `AUTO-APPROVED: ${upperSymbol} (was ${existing.status})`
        );
      } else {
        await candidatesService.ensureWatchlistApproved(
          [upperSymbol],
          "ai-signal"
        );
        await candidatesService.approveCandidate(
          upperSymbol,
          "ai-auto-approve"
        );
        log.info(
          "Orchestrator",
          `AUTO-APPROVED: ${upperSymbol} (new candidate)`
        );
      }
    } catch (error) {
      log.warn("Orchestrator", `Failed to auto-approve ${symbol}`, {
        error: String(error)
      });
    }
  }
  // ============================================================================
  // SIGNAL PROCESSING
  // ============================================================================
  async processSignals() {
    for (const [symbol, decision] of this.state.pendingSignals.entries()) {
      let result;
      try {
        result = await this.executeSignal(symbol, decision);
      } catch (error) {
        result = {
          success: false,
          action: "skip",
          reason: `Execution error: ${String(error)}`,
          symbol
        };
        log.error("Orchestrator", `Error executing signal for ${symbol}`, {
          error: String(error)
        });
      }
      this.state.executionHistory.push(result);
      if (decision.aiDecisionId) {
        try {
          if (result.success && result.action !== "hold" && result.action !== "skip") {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "executed",
              filledPrice: result.price?.toString(),
              filledAt: /* @__PURE__ */ new Date()
            });
          } else if (result.action === "hold") {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "skipped",
              skipReason: "Hold action - no trade executed"
            });
          } else if (result.action === "skip") {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "skipped",
              skipReason: result.reason || "Validation failed - trade skipped"
            });
          } else if (!result.success) {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "failed",
              skipReason: result.reason || result.error || "Order execution failed"
            });
            log.warn(
              "Orchestrator",
              `AI decision ${decision.aiDecisionId} failed`,
              {
                symbol,
                action: result.action,
                reason: result.reason,
                error: result.error
              }
            );
          } else {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "skipped",
              skipReason: result.reason || "Trade not executed"
            });
          }
        } catch (e) {
          log.error(
            "Orchestrator",
            `Failed to update AI decision status for ${decision.aiDecisionId}`,
            { error: String(e) }
          );
        }
      }
      if (this.state.executionHistory.length > 100) {
        this.state.executionHistory = this.state.executionHistory.slice(-100);
      }
    }
    this.state.pendingSignals.clear();
  }
  async executeSignal(symbol, decision) {
    const positionCount = this.state.activePositions.size;
    if (decision.action === "buy" && positionCount >= this.riskLimits.maxPositionsCount) {
      return {
        success: false,
        action: "skip",
        reason: `Max positions limit reached (${positionCount}/${this.riskLimits.maxPositionsCount})`,
        symbol
      };
    }
    const existingPosition = this.state.activePositions.get(symbol);
    const executionContext = decision.executionContext || null;
    if (decision.action === "buy" && existingPosition) {
      if (decision.confidence >= 0.5) {
        log.info(
          "Orchestrator",
          `Reinforcing position: ${symbol} (confidence: ${(decision.confidence * 100).toFixed(1)}%)`
        );
        return await this.positionManager.reinforcePosition(
          symbol,
          decision,
          existingPosition,
          executionContext
        );
      }
      return {
        success: false,
        action: "skip",
        reason: `Already have position, confidence ${(decision.confidence * 100).toFixed(1)}% below 50% threshold`,
        symbol
      };
    }
    if (decision.action === "sell" && !existingPosition) {
      return {
        success: false,
        action: "skip",
        reason: "No position to sell",
        symbol
      };
    }
    if (decision.action === "buy") {
      return await this.positionManager.openPosition(
        symbol,
        decision,
        executionContext
      );
    }
    if (decision.action === "sell" && existingPosition) {
      return await this.positionManager.closePosition(
        symbol,
        decision,
        existingPosition
      );
    }
    return {
      success: true,
      action: "hold",
      reason: decision.reasoning,
      symbol
    };
  }
  // ============================================================================
  // POSITION MANAGEMENT CYCLE
  // ============================================================================
  async runPositionManagementCycle() {
    if (!this.state.isRunning) return;
    try {
      this.state.lastPositionCheckTime = /* @__PURE__ */ new Date();
      await this.syncPositionsFromBroker();
      for (const [symbol, position] of this.state.activePositions.entries()) {
        await this.positionManager.checkPositionRules(symbol, position);
      }
      await this.rebalancingManager.rebalancePositions();
    } catch (error) {
      log.error("Orchestrator", "Position management cycle error", {
        error: String(error)
      });
    }
  }
  // ============================================================================
  // RISK CHECKS
  // ============================================================================
  checkDailyLossLimit() {
    const portfolioValue = this.state.portfolioValue || 1e5;
    const dailyLoss = Math.min(0, this.state.dailyPnl);
    const lossPercent = toDecimal(dailyLoss).abs().dividedBy(toDecimal(portfolioValue)).times(100).toNumber();
    return lossPercent >= this.riskLimits.dailyLossLimitPercent;
  }
  // ============================================================================
  // PUBLIC API
  // ============================================================================
  getPendingAnalysis() {
    const pending = [];
    for (const [symbol] of this.state.pendingSignals.entries()) {
      pending.push({
        symbol,
        startedAt: /* @__PURE__ */ new Date(),
        status: "pending_execution"
      });
    }
    return pending;
  }
  getRiskLimits() {
    return { ...this.riskLimits };
  }
  async updateRiskLimits(limits) {
    this.riskLimits = { ...this.riskLimits, ...limits };
    this.positionManager.updateRiskLimits(this.riskLimits);
    await storage.updateAgentStatus({
      maxPositionSizePercent: limits.maxPositionSizePercent?.toString(),
      maxTotalExposurePercent: limits.maxTotalExposurePercent?.toString(),
      maxPositionsCount: limits.maxPositionsCount,
      dailyLossLimitPercent: limits.dailyLossLimitPercent?.toString(),
      killSwitchActive: limits.killSwitchActive
    });
    log.info("Orchestrator", "Updated risk limits", { ...this.riskLimits });
  }
  async setMode(mode) {
    if (mode === "autonomous" && !this.state.isRunning) {
      await this.start();
    } else if (mode === "manual" && this.state.isRunning) {
      await this.stop();
    }
    this.state.mode = mode;
  }
  getMode() {
    return this.state.mode;
  }
  resetDailyStats() {
    this.state.dailyPnl = 0;
    this.state.dailyTradeCount = 0;
    log.info("Orchestrator", "Reset daily stats");
  }
  // Delegate to PositionManager
  async adjustStopLossTakeProfit(symbol, newStopLoss, newTakeProfit, trailingStopPercent) {
    return this.positionManager.adjustStopLossTakeProfit(
      symbol,
      newStopLoss,
      newTakeProfit,
      trailingStopPercent
    );
  }
  async applyTrailingStopToAllPositions(trailPercent = 5) {
    return this.positionManager.applyTrailingStopToAllPositions(trailPercent);
  }
  // Delegate to RebalancingManager
  async rebalancePositions() {
    return this.rebalancingManager.rebalancePositions();
  }
};
var orchestrator = new AutonomousOrchestrator();

// server/routes.ts
init_orchestration2();
init_work_queue();

// server/routes/backtests.ts
init_db();
init_schema2();
import { Router } from "express";

// server/services/backtesting/historical-data-service.ts
init_callExternal();
init_alpaca();
init_logger();
function transformAlpacaBar(bar, symbol) {
  return {
    ts: bar.t,
    open: bar.o,
    high: bar.h,
    low: bar.l,
    close: bar.c,
    volume: bar.v,
    vwap: bar.vw,
    symbol
  };
}
async function fetchBarsPage(symbol, timeframe, startDate, endDate, limit4, cacheKeySuffix, pageToken) {
  const cacheKeyStr = `bars:${symbol}:${timeframe}:${startDate}:${endDate}:${cacheKeySuffix}`;
  const endpoint = `bars/${symbol}/${timeframe}/${startDate}/${endDate}`;
  return callExternal(
    () => alpaca.getBars([symbol], timeframe, startDate, endDate, limit4, pageToken),
    {
      provider: "alpaca",
      endpoint,
      cacheKey: cacheKeyStr,
      budgetPolicy: {
        countAsMultiple: 1
      }
    }
  );
}
async function fetchHistoricalBars(options) {
  const {
    symbols,
    timeframe,
    startDate,
    endDate,
    maxBarsPerSymbol = 5e3
  } = options;
  const BATCH_LIMIT = 5e3;
  log.info(
    "HistoricalData",
    `Fetching bars for ${symbols.length} symbols from ${startDate} to ${endDate}`
  );
  const allBars = {};
  const barsCountBySymbol = {};
  let totalCacheHits = 0;
  let totalRequests = 0;
  let nextPageTokensUsed = 0;
  for (const symbol of symbols) {
    allBars[symbol] = [];
    let currentPageToken = null;
    let totalBarsForSymbol = 0;
    let hasMorePages = true;
    while (hasMorePages) {
      const tokenSuffix = currentPageToken || "first";
      try {
        const fetchResult = await fetchBarsPage(
          symbol,
          timeframe,
          startDate,
          endDate,
          BATCH_LIMIT,
          tokenSuffix,
          currentPageToken ?? void 0
        );
        totalRequests++;
        if (fetchResult.provenance.cacheStatus === "fresh") {
          totalCacheHits++;
        }
        const symbolBars = fetchResult.data.bars?.[symbol] || [];
        const transformedBars = symbolBars.map(
          (bar) => transformAlpacaBar(bar, symbol)
        );
        allBars[symbol].push(...transformedBars);
        totalBarsForSymbol += transformedBars.length;
        const nextToken = fetchResult.data.next_page_token ?? null;
        if (nextToken) {
          currentPageToken = nextToken;
          nextPageTokensUsed++;
        } else {
          hasMorePages = false;
        }
        if (totalBarsForSymbol >= maxBarsPerSymbol) {
          log.debug(
            "HistoricalData",
            `Reached max bars limit for ${symbol}: ${totalBarsForSymbol}`
          );
          hasMorePages = false;
        }
      } catch (error) {
        log.error(
          "HistoricalData",
          `Failed to fetch bars for ${symbol}: ${error}`
        );
        hasMorePages = false;
      }
    }
    barsCountBySymbol[symbol] = allBars[symbol].length;
    log.debug(
      "HistoricalData",
      `Fetched ${allBars[symbol].length} bars for ${symbol}`
    );
  }
  for (const symbol of symbols) {
    allBars[symbol].sort(
      (a, b) => new Date(a.ts).getTime() - new Date(b.ts).getTime()
    );
  }
  const cacheHitRate = totalRequests > 0 ? totalCacheHits / totalRequests : 0;
  const provenance = {
    provider: "alpaca",
    cacheHitRate,
    dataPulledAt: (/* @__PURE__ */ new Date()).toISOString(),
    barsCountBySymbol,
    timeframe,
    dateRange: { start: startDate, end: endDate },
    nextPageTokensUsed
  };
  log.info(
    "HistoricalData",
    `Completed fetching bars. Cache hit rate: ${(cacheHitRate * 100).toFixed(1)}%`
  );
  return { bars: allBars, provenance };
}

// server/services/backtesting/execution-engine.ts
init_money();
function calculateSlippage2(price, model, side) {
  if (model.type === "bps") {
    return calculateSlippage(price, model.value, side).toNumber();
  } else if (model.type === "spread_proxy") {
    const estimatedSpread = toDecimal(price).times(1e-3);
    const slippage = estimatedSpread.times(model.value);
    return side === "buy" ? slippage.toNumber() : slippage.negated().toNumber();
  }
  return 0;
}
function calculateFees(notional, model) {
  if (model.type === "fixed") {
    return model.value;
  } else if (model.type === "percentage") {
    return calculateFeePercent(notional, model.value).toNumber();
  }
  return 0;
}
function getExecutionPrice(bar, rule, slippageModel, side) {
  const basePrice = rule === "NEXT_OPEN" ? bar.open : bar.close;
  const slippage = calculateSlippage2(basePrice, slippageModel, side);
  return basePrice + slippage;
}
function calculateEquity(cash, positions2, prices) {
  let equity = toDecimal(cash);
  for (const [symbol, position] of Object.entries(positions2)) {
    const price = prices[symbol] || position.avgPrice;
    equity = equity.plus(positionValue(position.qty, price));
  }
  return equity.toNumber();
}
function calculateExposure(positions2, prices) {
  let totalValue = toDecimal(0);
  for (const [symbol, position] of Object.entries(positions2)) {
    const price = prices[symbol] || position.avgPrice;
    totalValue = totalValue.plus(positionValue(position.qty, price).abs());
  }
  return totalValue.toNumber();
}
function mergeAndSortBars(bars) {
  const allEntries = [];
  for (const [symbol, symbolBars] of Object.entries(bars)) {
    symbolBars.forEach((bar, index18) => {
      allEntries.push({
        symbol,
        bar,
        symbolBarIndex: index18,
        time: new Date(bar.ts).getTime()
      });
    });
  }
  allEntries.sort((a, b) => a.time - b.time);
  return allEntries.map(({ symbol, bar, symbolBarIndex }) => ({
    symbol,
    bar,
    symbolBarIndex
  }));
}
function runSimulation(bars, signalGenerator, config2) {
  const { runId, initialCash, feesModel, slippageModel, executionPriceRule } = config2;
  const positions2 = {};
  let cash = initialCash;
  const trades3 = [];
  const equityCurve = [];
  const tradePnLs = [];
  const equityHistory = [];
  const pendingSignals = {};
  const processedBarsBySymbol = {};
  const lastProcessedBarIndex = {};
  const currentPrices = {};
  for (const symbol of Object.keys(bars)) {
    pendingSignals[symbol] = [];
    processedBarsBySymbol[symbol] = [];
    lastProcessedBarIndex[symbol] = -1;
  }
  const sortedBars = mergeAndSortBars(bars);
  for (const { symbol, bar, symbolBarIndex } of sortedBars) {
    currentPrices[symbol] = bar.close;
    const symbolPendingSignals = pendingSignals[symbol] || [];
    const signalsToExecute = [];
    const signalsToKeep = [];
    for (const ps of symbolPendingSignals) {
      if (ps.signal.symbol === symbol && ps.signalBarIndex < symbolBarIndex) {
        signalsToExecute.push(ps);
      } else {
        signalsToKeep.push(ps);
      }
    }
    pendingSignals[symbol] = signalsToKeep;
    for (const { signal } of signalsToExecute) {
      const executionPrice = getExecutionPrice(
        bar,
        executionPriceRule,
        slippageModel,
        signal.side
      );
      const slippageAmount = calculateSlippage2(
        executionPriceRule === "NEXT_OPEN" ? bar.open : bar.close,
        slippageModel,
        signal.side
      );
      const notional = signal.qty * executionPrice;
      const fees = calculateFees(notional, feesModel);
      const currentPosition = positions2[symbol] || { qty: 0, avgPrice: 0 };
      let pnl = 0;
      let executedQty = 0;
      if (signal.side === "buy") {
        const totalCost = notional + fees;
        if (cash >= totalCost) {
          cash -= totalCost;
          executedQty = signal.qty;
          const newQty = currentPosition.qty + signal.qty;
          const newAvgPrice = currentPosition.qty > 0 ? (currentPosition.avgPrice * currentPosition.qty + executionPrice * signal.qty) / newQty : executionPrice;
          positions2[symbol] = { qty: newQty, avgPrice: newAvgPrice };
        } else {
          continue;
        }
      } else {
        executedQty = Math.min(signal.qty, currentPosition.qty);
        if (executedQty > 0) {
          const proceeds = executedQty * executionPrice - fees;
          pnl = (executionPrice - currentPosition.avgPrice) * executedQty - fees;
          cash += proceeds;
          tradePnLs.push(pnl);
          const remainingQty = currentPosition.qty - executedQty;
          if (remainingQty > 0) {
            positions2[symbol] = {
              qty: remainingQty,
              avgPrice: currentPosition.avgPrice
            };
          } else {
            delete positions2[symbol];
          }
        } else {
          continue;
        }
      }
      const tradeEvent = {
        id: `${runId}-${trades3.length}`,
        runId,
        ts: bar.ts,
        symbol,
        side: signal.side,
        qty: executedQty,
        price: executionPrice,
        reason: signal.reason,
        orderType: "market",
        fees,
        slippage: Math.abs(slippageAmount),
        positionAfter: positions2[symbol]?.qty || 0,
        cashAfter: cash
      };
      trades3.push(tradeEvent);
    }
    processedBarsBySymbol[symbol].push(bar);
    lastProcessedBarIndex[symbol] = symbolBarIndex;
    const newSignals = signalGenerator.onBar(bar, symbolBarIndex, [
      ...processedBarsBySymbol[symbol]
    ]);
    for (const signal of newSignals) {
      const targetSymbol = signal.symbol;
      if (targetSymbol === symbol) {
        pendingSignals[targetSymbol] = pendingSignals[targetSymbol] || [];
        pendingSignals[targetSymbol].push({
          signal,
          signalBarIndex: symbolBarIndex
        });
      }
    }
    const equity = calculateEquity(cash, positions2, currentPrices);
    const exposure = calculateExposure(positions2, currentPrices);
    equityHistory.push(equity);
    equityCurve.push({
      runId,
      ts: bar.ts,
      equity,
      cash,
      exposure
    });
  }
  const metrics = calculateMetrics(
    initialCash,
    equityHistory,
    tradePnLs,
    trades3,
    equityCurve
  );
  return { trades: trades3, equityCurve, metrics };
}
function calculateMetrics(initialCash, equityHistory, tradePnLs, trades3, equityCurve) {
  if (equityHistory.length === 0) {
    return {
      cagr: null,
      totalReturnPct: 0,
      maxDrawdownPct: 0,
      sharpeRatio: null,
      sortinoRatio: null,
      calmarRatio: null,
      winRatePct: 0,
      totalTrades: 0,
      profitFactor: null,
      avgWinPct: 0,
      avgLossPct: 0,
      expectancy: null,
      tradesPerMonth: null,
      avgHoldingPeriodDays: null
    };
  }
  const finalEquity = equityHistory[equityHistory.length - 1];
  if (!Number.isFinite(finalEquity) || initialCash <= 0) {
    return {
      cagr: null,
      totalReturnPct: 0,
      maxDrawdownPct: 0,
      sharpeRatio: null,
      sortinoRatio: null,
      calmarRatio: null,
      winRatePct: 0,
      totalTrades: tradePnLs.length,
      profitFactor: null,
      avgWinPct: 0,
      avgLossPct: 0,
      expectancy: null,
      tradesPerMonth: null,
      avgHoldingPeriodDays: null
    };
  }
  const totalReturnPct = (finalEquity - initialCash) / initialCash * 100;
  let maxDrawdownPct = 0;
  let peak = initialCash;
  for (const equity of equityHistory) {
    if (equity > peak) {
      peak = equity;
    }
    if (peak > 0) {
      const drawdown = (peak - equity) / peak * 100;
      if (drawdown > maxDrawdownPct) {
        maxDrawdownPct = drawdown;
      }
    }
  }
  const returns = [];
  for (let i = 1; i < equityHistory.length; i++) {
    const prevEquity = equityHistory[i - 1];
    if (prevEquity > 0 && Number.isFinite(prevEquity)) {
      const ret = (equityHistory[i] - prevEquity) / prevEquity;
      if (Number.isFinite(ret)) {
        returns.push(ret);
      }
    }
  }
  let sharpeRatio2 = null;
  let sortinoRatio = null;
  if (returns.length > 1) {
    const meanReturn = mean(returns).toNumber();
    const returnVariance = variance(returns).toNumber();
    const stdDev2 = Math.sqrt(returnVariance);
    if (stdDev2 > 1e-10 && Number.isFinite(stdDev2)) {
      sharpeRatio2 = sharpeRatio(returns, 0, 252).toNumber();
      if (!Number.isFinite(sharpeRatio2)) {
        sharpeRatio2 = null;
      }
    }
    const negativeReturns = returns.filter((r) => r < 0);
    if (negativeReturns.length > 0) {
      const downVariance = variance(negativeReturns).toNumber();
      const downStdDev = Math.sqrt(downVariance);
      if (downStdDev > 1e-10 && Number.isFinite(downStdDev)) {
        const annualizedMean = meanReturn * 252;
        const annualizedDownStd = downStdDev * Math.sqrt(252);
        if (annualizedDownStd > 0 && Number.isFinite(annualizedDownStd)) {
          sortinoRatio = annualizedMean / annualizedDownStd;
          if (!Number.isFinite(sortinoRatio)) {
            sortinoRatio = null;
          }
        }
      }
    }
  }
  const totalTrades = tradePnLs.length;
  const winningTrades = tradePnLs.filter((pnl) => pnl > 0);
  const losingTrades = tradePnLs.filter((pnl) => pnl < 0);
  const winRatePct = totalTrades > 0 ? winningTrades.length / totalTrades * 100 : 0;
  const grossProfit = winningTrades.reduce((sum, pnl) => sum + pnl, 0);
  const grossLoss = Math.abs(losingTrades.reduce((sum, pnl) => sum + pnl, 0));
  let profitFactor = null;
  if (grossLoss > 0) {
    profitFactor = grossProfit / grossLoss;
  } else if (grossProfit > 0) {
    profitFactor = null;
  } else {
    profitFactor = null;
  }
  if (profitFactor !== null && !Number.isFinite(profitFactor)) {
    profitFactor = null;
  }
  const avgWinPct = winningTrades.length > 0 && initialCash > 0 ? grossProfit / winningTrades.length / initialCash * 100 : 0;
  const avgLossPct = losingTrades.length > 0 && initialCash > 0 ? grossLoss / losingTrades.length / initialCash * 100 : 0;
  let cagr = null;
  if (equityHistory.length >= 252 && finalEquity > 0 && initialCash > 0) {
    const years = equityHistory.length / 252;
    const ratio = finalEquity / initialCash;
    if (ratio > 0 && years > 0) {
      cagr = (Math.pow(ratio, 1 / years) - 1) * 100;
      if (!Number.isFinite(cagr)) {
        cagr = null;
      }
    }
  }
  let calmarRatio = null;
  if (cagr !== null && maxDrawdownPct > 0) {
    calmarRatio = cagr / maxDrawdownPct;
    if (!Number.isFinite(calmarRatio)) {
      calmarRatio = null;
    }
  }
  let expectancy = null;
  if (totalTrades > 0) {
    const winRate = winRatePct / 100;
    const lossRate = 1 - winRate;
    expectancy = winRate * avgWinPct - lossRate * avgLossPct;
    if (!Number.isFinite(expectancy)) {
      expectancy = null;
    }
  }
  let tradesPerMonth = null;
  if (equityCurve.length >= 2 && totalTrades > 0) {
    const firstTs = new Date(equityCurve[0].ts).getTime();
    const lastTs = new Date(equityCurve[equityCurve.length - 1].ts).getTime();
    const elapsedMs = lastTs - firstTs;
    const elapsedDays = elapsedMs / (1e3 * 60 * 60 * 24);
    const months = elapsedDays / 30;
    if (months > 0) {
      tradesPerMonth = totalTrades / months;
      if (!Number.isFinite(tradesPerMonth)) {
        tradesPerMonth = null;
      }
    }
  }
  let avgHoldingPeriodDays = null;
  if (trades3.length > 0) {
    const positionEntries = {};
    const holdingPeriods = [];
    for (const trade of trades3) {
      const tradeTs = new Date(trade.ts).getTime();
      if (trade.side === "buy") {
        if (!positionEntries[trade.symbol]) {
          positionEntries[trade.symbol] = [];
        }
        positionEntries[trade.symbol].push({ ts: tradeTs, qty: trade.qty });
      } else if (trade.side === "sell") {
        const entries = positionEntries[trade.symbol] || [];
        let remainingToSell = trade.qty;
        while (remainingToSell > 0 && entries.length > 0) {
          const entry = entries[0];
          const qtyToMatch = Math.min(remainingToSell, entry.qty);
          const holdingMs = tradeTs - entry.ts;
          const holdingDays = holdingMs / (1e3 * 60 * 60 * 24);
          if (holdingDays >= 0) {
            holdingPeriods.push({ days: holdingDays, qty: qtyToMatch });
          }
          entry.qty -= qtyToMatch;
          remainingToSell -= qtyToMatch;
          if (entry.qty <= 0) {
            entries.shift();
          }
        }
      }
    }
    if (holdingPeriods.length > 0) {
      const totalQty = holdingPeriods.reduce((sum, hp) => sum + hp.qty, 0);
      const weightedDays = holdingPeriods.reduce(
        (sum, hp) => sum + hp.days * hp.qty,
        0
      );
      avgHoldingPeriodDays = totalQty > 0 ? weightedDays / totalQty : null;
      if (avgHoldingPeriodDays !== null && !Number.isFinite(avgHoldingPeriodDays)) {
        avgHoldingPeriodDays = null;
      }
    }
  }
  return {
    cagr,
    totalReturnPct: Number.isFinite(totalReturnPct) ? totalReturnPct : 0,
    maxDrawdownPct: Number.isFinite(maxDrawdownPct) ? maxDrawdownPct : 0,
    sharpeRatio: sharpeRatio2,
    sortinoRatio,
    calmarRatio,
    winRatePct: Number.isFinite(winRatePct) ? winRatePct : 0,
    totalTrades,
    profitFactor,
    avgWinPct: Number.isFinite(avgWinPct) ? avgWinPct : 0,
    avgLossPct: Number.isFinite(avgLossPct) ? avgLossPct : 0,
    expectancy,
    tradesPerMonth,
    avgHoldingPeriodDays
  };
}

// server/services/backtesting/backtest-runner.ts
init_db();
init_schema2();

// server/services/backtesting/strategies.ts
function createMovingAverageCrossoverStrategy(universe, initialCash, fastPeriod = 10, slowPeriod = 20, allocationPct = 10) {
  const state = /* @__PURE__ */ new Map();
  for (const symbol of universe) {
    state.set(symbol, { prices: [], position: "none", positionQty: 0 });
  }
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const signals = [];
      const symbol = bar.symbol;
      let symbolState = state.get(symbol);
      if (!symbolState) {
        symbolState = { prices: [], position: "none", positionQty: 0 };
        state.set(symbol, symbolState);
      }
      symbolState.prices.push(bar.close);
      if (symbolState.prices.length < slowPeriod) return signals;
      const recentPrices = symbolState.prices.slice(-slowPeriod);
      const fastMA = recentPrices.slice(-fastPeriod).reduce((a, b) => a + b, 0) / fastPeriod;
      const slowMA = recentPrices.reduce((a, b) => a + b, 0) / slowPeriod;
      if (symbolState.prices.length > slowPeriod) {
        const prevPrices = symbolState.prices.slice(-slowPeriod - 1, -1);
        const prevFastMA = prevPrices.slice(-fastPeriod).reduce((a, b) => a + b, 0) / fastPeriod;
        const prevSlowMA = prevPrices.reduce((a, b) => a + b, 0) / slowPeriod;
        if (prevFastMA <= prevSlowMA && fastMA > slowMA && symbolState.position === "none") {
          const allocationAmount = initialCash * (allocationPct / 100);
          const qty = Math.floor(allocationAmount / bar.close);
          if (qty > 0) {
            signals.push({
              symbol,
              side: "buy",
              qty,
              reason: `Bullish crossover: Fast MA (${fastMA.toFixed(2)}) crossed above Slow MA (${slowMA.toFixed(2)})`
            });
            symbolState.position = "long";
            symbolState.positionQty = qty;
          }
        } else if (prevFastMA >= prevSlowMA && fastMA < slowMA && symbolState.position === "long") {
          signals.push({
            symbol,
            side: "sell",
            qty: symbolState.positionQty,
            reason: `Bearish crossover: Fast MA (${fastMA.toFixed(2)}) crossed below Slow MA (${slowMA.toFixed(2)})`
          });
          symbolState.position = "none";
          symbolState.positionQty = 0;
        }
      }
      return signals;
    }
  };
}
function createRSIStrategy(universe, initialCash, period = 14, oversoldThreshold = 30, overboughtThreshold = 70, allocationPct = 10) {
  const state = /* @__PURE__ */ new Map();
  for (const symbol of universe) {
    state.set(symbol, {
      prices: [],
      position: "none",
      positionQty: 0,
      gains: [],
      losses: []
    });
  }
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const signals = [];
      const symbol = bar.symbol;
      let symbolState = state.get(symbol);
      if (!symbolState) {
        symbolState = {
          prices: [],
          position: "none",
          positionQty: 0,
          gains: [],
          losses: []
        };
        state.set(symbol, symbolState);
      }
      const prevPrice = symbolState.prices[symbolState.prices.length - 1];
      symbolState.prices.push(bar.close);
      if (prevPrice !== void 0) {
        const change = bar.close - prevPrice;
        symbolState.gains.push(change > 0 ? change : 0);
        symbolState.losses.push(change < 0 ? Math.abs(change) : 0);
      }
      if (symbolState.gains.length < period) return signals;
      const recentGains = symbolState.gains.slice(-period);
      const recentLosses = symbolState.losses.slice(-period);
      const avgGain = recentGains.reduce((a, b) => a + b, 0) / period;
      const avgLoss = recentLosses.reduce((a, b) => a + b, 0) / period;
      const rs = avgLoss > 0 ? avgGain / avgLoss : 100;
      const rsi = 100 - 100 / (1 + rs);
      if (rsi < oversoldThreshold && symbolState.position === "none") {
        const allocationAmount = initialCash * (allocationPct / 100);
        const qty = Math.floor(allocationAmount / bar.close);
        if (qty > 0) {
          signals.push({
            symbol,
            side: "buy",
            qty,
            reason: `RSI oversold: RSI (${rsi.toFixed(2)}) < ${oversoldThreshold}`
          });
          symbolState.position = "long";
          symbolState.positionQty = qty;
        }
      } else if (rsi > overboughtThreshold && symbolState.position === "long") {
        signals.push({
          symbol,
          side: "sell",
          qty: symbolState.positionQty,
          reason: `RSI overbought: RSI (${rsi.toFixed(2)}) > ${overboughtThreshold}`
        });
        symbolState.position = "none";
        symbolState.positionQty = 0;
      }
      return signals;
    }
  };
}
function createBuyAndHoldStrategy(universe, initialCash, allocationPct = 10) {
  const bought = /* @__PURE__ */ new Set();
  const positionQty = /* @__PURE__ */ new Map();
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const symbol = bar.symbol;
      if (!bought.has(symbol)) {
        const allocationAmount = initialCash * (allocationPct / 100);
        const qty = Math.floor(allocationAmount / bar.close);
        if (qty > 0) {
          bought.add(symbol);
          positionQty.set(symbol, qty);
          return [
            {
              symbol,
              side: "buy",
              qty,
              reason: `Buy and hold: Initial purchase of ${symbol}`
            }
          ];
        }
      }
      return [];
    }
  };
}
function createStrategy(strategyConfig, universe, initialCash) {
  const { type, params } = strategyConfig;
  switch (type) {
    case "moving_average_crossover":
      return createMovingAverageCrossoverStrategy(
        universe,
        initialCash,
        params.fastPeriod || 10,
        params.slowPeriod || 20,
        params.allocationPct || 10
      );
    case "rsi_oscillator":
      return createRSIStrategy(
        universe,
        initialCash,
        params.period || 14,
        params.oversoldThreshold || 30,
        params.overboughtThreshold || 70,
        params.allocationPct || 10
      );
    case "buy_and_hold":
    default:
      return createBuyAndHoldStrategy(
        universe,
        initialCash,
        params.allocationPct || 10
      );
  }
}

// server/services/backtesting/backtest-runner.ts
init_logger();
import { eq as eq15, desc as desc9 } from "drizzle-orm";
import crypto3 from "crypto";
function hashConfig(config2) {
  const sorted = JSON.stringify(config2, Object.keys(config2).sort());
  return crypto3.createHash("sha256").update(sorted).digest("hex").substring(0, 16);
}
async function runBacktest(params) {
  const startTime = Date.now();
  const configHash = hashConfig(params.strategyConfig);
  log.info(
    "BacktestRunner",
    `Starting backtest for ${params.universe.length} symbols from ${params.startDate} to ${params.endDate}`
  );
  const [insertedRun] = await db.insert(backtestRuns).values({
    status: "QUEUED",
    strategyId: params.strategyId || null,
    strategyConfigHash: configHash,
    strategyConfig: params.strategyConfig,
    universe: params.universe,
    broker: "alpaca",
    timeframe: params.timeframe,
    startDate: params.startDate,
    endDate: params.endDate,
    initialCash: params.initialCash.toString(),
    feesModel: params.feesModel,
    slippageModel: params.slippageModel,
    executionPriceRule: params.executionPriceRule,
    dataSource: "alpaca"
  }).returning();
  const runId = insertedRun.id;
  try {
    await db.update(backtestRuns).set({ status: "RUNNING", updatedAt: /* @__PURE__ */ new Date() }).where(eq15(backtestRuns.id, runId));
    log.info("BacktestRunner", `Fetching historical data for run ${runId}`);
    const { bars, provenance } = await fetchHistoricalBars({
      symbols: params.universe,
      timeframe: params.timeframe,
      startDate: params.startDate,
      endDate: params.endDate
    });
    const totalBars = Object.values(bars).reduce(
      (sum, arr) => sum + arr.length,
      0
    );
    log.info(
      "BacktestRunner",
      `Fetched ${totalBars} total bars for ${params.universe.length} symbols`
    );
    if (totalBars === 0) {
      const symbolsWithData = Object.entries(bars).filter(([_, symbolBars]) => symbolBars.length > 0).map(([symbol]) => symbol);
      const symbolsWithoutData = params.universe.filter(
        (s) => !symbolsWithData.includes(s)
      );
      throw new Error(
        `No historical data found for the specified date range (${params.startDate} to ${params.endDate}). Symbols without data: ${symbolsWithoutData.join(", ")}. Please verify the date range is valid and the symbols are active.`
      );
    }
    for (const symbol of params.universe) {
      const symbolBars = bars[symbol] || [];
      if (symbolBars.length === 0) {
        log.warn(
          "BacktestRunner",
          `No bars fetched for symbol ${symbol} - it may be inactive or date range invalid`
        );
      } else {
        log.debug(
          "BacktestRunner",
          `Symbol ${symbol}: ${symbolBars.length} bars`
        );
      }
    }
    const strategyConfig = {
      type: params.strategyType || "moving_average_crossover",
      params: params.strategyParams || {
        allocationPct: 10,
        fastPeriod: 10,
        slowPeriod: 20
      }
    };
    const signalGenerator = createStrategy(
      strategyConfig,
      params.universe,
      params.initialCash
    );
    const simConfig = {
      runId,
      initialCash: params.initialCash,
      feesModel: params.feesModel,
      slippageModel: params.slippageModel,
      executionPriceRule: params.executionPriceRule
    };
    log.info("BacktestRunner", `Running simulation for run ${runId}`);
    const result = runSimulation(bars, signalGenerator, simConfig);
    if (!result || !result.metrics) {
      throw new Error(
        "Simulation returned invalid results: metrics are null or undefined"
      );
    }
    const metrics = result.metrics;
    if (typeof metrics.totalReturnPct !== "number" || typeof metrics.maxDrawdownPct !== "number" || typeof metrics.winRatePct !== "number" || typeof metrics.totalTrades !== "number") {
      throw new Error(
        `Metrics calculation failed: invalid metric values - totalReturnPct=${metrics.totalReturnPct}, maxDrawdownPct=${metrics.maxDrawdownPct}, winRatePct=${metrics.winRatePct}, totalTrades=${metrics.totalTrades}`
      );
    }
    if (result.trades.length > 0) {
      const tradeInserts = result.trades.map((trade) => ({
        runId: trade.runId,
        ts: new Date(trade.ts),
        symbol: trade.symbol,
        side: trade.side,
        qty: trade.qty.toString(),
        price: trade.price.toString(),
        reason: trade.reason,
        orderType: trade.orderType,
        fees: trade.fees.toString(),
        slippage: trade.slippage.toString(),
        positionAfter: trade.positionAfter.toString(),
        cashAfter: trade.cashAfter.toString()
      }));
      const BATCH_SIZE = 100;
      for (let i = 0; i < tradeInserts.length; i += BATCH_SIZE) {
        const batch = tradeInserts.slice(i, i + BATCH_SIZE);
        await db.insert(backtestTradeEvents).values(batch);
      }
      log.info(
        "BacktestRunner",
        `Persisted ${result.trades.length} trade events`
      );
    }
    if (result.equityCurve.length > 0) {
      const sampleRate = Math.max(
        1,
        Math.floor(result.equityCurve.length / 1e3)
      );
      const sampledEquity = result.equityCurve.filter(
        (_, i) => i % sampleRate === 0
      );
      const equityInserts = sampledEquity.map((point) => ({
        runId: point.runId,
        ts: new Date(point.ts),
        equity: point.equity.toString(),
        cash: point.cash.toString(),
        exposure: point.exposure.toString()
      }));
      const BATCH_SIZE = 100;
      for (let i = 0; i < equityInserts.length; i += BATCH_SIZE) {
        const batch = equityInserts.slice(i, i + BATCH_SIZE);
        await db.insert(backtestEquityCurve).values(batch);
      }
      log.info(
        "BacktestRunner",
        `Persisted ${equityInserts.length} equity curve points (sampled from ${result.equityCurve.length})`
      );
    }
    const runtimeMs = Date.now() - startTime;
    const [updatedRun] = await db.update(backtestRuns).set({
      status: "DONE",
      provenance,
      resultsSummary: result.metrics,
      runtimeMs,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq15(backtestRuns.id, runId)).returning();
    log.info(
      "BacktestRunner",
      `Backtest ${runId} completed in ${runtimeMs}ms with ${result.trades.length} trades`
    );
    return mapToBacktestRun(updatedRun);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.error("BacktestRunner", `Backtest ${runId} failed: ${errorMessage}`);
    const [failedRun] = await db.update(backtestRuns).set({
      status: "FAILED",
      errorMessage,
      runtimeMs: Date.now() - startTime,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq15(backtestRuns.id, runId)).returning();
    return mapToBacktestRun(failedRun);
  }
}
function mapToBacktestRun(row) {
  return {
    id: row.id,
    createdAt: row.createdAt.toISOString(),
    updatedAt: row.updatedAt.toISOString(),
    status: row.status,
    strategyId: row.strategyId,
    strategyConfigHash: row.strategyConfigHash,
    strategyConfig: row.strategyConfig,
    universe: row.universe,
    broker: row.broker,
    timeframe: row.timeframe,
    startDate: row.startDate,
    endDate: row.endDate,
    initialCash: parseFloat(row.initialCash),
    feesModel: row.feesModel,
    slippageModel: row.slippageModel,
    executionPriceRule: row.executionPriceRule,
    dataSource: row.dataSource,
    provenance: row.provenance,
    resultsSummary: row.resultsSummary,
    errorMessage: row.errorMessage,
    runtimeMs: row.runtimeMs
  };
}
async function getBacktestRun(runId) {
  const [run] = await db.select().from(backtestRuns).where(eq15(backtestRuns.id, runId)).limit(1);
  if (!run) {
    return null;
  }
  return mapToBacktestRun(run);
}
async function listBacktestRuns(limit4 = 20, offset = 0) {
  const runs = await db.select().from(backtestRuns).orderBy(desc9(backtestRuns.createdAt)).limit(limit4).offset(offset);
  return runs.map(mapToBacktestRun);
}

// server/services/backtesting/walk-forward-engine.ts
init_logger();
var WalkForwardEngine = class {
  async runWalkForward(strategyType, symbols, baseParams, config2) {
    log.info("WalkForward", `Starting walk-forward optimization...`);
    log.info(
      "WalkForward",
      `IS: ${config2.inSampleDays}d, OOS: ${config2.outOfSampleDays}d, Step: ${config2.stepDays}d`
    );
    const windows = this.generateWindows(config2);
    log.info("WalkForward", `Generated ${windows.length} windows`);
    const windowResults = [];
    let previousParams = null;
    for (let i = 0; i < windows.length; i++) {
      const window = windows[i];
      log.info("WalkForward", `Processing window ${i + 1}/${windows.length}`);
      const optimizedParams = await this.optimizeParameters(
        symbols,
        baseParams,
        window.inSampleStart,
        window.inSampleEnd,
        config2
      );
      log.info(
        "WalkForward",
        `Optimized params for window ${i + 1}: ${JSON.stringify(optimizedParams)}`
      );
      const inSampleMetrics = await this.runBacktest(
        symbols,
        baseParams,
        window.inSampleStart,
        window.inSampleEnd,
        optimizedParams
      );
      const outOfSampleMetrics = await this.runBacktest(
        symbols,
        baseParams,
        window.outOfSampleStart,
        window.outOfSampleEnd,
        optimizedParams
      );
      const performanceDegradation = this.calculateDegradation(
        inSampleMetrics,
        outOfSampleMetrics,
        config2.optimizationMetric
      );
      const parameterStability = previousParams ? this.calculateParameterStability(
        previousParams,
        optimizedParams,
        config2.parameterRanges
      ) : 1;
      log.info(
        "WalkForward",
        `Window ${i + 1}: IS ${this.getOptimizationScore(inSampleMetrics, config2.optimizationMetric).toFixed(2)} -> OOS ${this.getOptimizationScore(outOfSampleMetrics, config2.optimizationMetric).toFixed(2)} (degradation: ${performanceDegradation.toFixed(1)}%)`
      );
      windowResults.push({
        windowIndex: i,
        inSampleStart: window.inSampleStart,
        inSampleEnd: window.inSampleEnd,
        outOfSampleStart: window.outOfSampleStart,
        outOfSampleEnd: window.outOfSampleEnd,
        optimizedParams,
        inSampleMetrics,
        outOfSampleMetrics,
        performanceDegradation,
        parameterStability
      });
      previousParams = optimizedParams;
    }
    const aggregateOOS = this.aggregateMetrics(
      windowResults.map((w) => w.outOfSampleMetrics)
    );
    const aggregateIS = this.aggregateMetrics(
      windowResults.map((w) => w.inSampleMetrics)
    );
    const overfittingScore = this.calculateOverfittingScore(
      windowResults,
      aggregateIS,
      aggregateOOS
    );
    const robustnessScore = this.calculateRobustnessScore(windowResults);
    const parameterStabilityScore = this.calculateParamStabilityScore(windowResults);
    log.info(
      "WalkForward",
      `Analysis complete - Overfitting: ${(overfittingScore * 100).toFixed(1)}%, Robustness: ${(robustnessScore * 100).toFixed(1)}%, Param Stability: ${(parameterStabilityScore * 100).toFixed(1)}%`
    );
    const { isOverfit, recommendations } = this.generateRecommendations(
      overfittingScore,
      robustnessScore,
      parameterStabilityScore,
      windowResults
    );
    return {
      config: config2,
      windows: windowResults,
      aggregateOOS,
      overfittingScore,
      robustnessScore,
      parameterStabilityScore,
      isOverfit,
      recommendations
    };
  }
  generateWindows(config2) {
    const windows = [];
    const totalDays = Math.floor(
      (config2.endDate.getTime() - config2.startDate.getTime()) / (1e3 * 60 * 60 * 24)
    );
    const windowSize = config2.inSampleDays + config2.outOfSampleDays;
    let currentStart = 0;
    while (currentStart + windowSize <= totalDays) {
      const inSampleStart = new Date(config2.startDate);
      inSampleStart.setDate(inSampleStart.getDate() + currentStart);
      const inSampleEnd = new Date(inSampleStart);
      inSampleEnd.setDate(inSampleEnd.getDate() + config2.inSampleDays);
      const outOfSampleStart = new Date(inSampleEnd);
      const outOfSampleEnd = new Date(outOfSampleStart);
      outOfSampleEnd.setDate(outOfSampleEnd.getDate() + config2.outOfSampleDays);
      windows.push({
        inSampleStart,
        inSampleEnd,
        outOfSampleStart,
        outOfSampleEnd
      });
      currentStart += config2.stepDays;
    }
    return windows;
  }
  async optimizeParameters(symbols, baseParams, startDate, endDate, config2) {
    const combinations = this.generateParameterCombinations(
      config2.parameterRanges
    );
    let bestParams = {};
    let bestScore = -Infinity;
    log.info(
      "WalkForward",
      `Testing ${combinations.length} parameter combinations...`
    );
    for (const params of combinations) {
      const metrics = await this.runBacktest(
        symbols,
        baseParams,
        startDate,
        endDate,
        params
      );
      if (metrics.tradeCount < config2.minTrades) continue;
      const score = this.getOptimizationScore(
        metrics,
        config2.optimizationMetric
      );
      if (score > bestScore) {
        bestScore = score;
        bestParams = params;
      }
    }
    if (Object.keys(bestParams).length === 0) {
      log.warn(
        "WalkForward",
        "No valid parameter combination found, using first combination"
      );
      bestParams = combinations[0] || {};
    }
    return bestParams;
  }
  generateParameterCombinations(ranges) {
    if (ranges.length === 0) return [{}];
    const first = ranges[0];
    const rest = ranges.slice(1);
    const restCombinations = this.generateParameterCombinations(rest);
    const combinations = [];
    for (let value = first.min; value <= first.max; value += first.step) {
      for (const restCombo of restCombinations) {
        combinations.push({
          [first.name]: value,
          ...restCombo
        });
      }
    }
    return combinations;
  }
  async runBacktest(symbols, baseParams, startDate, endDate, params) {
    const backtestParams = {
      ...baseParams,
      startDate: startDate.toISOString().split("T")[0],
      endDate: endDate.toISOString().split("T")[0],
      universe: symbols,
      strategyParams: params
    };
    try {
      const result = await runBacktest(backtestParams);
      if (!result.resultsSummary) {
        return this.createEmptyMetrics();
      }
      const summary = result.resultsSummary;
      return {
        totalReturn: summary.totalReturnPct,
        annualizedReturn: summary.cagr || 0,
        sharpeRatio: summary.sharpeRatio || 0,
        sortinoRatio: summary.sortinoRatio || 0,
        calmarRatio: summary.calmarRatio || 0,
        maxDrawdown: summary.maxDrawdownPct,
        winRate: summary.winRatePct,
        profitFactor: summary.profitFactor || 0,
        tradeCount: summary.totalTrades,
        avgTradeDuration: summary.avgHoldingPeriodDays || 0
      };
    } catch (error) {
      log.error(
        "WalkForward",
        `Backtest failed: ${error instanceof Error ? error.message : String(error)}`
      );
      return this.createEmptyMetrics();
    }
  }
  createEmptyMetrics() {
    return {
      totalReturn: 0,
      annualizedReturn: 0,
      sharpeRatio: 0,
      sortinoRatio: 0,
      calmarRatio: 0,
      maxDrawdown: 0,
      winRate: 0,
      profitFactor: 0,
      tradeCount: 0,
      avgTradeDuration: 0
    };
  }
  getOptimizationScore(metrics, metric) {
    switch (metric) {
      case "sharpe":
        return metrics.sharpeRatio;
      case "sortino":
        return metrics.sortinoRatio;
      case "calmar":
        return metrics.calmarRatio;
      case "returns":
        return metrics.annualizedReturn;
      case "profitFactor":
        return metrics.profitFactor;
      default:
        return metrics.sharpeRatio;
    }
  }
  calculateDegradation(is, oos, metric) {
    const isScore = this.getOptimizationScore(is, metric);
    const oosScore = this.getOptimizationScore(oos, metric);
    if (isScore === 0) return 0;
    return (isScore - oosScore) / Math.abs(isScore) * 100;
  }
  calculateParameterStability(prev, curr, ranges) {
    let totalDiff = 0;
    let totalRange = 0;
    for (const range of ranges) {
      const prevVal = prev[range.name] || 0;
      const currVal = curr[range.name] || 0;
      const rangeSize = range.max - range.min;
      if (rangeSize > 0) {
        totalDiff += Math.abs(prevVal - currVal) / rangeSize;
        totalRange += 1;
      }
    }
    return totalRange > 0 ? 1 - totalDiff / totalRange : 1;
  }
  aggregateMetrics(metrics) {
    const n = metrics.length;
    if (n === 0) return this.createEmptyMetrics();
    return {
      totalReturn: metrics.reduce((s, m) => s + m.totalReturn, 0) / n,
      annualizedReturn: metrics.reduce((s, m) => s + m.annualizedReturn, 0) / n,
      sharpeRatio: metrics.reduce((s, m) => s + m.sharpeRatio, 0) / n,
      sortinoRatio: metrics.reduce((s, m) => s + m.sortinoRatio, 0) / n,
      calmarRatio: metrics.reduce((s, m) => s + m.calmarRatio, 0) / n,
      maxDrawdown: Math.max(...metrics.map((m) => m.maxDrawdown)),
      winRate: metrics.reduce((s, m) => s + m.winRate, 0) / n,
      profitFactor: metrics.reduce((s, m) => s + m.profitFactor, 0) / n,
      tradeCount: metrics.reduce((s, m) => s + m.tradeCount, 0),
      avgTradeDuration: metrics.reduce((s, m) => s + m.avgTradeDuration, 0) / n
    };
  }
  calculateOverfittingScore(windows, aggIS, aggOOS) {
    const avgDegradation = windows.reduce((s, w) => s + w.performanceDegradation, 0) / windows.length;
    let score = Math.min(1, Math.max(0, avgDegradation / 100));
    if (aggIS.sharpeRatio > 0.5 && aggOOS.sharpeRatio < 0) {
      score = Math.min(1, score + 0.3);
    }
    return score;
  }
  calculateRobustnessScore(windows) {
    if (windows.length === 0) return 0;
    const profitableWindows = windows.filter(
      (w) => w.outOfSampleMetrics.totalReturn > 0
    );
    const profitableRatio = profitableWindows.length / windows.length;
    const oosSharpes = windows.map((w) => w.outOfSampleMetrics.sharpeRatio);
    const avgSharpe = oosSharpes.reduce((a, b) => a + b, 0) / oosSharpes.length;
    const sharpeStdDev = Math.sqrt(
      oosSharpes.reduce((s, v) => s + Math.pow(v - avgSharpe, 2), 0) / oosSharpes.length
    );
    const consistencyScore = Math.max(0, 1 - sharpeStdDev / 2);
    return profitableRatio * 0.6 + consistencyScore * 0.4;
  }
  calculateParamStabilityScore(windows) {
    if (windows.length < 2) return 1;
    const stabilities = windows.slice(1).map((w) => w.parameterStability);
    return stabilities.reduce((a, b) => a + b, 0) / stabilities.length;
  }
  generateRecommendations(overfitting, robustness, paramStability, windows) {
    const recommendations = [];
    const isOverfit = overfitting > 0.4 || robustness < 0.5;
    if (overfitting > 0.6) {
      recommendations.push(
        "HIGH OVERFITTING: Reduce parameter complexity or add regularization"
      );
    } else if (overfitting > 0.4) {
      recommendations.push(
        "MODERATE OVERFITTING: Consider simpler strategy rules"
      );
    }
    if (robustness < 0.4) {
      recommendations.push(
        "LOW ROBUSTNESS: Strategy may not work in live trading"
      );
    } else if (robustness < 0.6) {
      recommendations.push(
        "MODERATE ROBUSTNESS: Exercise caution with live deployment"
      );
    }
    if (paramStability < 0.6) {
      recommendations.push(
        "UNSTABLE PARAMETERS: Optimal params change significantly between periods"
      );
      recommendations.push(
        "Consider using parameter averaging or ensemble approach"
      );
    }
    const negativeWindows = windows.filter(
      (w) => w.outOfSampleMetrics.sharpeRatio < 0
    );
    if (negativeWindows.length > windows.length * 0.3) {
      recommendations.push(
        `WARNING: ${negativeWindows.length}/${windows.length} windows had negative OOS Sharpe`
      );
    }
    const negativeReturns = windows.filter(
      (w) => w.outOfSampleMetrics.totalReturn < 0
    );
    if (negativeReturns.length > windows.length * 0.4) {
      recommendations.push(
        `WARNING: ${negativeReturns.length}/${windows.length} windows had negative OOS returns`
      );
    }
    if (recommendations.length === 0) {
      recommendations.push(
        "Strategy appears robust with acceptable overfitting levels"
      );
      recommendations.push(
        "Consider live paper trading before deploying with real capital"
      );
    }
    return { isOverfit, recommendations };
  }
};
var walkForwardEngine = new WalkForwardEngine();

// server/routes/backtests.ts
init_logger();
init_sanitization();
import { eq as eq16 } from "drizzle-orm";

// server/lib/standard-errors.ts
init_logger();
function sendError(res, statusCode, error, message, details) {
  const errorResponse = {
    error,
    message,
    statusCode,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (details) {
    errorResponse.details = details;
  }
  return res.status(statusCode).json(errorResponse);
}
function badRequest(res, message = "Invalid request parameters", details) {
  return sendError(res, 400, "Bad Request", message, details);
}
function unauthorized(res, message = "Authentication required", details) {
  return sendError(res, 401, "Unauthorized", message, details);
}
function notFound(res, message = "Resource not found", details) {
  return sendError(res, 404, "Not Found", message, details);
}
function validationError(res, message = "Validation failed", details) {
  return sendError(res, 422, "Validation Error", message, details);
}
function serverError(res, message = "An internal server error occurred", details) {
  return sendError(res, 500, "Internal Server Error", message, details);
}
function fromZodError(res, zodError) {
  const issues = zodError.errors || zodError.issues || [];
  const details = issues.map((err) => ({
    field: err.path.join("."),
    message: err.message
  }));
  return validationError(res, "Request validation failed", { fields: details });
}
function isZodError(error) {
  return typeof error === "object" && error !== null && "name" in error && error.name === "ZodError";
}
function isHttpError(error) {
  return error instanceof Error && "statusCode" in error;
}
function asyncHandler(fn) {
  return (req, res, next) => {
    Promise.resolve(fn(req, res, next)).catch((error) => {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      const errorStack = error instanceof Error ? error.stack : void 0;
      log.error("AsyncHandler", "Error caught in async handler", {
        error: errorMessage,
        stack: errorStack
      });
      if (isZodError(error)) {
        return fromZodError(res, error);
      }
      if (isHttpError(error)) {
        return sendError(
          res,
          error.statusCode || 500,
          error.name || "Error",
          error.message
        );
      }
      return serverError(res, errorMessage || "An unexpected error occurred", {
        stack: process.env.NODE_ENV === "development" ? errorStack : void 0
      });
    });
  };
}
var AppError = class extends Error {
  constructor(statusCode, message, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = "AppError";
    Error.captureStackTrace(this, this.constructor);
  }
};
function badRequestError(message = "Invalid request parameters", details) {
  const error = new AppError(400, message, details);
  error.name = "Bad Request";
  return error;
}
function notFoundError(message = "Resource not found", details) {
  const error = new AppError(404, message, details);
  error.name = "Not Found";
  return error;
}

// server/middleware/requireAuth.ts
var requireAuth = (req, res, next) => {
  if (!req.userId) {
    unauthorized(res, "Authentication required");
    return;
  }
  next();
};
var requireAdmin = (req, res, next) => {
  if (!req.userId) {
    unauthorized(res, "Authentication required");
    return;
  }
  next();
};

// server/routes/backtests.ts
var router = Router();
router.post("/run", requireAuth, async (req, res) => {
  try {
    const {
      strategyId,
      strategyConfig,
      universe,
      timeframe = "1Day",
      startDate,
      endDate,
      initialCash = 1e4,
      feesModel = { type: "fixed", value: 1 },
      slippageModel = { type: "bps", value: 5 },
      executionPriceRule = "NEXT_OPEN",
      strategyType = "moving_average_crossover",
      strategyParams = {}
    } = req.body;
    if (universe && !Array.isArray(universe)) {
      return res.status(400).json({ error: "universe must be an array of symbols" });
    }
    const defaultUniverse = ["SPY", "QQQ", "AAPL"];
    const backtestUniverse = universe && universe.length > 0 ? universe : defaultUniverse;
    if (backtestUniverse.length === 0) {
      return res.status(400).json({
        error: "universe must contain at least one symbol. Default symbols: SPY, QQQ, AAPL"
      });
    }
    if (!startDate || !endDate) {
      return res.status(400).json({ error: "startDate and endDate are required" });
    }
    const validStrategyTypes = [
      "moving_average_crossover",
      "rsi_oscillator",
      "buy_and_hold"
    ];
    if (strategyType && !validStrategyTypes.includes(strategyType)) {
      return res.status(400).json({
        error: `Invalid strategyType. Must be one of: ${validStrategyTypes.join(", ")}`
      });
    }
    const sanitizedUniverse = sanitizeArray(backtestUniverse);
    const result = await runBacktest({
      strategyId,
      strategyConfig: strategyConfig || {},
      universe: sanitizedUniverse,
      timeframe,
      startDate,
      endDate,
      initialCash,
      feesModel,
      slippageModel,
      executionPriceRule,
      strategyType,
      strategyParams: {
        fastPeriod: strategyParams.fastPeriod || 10,
        slowPeriod: strategyParams.slowPeriod || 20,
        period: strategyParams.period || 14,
        oversoldThreshold: strategyParams.oversoldThreshold || 30,
        overboughtThreshold: strategyParams.overboughtThreshold || 70,
        allocationPct: strategyParams.allocationPct || 10,
        ...strategyParams
      }
    });
    res.json(result);
  } catch (error) {
    log.error("BacktestAPI", `Failed to run backtest: ${error}`);
    res.status(500).json({ error: error.message || "Failed to run backtest" });
  }
});
router.get("/", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    const runs = await listBacktestRuns(limit4, offset);
    res.json({ runs, limit: limit4, offset });
  } catch (error) {
    log.error("BacktestAPI", `Failed to list backtests: ${error}`);
    res.status(500).json({ error: "Failed to list backtests" });
  }
});
router.get("/:id", requireAuth, async (req, res) => {
  try {
    const run = await getBacktestRun(req.params.id);
    if (!run) {
      return res.status(404).json({ error: "Backtest not found" });
    }
    res.json(run);
  } catch (error) {
    log.error("BacktestAPI", `Failed to get backtest: ${error}`);
    res.status(500).json({ error: "Failed to get backtest" });
  }
});
router.get(
  "/:id/equity-curve",
  requireAuth,
  async (req, res) => {
    try {
      const points = await db.select().from(backtestEquityCurve).where(eq16(backtestEquityCurve.runId, req.params.id)).orderBy(backtestEquityCurve.ts);
      const formattedPoints = points.map((p) => ({
        ts: p.ts.toISOString(),
        equity: parseFloat(p.equity),
        cash: parseFloat(p.cash),
        exposure: parseFloat(p.exposure)
      }));
      res.json({ points: formattedPoints });
    } catch (error) {
      log.error("BacktestAPI", `Failed to get equity curve: ${error}`);
      res.status(500).json({ error: "Failed to get equity curve" });
    }
  }
);
router.get("/:id/trades", requireAuth, async (req, res) => {
  try {
    const trades3 = await db.select().from(backtestTradeEvents).where(eq16(backtestTradeEvents.runId, req.params.id)).orderBy(backtestTradeEvents.ts);
    const formattedTrades = trades3.map((t) => ({
      id: t.id,
      runId: t.runId,
      ts: t.ts.toISOString(),
      symbol: t.symbol,
      side: t.side,
      qty: parseFloat(t.qty),
      price: parseFloat(t.price),
      reason: t.reason,
      orderType: t.orderType,
      fees: parseFloat(t.fees),
      slippage: parseFloat(t.slippage),
      positionAfter: parseFloat(t.positionAfter),
      cashAfter: parseFloat(t.cashAfter)
    }));
    res.json({ trades: formattedTrades });
  } catch (error) {
    log.error("BacktestAPI", `Failed to get trades: ${error}`);
    res.status(500).json({ error: "Failed to get trades" });
  }
});
var backtests_default = router;

// server/routes/traces.ts
init_db();
init_schema2();
init_logger();
import { Router as Router2 } from "express";
import { eq as eq17, desc as desc11, and as and12, or as or2, like as like3 } from "drizzle-orm";
var tracesRouter = Router2();
tracesRouter.get("/:traceId", async (req, res) => {
  const { traceId } = req.params;
  if (!traceId) {
    return res.status(400).json({ error: "traceId is required" });
  }
  try {
    const [decisionResults, llmCallResults, workItemResults, tradeResults] = await Promise.all([
      db.select().from(aiDecisions).where(eq17(aiDecisions.traceId, traceId)),
      db.select().from(llmCalls).where(eq17(llmCalls.traceId, traceId)).orderBy(desc11(llmCalls.createdAt)),
      db.select().from(workItems).where(
        or2(
          like3(workItems.payload, `%${traceId}%`),
          like3(workItems.result, `%${traceId}%`)
        )
      ),
      Promise.resolve([])
    ]);
    const decision = decisionResults[0] || null;
    let relatedTrades = [];
    if (decision?.executedTradeId) {
      relatedTrades = await db.select().from(trades).where(eq17(trades.id, decision.executedTradeId));
    }
    const events = [];
    if (decision) {
      events.push({
        timestamp: decision.createdAt,
        type: "decision",
        id: decision.id,
        status: decision.status,
        details: {
          symbol: decision.symbol,
          action: decision.action,
          confidence: decision.confidence
        }
      });
    }
    for (const call of llmCallResults) {
      events.push({
        timestamp: call.createdAt,
        type: "llm_call",
        id: call.id,
        status: call.status,
        details: {
          role: call.role,
          provider: call.provider,
          model: call.model,
          tokensUsed: call.totalTokens,
          latencyMs: call.latencyMs
        }
      });
    }
    for (const item of workItemResults) {
      events.push({
        timestamp: item.nextRunAt,
        type: "work_item",
        id: item.id,
        status: item.status,
        details: {
          type: item.type,
          attempts: item.attempts,
          brokerOrderId: item.brokerOrderId
        }
      });
    }
    for (const trade of relatedTrades) {
      events.push({
        timestamp: trade.executedAt,
        type: "trade",
        id: trade.id,
        status: trade.status,
        details: {
          symbol: trade.symbol,
          side: trade.side,
          quantity: trade.quantity,
          price: trade.price
        }
      });
    }
    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    const totalTokens = llmCallResults.reduce(
      (sum, c) => sum + (c.totalTokens || 0),
      0
    );
    const estimatedCost = llmCallResults.reduce(
      (sum, c) => sum + parseFloat(c.estimatedCost || "0"),
      0
    );
    const totalLatency = llmCallResults.reduce(
      (sum, c) => sum + (c.latencyMs || 0),
      0
    );
    const providersUsed = [...new Set(llmCallResults.map((c) => c.provider))];
    let finalOutcome = "unknown";
    if (relatedTrades.length > 0) {
      finalOutcome = relatedTrades[0].status;
    } else if (decision?.status === "executed") {
      finalOutcome = "executed";
    } else if (decision?.status === "skipped") {
      finalOutcome = `skipped: ${decision.skipReason || "unknown"}`;
    } else if (decision) {
      finalOutcome = decision.status;
    } else if (llmCallResults.length > 0) {
      finalOutcome = "pending";
    }
    const response = {
      traceId,
      events,
      decision: decision ? {
        id: decision.id,
        symbol: decision.symbol,
        action: decision.action,
        confidence: decision.confidence ? parseFloat(decision.confidence) : null,
        reasoning: decision.reasoning,
        status: decision.status,
        createdAt: decision.createdAt
      } : void 0,
      llmCalls: llmCallResults.map((c) => {
        let purpose = null;
        let criticality = null;
        try {
          if (c.metadata) {
            const meta = JSON.parse(c.metadata);
            purpose = meta.purpose || null;
            criticality = meta.criticality || null;
          }
        } catch {
        }
        return {
          id: c.id,
          role: c.role,
          provider: c.provider,
          model: c.model,
          purpose: c.purpose || purpose,
          criticality: c.criticality || criticality,
          tokensUsed: c.totalTokens,
          latencyMs: c.latencyMs,
          status: c.status,
          createdAt: c.createdAt
        };
      }),
      workItems: workItemResults.map((w) => ({
        id: w.id,
        type: w.type,
        status: w.status,
        attempts: w.attempts,
        brokerOrderId: w.brokerOrderId,
        symbol: w.symbol,
        result: w.result
      })),
      trades: relatedTrades.map((t) => ({
        id: t.id,
        symbol: t.symbol,
        side: t.side,
        quantity: t.quantity,
        price: t.price,
        status: t.status,
        executedAt: t.executedAt
      })),
      summary: {
        totalLLMCalls: llmCallResults.length,
        totalTokens,
        estimatedCost,
        latencyMs: totalLatency,
        providersUsed,
        finalOutcome
      }
    };
    log.debug("Traces", "Trace lookup complete", {
      traceId,
      eventsCount: events.length,
      llmCallsCount: llmCallResults.length
    });
    return res.json(response);
  } catch (error) {
    log.error("Traces", "Failed to fetch trace", {
      traceId,
      error: String(error)
    });
    return res.status(500).json({ error: "Failed to fetch trace" });
  }
});
tracesRouter.get("/", async (req, res) => {
  const { limit: limitStr = "20", symbol, status } = req.query;
  const limit4 = Math.min(parseInt(limitStr, 10) || 20, 100);
  try {
    let query = db.select({
      traceId: aiDecisions.traceId,
      id: aiDecisions.id,
      symbol: aiDecisions.symbol,
      action: aiDecisions.action,
      status: aiDecisions.status,
      createdAt: aiDecisions.createdAt
    }).from(aiDecisions);
    const conditions = [];
    if (symbol) {
      conditions.push(eq17(aiDecisions.symbol, symbol));
    }
    if (status) {
      conditions.push(eq17(aiDecisions.status, status));
    }
    conditions.push(eq17(aiDecisions.traceId, aiDecisions.traceId));
    if (conditions.length > 0) {
      query = query.where(and12(...conditions));
    }
    const results = await query.orderBy(desc11(aiDecisions.createdAt)).limit(limit4);
    return res.json({
      traces: results.filter((r) => r.traceId),
      total: results.length
    });
  } catch (error) {
    log.error("Traces", "Failed to list traces", { error: String(error) });
    return res.status(500).json({ error: "Failed to list traces" });
  }
});

// server/observability/routes.ts
init_db();
init_schema2();
init_logger();
import { Router as Router3 } from "express";
import { eq as eq19, desc as desc13, and as and14, or as or3, like as like4, gte as gte6, sql as sql26, count as count2 } from "drizzle-orm";

// server/observability/alertService.ts
init_db();
init_schema2();
init_logger();
import { eq as eq18, desc as desc12, gte as gte5, sql as sql25, and as and13, count } from "drizzle-orm";
var AlertService = class {
  evaluationInterval = null;
  async getMetricsSnapshot() {
    const now = /* @__PURE__ */ new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
    const [
      queueCounts,
      llmStats,
      orchestratorStatus,
      oldestPending,
      retryCount
    ] = await Promise.all([
      db.select({
        status: workItems.status,
        count: count()
      }).from(workItems).groupBy(workItems.status),
      db.select({
        total: count(),
        errors: sql25`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte5(llmCalls.createdAt, oneHourAgo)),
      db.select().from(agentStatus).limit(1),
      db.select({
        createdAt: workItems.createdAt
      }).from(workItems).where(eq18(workItems.status, "PENDING")).orderBy(workItems.createdAt).limit(1),
      db.select({
        count: count()
      }).from(workItems).where(
        and13(
          gte5(workItems.attempts, 1),
          gte5(workItems.updatedAt, new Date(now.getTime() - 60 * 1e3))
        )
      )
    ]);
    const counts = {};
    queueCounts.forEach((c) => {
      counts[c.status] = Number(c.count);
    });
    const llmTotal = Number(llmStats[0]?.total || 0);
    const llmErrors = Number(llmStats[0]?.errors || 0);
    const llmErrorRate = llmTotal > 0 ? llmErrors / llmTotal * 100 : 0;
    const lastHeartbeat = orchestratorStatus[0]?.lastHeartbeat;
    const orchestratorLastRunMinutesAgo = lastHeartbeat ? (now.getTime() - new Date(lastHeartbeat).getTime()) / 6e4 : Infinity;
    const oldestPendingAge = oldestPending[0]?.createdAt ? (now.getTime() - new Date(oldestPending[0].createdAt).getTime()) / 6e4 : 0;
    return {
      deadLetterCount: counts["DEAD_LETTER"] || 0,
      pendingCount: counts["PENDING"] || 0,
      runningCount: counts["RUNNING"] || 0,
      failedCount: counts["FAILED"] || 0,
      succeededCount: counts["SUCCEEDED"] || 0,
      oldestPendingAgeMinutes: oldestPendingAge,
      llmCallsLastHour: llmTotal,
      llmErrorsLastHour: llmErrors,
      llmErrorRate,
      orchestratorLastRunMinutesAgo,
      retryRatePerMinute: Number(retryCount[0]?.count || 0)
    };
  }
  async createRule(input) {
    const [rule] = await db.insert(alertRules).values({
      name: input.name,
      description: input.description || null,
      ruleType: input.ruleType,
      condition: input.condition,
      threshold: String(input.threshold),
      enabled: input.enabled ?? true,
      webhookUrl: input.webhookUrl || null
    }).returning();
    log.info("AlertService", "Created alert rule", {
      ruleId: rule.id,
      name: rule.name
    });
    return rule;
  }
  async getRules() {
    return db.select().from(alertRules).orderBy(desc12(alertRules.createdAt));
  }
  async getRule(id) {
    const [rule] = await db.select().from(alertRules).where(eq18(alertRules.id, id));
    return rule || null;
  }
  async toggleRule(id, enabled) {
    const [rule] = await db.update(alertRules).set({ enabled, updatedAt: /* @__PURE__ */ new Date() }).where(eq18(alertRules.id, id)).returning();
    return rule || null;
  }
  async deleteRule(id) {
    const result = await db.delete(alertRules).where(eq18(alertRules.id, id));
    return true;
  }
  async evaluateRules() {
    const enabledRules = await db.select().from(alertRules).where(eq18(alertRules.enabled, true));
    const metrics = await this.getMetricsSnapshot();
    const triggered = [];
    for (const rule of enabledRules) {
      const condition = rule.condition;
      const threshold = parseFloat(rule.threshold);
      let currentValue = 0;
      switch (rule.ruleType) {
        case "dead_letter_count":
          currentValue = metrics.deadLetterCount;
          break;
        case "retry_rate":
          currentValue = metrics.retryRatePerMinute;
          break;
        case "orchestrator_silent":
          currentValue = metrics.orchestratorLastRunMinutesAgo;
          break;
        case "llm_error_rate":
          currentValue = metrics.llmErrorRate;
          break;
        default:
          continue;
      }
      const shouldTrigger = this.evaluateCondition(
        currentValue,
        condition.operator,
        threshold
      );
      await db.update(alertRules).set({ lastCheckedAt: /* @__PURE__ */ new Date() }).where(eq18(alertRules.id, rule.id));
      if (shouldTrigger) {
        triggered.push(rule.name);
        await this.triggerAlert(rule, currentValue);
      }
    }
    return { triggered, checked: enabledRules.length };
  }
  evaluateCondition(value, operator, threshold) {
    switch (operator) {
      case ">":
        return value > threshold;
      case "<":
        return value < threshold;
      case ">=":
        return value >= threshold;
      case "<=":
        return value <= threshold;
      case "==":
        return value === threshold;
      default:
        return false;
    }
  }
  async triggerAlert(rule, triggeredValue) {
    const [event] = await db.insert(alertEvents).values({
      ruleId: rule.id,
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue: String(triggeredValue),
      threshold: rule.threshold,
      status: "triggered",
      webhookSent: false
    }).returning();
    await db.update(alertRules).set({ lastTriggeredAt: /* @__PURE__ */ new Date() }).where(eq18(alertRules.id, rule.id));
    log.warn("AlertService", "Alert triggered", {
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue,
      threshold: rule.threshold
    });
    if (rule.webhookUrl) {
      await this.sendWebhook(rule, event, triggeredValue);
    }
  }
  async sendWebhook(rule, event, triggeredValue) {
    if (!rule.webhookUrl) return;
    const payload = {
      alertId: event.id,
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue,
      threshold: parseFloat(rule.threshold),
      triggeredAt: event.createdAt.toISOString(),
      service: "ai-active-trader",
      severity: "warning"
    };
    try {
      const response = await fetch(rule.webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      await db.update(alertEvents).set({
        webhookSent: true,
        webhookResponse: `${response.status} ${response.statusText}`
      }).where(eq18(alertEvents.id, event.id));
      log.info("AlertService", "Webhook sent successfully", {
        ruleName: rule.name,
        webhookUrl: rule.webhookUrl,
        status: response.status
      });
    } catch (error) {
      await db.update(alertEvents).set({
        webhookSent: false,
        webhookResponse: String(error)
      }).where(eq18(alertEvents.id, event.id));
      log.error("AlertService", "Webhook failed", {
        ruleName: rule.name,
        error: String(error)
      });
    }
  }
  async getRecentEvents(limit4 = 50) {
    return db.select().from(alertEvents).orderBy(desc12(alertEvents.createdAt)).limit(limit4);
  }
  async testAlert(ruleId) {
    const rule = await this.getRule(ruleId);
    if (!rule) {
      return { success: false, message: "Rule not found" };
    }
    if (!rule.webhookUrl) {
      return { success: false, message: "No webhook URL configured" };
    }
    const testPayload = {
      alertId: "test-" + Date.now(),
      ruleName: rule.name + " (TEST)",
      ruleType: rule.ruleType,
      triggeredValue: parseFloat(rule.threshold),
      threshold: parseFloat(rule.threshold),
      triggeredAt: (/* @__PURE__ */ new Date()).toISOString(),
      service: "ai-active-trader",
      severity: "test"
    };
    try {
      const response = await fetch(rule.webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(testPayload)
      });
      return {
        success: response.ok,
        message: `Webhook returned ${response.status} ${response.statusText}`
      };
    } catch (error) {
      return {
        success: false,
        message: String(error)
      };
    }
  }
  startEvaluationJob(intervalMs = 3e4) {
    if (this.evaluationInterval) {
      return;
    }
    log.info("AlertService", "Starting alert evaluation job", { intervalMs });
    this.evaluationInterval = setInterval(async () => {
      try {
        const result = await this.evaluateRules();
        if (result.triggered.length > 0) {
          log.warn("AlertService", "Alert evaluation complete", {
            checked: result.checked,
            triggered: result.triggered
          });
        }
      } catch (error) {
        log.error("AlertService", "Alert evaluation failed", {
          error: String(error)
        });
      }
    }, intervalMs);
  }
  stopEvaluationJob() {
    if (this.evaluationInterval) {
      clearInterval(this.evaluationInterval);
      this.evaluationInterval = null;
      log.info("AlertService", "Stopped alert evaluation job");
    }
  }
};
var alertService = new AlertService();

// server/observability/routes.ts
init_work_queue();
var observabilityRouter = Router3();
observabilityRouter.get("/health", async (req, res) => {
  try {
    const now = /* @__PURE__ */ new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
    const [
      queueCounts,
      oldestPending,
      llmStatsHour,
      llmStatsDay,
      orchestratorStatus
    ] = await Promise.all([
      db.select({
        status: workItems.status,
        count: count2()
      }).from(workItems).groupBy(workItems.status),
      db.select({
        createdAt: workItems.createdAt
      }).from(workItems).where(eq19(workItems.status, "PENDING")).orderBy(workItems.createdAt).limit(1),
      db.select({
        total: count2(),
        errors: sql26`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte6(llmCalls.createdAt, oneHourAgo)),
      db.select({
        total: count2(),
        errors: sql26`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte6(llmCalls.createdAt, oneDayAgo)),
      db.select().from(agentStatus).limit(1)
    ]);
    const counts = {};
    queueCounts.forEach((c) => {
      counts[c.status] = Number(c.count);
    });
    const oldestPendingAge = oldestPending[0]?.createdAt ? Math.round(
      (now.getTime() - new Date(oldestPending[0].createdAt).getTime()) / 6e4
    ) : 0;
    const agent = orchestratorStatus[0];
    const lastHeartbeat = agent?.lastHeartbeat;
    const minutesSinceHeartbeat = lastHeartbeat ? Math.round((now.getTime() - new Date(lastHeartbeat).getTime()) / 6e4) : null;
    const llmHour = llmStatsHour[0] || { total: 0, errors: 0 };
    const llmDay = llmStatsDay[0] || { total: 0, errors: 0 };
    const response = {
      queue: {
        pending: counts["PENDING"] || 0,
        running: counts["RUNNING"] || 0,
        succeeded: counts["SUCCEEDED"] || 0,
        failed: counts["FAILED"] || 0,
        deadLetter: counts["DEAD_LETTER"] || 0,
        oldestPendingAgeMinutes: oldestPendingAge
      },
      orchestrator: {
        isRunning: agent?.isRunning ?? false,
        lastHeartbeat: lastHeartbeat?.toISOString() || null,
        minutesSinceHeartbeat,
        killSwitchActive: agent?.killSwitchActive ?? false,
        dynamicOrderLimit: agent?.dynamicOrderLimit ?? 10,
        marketCondition: agent?.marketCondition || "unknown"
      },
      llm: {
        lastHour: {
          calls: Number(llmHour.total),
          errors: Number(llmHour.errors),
          errorRate: llmHour.total > 0 ? (Number(llmHour.errors) / Number(llmHour.total) * 100).toFixed(2) + "%" : "0%"
        },
        last24Hours: {
          calls: Number(llmDay.total),
          errors: Number(llmDay.errors),
          errorRate: llmDay.total > 0 ? (Number(llmDay.errors) / Number(llmDay.total) * 100).toFixed(
            2
          ) + "%" : "0%"
        }
      },
      fetchedAt: now.toISOString(),
      sources: {
        queue: "db:work_items",
        orchestrator: "db:agent_status",
        llm: "db:llm_calls"
      }
    };
    return res.json(response);
  } catch (error) {
    log.error("Observability", "Health endpoint failed", {
      error: String(error)
    });
    return res.status(500).json({ error: "Failed to fetch health data" });
  }
});
observabilityRouter.get(
  "/metrics/summary",
  async (req, res) => {
    try {
      const metrics = await alertService.getMetricsSnapshot();
      return res.json({
        metrics,
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
        source: "db/computed"
      });
    } catch (error) {
      log.error("Observability", "Metrics summary failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch metrics" });
    }
  }
);
observabilityRouter.get(
  "/work-queue/items",
  async (req, res) => {
    try {
      const { status, type, traceId, limit: limitStr = "50" } = req.query;
      const limit4 = Math.min(parseInt(limitStr, 10) || 50, 200);
      const conditions = [];
      if (status && status !== "all") {
        conditions.push(eq19(workItems.status, status));
      }
      if (type) {
        conditions.push(eq19(workItems.type, type));
      }
      if (traceId) {
        conditions.push(like4(workItems.payload, `%${traceId}%`));
      }
      let query = db.select().from(workItems);
      if (conditions.length > 0) {
        query = query.where(and14(...conditions));
      }
      const items = await query.orderBy(desc13(workItems.createdAt)).limit(limit4);
      return res.json({
        items,
        total: items.length
      });
    } catch (error) {
      log.error("Observability", "Work queue list failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch work queue items" });
    }
  }
);
observabilityRouter.get(
  "/work-queue/items/:id",
  async (req, res) => {
    try {
      const { id } = req.params;
      const item = await workQueue.getById(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      let parsedPayload = null;
      try {
        if (item.payload) {
          parsedPayload = JSON.parse(item.payload);
        }
      } catch {
      }
      return res.json({
        ...item,
        parsedPayload
      });
    } catch (error) {
      log.error("Observability", "Work item fetch failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch work item" });
    }
  }
);
observabilityRouter.post(
  "/work-queue/items/:id/retry",
  async (req, res) => {
    try {
      const { id } = req.params;
      const item = await workQueue.retryDeadLetter(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found or not a dead letter" });
      }
      log.info("Observability", "Work item retried", { id, type: item.type });
      return res.json({ success: true, item });
    } catch (error) {
      log.error("Observability", "Work item retry failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to retry work item" });
    }
  }
);
observabilityRouter.post(
  "/work-queue/items/:id/cancel",
  async (req, res) => {
    try {
      const { id } = req.params;
      const item = await workQueue.getById(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      if (item.status !== "PENDING") {
        return res.status(400).json({ error: "Only pending items can be cancelled" });
      }
      await workQueue.markDeadLetter(id, "Cancelled by admin");
      log.info("Observability", "Work item cancelled", { id, type: item.type });
      return res.json({ success: true, message: "Work item cancelled" });
    } catch (error) {
      log.error("Observability", "Work item cancel failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to cancel work item" });
    }
  }
);
observabilityRouter.post(
  "/work-queue/items/:id/dead-letter",
  async (req, res) => {
    try {
      const { id } = req.params;
      const { reason = "Force dead-lettered by admin" } = req.body;
      await workQueue.markDeadLetter(id, reason);
      log.info("Observability", "Work item force dead-lettered", {
        id,
        reason
      });
      return res.json({
        success: true,
        message: "Work item moved to dead letter"
      });
    } catch (error) {
      log.error("Observability", "Force dead-letter failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to dead-letter work item" });
    }
  }
);
observabilityRouter.get(
  "/trace/:traceId",
  async (req, res) => {
    const { traceId } = req.params;
    if (!traceId) {
      return res.status(400).json({ error: "traceId is required" });
    }
    try {
      const [decisionResults, llmCallResults, workItemResults, tradeResults] = await Promise.all([
        db.select().from(aiDecisions).where(eq19(aiDecisions.traceId, traceId)),
        db.select().from(llmCalls).where(eq19(llmCalls.traceId, traceId)).orderBy(desc13(llmCalls.createdAt)),
        db.select().from(workItems).where(
          or3(
            like4(workItems.payload, `%${traceId}%`),
            like4(workItems.result, `%${traceId}%`)
          )
        ),
        db.select().from(trades).where(eq19(trades.traceId, traceId))
      ]);
      const totalTokens = llmCallResults.reduce(
        (sum, c) => sum + (c.totalTokens || 0),
        0
      );
      const estimatedCost = llmCallResults.reduce(
        (sum, c) => sum + parseFloat(c.estimatedCost || "0"),
        0
      );
      const totalLatency = llmCallResults.reduce(
        (sum, c) => sum + (c.latencyMs || 0),
        0
      );
      const providersUsed = [...new Set(llmCallResults.map((c) => c.provider))];
      const missingModules = [];
      return res.json({
        traceId,
        decisions: decisionResults.map((d) => ({
          id: d.id,
          symbol: d.symbol,
          action: d.action,
          confidence: d.confidence ? parseFloat(d.confidence) : null,
          status: d.status,
          createdAt: d.createdAt
        })),
        llmCalls: llmCallResults.map((c) => ({
          id: c.id,
          role: c.role,
          provider: c.provider,
          model: c.model,
          tokensUsed: c.totalTokens,
          latencyMs: c.latencyMs,
          status: c.status,
          createdAt: c.createdAt
        })),
        workItems: workItemResults.map((w) => ({
          id: w.id,
          type: w.type,
          status: w.status,
          attempts: w.attempts,
          symbol: w.symbol,
          brokerOrderId: w.brokerOrderId
        })),
        trades: tradeResults.map((t) => ({
          id: t.id,
          symbol: t.symbol,
          side: t.side,
          quantity: t.quantity,
          price: t.price,
          status: t.status,
          executedAt: t.executedAt
        })),
        summary: {
          totalDecisions: decisionResults.length,
          totalLLMCalls: llmCallResults.length,
          totalWorkItems: workItemResults.length,
          totalTrades: tradeResults.length,
          totalTokens,
          estimatedCost,
          latencyMs: totalLatency,
          providersUsed
        },
        missingModules
      });
    } catch (error) {
      log.error("Observability", "Trace lookup failed", {
        traceId,
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch trace" });
    }
  }
);
observabilityRouter.get(
  "/alerts/rules",
  async (req, res) => {
    try {
      const rules = await alertService.getRules();
      return res.json({ rules });
    } catch (error) {
      log.error("Observability", "Alert rules fetch failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch alert rules" });
    }
  }
);
observabilityRouter.post(
  "/alerts/rules",
  async (req, res) => {
    try {
      const {
        name,
        description,
        ruleType,
        condition,
        threshold,
        enabled,
        webhookUrl
      } = req.body;
      if (!name || !ruleType || !condition || threshold === void 0) {
        return res.status(400).json({
          error: "Missing required fields: name, ruleType, condition, threshold"
        });
      }
      const rule = await alertService.createRule({
        name,
        description,
        ruleType,
        condition,
        threshold,
        enabled,
        webhookUrl
      });
      return res.status(201).json({ rule });
    } catch (error) {
      log.error("Observability", "Alert rule creation failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to create alert rule" });
    }
  }
);
observabilityRouter.post(
  "/alerts/rules/:id/toggle",
  async (req, res) => {
    try {
      const { id } = req.params;
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({ error: "enabled must be a boolean" });
      }
      const rule = await alertService.toggleRule(id, enabled);
      if (!rule) {
        return res.status(404).json({ error: "Alert rule not found" });
      }
      return res.json({ rule });
    } catch (error) {
      log.error("Observability", "Alert rule toggle failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to toggle alert rule" });
    }
  }
);
observabilityRouter.delete(
  "/alerts/rules/:id",
  async (req, res) => {
    try {
      const { id } = req.params;
      await alertService.deleteRule(id);
      return res.json({ success: true });
    } catch (error) {
      log.error("Observability", "Alert rule deletion failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to delete alert rule" });
    }
  }
);
observabilityRouter.post(
  "/alerts/test",
  async (req, res) => {
    try {
      const { ruleId } = req.body;
      if (!ruleId) {
        return res.status(400).json({ error: "ruleId is required" });
      }
      const result = await alertService.testAlert(ruleId);
      return res.json(result);
    } catch (error) {
      log.error("Observability", "Alert test failed", { error: String(error) });
      return res.status(500).json({ error: "Failed to test alert" });
    }
  }
);
observabilityRouter.get(
  "/alerts/events",
  async (req, res) => {
    try {
      const { limit: limitStr = "50" } = req.query;
      const limit4 = Math.min(parseInt(limitStr, 10) || 50, 200);
      const events = await alertService.getRecentEvents(limit4);
      return res.json({ events });
    } catch (error) {
      log.error("Observability", "Alert events fetch failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to fetch alert events" });
    }
  }
);
observabilityRouter.post(
  "/alerts/evaluate",
  async (req, res) => {
    try {
      const result = await alertService.evaluateRules();
      return res.json(result);
    } catch (error) {
      log.error("Observability", "Alert evaluation failed", {
        error: String(error)
      });
      return res.status(500).json({ error: "Failed to evaluate alerts" });
    }
  }
);

// server/routes/debate.ts
import { Router as Router4 } from "express";

// server/ai/debateArena.ts
init_storage();
init_llmGateway();

// server/ai/toolRouter.ts
init_storage();
init_logger();
init_alpaca();
import { z as z8 } from "zod";
var toolRegistry = /* @__PURE__ */ new Map();
function registerTool(tool) {
  if (toolRegistry.has(tool.name)) {
    log.warn(
      "ToolRouter",
      `Tool already registered: ${tool.name}, overwriting`
    );
  }
  toolRegistry.set(tool.name, tool);
  log.debug("ToolRouter", `Registered tool: ${tool.name}`, {
    category: tool.category
  });
}
function listTools() {
  return Array.from(toolRegistry.values());
}
function listToolsByCategory(category) {
  return Array.from(toolRegistry.values()).filter(
    (t) => t.category === category
  );
}
function getToolSchemas() {
  return Array.from(toolRegistry.values()).map((t) => ({
    name: t.name,
    description: t.description,
    inputSchema: t.inputSchema instanceof z8.ZodObject ? t.inputSchema.shape : {}
  }));
}
async function invokeTool(toolName, params, context) {
  const startTime = Date.now();
  const tool = toolRegistry.get(toolName);
  if (!tool) {
    log.error("ToolRouter", `Tool not found: ${toolName}`, {
      traceId: context.traceId
    });
    return {
      success: false,
      error: `Tool not found: ${toolName}`,
      latencyMs: Date.now() - startTime,
      cacheHit: false,
      invocationId: ""
    };
  }
  const invocation = await storage.createToolInvocation({
    traceId: context.traceId,
    toolName,
    category: tool.category,
    inputParams: params,
    status: "pending",
    callerRole: context.callerRole,
    debateSessionId: context.debateSessionId
  });
  try {
    const parseResult = tool.inputSchema.safeParse(params);
    if (!parseResult.success) {
      const errorMsg = `Invalid input: ${parseResult.error.message}`;
      await storage.updateToolInvocation(invocation.id, {
        status: "error",
        errorMessage: errorMsg,
        latencyMs: Date.now() - startTime
      });
      return {
        success: false,
        error: errorMsg,
        latencyMs: Date.now() - startTime,
        cacheHit: false,
        invocationId: invocation.id
      };
    }
    const result = await tool.execute(parseResult.data, context);
    const latencyMs = Date.now() - startTime;
    await storage.updateToolInvocation(invocation.id, {
      status: "success",
      outputResult: result,
      latencyMs
    });
    log.debug("ToolRouter", `Tool invoked: ${toolName}`, {
      traceId: context.traceId,
      latencyMs
    });
    return {
      success: true,
      result,
      latencyMs,
      cacheHit: false,
      invocationId: invocation.id
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    const latencyMs = Date.now() - startTime;
    await storage.updateToolInvocation(invocation.id, {
      status: "error",
      errorMessage: errorMsg,
      latencyMs
    });
    log.error("ToolRouter", `Tool execution failed: ${toolName}`, {
      traceId: context.traceId,
      error: errorMsg
    });
    return {
      success: false,
      error: errorMsg,
      latencyMs,
      cacheHit: false,
      invocationId: invocation.id
    };
  }
}
registerTool({
  name: "getQuote",
  description: "Get real-time quote for a symbol from Alpaca",
  category: "market_data",
  inputSchema: z8.object({
    symbol: z8.string().describe("Stock or crypto symbol")
  }),
  cacheable: true,
  cacheTtlMs: 5e3,
  execute: async (params) => {
    const { symbol } = params;
    const snapshots = await alpaca.getSnapshots([symbol]);
    const snapshot = snapshots[symbol];
    if (!snapshot) throw new Error(`No quote data for ${symbol}`);
    return {
      symbol,
      price: snapshot.latestTrade?.p || snapshot.dailyBar?.c,
      bid: snapshot.latestQuote?.bp,
      ask: snapshot.latestQuote?.ap,
      volume: snapshot.dailyBar?.v,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
});
registerTool({
  name: "getBars",
  description: "Get historical price bars for a symbol",
  category: "market_data",
  inputSchema: z8.object({
    symbol: z8.string(),
    timeframe: z8.enum(["1Min", "5Min", "15Min", "1Hour", "1Day"]).default("1Day"),
    limit: z8.number().min(1).max(100).default(20)
  }),
  cacheable: true,
  cacheTtlMs: 6e4,
  execute: async (params) => {
    const { symbol, timeframe, limit: limit4 } = params;
    const barsResponse = await alpaca.getBars(
      [symbol],
      timeframe,
      void 0,
      void 0,
      limit4
    );
    const bars = barsResponse.bars[symbol] || [];
    return bars.map((b) => ({
      timestamp: b.t,
      open: b.o,
      high: b.h,
      low: b.l,
      close: b.c,
      volume: b.v
    }));
  }
});
registerTool({
  name: "listPositions",
  description: "Get all open positions from Alpaca",
  category: "broker",
  inputSchema: z8.object({}),
  execute: async () => {
    const positions2 = await alpaca.getPositions();
    return positions2.map(
      (p) => ({
        symbol: p.symbol,
        qty: parseFloat(p.qty),
        marketValue: parseFloat(p.market_value),
        avgEntryPrice: parseFloat(p.avg_entry_price),
        unrealizedPnl: parseFloat(p.unrealized_pl),
        side: p.side
      })
    );
  }
});
registerTool({
  name: "getAccount",
  description: "Get Alpaca account information",
  category: "broker",
  inputSchema: z8.object({}),
  execute: async () => {
    const account = await alpaca.getAccount();
    return {
      id: account.id,
      status: account.status,
      buyingPower: parseFloat(account.buying_power),
      cash: parseFloat(account.cash),
      portfolioValue: parseFloat(account.portfolio_value),
      equity: parseFloat(account.equity),
      daytradeCount: account.daytrade_count,
      patternDayTrader: account.pattern_day_trader
    };
  }
});
registerTool({
  name: "listOrders",
  description: "Get orders from Alpaca",
  category: "broker",
  inputSchema: z8.object({
    status: z8.enum(["open", "closed", "all"]).default("open"),
    limit: z8.number().min(1).max(100).default(50)
  }),
  execute: async (params) => {
    const { status, limit: limit4 } = params;
    const orders2 = await alpaca.getOrders(status, limit4);
    return orders2.map((o) => ({
      id: o.id,
      clientOrderId: o.client_order_id,
      symbol: o.symbol,
      side: o.side,
      type: o.type,
      qty: o.qty,
      status: o.status,
      submittedAt: o.submitted_at,
      filledQty: o.filled_qty,
      filledAvgPrice: o.filled_avg_price ?? void 0
    }));
  }
});
registerTool({
  name: "getMarketClock",
  description: "Get market open/close times",
  category: "market_data",
  inputSchema: z8.object({}),
  cacheable: true,
  cacheTtlMs: 6e4,
  execute: async () => {
    const clock = await alpaca.getClock();
    return {
      isOpen: clock.is_open,
      nextOpen: clock.next_open,
      nextClose: clock.next_close,
      timestamp: clock.timestamp
    };
  }
});

// server/ai/debateArena.ts
init_logger();
init_work_queue();
var DEFAULT_ROLES = [
  "bull",
  "bear",
  "risk_manager",
  "technical_analyst",
  "fundamental_analyst"
];
var ROLE_PROMPTS = {
  bull: `You are the BULL analyst. Your job is to find reasons WHY this trade could succeed.
Focus on: upside catalysts, momentum signals, positive news, growth indicators.
Be optimistic but data-driven. Cite specific evidence.`,
  bear: `You are the BEAR analyst. Your job is to find reasons WHY this trade could fail.
Focus on: downside risks, headwinds, negative news, valuation concerns.
Be skeptical but fair. Cite specific evidence.`,
  risk_manager: `You are the RISK MANAGER. Your job is to assess position sizing and risk controls.
Focus on: max drawdown, stop-loss levels, portfolio concentration, correlation risks.
Recommend specific risk parameters. Be conservative.`,
  technical_analyst: `You are the TECHNICAL ANALYST. Your job is to analyze price action and indicators.
Focus on: support/resistance, trend strength, RSI/MACD signals, volume patterns.
Provide specific entry/exit levels based on technicals.`,
  fundamental_analyst: `You are the FUNDAMENTAL ANALYST. Your job is to analyze company/asset fundamentals.
Focus on: valuation metrics, earnings, growth rates, competitive position.
Assess intrinsic value vs current price.`,
  judge: `You are the JUDGE. Your job is to synthesize all analyst opinions into a final decision.
Weigh each analyst's arguments and confidence levels.
Make a clear BUY/SELL/HOLD decision with risk parameters.
If there's strong dissent, explain why you overruled it.`
};
var ROLE_OUTPUT_SCHEMA = {
  type: "object",
  properties: {
    stance: {
      type: "string",
      enum: ["bullish", "bearish", "neutral", "abstain"]
    },
    confidence: { type: "number", minimum: 0, maximum: 1 },
    keySignals: { type: "array", items: { type: "string" } },
    risks: { type: "array", items: { type: "string" } },
    invalidationPoints: { type: "array", items: { type: "string" } },
    proposedAction: {
      type: "string",
      enum: ["buy", "sell", "hold", "scale_in", "scale_out"]
    },
    proposedOrder: {
      type: "object",
      properties: {
        side: { type: "string", enum: ["buy", "sell"] },
        qty: { type: "number" },
        notional: { type: "number" },
        type: { type: "string", enum: ["market", "limit"] },
        limitPrice: { type: "number" }
      }
    },
    evidenceRefs: { type: "array", items: { type: "string" } },
    rationale: { type: "string" }
  },
  required: [
    "stance",
    "confidence",
    "keySignals",
    "risks",
    "proposedAction",
    "rationale"
  ]
};
async function gatherMarketContext(symbols, traceId) {
  const context = {};
  for (const symbol of symbols) {
    try {
      const quoteResult = await invokeTool("getQuote", { symbol }, { traceId });
      if (quoteResult.success) {
        context[`${symbol}_quote`] = quoteResult.result;
      }
      const barsResult = await invokeTool(
        "getBars",
        { symbol, timeframe: "1Day", limit: 10 },
        { traceId }
      );
      if (barsResult.success) {
        context[`${symbol}_bars`] = barsResult.result;
      }
    } catch (e) {
      log.warn("DebateArena", `Failed to gather data for ${symbol}`, {
        error: e.message
      });
    }
  }
  try {
    const accountResult = await invokeTool("getAccount", {}, { traceId });
    if (accountResult.success) {
      context.account = accountResult.result;
    }
    const positionsResult = await invokeTool("listPositions", {}, { traceId });
    if (positionsResult.success) {
      context.positions = positionsResult.result;
    }
    const clockResult = await invokeTool("getMarketClock", {}, { traceId });
    if (clockResult.success) {
      context.marketClock = clockResult.result;
    }
  } catch (e) {
    log.warn("DebateArena", `Failed to gather account data`, {
      error: e.message
    });
  }
  return context;
}
async function runRole(role, symbols, marketContext, priorMessages, session, config2) {
  const priorContext = priorMessages.map(
    (m) => `[${m.role.toUpperCase()}] Stance: ${m.stance}, Confidence: ${m.confidence}, Action: ${m.proposedAction}
Rationale: ${m.rawOutput?.slice(0, 500) || "N/A"}`
  ).join("\n\n");
  const systemPrompt = `${ROLE_PROMPTS[role]}

You are analyzing: ${symbols.join(", ")}

Your response MUST be valid JSON matching this schema:
${JSON.stringify(ROLE_OUTPUT_SCHEMA, null, 2)}

Market Context:
${JSON.stringify(marketContext, null, 2)}

${priorMessages.length > 0 ? `
Prior Analyst Opinions:
${priorContext}` : ""}`;
  const startTime = Date.now();
  try {
    const response = await callLLM({
      role: role === "judge" ? "execution_planner" : "technical_analyst",
      criticality: "high",
      traceId: session.traceId,
      purpose: `debate_${role}`,
      system: systemPrompt,
      messages: [
        {
          role: "user",
          content: `Analyze ${symbols.join(", ")} and provide your ${role} perspective.`
        }
      ],
      responseFormat: { type: "json_object" },
      maxTokens: config2.tokenBudgetPerRole || 1500
    });
    const latencyMs = Date.now() - startTime;
    let parsed;
    try {
      parsed = response.json;
    } catch {
      parsed = JSON.parse(response.text || "{}");
    }
    const message = await storage.createDebateMessage({
      sessionId: session.id,
      role,
      stance: parsed.stance,
      confidence: String(parsed.confidence),
      keySignals: parsed.keySignals,
      risks: parsed.risks,
      invalidationPoints: parsed.invalidationPoints,
      proposedAction: parsed.proposedAction,
      proposedOrder: parsed.proposedOrder,
      evidenceRefs: parsed.evidenceRefs,
      rawOutput: parsed.rationale,
      provider: response.provider,
      model: response.model,
      tokensUsed: response.tokensUsed,
      estimatedCost: String(response.estimatedCost),
      latencyMs
    });
    log.info("DebateArena", `Role ${role} completed`, {
      sessionId: session.id,
      stance: parsed.stance,
      confidence: parsed.confidence,
      latencyMs
    });
    return message;
  } catch (error) {
    log.error("DebateArena", `Role ${role} failed`, {
      sessionId: session.id,
      error: error.message
    });
    throw error;
  }
}
async function runJudge(symbols, roleMessages, session) {
  const analysisContext = roleMessages.map(
    (m) => `
[${m.role.toUpperCase()}]
Stance: ${m.stance} (Confidence: ${m.confidence})
Key Signals: ${(m.keySignals || []).join(", ")}
Risks: ${(m.risks || []).join(", ")}
Proposed Action: ${m.proposedAction}
Rationale: ${m.rawOutput || "N/A"}
`
  ).join("\n---\n");
  const systemPrompt = `You are the JUDGE synthesizing analyst opinions for ${symbols.join(", ")}.

Analyst Opinions:
${analysisContext}

Make a final decision. Your response MUST be valid JSON:
{
  "decision": "buy" | "sell" | "hold" | "scale_in" | "scale_out",
  "orderIntent": { "symbol": "...", "side": "buy" | "sell", "qty": number, "type": "market" | "limit" } | null,
  "reasonsSummary": "Concise explanation of the decision",
  "riskChecks": {
    "passedAll": boolean,
    "checks": [{ "name": "...", "passed": boolean, "note": "..." }]
  },
  "confidence": 0.0-1.0,
  "dissent": [{ "role": "...", "reason": "..." }]
}

Include orderIntent ONLY if decision is buy/sell/scale_in/scale_out.
Be decisive. If the risk manager has serious concerns, address them.`;
  const response = await callLLM({
    role: "execution_planner",
    criticality: "high",
    traceId: session.traceId,
    purpose: "debate_judge",
    system: systemPrompt,
    messages: [
      {
        role: "user",
        content: "Synthesize all analyst opinions and make a final decision."
      }
    ],
    responseFormat: { type: "json_object" },
    maxTokens: 2e3
  });
  try {
    return response.json;
  } catch {
    return JSON.parse(response.text || "{}");
  }
}
async function startDebate(symbols, traceId, config2 = {}, triggeredBy, strategyVersionId) {
  const session = await storage.createDebateSession({
    traceId,
    symbols,
    status: "running",
    triggeredBy,
    strategyVersionId,
    config: config2,
    startedAt: /* @__PURE__ */ new Date()
  });
  log.info("DebateArena", `Starting debate session`, {
    sessionId: session.id,
    symbols,
    traceId
  });
  const startTime = Date.now();
  const enabledRoles = config2.enabledRoles || DEFAULT_ROLES;
  const roleMessages = [];
  let totalCost = 0;
  try {
    const marketContext = await gatherMarketContext(symbols, traceId);
    await storage.updateDebateSession(session.id, { marketContext });
    for (const role of enabledRoles) {
      const message = await runRole(
        role,
        symbols,
        marketContext,
        roleMessages,
        session,
        config2
      );
      roleMessages.push(message);
      totalCost += parseFloat(message.estimatedCost || "0");
    }
    const consensusOutput = await runJudge(symbols, roleMessages, session);
    let workItemId;
    let brokerOrderId;
    if (consensusOutput.orderIntent && consensusOutput.decision !== "hold") {
      const workItem = await workQueue.enqueue({
        type: "ORDER_SUBMIT",
        symbol: consensusOutput.orderIntent.symbol,
        payload: JSON.stringify({
          symbol: consensusOutput.orderIntent.symbol,
          side: consensusOutput.orderIntent.side,
          qty: consensusOutput.orderIntent.qty,
          notional: consensusOutput.orderIntent.notional,
          type: consensusOutput.orderIntent.type,
          time_in_force: "day",
          debateSessionId: session.id
        }),
        idempotencyKey: `debate-${session.id}-${consensusOutput.orderIntent.symbol}`
      });
      workItemId = workItem.id;
      log.info("DebateArena", `Order enqueued from debate`, {
        sessionId: session.id,
        workItemId,
        symbol: consensusOutput.orderIntent.symbol,
        side: consensusOutput.orderIntent.side
      });
    }
    const consensus = await storage.createDebateConsensus({
      sessionId: session.id,
      decision: consensusOutput.decision,
      orderIntent: consensusOutput.orderIntent,
      reasonsSummary: consensusOutput.reasonsSummary,
      riskChecks: consensusOutput.riskChecks,
      confidence: String(consensusOutput.confidence),
      dissent: consensusOutput.dissent,
      workItemId,
      brokerOrderId
    });
    const durationMs = Date.now() - startTime;
    await storage.updateDebateSession(session.id, {
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs,
      totalCost: String(totalCost)
    });
    log.info("DebateArena", `Debate completed`, {
      sessionId: session.id,
      decision: consensusOutput.decision,
      confidence: consensusOutput.confidence,
      durationMs,
      totalCost
    });
    const updatedSession = await storage.getDebateSession(session.id);
    return { session: updatedSession, consensus };
  } catch (error) {
    await storage.updateDebateSession(session.id, {
      status: "failed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs: Date.now() - startTime
    });
    log.error("DebateArena", `Debate failed`, {
      sessionId: session.id,
      error: error.message
    });
    throw error;
  }
}
async function getDebateDetails(sessionId) {
  const session = await storage.getDebateSession(sessionId);
  if (!session) return null;
  const messages = await storage.getDebateMessagesBySession(sessionId);
  const consensus = await storage.getDebateConsensusBySession(sessionId);
  return { session, messages, consensus };
}
async function listDebateSessions(limit4 = 50) {
  return storage.getDebateSessions(limit4);
}

// server/routes/debate.ts
init_logger();
var router2 = Router4();
router2.post("/sessions", requireAuth, async (req, res) => {
  try {
    const { symbols, config: config2 = {}, triggeredBy, strategyVersionId } = req.body;
    if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
      return res.status(400).json({ error: "symbols is required and must be a non-empty array" });
    }
    const traceId = `debate-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    const { session, consensus } = await startDebate(
      symbols,
      traceId,
      config2,
      triggeredBy,
      strategyVersionId
    );
    res.json({ session, consensus });
  } catch (error) {
    log.error("DebateAPI", `Failed to start debate: ${error}`);
    res.status(500).json({ error: error.message || "Failed to start debate" });
  }
});
router2.get("/sessions", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const sessions2 = await listDebateSessions(limit4);
    res.json({ sessions: sessions2, limit: limit4 });
  } catch (error) {
    log.error("DebateAPI", `Failed to list debate sessions: ${error}`);
    res.status(500).json({ error: "Failed to list debate sessions" });
  }
});
router2.get(
  "/sessions/:id",
  requireAuth,
  async (req, res) => {
    try {
      const details = await getDebateDetails(req.params.id);
      if (!details) {
        return res.status(404).json({ error: "Debate session not found" });
      }
      res.json(details);
    } catch (error) {
      log.error("DebateAPI", `Failed to get debate session: ${error}`);
      res.status(500).json({ error: "Failed to get debate session" });
    }
  }
);
var debate_default = router2;

// server/routes/tools.ts
import { Router as Router5 } from "express";
init_storage();
init_logger();
var router3 = Router5();
router3.get("/", requireAuth, async (req, res) => {
  try {
    const category = req.query.category;
    const tools = category ? listToolsByCategory(category) : listTools();
    res.json({
      tools: tools.map((t) => ({
        name: t.name,
        description: t.description,
        category: t.category,
        dangerous: t.dangerous || false,
        cacheable: t.cacheable || false
      })),
      count: tools.length
    });
  } catch (error) {
    log.error("ToolsAPI", `Failed to list tools: ${error}`);
    return serverError(res, "Failed to list tools");
  }
});
router3.get("/schemas", requireAuth, async (req, res) => {
  try {
    const schemas = getToolSchemas();
    res.json({ schemas });
  } catch (error) {
    log.error("ToolsAPI", `Failed to get tool schemas: ${error}`);
    return serverError(res, "Failed to get tool schemas");
  }
});
router3.post("/invoke", requireAuth, async (req, res) => {
  try {
    const { toolName, params, traceId, callerRole, debateSessionId } = req.body;
    if (!toolName) {
      return badRequest(res, "toolName is required");
    }
    const context = {
      traceId: traceId || `tool-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`,
      callerRole,
      debateSessionId
    };
    const result = await invokeTool(toolName, params || {}, context);
    res.json(result);
  } catch (error) {
    log.error("ToolsAPI", `Failed to invoke tool: ${error}`);
    return serverError(
      res,
      error.message || "Failed to invoke tool"
    );
  }
});
router3.get("/invocations", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 100;
    const traceId = req.query.traceId;
    const sessionId = req.query.sessionId;
    let invocations;
    if (traceId) {
      invocations = await storage.getToolInvocationsByTrace(traceId);
    } else if (sessionId) {
      invocations = await storage.getToolInvocationsBySession(sessionId);
    } else {
      invocations = await storage.getRecentToolInvocations(limit4);
    }
    res.json({ invocations, count: invocations.length });
  } catch (error) {
    log.error("ToolsAPI", `Failed to get tool invocations: ${error}`);
    return serverError(res, "Failed to get tool invocations");
  }
});
var tools_default = router3;

// server/routes/competition.ts
init_storage();
init_logger();
import { Router as Router6 } from "express";
var router4 = Router6();
router4.get("/traders", requireAuth, async (req, res) => {
  try {
    const traders = await storage.getTraderProfiles();
    res.json({ traders, count: traders.length });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to list traders: ${error}`);
    res.status(500).json({ error: "Failed to list traders" });
  }
});
router4.post("/traders", requireAuth, async (req, res) => {
  try {
    const {
      name,
      description,
      strategyVersionId,
      modelProfile,
      riskPreset,
      universeFilter
    } = req.body;
    if (!name) {
      return res.status(400).json({ error: "name is required" });
    }
    const trader = await storage.createTraderProfile({
      name,
      description,
      strategyVersionId,
      modelProfile,
      riskPreset,
      universeFilter,
      status: "active"
    });
    res.json(trader);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to create trader: ${error}`);
    res.status(500).json({ error: error.message || "Failed to create trader" });
  }
});
router4.get("/traders/:id", requireAuth, async (req, res) => {
  try {
    const trader = await storage.getTraderProfile(req.params.id);
    if (!trader) {
      return res.status(404).json({ error: "Trader not found" });
    }
    res.json(trader);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to get trader: ${error}`);
    res.status(500).json({ error: "Failed to get trader" });
  }
});
router4.patch(
  "/traders/:id",
  requireAuth,
  async (req, res) => {
    try {
      const trader = await storage.updateTraderProfile(req.params.id, req.body);
      if (!trader) {
        return res.status(404).json({ error: "Trader not found" });
      }
      res.json(trader);
    } catch (error) {
      log.error("CompetitionAPI", `Failed to update trader: ${error}`);
      res.status(500).json({ error: error.message || "Failed to update trader" });
    }
  }
);
router4.get("/runs", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 20;
    const runs = await storage.getCompetitionRuns(limit4);
    res.json({ runs, count: runs.length });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to list competition runs: ${error}`);
    res.status(500).json({ error: "Failed to list competition runs" });
  }
});
router4.post("/runs", requireAuth, async (req, res) => {
  try {
    const { name, mode, traderIds, universeSymbols, config: config2 } = req.body;
    if (!name || !mode || !traderIds || !Array.isArray(traderIds) || traderIds.length === 0) {
      return res.status(400).json({ error: "name, mode, and traderIds are required" });
    }
    const validModes = ["paper", "backtest", "simulation"];
    if (!validModes.includes(mode)) {
      return res.status(400).json({
        error: `Invalid mode. Must be one of: ${validModes.join(", ")}`
      });
    }
    const traceId = `competition-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    const run = await storage.createCompetitionRun({
      name,
      mode,
      traceId,
      traderIds,
      universeSymbols,
      config: config2,
      status: "pending"
    });
    res.json(run);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to create competition run: ${error}`);
    res.status(500).json({
      error: error.message || "Failed to create competition run"
    });
  }
});
router4.get("/runs/:id", requireAuth, async (req, res) => {
  try {
    const run = await storage.getCompetitionRun(req.params.id);
    if (!run) {
      return res.status(404).json({ error: "Competition run not found" });
    }
    const scores = await storage.getCompetitionScoresByRun(req.params.id);
    res.json({ run, scores });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to get competition run: ${error}`);
    res.status(500).json({ error: "Failed to get competition run" });
  }
});
router4.patch("/runs/:id", requireAuth, async (req, res) => {
  try {
    const run = await storage.updateCompetitionRun(req.params.id, req.body);
    if (!run) {
      return res.status(404).json({ error: "Competition run not found" });
    }
    res.json(run);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to update competition run: ${error}`);
    res.status(500).json({
      error: error.message || "Failed to update competition run"
    });
  }
});
router4.post(
  "/runs/:id/scores",
  requireAuth,
  async (req, res) => {
    try {
      const {
        traderId,
        rank,
        metrics,
        pnl,
        pnlPct,
        sharpe,
        sortino,
        maxDrawdown,
        winRate,
        totalTrades
      } = req.body;
      if (!traderId) {
        return res.status(400).json({ error: "traderId is required" });
      }
      const score = await storage.createCompetitionScore({
        runId: req.params.id,
        traderProfileId: traderId,
        rank,
        totalPnl: pnl ? String(pnl) : void 0,
        roi: pnlPct ? String(pnlPct) : void 0,
        sharpe: sharpe ? String(sharpe) : void 0,
        sortino: sortino ? String(sortino) : void 0,
        maxDrawdown: maxDrawdown ? String(maxDrawdown) : void 0,
        winRate: winRate ? String(winRate) : void 0,
        tradeCount: totalTrades,
        details: metrics
      });
      res.json(score);
    } catch (error) {
      log.error("CompetitionAPI", `Failed to create score: ${error}`);
      res.status(500).json({ error: error.message || "Failed to create score" });
    }
  }
);
var competition_default = router4;

// server/routes/strategies.ts
init_storage();
init_logger();
import { Router as Router7 } from "express";
init_sanitization();
init_schema2();
init_trading();
init_alpaca_trading_engine();

// server/services/strategy-lifecycle-service.ts
init_storage();
init_logger();
var VALID_TRANSITIONS = {
  draft: ["backtesting", "paper"],
  // Can go to paper directly, or backtest first
  backtesting: ["draft", "backtested", "paper", "live"],
  backtested: ["backtesting", "paper", "live"],
  paper: ["paused", "stopped", "live"],
  live: ["paused", "stopped"],
  paused: ["paper", "live", "stopped"],
  stopped: ["draft"]
};
function isValidTransition(from, to) {
  return VALID_TRANSITIONS[from]?.includes(to) ?? false;
}
var StrategyLifecycleService = class {
  /**
   * Deploy a strategy to paper or live trading
   *
   * @param strategyId - Strategy to deploy
   * @param mode - 'paper' or 'live'
   * @returns Result with success status and updated strategy
   */
  async deployStrategy(strategyId, mode) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    const targetStatus = mode;
    if (!isValidTransition(currentStatus, targetStatus)) {
      const validSources = Object.entries(VALID_TRANSITIONS).filter(([_, targets]) => targets.includes(targetStatus)).map(([source]) => source);
      return {
        success: false,
        error: `Cannot deploy to '${targetStatus}' from '${currentStatus}' status. Valid source states: ${validSources.join(", ")}.`
      };
    }
    if (mode === "live" && !strategy.lastBacktestId) {
      return {
        success: false,
        error: "A successful backtest is required before live deployment"
      };
    }
    const updated = await storage.updateStrategyStatus(
      strategyId,
      targetStatus,
      mode
    );
    if (!updated) {
      return { success: false, error: "Failed to update strategy status" };
    }
    log.info("StrategyLifecycle", `Strategy deployed to ${mode}`, {
      strategyId,
      strategyName: strategy.name,
      previousStatus: currentStatus,
      newStatus: targetStatus
    });
    return { success: true, strategy: updated };
  }
  /**
   * Pause a running strategy
   *
   * @param strategyId - Strategy to pause
   * @returns Result with success status
   */
  async pauseStrategy(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    if (!["paper", "live"].includes(currentStatus)) {
      return {
        success: false,
        error: `Cannot pause strategy in '${currentStatus}' status. Must be 'paper' or 'live'.`
      };
    }
    const currentMode = strategy.mode || "paper";
    const updated = await storage.updateStrategyStatus(
      strategyId,
      "paused",
      currentMode
    );
    if (!updated) {
      return { success: false, error: "Failed to pause strategy" };
    }
    log.info("StrategyLifecycle", "Strategy paused", {
      strategyId,
      strategyName: strategy.name,
      previousStatus: currentStatus,
      preservedMode: currentMode
    });
    return { success: true, strategy: updated };
  }
  /**
   * Resume a paused strategy
   *
   * @param strategyId - Strategy to resume
   * @returns Result with success status
   */
  async resumeStrategy(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    if (currentStatus !== "paused") {
      return {
        success: false,
        error: `Cannot resume strategy in '${currentStatus}' status. Must be 'paused'.`
      };
    }
    const targetMode = strategy.mode || "paper";
    const targetStatus = targetMode;
    const updated = await storage.updateStrategyStatus(
      strategyId,
      targetStatus,
      targetMode
    );
    if (!updated) {
      return { success: false, error: "Failed to resume strategy" };
    }
    log.info("StrategyLifecycle", "Strategy resumed", {
      strategyId,
      strategyName: strategy.name,
      newStatus: targetStatus
    });
    return { success: true, strategy: updated };
  }
  /**
   * Stop a strategy completely
   *
   * @param strategyId - Strategy to stop
   * @param closePositions - Whether to close open positions (undefined = prompt user)
   * @returns Result with success status or confirmation request
   */
  async stopStrategy(strategyId, closePositions) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    if (!isValidTransition(currentStatus, "stopped")) {
      return {
        success: false,
        error: `Cannot stop strategy in '${currentStatus}' status.`
      };
    }
    const positions2 = await storage.getPositionsByStrategy(strategyId);
    if (closePositions === void 0 && positions2.length > 0) {
      return {
        success: false,
        requiresConfirmation: true,
        positionCount: positions2.length,
        message: `Strategy has ${positions2.length} open position(s). Do you want to close them?`
      };
    }
    if (closePositions && positions2.length > 0) {
      log.info("StrategyLifecycle", "Closing positions before stop", {
        strategyId,
        positionCount: positions2.length,
        symbols: positions2.map((p) => p.symbol)
      });
      try {
        const { alpaca: alpaca2 } = await Promise.resolve().then(() => (init_alpaca(), alpaca_exports));
        for (const pos of positions2) {
          try {
            await alpaca2.closePosition(pos.symbol);
            log.info("StrategyLifecycle", `Closed position for ${pos.symbol}`);
          } catch (error) {
            log.error(
              "StrategyLifecycle",
              `Failed to close position ${pos.symbol}`,
              {
                error
              }
            );
          }
        }
      } catch (error) {
        log.error("StrategyLifecycle", "Failed to import alpaca connector", {
          error
        });
      }
    }
    const updated = await storage.updateStrategyStatus(
      strategyId,
      "stopped",
      void 0
    );
    if (!updated) {
      return { success: false, error: "Failed to stop strategy" };
    }
    log.info("StrategyLifecycle", "Strategy stopped", {
      strategyId,
      strategyName: strategy.name,
      previousStatus: currentStatus,
      positionsClosed: closePositions && positions2.length > 0
    });
    return { success: true, strategy: updated };
  }
  /**
   * Start backtesting for a strategy
   *
   * @param strategyId - Strategy to backtest
   * @returns Result with success status
   */
  async startBacktest(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    if (currentStatus !== "draft") {
      return {
        success: false,
        error: `Cannot start backtest from '${currentStatus}' status. Must be 'draft'.`
      };
    }
    const updated = await storage.updateStrategyStatus(
      strategyId,
      "backtesting",
      void 0
    );
    if (!updated) {
      return { success: false, error: "Failed to start backtest" };
    }
    log.info("StrategyLifecycle", "Backtest started", {
      strategyId,
      strategyName: strategy.name
    });
    return { success: true, strategy: updated };
  }
  /**
   * Complete backtesting and return to draft (or ready for deployment)
   *
   * @param strategyId - Strategy that completed backtesting
   * @param backtestId - ID of the completed backtest run
   * @param performance - Performance summary from backtest
   * @returns Result with success status
   */
  async completeBacktest(strategyId, backtestId, performance) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const updated = await storage.updateStrategy(strategyId, {
      status: "draft",
      // Return to draft, ready for deployment
      lastBacktestId: backtestId,
      performanceSummary: performance ? { ...performance, lastUpdated: (/* @__PURE__ */ new Date()).toISOString() } : void 0
    });
    if (!updated) {
      return { success: false, error: "Failed to complete backtest" };
    }
    log.info("StrategyLifecycle", "Backtest completed", {
      strategyId,
      strategyName: strategy.name,
      backtestId,
      performance
    });
    return { success: true, strategy: updated };
  }
  /**
   * Reset a stopped strategy to draft
   *
   * @param strategyId - Strategy to reset
   * @returns Result with success status
   */
  async resetToDraft(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const currentStatus = strategy.status || "draft";
    if (currentStatus !== "stopped") {
      return {
        success: false,
        error: `Cannot reset strategy in '${currentStatus}' status. Must be 'stopped'.`
      };
    }
    const updated = await storage.updateStrategyStatus(
      strategyId,
      "draft",
      void 0
    );
    if (!updated) {
      return { success: false, error: "Failed to reset strategy" };
    }
    log.info("StrategyLifecycle", "Strategy reset to draft", {
      strategyId,
      strategyName: strategy.name
    });
    return { success: true, strategy: updated };
  }
  /**
   * Get the current status of a strategy
   */
  async getStrategyStatus(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return null;
    }
    return {
      status: strategy.status || "draft",
      mode: strategy.mode || null
    };
  }
  /**
   * Get all strategies that are currently active (paper or live)
   */
  async getRunningStrategies() {
    return storage.getActiveStrategies();
  }
  /**
   * Calculate and update performance summary for a strategy
   */
  async updatePerformanceMetrics(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return { success: false, error: "Strategy not found" };
    }
    const strategyTrades = await storage.getTradesByStrategy(strategyId, 1e3);
    if (strategyTrades.length === 0) {
      return {
        success: true,
        strategy,
        message: "No trades to calculate metrics"
      };
    }
    const closedTrades = strategyTrades.filter((t) => t.pnl !== null);
    const totalPnl = closedTrades.reduce(
      (sum, t) => sum + parseFloat(t.pnl || "0"),
      0
    );
    const winningTrades = closedTrades.filter(
      (t) => parseFloat(t.pnl || "0") > 0
    );
    const losingTrades = closedTrades.filter(
      (t) => parseFloat(t.pnl || "0") < 0
    );
    const winRate = closedTrades.length > 0 ? winningTrades.length / closedTrades.length * 100 : 0;
    const returns = closedTrades.map((t) => parseFloat(t.pnl || "0"));
    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
    const stdDev2 = Math.sqrt(
      returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length
    );
    const sharpeRatio2 = stdDev2 > 0 ? avgReturn / stdDev2 * Math.sqrt(252) : 0;
    let peak = 0;
    let maxDrawdown = 0;
    let cumulative = 0;
    for (const trade of closedTrades) {
      cumulative += parseFloat(trade.pnl || "0");
      if (cumulative > peak) {
        peak = cumulative;
      }
      const drawdown = peak > 0 ? (peak - cumulative) / peak * 100 : 0;
      if (drawdown > maxDrawdown) {
        maxDrawdown = drawdown;
      }
    }
    const performanceSummary = {
      totalReturn: totalPnl,
      winRate,
      sharpeRatio: sharpeRatio2,
      maxDrawdown,
      totalTrades: closedTrades.length,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
    };
    const updated = await storage.updateStrategyPerformance(
      strategyId,
      performanceSummary
    );
    if (!updated) {
      return { success: false, error: "Failed to update performance metrics" };
    }
    log.info("StrategyLifecycle", "Performance metrics updated", {
      strategyId,
      metrics: performanceSummary
    });
    return { success: true, strategy: updated };
  }
};
var strategyLifecycleService = new StrategyLifecycleService();

// server/trading/strategy-order-service.ts
init_storage();
init_alpaca();
init_logger();
init_redis_cache();

// server/trading/unified-order-executor.ts
init_work_queue();
init_alpaca();
init_storage();
init_logger();
init_tradability_service();
init_universe2();
var QUEUE_POLL_INTERVAL_MS2 = 500;
var QUEUE_POLL_TIMEOUT_MS2 = 3e4;
var UnifiedOrderExecutor = class {
  useQueueByDefault = true;
  setQueueEnabled(enabled) {
    this.useQueueByDefault = enabled;
    log.info(
      "UnifiedOrderExecutor",
      `Queue mode: ${enabled ? "ENABLED" : "DISABLED"}`
    );
  }
  isQueueEnabled() {
    return this.useQueueByDefault;
  }
  async submitOrder(request) {
    const {
      symbol,
      side,
      qty,
      notional,
      type = "market",
      timeInForce = "day",
      limitPrice,
      stopPrice,
      extendedHours,
      orderClass,
      takeProfitLimitPrice,
      stopLossStopPrice,
      trailPercent,
      strategyId,
      decisionId,
      traceId,
      bypassQueue = false
    } = request;
    const clientOrderId = this.generateClientOrderId(request);
    log.info("UnifiedOrderExecutor", `Order request: ${side} ${symbol}`, {
      traceId,
      clientOrderId,
      qty,
      notional,
      type,
      useQueue: this.useQueueByDefault && !bypassQueue
    });
    if (side === "buy") {
      const enforcement = await tradingEnforcementService.canTradeSymbol(
        symbol,
        traceId
      );
      if (!enforcement.eligible) {
        return {
          success: false,
          error: `Trading enforcement blocked: ${enforcement.reason}`
        };
      }
    }
    const tradability = await tradabilityService.validateSymbolTradable(symbol);
    if (!tradability.tradable) {
      return {
        success: false,
        error: `Symbol not tradable: ${tradability.reason || "Not found"}`
      };
    }
    if (this.useQueueByDefault && !bypassQueue) {
      return this.executeViaQueue({
        symbol,
        side,
        qty,
        notional,
        type,
        timeInForce,
        limitPrice,
        stopPrice,
        extendedHours,
        orderClass,
        takeProfitLimitPrice,
        stopLossStopPrice,
        trailPercent,
        strategyId,
        decisionId,
        traceId,
        clientOrderId
      });
    }
    return this.executeDirect({
      symbol,
      side,
      qty,
      notional,
      type,
      timeInForce,
      limitPrice,
      stopPrice,
      extendedHours,
      orderClass,
      takeProfitLimitPrice,
      stopLossStopPrice,
      traceId,
      clientOrderId
    });
  }
  async executeViaQueue(params) {
    const {
      symbol,
      side,
      qty,
      notional,
      type,
      timeInForce,
      limitPrice,
      stopPrice,
      extendedHours,
      orderClass,
      takeProfitLimitPrice,
      stopLossStopPrice,
      strategyId,
      decisionId,
      traceId,
      clientOrderId
    } = params;
    const workItem = await workQueue.enqueue({
      type: "ORDER_SUBMIT",
      symbol,
      idempotencyKey: clientOrderId,
      decisionId: decisionId || null,
      payload: JSON.stringify({
        symbol,
        side,
        qty,
        notional,
        type,
        time_in_force: timeInForce,
        limit_price: limitPrice,
        stop_price: stopPrice,
        extended_hours: extendedHours,
        order_class: orderClass,
        take_profit_limit_price: takeProfitLimitPrice,
        stop_loss_stop_price: stopLossStopPrice,
        traceId,
        strategyId
      }),
      maxAttempts: 3
    });
    if (workItem.status === "SUCCEEDED" && workItem.result) {
      const result = JSON.parse(workItem.result);
      return {
        success: true,
        orderId: result.orderId,
        clientOrderId,
        status: result.status || "filled",
        workItemId: workItem.id,
        deduplicated: result.deduplicated || false
      };
    }
    const startTime = Date.now();
    while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS2) {
      await new Promise(
        (resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS2)
      );
      const updatedItem = await workQueue.getById(workItem.id);
      if (!updatedItem) {
        return { success: false, error: `Work item ${workItem.id} not found` };
      }
      if (updatedItem.status === "SUCCEEDED") {
        const result = updatedItem.result ? JSON.parse(updatedItem.result) : {};
        return {
          success: true,
          orderId: result.orderId,
          clientOrderId,
          status: result.status,
          workItemId: workItem.id,
          deduplicated: result.deduplicated
        };
      }
      if (updatedItem.status === "DEAD_LETTER") {
        return {
          success: false,
          error: updatedItem.lastError || "Order failed after retries",
          workItemId: workItem.id
        };
      }
    }
    return {
      success: false,
      error: `Order submission timed out after ${QUEUE_POLL_TIMEOUT_MS2}ms`,
      workItemId: workItem.id
    };
  }
  async executeDirect(params) {
    const {
      symbol,
      side,
      qty,
      notional,
      type,
      timeInForce,
      limitPrice,
      stopPrice,
      extendedHours,
      orderClass,
      takeProfitLimitPrice,
      stopLossStopPrice,
      traceId,
      clientOrderId
    } = params;
    try {
      const existingOrders = await alpaca.getOrders("open", 100);
      const existingOrder = existingOrders.find(
        (o) => o.client_order_id === clientOrderId
      );
      if (existingOrder) {
        log.info(
          "UnifiedOrderExecutor",
          `Duplicate order detected: ${clientOrderId}`,
          {
            traceId,
            existingOrderId: existingOrder.id
          }
        );
        return {
          success: true,
          orderId: existingOrder.id,
          clientOrderId,
          status: existingOrder.status,
          deduplicated: true
        };
      }
      const orderParams = {
        symbol,
        side,
        type,
        time_in_force: timeInForce,
        client_order_id: clientOrderId
      };
      if (qty) orderParams.qty = qty;
      if (notional) orderParams.notional = notional;
      if (limitPrice) orderParams.limit_price = limitPrice;
      if (stopPrice) orderParams.stop_price = stopPrice;
      if (extendedHours) orderParams.extended_hours = extendedHours;
      if (orderClass) orderParams.order_class = orderClass;
      if (takeProfitLimitPrice)
        orderParams.take_profit = { limit_price: takeProfitLimitPrice };
      if (stopLossStopPrice)
        orderParams.stop_loss = { stop_price: stopLossStopPrice };
      const order = await alpaca.createOrder(orderParams);
      log.info("UnifiedOrderExecutor", `Order submitted: ${order.id}`, {
        traceId,
        status: order.status
      });
      const adminUser = await storage.getAdminUser();
      const userId = adminUser?.id || "system";
      const orderData = {
        userId,
        broker: "alpaca",
        brokerOrderId: order.id,
        clientOrderId,
        symbol,
        side,
        type,
        timeInForce,
        qty,
        notional,
        limitPrice,
        stopPrice,
        status: order.status,
        submittedAt: new Date(order.submitted_at || Date.now()),
        updatedAt: /* @__PURE__ */ new Date(),
        filledQty: order.filled_qty,
        filledAvgPrice: order.filled_avg_price,
        traceId,
        rawJson: order
      };
      await storage.upsertOrderByBrokerOrderId(order.id, orderData);
      return {
        success: true,
        orderId: order.id,
        clientOrderId,
        status: order.status
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("UnifiedOrderExecutor", `Order failed: ${errorMsg}`, {
        traceId
      });
      return { success: false, error: errorMsg };
    }
  }
  async cancelOrder(orderId, traceId) {
    const clientOrderId = generateIdempotencyKey({
      strategyId: "cancel",
      symbol: orderId,
      side: "cancel",
      timeframeBucket: Math.floor(Date.now() / 6e4).toString()
    });
    if (this.useQueueByDefault) {
      const workItem = await workQueue.enqueue({
        type: "ORDER_CANCEL",
        symbol: orderId,
        idempotencyKey: clientOrderId,
        payload: JSON.stringify({ orderId, traceId }),
        maxAttempts: 3
      });
      if (workItem.status === "SUCCEEDED") {
        return { success: true };
      }
      const startTime = Date.now();
      while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS2) {
        await new Promise(
          (resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS2)
        );
        const updatedItem = await workQueue.getById(workItem.id);
        if (!updatedItem) continue;
        if (updatedItem.status === "SUCCEEDED") {
          return { success: true };
        }
        if (updatedItem.status === "DEAD_LETTER") {
          const errorLower = (updatedItem.lastError || "").toLowerCase();
          if (errorLower.includes("already") || errorLower.includes("not found")) {
            return { success: true };
          }
          return {
            success: false,
            error: updatedItem.lastError || "Cancel failed"
          };
        }
      }
      return { success: false, error: "Cancel timed out" };
    }
    try {
      await alpaca.cancelOrder(orderId);
      return { success: true };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      if (errorMsg.toLowerCase().includes("already") || errorMsg.toLowerCase().includes("not found")) {
        return { success: true };
      }
      return { success: false, error: errorMsg };
    }
  }
  generateClientOrderId(request) {
    const bucket = Math.floor(Date.now() / 3e5).toString();
    return generateIdempotencyKey({
      strategyId: request.strategyId || "unified",
      symbol: request.symbol,
      side: request.side,
      timeframeBucket: bucket
    });
  }
};
var unifiedOrderExecutor = new UnifiedOrderExecutor();

// server/trading/strategy-order-service.ts
var StrategyOrderService = class {
  // Removed: in-memory position count cache (TE-004 fix)
  // Now using Redis atomic counters for thread-safe position counting
  /**
   * Execute a trade using strategy configuration
   *
   * This is the main entry point for strategy-aware order execution.
   * It loads the strategy, validates the decision, calculates position size,
   * and submits the order with all strategy parameters applied.
   */
  async executeWithStrategy(request) {
    const {
      strategyId,
      symbol,
      side,
      decision,
      overrideQty,
      overrideNotional,
      traceId,
      bypassQueue
    } = request;
    try {
      const strategy = await storage.getStrategy(strategyId);
      if (!strategy) {
        return {
          success: false,
          error: `Strategy not found: ${strategyId}`
        };
      }
      if (!this.isStrategyExecutable(strategy)) {
        return {
          success: false,
          error: `Strategy ${strategy.name} is not in an executable state (status: ${strategy.status})`,
          context: {
            strategyId: strategy.id,
            strategyName: strategy.name,
            mode: strategy.mode || null
          }
        };
      }
      const context = parseStrategyContext(strategy);
      logExecutionContext(context);
      const positionCount = await this.getStrategyPositionCount(strategyId);
      if (decision) {
        const validation = validateDecision(decision, context, positionCount);
        if (!validation.valid) {
          log.warn("StrategyOrderService", "Decision validation failed", {
            strategyId,
            symbol,
            reason: validation.reason
          });
          return {
            success: false,
            error: validation.reason,
            validation,
            context: {
              strategyId: strategy.id,
              strategyName: strategy.name,
              mode: strategy.mode || null
            }
          };
        }
        if (validation.warnings && validation.warnings.length > 0) {
          log.info("StrategyOrderService", "Decision validation warnings", {
            strategyId,
            symbol,
            warnings: validation.warnings
          });
        }
      }
      const quote = await this.getCurrentPrice(symbol);
      if (!quote.price) {
        return {
          success: false,
          error: `Unable to get current price for ${symbol}`
        };
      }
      const portfolioValue = await this.getPortfolioValue();
      if (!portfolioValue) {
        return {
          success: false,
          error: "Unable to get portfolio value"
        };
      }
      let quantity;
      let notional;
      let positionSizeResult;
      if (overrideQty) {
        quantity = overrideQty;
      } else if (overrideNotional) {
        quantity = Math.floor(overrideNotional / quote.price);
        notional = overrideNotional;
      } else {
        positionSizeResult = calculatePositionSize(
          context,
          portfolioValue,
          quote.price
        );
        if (positionSizeResult.quantity < 1) {
          return {
            success: false,
            error: positionSizeResult.warnings?.[0] || "Position size too small",
            positionSize: positionSizeResult
          };
        }
        quantity = positionSizeResult.quantity;
        notional = positionSizeResult.notional;
        if (positionSizeResult.warnings && positionSizeResult.warnings.length > 0) {
          log.info("StrategyOrderService", "Position sizing warnings", {
            strategyId,
            symbol,
            warnings: positionSizeResult.warnings
          });
        }
      }
      const bracketParams = calculateBracketOrderParams(
        context,
        quote.price,
        side
      );
      const orderType = getOrderType(context);
      const timeInForce = getTimeInForce(context);
      const limitPrice = orderType === "limit" ? calculateLimitPrice(context, quote.price, side) : void 0;
      const orderRequest = {
        symbol,
        side,
        qty: quantity.toString(),
        type: orderType,
        timeInForce,
        limitPrice: limitPrice?.toString(),
        strategyId,
        decisionId: decision ? decision.id : void 0,
        traceId,
        bypassQueue,
        extendedHours: context.params.orderExecution.extendedHours
      };
      if (bracketParams) {
        orderRequest.orderClass = "bracket";
        orderRequest.takeProfitLimitPrice = bracketParams.takeProfitPrice?.toString();
        orderRequest.stopLossStopPrice = bracketParams.stopLossPrice?.toString();
        if (bracketParams.trailingStopPercent) {
          orderRequest.trailPercent = bracketParams.trailingStopPercent.toString();
        }
      }
      log.info("StrategyOrderService", "Submitting strategy order", {
        strategyId,
        strategyName: strategy.name,
        symbol,
        side,
        quantity,
        orderType,
        timeInForce,
        hasBracket: !!bracketParams,
        mode: strategy.mode
      });
      const result = await unifiedOrderExecutor.submitOrder(orderRequest);
      if (result.success) {
        log.info(
          "StrategyOrderService",
          "Strategy order submitted successfully",
          {
            strategyId,
            orderId: result.orderId,
            clientOrderId: result.clientOrderId
          }
        );
      } else {
        log.error("StrategyOrderService", "Strategy order failed", {
          strategyId,
          error: result.error
        });
      }
      return {
        success: result.success,
        orderId: result.orderId,
        clientOrderId: result.clientOrderId,
        status: result.status,
        error: result.error,
        positionSize: positionSizeResult,
        bracketParams,
        context: {
          strategyId: strategy.id,
          strategyName: strategy.name,
          mode: strategy.mode || null
        }
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log.error(
        "StrategyOrderService",
        "Unexpected error executing strategy order",
        {
          strategyId,
          symbol,
          error: errorMessage
        }
      );
      return {
        success: false,
        error: `Unexpected error: ${errorMessage}`
      };
    }
  }
  /**
   * Check if a strategy is in an executable state
   */
  isStrategyExecutable(strategy) {
    const executableStatuses = ["paper", "live"];
    return executableStatuses.includes(strategy.status || "");
  }
  /**
   * Get current position count for a strategy (thread-safe via Redis)
   *
   * TE-004 FIX: Uses Redis atomic counters instead of in-memory cache
   * - Redis GET is atomic - no race conditions
   * - Falls back to database if Redis unavailable
   * - Counter initialized from DB on first access
   */
  async getStrategyPositionCount(strategyId) {
    const cacheKey = `strategy:${strategyId}:position_count`;
    try {
      if (isRedisAvailable()) {
        const cachedCount = await getCounter(cacheKey);
        if (cachedCount !== null) {
          return cachedCount;
        }
        const positions3 = await storage.getPositionsByStrategy(strategyId);
        const count3 = positions3.length;
        await setCounter(cacheKey, count3);
        log.debug(
          "StrategyOrderService",
          "Initialized position count in Redis",
          {
            strategyId,
            count: count3
          }
        );
        return count3;
      }
      const positions2 = await storage.getPositionsByStrategy(strategyId);
      return positions2.length;
    } catch (error) {
      log.warn(
        "StrategyOrderService",
        "Failed to get position count, using 0",
        {
          strategyId,
          error: error instanceof Error ? error.message : String(error)
        }
      );
      return 0;
    }
  }
  /**
   * Get current price for a symbol
   */
  async getCurrentPrice(symbol) {
    try {
      const snapshots = await alpaca.getSnapshots([symbol]);
      const snapshot = snapshots[symbol];
      if (!snapshot) {
        log.warn("StrategyOrderService", "No snapshot returned for symbol", {
          symbol
        });
        return { price: null };
      }
      if (snapshot.latestQuote && snapshot.latestQuote.bp > 0 && snapshot.latestQuote.ap > 0) {
        const price = (snapshot.latestQuote.bp + snapshot.latestQuote.ap) / 2;
        return {
          price,
          bid: snapshot.latestQuote.bp,
          ask: snapshot.latestQuote.ap
        };
      }
      if (snapshot.latestTrade && snapshot.latestTrade.p > 0) {
        return { price: snapshot.latestTrade.p };
      }
      log.warn("StrategyOrderService", "Snapshot has no valid price data", {
        symbol
      });
      return { price: null };
    } catch (error) {
      log.error("StrategyOrderService", "Failed to get price data", {
        symbol,
        error: error instanceof Error ? error.message : String(error)
      });
      return { price: null };
    }
  }
  /**
   * Get current portfolio value for position sizing
   */
  async getPortfolioValue() {
    try {
      const account = await alpaca.getAccount();
      return parseFloat(account.portfolio_value);
    } catch (error) {
      log.error("StrategyOrderService", "Failed to get portfolio value", {
        error: error instanceof Error ? error.message : String(error)
      });
      return null;
    }
  }
  /**
   * Execute a sell order for an existing position using strategy context
   */
  async closePosition(strategyId, symbol, quantity, traceId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return {
        success: false,
        error: `Strategy not found: ${strategyId}`
      };
    }
    const context = parseStrategyContext(strategy);
    let closeQty = quantity;
    if (!closeQty) {
      try {
        const positions2 = await alpaca.getPositions();
        const position = positions2.find((p) => p.symbol === symbol);
        if (!position) {
          return {
            success: false,
            error: `No position found for ${symbol}`
          };
        }
        closeQty = Math.abs(parseFloat(position.qty));
      } catch (error) {
        return {
          success: false,
          error: `Failed to get position: ${error instanceof Error ? error.message : String(error)}`
        };
      }
    }
    const orderRequest = {
      symbol,
      side: "sell",
      qty: closeQty.toString(),
      type: getOrderType(context),
      timeInForce: getTimeInForce(context),
      strategyId,
      traceId
    };
    const result = await unifiedOrderExecutor.submitOrder(orderRequest);
    return {
      success: result.success,
      orderId: result.orderId,
      clientOrderId: result.clientOrderId,
      status: result.status,
      error: result.error,
      context: {
        strategyId: strategy.id,
        strategyName: strategy.name,
        mode: strategy.mode || null
      }
    };
  }
  /**
   * Get strategy execution context for a strategy
   */
  async getExecutionContext(strategyId) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return null;
    }
    return parseStrategyContext(strategy);
  }
  /**
   * Validate an AI decision against strategy rules without executing
   */
  async validateDecisionForStrategy(strategyId, decision) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return {
        valid: false,
        reason: `Strategy not found: ${strategyId}`
      };
    }
    const context = parseStrategyContext(strategy);
    const positionCount = await this.getStrategyPositionCount(strategyId);
    return validateDecision(decision, context, positionCount);
  }
  /**
   * Preview position size calculation for a strategy
   */
  async previewPositionSize(strategyId, symbol) {
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return {
        notional: 0,
        quantity: 0,
        warnings: [`Strategy not found: ${strategyId}`]
      };
    }
    const context = parseStrategyContext(strategy);
    const portfolioValue = await this.getPortfolioValue();
    const quote = await this.getCurrentPrice(symbol);
    if (!portfolioValue || !quote.price) {
      return {
        notional: 0,
        quantity: 0,
        warnings: ["Unable to get portfolio value or current price"]
      };
    }
    const result = calculatePositionSize(context, portfolioValue, quote.price);
    return {
      ...result,
      portfolioValue,
      currentPrice: quote.price
    };
  }
};
var strategyOrderService = new StrategyOrderService();

// server/routes/strategies.ts
import { z as z9 } from "zod";
var router5 = Router7();
router5.get("/", requireAuth, async (req, res) => {
  try {
    const strategies2 = await storage.getStrategies();
    res.json(strategies2);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get strategies", { error });
    return serverError(res, "Failed to get strategies");
  }
});
router5.get("/:id", requireAuth, async (req, res) => {
  try {
    const strategy = await storage.getStrategy(req.params.id);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    res.json(strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get strategy", { error });
    return serverError(res, "Failed to get strategy");
  }
});
router5.post("/", requireAuth, async (req, res) => {
  try {
    const parsed = insertStrategySchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const strategy = await storage.createStrategy(parsed.data);
    res.status(201).json(strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to create strategy", { error });
    return serverError(res, "Failed to create strategy");
  }
});
router5.patch("/:id", requireAuth, async (req, res) => {
  try {
    const updateSchema = insertStrategySchema.partial();
    const parsed = updateSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const strategy = await storage.updateStrategy(req.params.id, parsed.data);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    res.json(strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to update strategy", { error });
    return serverError(res, "Failed to update strategy");
  }
});
router5.put("/:id", requireAuth, async (req, res) => {
  try {
    const parsed = insertStrategySchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const strategy = await storage.updateStrategy(req.params.id, parsed.data);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    res.json(strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to update strategy", { error });
    return serverError(res, "Failed to update strategy");
  }
});
router5.post("/:id/toggle", requireAuth, async (req, res) => {
  try {
    const currentStrategy = await storage.getStrategy(req.params.id);
    if (!currentStrategy) {
      return notFound(res, "Strategy not found");
    }
    const strategy = await storage.toggleStrategy(
      req.params.id,
      !currentStrategy.isActive
    );
    res.json(strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to toggle strategy", { error });
    return serverError(res, "Failed to toggle strategy");
  }
});
router5.post("/:id/start", requireAuth, async (req, res) => {
  try {
    const strategy = await storage.getStrategy(req.params.id);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    const result = await alpacaTradingEngine.startStrategy(req.params.id);
    if (!result.success) {
      return badRequest(res, result.error || "Failed to start strategy");
    }
    const updatedStrategy = await storage.getStrategy(req.params.id);
    res.json(updatedStrategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to start strategy", { error });
    return serverError(res, "Failed to start strategy");
  }
});
router5.post("/:id/stop", requireAuth, async (req, res) => {
  try {
    const strategy = await storage.getStrategy(req.params.id);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    const result = await alpacaTradingEngine.stopStrategy(req.params.id);
    if (!result.success) {
      return badRequest(res, result.error || "Failed to stop strategy");
    }
    const updatedStrategy = await storage.getStrategy(req.params.id);
    res.json(updatedStrategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to stop strategy", { error });
    return serverError(res, "Failed to stop strategy");
  }
});
router5.get("/:id/status", requireAuth, async (req, res) => {
  try {
    const strategy = await storage.getStrategy(req.params.id);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    const strategyState = alpacaTradingEngine.getStrategyState(req.params.id);
    res.json({
      id: req.params.id,
      name: strategy.name,
      isActive: strategy.isActive,
      status: strategy.status,
      mode: strategy.mode,
      isRunning: strategyState?.isRunning ?? false,
      lastCheck: strategyState?.lastCheck ?? null,
      error: strategyState?.error ?? null
    });
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get strategy status", { error });
    return serverError(res, "Failed to get strategy status");
  }
});
router5.post("/:id/deploy", requireAuth, async (req, res) => {
  try {
    const parsed = deployStrategySchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, "Mode must be 'paper' or 'live'");
    }
    const result = await strategyLifecycleService.deployStrategy(
      req.params.id,
      parsed.data.mode
    );
    if (!result.success) {
      return badRequest(res, result.error || "Failed to deploy strategy");
    }
    await alpacaTradingEngine.startStrategy(req.params.id);
    res.json(result.strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to deploy strategy", { error });
    return serverError(res, "Failed to deploy strategy");
  }
});
router5.post("/:id/pause", requireAuth, async (req, res) => {
  try {
    const result = await strategyLifecycleService.pauseStrategy(req.params.id);
    if (!result.success) {
      return badRequest(res, result.error || "Failed to pause strategy");
    }
    await alpacaTradingEngine.stopStrategy(req.params.id);
    res.json(result.strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to pause strategy", { error });
    return serverError(res, "Failed to pause strategy");
  }
});
router5.post("/:id/resume", requireAuth, async (req, res) => {
  try {
    const result = await strategyLifecycleService.resumeStrategy(req.params.id);
    if (!result.success) {
      return badRequest(res, result.error || "Failed to resume strategy");
    }
    await alpacaTradingEngine.startStrategy(req.params.id);
    res.json(result.strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to resume strategy", { error });
    return serverError(res, "Failed to resume strategy");
  }
});
router5.post(
  "/:id/lifecycle/stop",
  requireAuth,
  async (req, res) => {
    try {
      const { closePositions } = req.body;
      const result = await strategyLifecycleService.stopStrategy(
        req.params.id,
        closePositions
      );
      if (!result.success) {
        if (result.requiresConfirmation) {
          return res.status(200).json({
            requiresConfirmation: true,
            positionCount: result.positionCount,
            message: result.message
          });
        }
        return badRequest(res, result.error || "Failed to stop strategy");
      }
      await alpacaTradingEngine.stopStrategy(req.params.id);
      res.json(result.strategy);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to stop strategy (lifecycle)", {
        error
      });
      return serverError(res, "Failed to stop strategy");
    }
  }
);
router5.post(
  "/:id/backtest/start",
  requireAuth,
  async (req, res) => {
    try {
      const result = await strategyLifecycleService.startBacktest(
        req.params.id
      );
      if (!result.success) {
        return badRequest(res, result.error || "Failed to start backtest");
      }
      res.json(result.strategy);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to start backtest", { error });
      return serverError(res, "Failed to start backtest");
    }
  }
);
router5.post(
  "/:id/backtest/complete",
  requireAuth,
  async (req, res) => {
    try {
      const { backtestId, performance } = req.body;
      if (!backtestId) {
        return badRequest(res, "backtestId is required");
      }
      const result = await strategyLifecycleService.completeBacktest(
        req.params.id,
        backtestId,
        performance
      );
      if (!result.success) {
        return badRequest(res, result.error || "Failed to complete backtest");
      }
      res.json(result.strategy);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to complete backtest", { error });
      return serverError(res, "Failed to complete backtest");
    }
  }
);
router5.post("/:id/reset", requireAuth, async (req, res) => {
  try {
    const result = await strategyLifecycleService.resetToDraft(req.params.id);
    if (!result.success) {
      return badRequest(res, result.error || "Failed to reset strategy");
    }
    res.json(result.strategy);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to reset strategy", { error });
    return serverError(res, "Failed to reset strategy");
  }
});
router5.post(
  "/:id/metrics/update",
  requireAuth,
  async (req, res) => {
    try {
      const result = await strategyLifecycleService.updatePerformanceMetrics(
        req.params.id
      );
      if (!result.success) {
        return badRequest(res, result.error || "Failed to update metrics");
      }
      res.json(result.strategy);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to update strategy metrics", {
        error
      });
      return serverError(res, "Failed to update strategy metrics");
    }
  }
);
router5.get("/running", requireAuth, async (req, res) => {
  try {
    const strategies2 = await strategyLifecycleService.getRunningStrategies();
    res.json(strategies2);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get running strategies", { error });
    return serverError(res, "Failed to get running strategies");
  }
});
router5.get(
  "/moving-average/schema",
  requireAuth,
  async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to get MA strategy schema", { error });
      return serverError(res, "Failed to get strategy schema");
    }
  }
);
router5.get(
  "/mean-reversion/schema",
  requireAuth,
  async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error(
        "StrategiesAPI",
        "Failed to get mean reversion strategy schema",
        {
          error
        }
      );
      return serverError(res, "Failed to get strategy schema");
    }
  }
);
router5.get(
  "/momentum/schema",
  requireAuth,
  async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to get momentum strategy schema", {
        error
      });
      return serverError(res, "Failed to get strategy schema");
    }
  }
);
router5.get("/all-schemas", requireAuth, async (req, res) => {
  try {
    const { ALL_STRATEGIES: ALL_STRATEGIES2 } = await Promise.resolve().then(() => (init_strategies(), strategies_exports));
    res.json(ALL_STRATEGIES2);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get all strategy schemas", { error });
    return serverError(res, "Failed to get strategy schemas");
  }
});
router5.post(
  "/moving-average/backtest",
  requireAuth,
  async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2, backtestMovingAverageStrategy: backtestMovingAverageStrategy2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const config2 = normalizeMovingAverageConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMovingAverageStrategy2(config2, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to run MA backtest", { error });
      return serverError(
        res,
        error.message || "Failed to run backtest"
      );
    }
  }
);
router5.post(
  "/moving-average/ai-validate",
  async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const { validateMovingAverageConfig: validateMovingAverageConfig2, getValidatorStatus: getValidatorStatus2 } = await Promise.resolve().then(() => (init_ai_strategy_validator(), ai_strategy_validator_exports));
      const status = getValidatorStatus2();
      if (!status.available) {
        return res.status(503).json({ error: "AI validation service is not available" });
      }
      const config2 = normalizeMovingAverageConfig2(req.body.config || req.body);
      const marketIntelligence = req.body.marketIntelligence;
      const result = await validateMovingAverageConfig2(
        config2,
        marketIntelligence
      );
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to AI validate strategy", { error });
      return serverError(
        res,
        error.message || "Failed to validate strategy"
      );
    }
  }
);
router5.post(
  "/mean-reversion/backtest",
  requireAuth,
  async (req, res) => {
    try {
      const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      const config2 = normalizeMeanReversionConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMeanReversionStrategy2(config2, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to run mean reversion backtest", {
        error
      });
      return serverError(
        res,
        error.message || "Failed to run backtest"
      );
    }
  }
);
router5.post(
  "/mean-reversion/signal",
  requireAuth,
  async (req, res) => {
    try {
      const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, generateMeanReversionSignal: generateMeanReversionSignal2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      const config2 = normalizeMeanReversionConfig2(req.body.config || req.body);
      const prices = req.body.prices;
      if (!prices || !Array.isArray(prices) || prices.length < config2.lookbackPeriod) {
        return badRequest(
          res,
          `Need at least ${config2.lookbackPeriod} price points`
        );
      }
      const signal = generateMeanReversionSignal2(prices, config2);
      res.json(signal);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to generate mean reversion signal", {
        error
      });
      return serverError(
        res,
        error.message || "Failed to generate signal"
      );
    }
  }
);
router5.post(
  "/momentum/backtest",
  requireAuth,
  async (req, res) => {
    try {
      const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      const config2 = normalizeMomentumConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMomentumStrategy2(config2, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to run momentum backtest", { error });
      return serverError(
        res,
        error.message || "Failed to run backtest"
      );
    }
  }
);
router5.post(
  "/momentum/signal",
  requireAuth,
  async (req, res) => {
    try {
      const { normalizeMomentumConfig: normalizeMomentumConfig2, generateMomentumSignal: generateMomentumSignal2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      const config2 = normalizeMomentumConfig2(req.body.config || req.body);
      const prices = req.body.prices;
      const requiredLength = Math.max(config2.lookbackPeriod, config2.rsiPeriod) + 1;
      if (!prices || !Array.isArray(prices) || prices.length < requiredLength) {
        return badRequest(res, `Need at least ${requiredLength} price points`);
      }
      const signal = generateMomentumSignal2(prices, config2);
      res.json(signal);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to generate momentum signal", {
        error
      });
      return serverError(
        res,
        error.message || "Failed to generate signal"
      );
    }
  }
);
router5.post("/backtest", requireAuth, async (req, res) => {
  try {
    const { strategyType, symbol, lookbackDays = 365 } = req.body;
    const parameters = req.body.parameters || {};
    if (!strategyType || typeof strategyType !== "string") {
      return badRequest(res, "strategyType is required");
    }
    if (!symbol || typeof symbol !== "string") {
      return badRequest(res, "symbol is required");
    }
    let result;
    switch (strategyType) {
      case "moving-average-crossover":
      case "moving-average": {
        const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2, backtestMovingAverageStrategy: backtestMovingAverageStrategy2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
        const config2 = normalizeMovingAverageConfig2({ symbol, ...parameters });
        result = await backtestMovingAverageStrategy2(config2, lookbackDays);
        break;
      }
      case "mean-reversion":
      case "mean-reversion-scalper": {
        const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
        const config2 = normalizeMeanReversionConfig2({ symbol, ...parameters });
        result = await backtestMeanReversionStrategy2(config2, lookbackDays);
        break;
      }
      case "momentum":
      case "momentum-breakout": {
        const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
        const config2 = normalizeMomentumConfig2({ symbol, ...parameters });
        result = await backtestMomentumStrategy2(config2, lookbackDays);
        break;
      }
      case "range-trading":
      case "breakout": {
        const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
        const defaultParams = {
          lookbackPeriod: parameters?.lookbackPeriod ?? 20,
          deviationThreshold: parameters?.deviationThreshold ?? 2,
          maxHoldingPeriod: parameters?.maxHoldingPeriod ?? 10,
          ...parameters
        };
        const config2 = normalizeMeanReversionConfig2({
          symbol,
          ...defaultParams
        });
        result = await backtestMeanReversionStrategy2(config2, lookbackDays);
        break;
      }
      default: {
        const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
        const config2 = normalizeMomentumConfig2({ symbol, ...parameters });
        result = await backtestMomentumStrategy2(config2, lookbackDays);
        break;
      }
    }
    res.json(result);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to run generic backtest", { error });
    return serverError(
      res,
      error.message || "Failed to run backtest"
    );
  }
});
router5.post("/config", requireAuth, async (req, res) => {
  try {
    const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
    const config2 = normalizeMovingAverageConfig2(req.body);
    res.json(config2);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to normalize strategy config", {
      error
    });
    return serverError(
      res,
      error.message || "Failed to normalize config"
    );
  }
});
router5.post("/validate", requireAuth, async (req, res) => {
  try {
    const { name, type, parameters } = req.body;
    const errors = [];
    if (!name || typeof name !== "string" || name.trim().length === 0) {
      errors.push("Strategy name is required");
    }
    if (!type || typeof type !== "string") {
      errors.push("Strategy type is required");
    }
    if (!parameters || typeof parameters !== "object") {
      errors.push("Strategy parameters are required");
    }
    if (errors.length > 0) {
      return validationError(res, errors.join(", "));
    }
    res.json({ valid: true, name, type, parameters });
  } catch (error) {
    log.error("StrategiesAPI", "Failed to validate strategy", { error });
    return serverError(
      res,
      error.message || "Failed to validate strategy"
    );
  }
});
router5.get("/versions", requireAuth, async (req, res) => {
  try {
    const strategyId = req.query.strategyId;
    const limit4 = parseInt(req.query.limit) || 50;
    if (!strategyId) {
      return badRequest(res, "strategyId is required");
    }
    const versions = await storage.getStrategyVersionsByStrategy(strategyId);
    res.json({ versions, count: versions.length });
  } catch (error) {
    log.error("StrategiesAPI", `Failed to list strategy versions: ${error}`);
    return serverError(res, "Failed to list strategy versions");
  }
});
router5.post("/versions", requireAuth, async (req, res) => {
  try {
    const {
      strategyId,
      name,
      spec,
      createdBy,
      universeConfig: universeConfig2,
      signalsConfig,
      riskConfig,
      executionConfig,
      backtestResultId,
      description
    } = req.body;
    if (!strategyId || !name || !spec) {
      return badRequest(res, "strategyId, name, and spec are required");
    }
    const sanitizedName = sanitizeInput(name);
    const sanitizedDescription = description ? sanitizeInput(description) : void 0;
    const version = await storage.getNextVersionNumber(strategyId);
    const strategyVersion = await storage.createStrategyVersion({
      strategyId,
      name: sanitizedName,
      version,
      spec,
      createdBy,
      universeConfig: universeConfig2,
      signalsConfig,
      riskConfig,
      executionConfig,
      backtestResultId,
      description: sanitizedDescription,
      status: "draft"
    });
    res.json(strategyVersion);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to create strategy version: ${error}`);
    return serverError(
      res,
      error.message || "Failed to create strategy version"
    );
  }
});
router5.get(
  "/versions/:id",
  requireAuth,
  async (req, res) => {
    try {
      const version = await storage.getStrategyVersion(req.params.id);
      if (!version) {
        return notFound(res, "Strategy version not found");
      }
      res.json(version);
    } catch (error) {
      log.error("StrategiesAPI", `Failed to get strategy version: ${error}`);
      return serverError(res, "Failed to get strategy version");
    }
  }
);
router5.patch(
  "/versions/:id",
  requireAuth,
  async (req, res) => {
    try {
      const sanitizedBody = sanitizeStrategyInput(req.body);
      const version = await storage.updateStrategyVersion(
        req.params.id,
        sanitizedBody
      );
      if (!version) {
        return notFound(res, "Strategy version not found");
      }
      res.json(version);
    } catch (error) {
      log.error("StrategiesAPI", `Failed to update strategy version: ${error}`);
      return serverError(
        res,
        error.message || "Failed to update strategy version"
      );
    }
  }
);
router5.post(
  "/versions/:id/activate",
  requireAuth,
  async (req, res) => {
    try {
      const version = await storage.getStrategyVersion(req.params.id);
      if (!version) {
        return notFound(res, "Strategy version not found");
      }
      if (version.strategyId) {
        const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
        const { backtestRuns: backtestRuns3 } = await Promise.resolve().then(() => (init_schema2(), schema_exports));
        const { eq: eq31, and: and21, desc: desc23 } = await import("drizzle-orm");
        const successfulBacktests = await db2.select().from(backtestRuns3).where(
          and21(
            eq31(backtestRuns3.strategyId, version.strategyId),
            eq31(backtestRuns3.status, "DONE")
          )
        ).orderBy(desc23(backtestRuns3.createdAt)).limit(1);
        if (successfulBacktests.length === 0) {
          log.warn(
            "StrategiesAPI",
            `Activation blocked for strategy version ${req.params.id}: No successful backtest found`
          );
          return validationError(
            res,
            "Strategy must have at least one successful backtest before activation. Please run a backtest and verify results before activating this strategy.",
            {
              strategyId: version.strategyId,
              strategyVersionId: req.params.id
            }
          );
        }
        log.info(
          "StrategiesAPI",
          `Backtest validation passed for strategy version ${req.params.id}`,
          {
            strategyId: version.strategyId,
            backtestId: successfulBacktests[0].id,
            backtestDate: successfulBacktests[0].createdAt
          }
        );
      }
      const updatedVersion = await storage.updateStrategyVersion(
        req.params.id,
        {
          status: "active",
          activatedAt: /* @__PURE__ */ new Date()
        }
      );
      if (!updatedVersion) {
        return notFound(res, "Strategy version not found");
      }
      res.json(updatedVersion);
    } catch (error) {
      log.error(
        "StrategiesAPI",
        `Failed to activate strategy version: ${error}`
      );
      return serverError(
        res,
        error.message || "Failed to activate strategy version"
      );
    }
  }
);
router5.post(
  "/versions/:id/archive",
  requireAuth,
  async (req, res) => {
    try {
      const version = await storage.updateStrategyVersion(req.params.id, {
        status: "archived"
      });
      if (!version) {
        return res.status(404).json({ error: "Strategy version not found" });
      }
      res.json(version);
    } catch (error) {
      log.error(
        "StrategiesAPI",
        `Failed to archive strategy version: ${error}`
      );
      res.status(500).json({
        error: error.message || "Failed to archive strategy version"
      });
    }
  }
);
router5.get(
  "/versions/:strategyId/latest",
  async (req, res) => {
    try {
      const version = await storage.getLatestStrategyVersion(
        req.params.strategyId
      );
      if (!version) {
        return res.status(404).json({ error: "No versions found for this strategy" });
      }
      res.json(version);
    } catch (error) {
      log.error(
        "StrategiesAPI",
        `Failed to get latest strategy version: ${error}`
      );
      res.status(500).json({ error: "Failed to get latest strategy version" });
    }
  }
);
router5.delete("/:id", requireAuth, async (req, res) => {
  try {
    const deleted = await storage.deleteStrategy(req.params.id);
    if (!deleted) {
      return notFound(res, "Strategy not found");
    }
    res.json({ success: true, message: "Strategy deleted" });
  } catch (error) {
    log.error("StrategiesAPI", "Failed to delete strategy", { error });
    return serverError(res, "Failed to delete strategy");
  }
});
router5.get(
  "/:id/performance",
  requireAuth,
  async (req, res) => {
    try {
      const strategyId = req.params.id;
      const strategy = await storage.getStrategy(strategyId);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      const { alpacaTradingEngine: alpacaTradingEngine2 } = await Promise.resolve().then(() => (init_alpaca_trading_engine(), alpaca_trading_engine_exports));
      const strategyState = alpacaTradingEngine2.getStrategyState(strategyId);
      const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { trades: trades3 } = await Promise.resolve().then(() => (init_schema2(), schema_exports));
      const { eq: eq31, and: and21, isNotNull: isNotNull2, sql: sql33 } = await import("drizzle-orm");
      const allTrades = await db2.select().from(trades3).where(eq31(trades3.strategyId, strategyId)).orderBy(sql33`${trades3.executedAt} DESC`).limit(1e3);
      const totalTrades = allTrades.length;
      const closingTrades = allTrades.filter(
        (t) => t.pnl !== null && t.pnl !== "0"
      );
      const winningTrades = closingTrades.filter(
        (t) => parseFloat(t.pnl || "0") > 0
      );
      const losingTrades = closingTrades.filter(
        (t) => parseFloat(t.pnl || "0") < 0
      );
      const winRate = closingTrades.length > 0 ? winningTrades.length / closingTrades.length * 100 : 0;
      const totalPnl = closingTrades.reduce((sum, t) => {
        return sum + parseFloat(t.pnl || "0");
      }, 0);
      const avgWin = winningTrades.length > 0 ? winningTrades.reduce(
        (sum, t) => sum + parseFloat(t.pnl || "0"),
        0
      ) / winningTrades.length : 0;
      const avgLoss = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + parseFloat(t.pnl || "0"), 0) / losingTrades.length : 0;
      const { positions: positions2 } = await Promise.resolve().then(() => (init_schema2(), schema_exports));
      const currentPositions = await db2.select().from(positions2).where(eq31(positions2.strategyId, strategyId));
      const unrealizedPnl = currentPositions.reduce((sum, p) => {
        return sum + parseFloat(p.unrealizedPnl || "0");
      }, 0);
      const performance = {
        strategyId,
        strategyName: strategy.name,
        status: strategyState?.isRunning ? "running" : "stopped",
        lastCheck: strategyState?.lastCheck || null,
        lastError: strategyState?.error || null,
        // Real-time metrics
        metrics: {
          totalTrades,
          closingTrades: closingTrades.length,
          openingTrades: totalTrades - closingTrades.length,
          // P&L metrics
          realizedPnl: totalPnl,
          unrealizedPnl,
          totalPnl: totalPnl + unrealizedPnl,
          // Win/Loss metrics
          winningTrades: winningTrades.length,
          losingTrades: losingTrades.length,
          winRate: parseFloat(winRate.toFixed(2)),
          // Average trade metrics
          avgWin: parseFloat(avgWin.toFixed(2)),
          avgLoss: parseFloat(avgLoss.toFixed(2)),
          avgTrade: closingTrades.length > 0 ? parseFloat((totalPnl / closingTrades.length).toFixed(2)) : 0,
          // Profit factor (avg win / abs(avg loss))
          profitFactor: avgLoss !== 0 ? parseFloat((avgWin / Math.abs(avgLoss)).toFixed(2)) : avgWin > 0 ? Infinity : 0
        },
        // Current positions
        positions: currentPositions.map((p) => ({
          id: p.id,
          symbol: p.symbol,
          side: p.side,
          quantity: parseFloat(p.quantity),
          entryPrice: parseFloat(p.entryPrice),
          currentPrice: parseFloat(p.currentPrice || p.entryPrice),
          unrealizedPnl: parseFloat(p.unrealizedPnl || "0"),
          openedAt: p.openedAt
        })),
        // Recent trades (last 10)
        recentTrades: allTrades.slice(0, 10).map((t) => ({
          id: t.id,
          symbol: t.symbol,
          side: t.side,
          quantity: parseFloat(t.quantity),
          price: parseFloat(t.price),
          pnl: t.pnl ? parseFloat(t.pnl) : null,
          status: t.status,
          executedAt: t.executedAt,
          notes: t.notes
        })),
        // Last decision info (if available)
        lastDecision: strategyState?.lastDecision ? {
          action: strategyState.lastDecision.action,
          confidence: strategyState.lastDecision.confidence,
          reasoning: strategyState.lastDecision.reasoning,
          riskLevel: strategyState.lastDecision.riskLevel
        } : null
      };
      res.json(performance);
    } catch (error) {
      log.error(
        "StrategiesAPI",
        `Failed to get strategy performance: ${error}`
      );
      res.status(500).json({
        error: error.message || "Failed to get strategy performance"
      });
    }
  }
);
var strategyOrderRequestSchema = z9.object({
  symbol: z9.string().min(1).max(10),
  side: z9.enum(["buy", "sell"]),
  decision: z9.object({
    confidence: z9.number().min(0).max(1),
    reasoning: z9.string().optional()
  }).optional(),
  overrideQty: z9.number().positive().optional(),
  overrideNotional: z9.number().positive().optional()
});
router5.post("/:id/orders", requireAuth, async (req, res) => {
  try {
    const strategyId = req.params.id;
    const parsed = strategyOrderRequestSchema.safeParse(req.body);
    if (!parsed.success) {
      return validationError(
        res,
        parsed.error.errors.map((e) => e.message).join(", ")
      );
    }
    const { symbol, side, decision, overrideQty, overrideNotional } = parsed.data;
    const result = await strategyOrderService.executeWithStrategy({
      strategyId,
      symbol,
      side,
      decision: decision ? {
        symbol,
        action: side,
        confidence: decision.confidence,
        reasoning: decision.reasoning
      } : void 0,
      overrideQty,
      overrideNotional,
      traceId: req.headers["x-trace-id"]
    });
    if (!result.success) {
      log.warn("StrategiesAPI", "Strategy order failed", {
        strategyId,
        symbol,
        error: result.error
      });
      return res.status(400).json({
        success: false,
        error: result.error,
        validation: result.validation,
        context: result.context
      });
    }
    log.info("StrategiesAPI", "Strategy order executed", {
      strategyId,
      symbol,
      side,
      orderId: result.orderId
    });
    res.json(result);
  } catch (error) {
    log.error("StrategiesAPI", "Failed to execute strategy order", { error });
    return serverError(res, "Failed to execute strategy order");
  }
});
router5.get("/:id/orders", requireAuth, async (req, res) => {
  try {
    const strategyId = req.params.id;
    const limit4 = parseInt(req.query.limit) || 50;
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return notFound(res, "Strategy not found");
    }
    const orders2 = await storage.getOrdersByStrategy(strategyId, limit4);
    res.json({
      strategyId,
      strategyName: strategy.name,
      orders: orders2,
      total: orders2.length
    });
  } catch (error) {
    log.error("StrategiesAPI", "Failed to get strategy orders", { error });
    return serverError(res, "Failed to get strategy orders");
  }
});
router5.post(
  "/:id/close-position",
  requireAuth,
  async (req, res) => {
    try {
      const strategyId = req.params.id;
      const { symbol, quantity } = req.body;
      if (!symbol) {
        return badRequest(res, "Symbol is required");
      }
      const result = await strategyOrderService.closePosition(
        strategyId,
        symbol,
        quantity,
        req.headers["x-trace-id"]
      );
      if (!result.success) {
        return res.status(400).json({
          success: false,
          error: result.error,
          context: result.context
        });
      }
      log.info("StrategiesAPI", "Position closed via strategy", {
        strategyId,
        symbol,
        orderId: result.orderId
      });
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to close position", { error });
      return serverError(res, "Failed to close position");
    }
  }
);
router5.get(
  "/:id/execution-context",
  requireAuth,
  async (req, res) => {
    try {
      const strategyId = req.params.id;
      const context = await strategyOrderService.getExecutionContext(strategyId);
      if (!context) {
        return notFound(res, "Strategy not found");
      }
      res.json(context);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to get execution context", { error });
      return serverError(res, "Failed to get execution context");
    }
  }
);
router5.post(
  "/:id/preview-position-size",
  requireAuth,
  async (req, res) => {
    try {
      const strategyId = req.params.id;
      const { symbol } = req.body;
      if (!symbol) {
        return badRequest(res, "Symbol is required");
      }
      const result = await strategyOrderService.previewPositionSize(
        strategyId,
        symbol
      );
      res.json(result);
    } catch (error) {
      log.error("StrategiesAPI", "Failed to preview position size", { error });
      return serverError(res, "Failed to preview position size");
    }
  }
);
var strategies_default = router5;

// server/routes/arena.ts
import { Router as Router8 } from "express";

// server/ai/arenaCoordinator.ts
init_llmGateway();
init_logger();
init_db();
init_schema2();
import { eq as eq20, and as and15, gte as gte7 } from "drizzle-orm";
import { z as z10 } from "zod";
var AgentDecisionOutputSchema = z10.object({
  action: z10.enum(["buy", "sell", "hold", "scale_in", "scale_out"]),
  symbols: z10.array(z10.string()).optional().default([]),
  confidence: z10.number().min(0).max(1),
  stance: z10.enum(["bullish", "bearish", "neutral", "abstain"]),
  rationale: z10.string(),
  keySignals: z10.array(z10.string()).optional().default([]),
  risks: z10.array(z10.string()).optional().default([]),
  proposedOrder: z10.object({
    symbol: z10.string(),
    side: z10.enum(["buy", "sell"]),
    qty: z10.number().optional(),
    notional: z10.number().optional(),
    type: z10.enum(["market", "limit"]),
    limitPrice: z10.number().optional()
  }).optional()
});
var DEFAULT_ESCALATION_POLICY = {
  disagreementThreshold: 0.34,
  minConfidenceThreshold: 0.62,
  highRiskPortfolioDeltaPct: 1.5,
  maxPowerCallsPerDay: 25
};
var ROLE_PROMPTS2 = {
  bull: `You are the BULL analyst. Find reasons WHY this trade could succeed. Focus on: upside catalysts, momentum, positive news, growth. Be optimistic but data-driven.`,
  bear: `You are the BEAR analyst. Find reasons WHY this trade could fail. Focus on: downside risks, headwinds, negative news, valuation concerns. Be skeptical but fair.`,
  risk_manager: `You are the RISK MANAGER. Assess position sizing and risk controls. Focus on: max drawdown, stop-loss levels, concentration, correlation risks. Be conservative.`,
  technical_analyst: `You are the TECHNICAL ANALYST. Analyze price action and indicators. Focus on: support/resistance, trend strength, RSI/MACD, volume. Provide specific levels.`,
  fundamental_analyst: `You are the FUNDAMENTAL ANALYST. Analyze company fundamentals. Focus on: valuation, earnings, growth rates, competitive position. Assess intrinsic value.`,
  judge: `You are the JUDGE. Synthesize all analyst opinions into a final decision. Weigh arguments and confidence levels. Make a clear BUY/SELL/HOLD decision.`
};
var ArenaCoordinator = class {
  escalationPolicy;
  powerCallsToday = 0;
  lastDayReset = /* @__PURE__ */ new Date();
  constructor(policy) {
    this.escalationPolicy = policy || DEFAULT_ESCALATION_POLICY;
  }
  resetDailyCounters() {
    const now = /* @__PURE__ */ new Date();
    if (now.getDate() !== this.lastDayReset.getDate()) {
      this.powerCallsToday = 0;
      this.lastDayReset = now;
    }
  }
  async runArena(config2) {
    this.resetDailyCounters();
    const traceId = `arena-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
    const startTime = Date.now();
    log.info("ArenaCoordinator", `Starting arena run`, {
      traceId,
      mode: config2.mode,
      symbols: config2.symbols
    });
    const agentProfiles = await this.getActiveAgentProfiles(
      config2.agentProfileIds
    );
    if (agentProfiles.length === 0) {
      throw new Error("No active agent profiles found for arena run");
    }
    const run = await this.createArenaRun({
      traceId,
      mode: config2.mode,
      symbols: config2.symbols,
      agentProfileIds: agentProfiles.map((p) => p.id),
      strategyVersionId: config2.strategyVersionId,
      triggeredBy: config2.triggeredBy,
      status: "running",
      startedAt: /* @__PURE__ */ new Date()
    });
    const marketContext = await this.gatherMarketContext(
      config2.symbols,
      traceId
    );
    const cheapAgents = agentProfiles.filter(
      (p) => p.mode === "cheap_first" || p.mode === "always"
    );
    const powerAgents = agentProfiles.filter(
      (p) => p.mode === "escalation_only"
    );
    const allDecisions = [];
    let escalationTriggered = false;
    let escalationReason;
    log.info("ArenaCoordinator", `Running ${cheapAgents.length} cheap agents`, {
      traceId
    });
    const cheapDecisions = await Promise.all(
      cheapAgents.map(
        (agent) => this.runAgent(
          agent,
          config2.symbols,
          marketContext,
          run.id,
          traceId,
          false
        )
      )
    );
    allDecisions.push(...cheapDecisions);
    let disagreementRate = this.calculateDisagreementRate(cheapDecisions);
    let avgConfidence = this.calculateAvgConfidence(cheapDecisions);
    const riskVeto = this.checkRiskVeto(cheapDecisions);
    if (this.shouldEscalate(disagreementRate, avgConfidence, riskVeto)) {
      escalationTriggered = true;
      escalationReason = this.getEscalationReason(
        disagreementRate,
        avgConfidence,
        riskVeto
      );
      log.info(
        "ArenaCoordinator",
        `Escalation triggered: ${escalationReason}`,
        { traceId }
      );
      if (powerAgents.length > 0 && this.powerCallsToday < this.escalationPolicy.maxPowerCallsPerDay) {
        log.info(
          "ArenaCoordinator",
          `Running ${powerAgents.length} power agents`,
          { traceId }
        );
        const powerDecisions = await Promise.all(
          powerAgents.map(
            (agent) => this.runAgent(
              agent,
              config2.symbols,
              marketContext,
              run.id,
              traceId,
              true
            )
          )
        );
        allDecisions.push(...powerDecisions);
        this.powerCallsToday += powerAgents.length;
        disagreementRate = this.calculateDisagreementRate(allDecisions);
        avgConfidence = this.calculateAvgConfidence(allDecisions);
      } else if (this.powerCallsToday >= this.escalationPolicy.maxPowerCallsPerDay) {
        log.warn(
          "ArenaCoordinator",
          `Power call limit reached (${this.powerCallsToday}/${this.escalationPolicy.maxPowerCallsPerDay}), using cheap decisions only`,
          { traceId }
        );
      }
    }
    const consensus = this.computeConsensus(
      allDecisions,
      disagreementRate,
      escalationTriggered,
      escalationReason
    );
    const durationMs = Date.now() - startTime;
    const totalCost = allDecisions.reduce(
      (sum, d) => sum + parseFloat(d.costUsd || "0"),
      0
    );
    const totalTokens = allDecisions.reduce(
      (sum, d) => sum + (d.tokensUsed || 0),
      0
    );
    await this.updateArenaRun(run.id, {
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs,
      totalCostUsd: String(totalCost),
      totalTokensUsed: totalTokens,
      escalationTriggered,
      escalationReason,
      consensusReached: consensus.decision !== "no_trade",
      finalDecision: consensus.decision,
      disagreementRate: String(disagreementRate),
      avgConfidence: String(avgConfidence)
    });
    if (consensus.decision !== "no_trade" && consensus.decision !== "hold" && consensus.orderIntent) {
      const outcomeLink = await this.createOutcomeLink(
        run.id,
        consensus,
        totalCost,
        traceId
      );
      log.info("ArenaCoordinator", `Created outcome link: ${outcomeLink.id}`, {
        traceId
      });
    }
    log.info("ArenaCoordinator", `Arena run completed`, {
      traceId,
      durationMs,
      decision: consensus.decision,
      confidence: consensus.confidence,
      escalated: escalationTriggered,
      totalCost: totalCost.toFixed(4),
      agentsRun: allDecisions.length
    });
    const updatedRun = await db.query.aiArenaRuns.findFirst({
      where: eq20(aiArenaRuns.id, run.id)
    });
    return {
      run: updatedRun,
      consensus,
      decisions: allDecisions
    };
  }
  async getActiveAgentProfiles(ids) {
    const allProfiles = await db.query.aiAgentProfiles.findMany({
      where: eq20(aiAgentProfiles.status, "active")
    });
    if (ids && ids.length > 0) {
      return allProfiles.filter((p) => ids.includes(p.id));
    }
    return allProfiles;
  }
  async createArenaRun(data) {
    const [run] = await db.insert(aiArenaRuns).values([data]).returning();
    return run;
  }
  async updateArenaRun(id, data) {
    await db.update(aiArenaRuns).set(data).where(eq20(aiArenaRuns.id, id));
  }
  async gatherMarketContext(symbols, traceId) {
    const context = {
      quotes: {},
      bars: {}
    };
    const quotePromises = symbols.map(async (symbol) => {
      try {
        const result = await invokeTool("getQuote", { symbol }, { traceId });
        if (result.success) {
          context.quotes[symbol] = result.result;
        }
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get quote for ${symbol}`, {
          error: e.message,
          traceId
        });
      }
    });
    const barsPromises = symbols.map(async (symbol) => {
      try {
        const result = await invokeTool(
          "getBars",
          { symbol, timeframe: "1Day", limit: 10 },
          { traceId }
        );
        if (result.success) {
          context.bars[symbol] = result.result;
        }
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get bars for ${symbol}`, {
          error: e.message,
          traceId
        });
      }
    });
    const accountPromise = (async () => {
      try {
        const result = await invokeTool("getAccount", {}, { traceId });
        if (result.success) context.account = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get account`, {
          error: e.message,
          traceId
        });
      }
    })();
    const positionsPromise = (async () => {
      try {
        const result = await invokeTool("listPositions", {}, { traceId });
        if (result.success) context.positions = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get positions`, {
          error: e.message,
          traceId
        });
      }
    })();
    const clockPromise = (async () => {
      try {
        const result = await invokeTool("getMarketClock", {}, { traceId });
        if (result.success) context.marketClock = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get market clock`, {
          error: e.message,
          traceId
        });
      }
    })();
    await Promise.all([
      ...quotePromises,
      ...barsPromises,
      accountPromise,
      positionsPromise,
      clockPromise
    ]);
    log.info("ArenaCoordinator", `Gathered market context`, {
      traceId,
      quotesCount: Object.keys(context.quotes).length,
      barsCount: Object.keys(context.bars).length,
      hasAccount: !!context.account,
      positionsCount: context.positions?.length || 0
    });
    return context;
  }
  async runAgent(agent, symbols, marketContext, arenaRunId, traceId, isEscalation, retryCount = 0) {
    const MAX_RETRIES = 2;
    const startTime = Date.now();
    const role = agent.role;
    try {
      const contextSummary = this.formatMarketContext(symbols, marketContext);
      const systemPrompt = `${ROLE_PROMPTS2[role] || ROLE_PROMPTS2.bull}

You are analyzing: ${symbols.join(", ")}

CRITICAL: You MUST respond with a valid JSON object containing these exact fields:
- action: one of "buy", "sell", "hold", "scale_in", "scale_out"
- confidence: number between 0 and 1
- stance: one of "bullish", "bearish", "neutral", "abstain"
- rationale: your reasoning (string)
- keySignals: array of key signals supporting your view
- risks: array of risks to consider
- proposedOrder: optional object with {symbol, side, qty?, notional?, type, limitPrice?}

${contextSummary}`;
      const request = {
        role: "technical_analyst",
        criticality: isEscalation ? "high" : "medium",
        purpose: "arena_evaluation",
        traceId,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: `Analyze ${symbols.join(", ")} and provide your ${role} perspective. Be specific and data-driven. Return valid JSON only. Do not include any text outside the JSON object.`
          }
        ],
        maxTokens: agent.maxTokens || 2e3,
        temperature: parseFloat(agent.temperature || "0.7"),
        responseFormat: { type: "json_object" }
      };
      const llmResult = await callLLM(request);
      const latencyMs = Date.now() - startTime;
      let output = null;
      let parseError = null;
      try {
        const rawJson = JSON.parse(llmResult.text || "{}");
        const parsed = AgentDecisionOutputSchema.safeParse(rawJson);
        if (parsed.success) {
          output = parsed.data;
        } else {
          parseError = parsed.error.message;
          log.warn(
            "ArenaCoordinator",
            `Agent output validation failed (attempt ${retryCount + 1})`,
            { traceId, agentId: agent.id, error: parseError }
          );
        }
      } catch (e) {
        parseError = e.message;
        log.warn(
          "ArenaCoordinator",
          `Failed to parse agent output JSON (attempt ${retryCount + 1})`,
          { traceId, agentId: agent.id, error: parseError }
        );
      }
      if (!output && retryCount < MAX_RETRIES) {
        log.info(
          "ArenaCoordinator",
          `Retrying agent ${agent.name} due to parse failure`,
          { traceId, retryCount: retryCount + 1 }
        );
        return this.runAgent(
          agent,
          symbols,
          marketContext,
          arenaRunId,
          traceId,
          isEscalation,
          retryCount + 1
        );
      }
      if (!output) {
        output = {
          action: "hold",
          symbols,
          confidence: 0.2,
          stance: "abstain",
          rationale: `Parse failed after ${MAX_RETRIES + 1} attempts: ${parseError}`,
          keySignals: [],
          risks: ["Output validation error - max retries exceeded"]
        };
      }
      const decision = {
        arenaRunId,
        agentProfileId: agent.id,
        role: agent.role,
        action: output.action,
        symbols: output.symbols || symbols,
        confidence: String(output.confidence),
        stance: output.stance,
        rationale: output.rationale,
        keySignals: Array.isArray(output.keySignals) ? JSON.stringify(output.keySignals) : output.keySignals,
        risks: Array.isArray(output.risks) ? JSON.stringify(output.risks) : output.risks,
        proposedOrder: typeof output.proposedOrder === "object" ? JSON.stringify(output.proposedOrder) : output.proposedOrder,
        tokensUsed: llmResult.tokensUsed,
        costUsd: String(llmResult.estimatedCost || 0),
        latencyMs,
        modelUsed: llmResult.model,
        wasEscalation: isEscalation,
        rawOutput: (llmResult.text || "").slice(0, 5e3),
        errorMessage: parseError && retryCount >= MAX_RETRIES ? `Parse failed: ${parseError}` : void 0
      };
      await db.insert(aiArenaAgentDecisions).values([decision]);
      await this.updateAgentStats(
        agent.id,
        llmResult.tokensUsed || 0,
        llmResult.estimatedCost || 0
      );
      log.info("ArenaCoordinator", `Agent ${agent.name} completed`, {
        traceId,
        action: output.action,
        confidence: output.confidence,
        isEscalation,
        latencyMs,
        retries: retryCount
      });
      return decision;
    } catch (error) {
      if (retryCount < MAX_RETRIES) {
        log.info(
          "ArenaCoordinator",
          `Retrying agent ${agent.name} due to error`,
          {
            traceId,
            retryCount: retryCount + 1,
            error: error.message
          }
        );
        return this.runAgent(
          agent,
          symbols,
          marketContext,
          arenaRunId,
          traceId,
          isEscalation,
          retryCount + 1
        );
      }
      const latencyMs = Date.now() - startTime;
      log.error(
        "ArenaCoordinator",
        `Agent ${agent.name} failed after ${MAX_RETRIES + 1} attempts: ${error.message}`,
        { traceId }
      );
      const decision = {
        arenaRunId,
        agentProfileId: agent.id,
        role: agent.role,
        action: "hold",
        symbols,
        confidence: "0",
        stance: "abstain",
        rationale: `Agent execution failed after ${MAX_RETRIES + 1} attempts`,
        keySignals: JSON.stringify([]),
        risks: JSON.stringify([error.message]),
        latencyMs,
        wasEscalation: isEscalation,
        errorMessage: error.message
      };
      await db.insert(aiArenaAgentDecisions).values([decision]);
      return decision;
    }
  }
  formatMarketContext(symbols, context) {
    let summary = "=== MARKET CONTEXT ===\n\n";
    if (context.marketClock) {
      summary += `Market Clock: ${JSON.stringify(context.marketClock)}

`;
    }
    if (context.account) {
      const acc = context.account;
      summary += `Account: Buying Power=$${acc.buying_power || "N/A"}, Equity=$${acc.equity || "N/A"}

`;
    }
    for (const symbol of symbols) {
      summary += `--- ${symbol} ---
`;
      if (context.quotes[symbol]) {
        const q = context.quotes[symbol];
        summary += `Quote: Bid=$${q.bid_price || "N/A"}, Ask=$${q.ask_price || "N/A"}, Last=$${q.last_price || q.price || "N/A"}
`;
      }
      if (context.bars[symbol]) {
        const bars = context.bars[symbol];
        if (Array.isArray(bars) && bars.length > 0) {
          summary += `Recent bars: ${bars.length} days of data
`;
          const latest = bars[bars.length - 1];
          summary += `Latest: O=${latest.o || latest.open}, H=${latest.h || latest.high}, L=${latest.l || latest.low}, C=${latest.c || latest.close}, V=${latest.v || latest.volume}
`;
        }
      }
      summary += "\n";
    }
    if (context.positions && context.positions.length > 0) {
      summary += "=== CURRENT POSITIONS ===\n";
      for (const pos of context.positions) {
        const p = pos;
        summary += `${p.symbol}: ${p.qty} shares @ $${p.avg_entry_price}, P&L=$${p.unrealized_pl}
`;
      }
    }
    return summary.slice(0, 6e3);
  }
  async updateAgentStats(agentId, tokens, cost) {
    const agent = await db.query.aiAgentProfiles.findFirst({
      where: eq20(aiAgentProfiles.id, agentId)
    });
    if (!agent) return;
    await db.update(aiAgentProfiles).set({
      totalCalls: agent.totalCalls + 1,
      totalTokens: agent.totalTokens + tokens,
      totalCostUsd: String(parseFloat(agent.totalCostUsd) + cost),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq20(aiAgentProfiles.id, agentId));
  }
  calculateDisagreementRate(decisions) {
    if (decisions.length < 2) return 0;
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length < 2) return 0;
    const actions = validDecisions.map((d) => d.action);
    const unique9 = new Set(actions);
    return (unique9.size - 1) / Math.max(1, validDecisions.length - 1);
  }
  calculateAvgConfidence(decisions) {
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length === 0) return 0;
    const sum = validDecisions.reduce(
      (acc, d) => acc + parseFloat(d.confidence || "0"),
      0
    );
    return sum / validDecisions.length;
  }
  checkRiskVeto(decisions) {
    const riskManager = decisions.find(
      (d) => d.role === "risk_manager" && !d.errorMessage
    );
    if (!riskManager) return false;
    const confidence = parseFloat(riskManager.confidence || "0");
    return riskManager.action === "hold" && confidence > 0.8;
  }
  shouldEscalate(disagreement, avgConfidence, riskVeto) {
    if (riskVeto) return true;
    if (disagreement > this.escalationPolicy.disagreementThreshold) return true;
    if (avgConfidence < this.escalationPolicy.minConfidenceThreshold)
      return true;
    return false;
  }
  getEscalationReason(disagreement, avgConfidence, riskVeto) {
    if (riskVeto) return "Risk manager veto with high confidence";
    if (disagreement > this.escalationPolicy.disagreementThreshold)
      return `Disagreement rate ${(disagreement * 100).toFixed(1)}% > ${this.escalationPolicy.disagreementThreshold * 100}%`;
    if (avgConfidence < this.escalationPolicy.minConfidenceThreshold)
      return `Avg confidence ${(avgConfidence * 100).toFixed(1)}% < ${this.escalationPolicy.minConfidenceThreshold * 100}%`;
    return "Unknown";
  }
  computeConsensus(decisions, disagreementRate, escalationTriggered, escalationReason) {
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length === 0) {
      return {
        decision: "no_trade",
        confidence: 0,
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: false
      };
    }
    const powerDecisions = validDecisions.filter((d) => d.wasEscalation);
    const hasPowerAgents = powerDecisions.length > 0;
    const powerRiskManager = powerDecisions.find(
      (d) => d.role === "risk_manager"
    );
    const cheapRiskManager = validDecisions.find(
      (d) => d.role === "risk_manager" && !d.wasEscalation
    );
    const powerRiskVeto = powerRiskManager && powerRiskManager.action === "hold" && parseFloat(powerRiskManager.confidence || "0") > 0.8;
    const cheapRiskVeto = cheapRiskManager && cheapRiskManager.action === "hold" && parseFloat(cheapRiskManager.confidence || "0") > 0.8;
    if (powerRiskVeto) {
      return {
        decision: "hold",
        confidence: parseFloat(powerRiskManager.confidence || "0.5"),
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: true,
        riskVetoReason: powerRiskManager.rationale || "Power risk manager vetoed the trade"
      };
    }
    if (cheapRiskVeto && !hasPowerAgents && !escalationTriggered) {
      return {
        decision: "hold",
        confidence: parseFloat(cheapRiskManager.confidence || "0.5"),
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: true,
        riskVetoReason: cheapRiskManager.rationale || "Risk manager vetoed the trade"
      };
    }
    if (cheapRiskVeto && !hasPowerAgents && escalationTriggered) {
      return {
        decision: "no_trade",
        confidence: 0.3,
        disagreementRate,
        escalationTriggered,
        escalationReason: (escalationReason || "") + " (power agents unavailable, deferring decision)",
        riskVeto: false,
        riskVetoReason: "Escalation triggered but power agents unavailable - decision deferred"
      };
    }
    const weightedVotes = {};
    const powerWeight = 1.5;
    const riskManagerDiscount = cheapRiskVeto && hasPowerAgents ? 0.3 : 1;
    for (const d of validDecisions) {
      const action = d.action;
      const confidence = parseFloat(d.confidence || "0");
      let weight = d.wasEscalation ? powerWeight : 1;
      if (d.role === "risk_manager" && !d.wasEscalation && cheapRiskVeto && hasPowerAgents) {
        weight *= riskManagerDiscount;
      }
      if (!weightedVotes[action]) {
        weightedVotes[action] = { score: 0, confidenceSum: 0, count: 0 };
      }
      weightedVotes[action].score += weight * (1 + confidence * 0.5);
      weightedVotes[action].confidenceSum += confidence;
      weightedVotes[action].count++;
    }
    let bestAction = "hold";
    let bestScore = 0;
    for (const [action, stats] of Object.entries(weightedVotes)) {
      if (stats.score > bestScore) {
        bestScore = stats.score;
        bestAction = action;
      }
    }
    const avgConfidence = this.calculateAvgConfidence(validDecisions);
    if (avgConfidence < 0.4 || disagreementRate > 0.7) {
      return {
        decision: "no_trade",
        confidence: avgConfidence,
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: false
      };
    }
    const orderDecision = validDecisions.find(
      (d) => d.action === bestAction && d.proposedOrder
    );
    const orderIntent = orderDecision?.proposedOrder;
    return {
      decision: bestAction,
      symbol: orderIntent?.symbol,
      confidence: avgConfidence,
      orderIntent,
      disagreementRate,
      escalationTriggered,
      escalationReason,
      riskVeto: false
    };
  }
  async createOutcomeLink(arenaRunId, consensus, llmCost, traceId) {
    if (!consensus.orderIntent) {
      throw new Error("No order intent in consensus");
    }
    const link = {
      symbol: consensus.orderIntent.symbol,
      side: consensus.orderIntent.side,
      intendedQty: consensus.orderIntent.qty ? String(consensus.orderIntent.qty) : void 0,
      intendedNotional: consensus.orderIntent.notional ? String(consensus.orderIntent.notional) : void 0,
      status: "pending",
      llmCostUsd: String(llmCost),
      traceId
    };
    const [inserted] = await db.insert(aiOutcomeLinks).values([link]).returning();
    await db.update(aiArenaRuns).set({ outcomeLinked: true }).where(eq20(aiArenaRuns.id, arenaRunId));
    return { id: inserted.id };
  }
  async getLeaderboard(windowDays = 30) {
    const agents = await db.query.aiAgentProfiles.findMany({
      where: eq20(aiAgentProfiles.status, "active")
    });
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - windowDays);
    const leaderboard = await Promise.all(
      agents.map(async (agent) => {
        const decisions = await db.query.aiArenaAgentDecisions.findMany({
          where: and15(
            eq20(aiArenaAgentDecisions.agentProfileId, agent.id),
            gte7(aiArenaAgentDecisions.createdAt, cutoffDate)
          )
        });
        const avgConfidence = decisions.length > 0 ? decisions.reduce(
          (sum, d) => sum + parseFloat(d.confidence || "0"),
          0
        ) / decisions.length : 0;
        const avgLatency = decisions.length > 0 ? decisions.reduce((sum, d) => sum + (d.latencyMs || 0), 0) / decisions.length : 0;
        const successfulDecisions = decisions.filter((d) => !d.errorMessage);
        return {
          agentId: agent.id,
          agentName: agent.name,
          role: agent.role,
          totalRuns: decisions.length,
          avgConfidence,
          totalCost: parseFloat(agent.totalCostUsd),
          avgLatency,
          successRate: decisions.length > 0 ? successfulDecisions.length / decisions.length : 1
        };
      })
    );
    return leaderboard.sort((a, b) => b.totalRuns - a.totalRuns);
  }
};
var arenaCoordinator = new ArenaCoordinator();

// server/routes/arena.ts
init_db();
init_schema2();
init_logger();
import { eq as eq21, desc as desc15, and as and16, gte as gte8, sql as sql28 } from "drizzle-orm";
var router6 = Router8();
router6.post("/run", requireAuth, async (req, res) => {
  try {
    const {
      symbols,
      mode = "debate",
      agentProfileIds,
      triggeredBy,
      strategyVersionId
    } = req.body;
    if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
      return badRequest(
        res,
        "symbols is required and must be a non-empty array"
      );
    }
    const config2 = {
      mode,
      symbols,
      agentProfileIds,
      triggeredBy: triggeredBy || "admin_manual",
      strategyVersionId
    };
    const result = await arenaCoordinator.runArena(config2);
    res.json({
      success: true,
      run: result.run,
      consensus: result.consensus,
      decisionsCount: result.decisions.length
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to run arena: ${error}`);
    return serverError(res, error.message || "Failed to run arena");
  }
});
router6.get("/runs", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const cursor = req.query.cursor;
    let whereClause = void 0;
    if (cursor) {
      whereClause = gte8(aiArenaRuns.createdAt, new Date(cursor));
    }
    const runs = await db.query.aiArenaRuns.findMany({
      where: whereClause,
      orderBy: [desc15(aiArenaRuns.createdAt)],
      limit: limit4
    });
    const costToday = await db.select({ total: sql28`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(
      gte8(aiArenaRuns.createdAt, new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0)))
    );
    res.json({
      runs,
      count: runs.length,
      costToday: parseFloat(costToday[0]?.total || "0"),
      nextCursor: runs.length === limit4 ? runs[runs.length - 1]?.createdAt?.toISOString() : null
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to list arena runs: ${error}`);
    return serverError(res, "Failed to list arena runs");
  }
});
router6.get("/runs/:id", requireAuth, async (req, res) => {
  try {
    const run = await db.query.aiArenaRuns.findFirst({
      where: eq21(aiArenaRuns.id, req.params.id)
    });
    if (!run) {
      return notFound(res, "Arena run not found");
    }
    const decisions = await db.query.aiArenaAgentDecisions.findMany({
      where: eq21(aiArenaAgentDecisions.arenaRunId, req.params.id),
      orderBy: [desc15(aiArenaAgentDecisions.createdAt)]
    });
    const agentIds = [...new Set(decisions.map((d) => d.agentProfileId))];
    const agents = await db.query.aiAgentProfiles.findMany();
    const agentMap = new Map(agents.map((a) => [a.id, a]));
    const decisionsWithAgents = decisions.map((d) => ({
      ...d,
      agent: d.agentProfileId ? agentMap.get(d.agentProfileId) : null
    }));
    const outcomeLinks = await db.query.aiOutcomeLinks.findMany({
      where: eq21(aiOutcomeLinks.traceId, run.traceId)
    });
    res.json({
      run,
      decisions: decisionsWithAgents,
      outcomeLinks,
      costBreakdown: {
        total: parseFloat(run.totalCostUsd || "0"),
        byAgent: decisionsWithAgents.map((d) => ({
          agent: d.agent?.name || "Unknown",
          cost: parseFloat(d.costUsd || "0"),
          tokens: d.tokensUsed || 0,
          latencyMs: d.latencyMs || 0
        }))
      }
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get arena run: ${error}`);
    res.status(500).json({ error: "Failed to get arena run" });
  }
});
router6.get("/leaderboard", requireAuth, async (req, res) => {
  try {
    const window = req.query.window || "30d";
    const days = parseInt(window.replace("d", "")) || 30;
    const leaderboard = await arenaCoordinator.getLeaderboard(days);
    res.json({
      window: `${days}d`,
      leaderboard,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get leaderboard: ${error}`);
    res.status(500).json({ error: "Failed to get leaderboard" });
  }
});
router6.get("/profiles", requireAuth, async (req, res) => {
  try {
    const profiles = await db.query.aiAgentProfiles.findMany({
      orderBy: [desc15(aiAgentProfiles.createdAt)]
    });
    res.json({ profiles, count: profiles.length });
  } catch (error) {
    log.error("ArenaAPI", `Failed to list agent profiles: ${error}`);
    res.status(500).json({ error: "Failed to list agent profiles" });
  }
});
router6.post("/profiles", requireAuth, async (req, res) => {
  try {
    const {
      name,
      description,
      provider,
      model,
      role,
      mode = "cheap_first",
      temperature = 0.7,
      maxTokens = 2e3,
      budgetLimitPerDay,
      budgetLimitPerRun,
      priority = 0
    } = req.body;
    if (!name || !provider || !model || !role) {
      return res.status(400).json({ error: "name, provider, model, and role are required" });
    }
    const validProviders = ["openai", "openrouter", "groq", "together"];
    if (!validProviders.includes(provider)) {
      return res.status(400).json({
        error: `Invalid provider. Must be one of: ${validProviders.join(", ")}`
      });
    }
    const validModes = ["cheap_first", "escalation_only", "always"];
    if (!validModes.includes(mode)) {
      return res.status(400).json({
        error: `Invalid mode. Must be one of: ${validModes.join(", ")}`
      });
    }
    const [profile] = await db.insert(aiAgentProfiles).values({
      name,
      description,
      provider,
      model,
      role,
      mode,
      temperature: String(temperature),
      maxTokens,
      budgetLimitPerDay: budgetLimitPerDay ? String(budgetLimitPerDay) : null,
      budgetLimitPerRun: budgetLimitPerRun ? String(budgetLimitPerRun) : null,
      priority,
      status: "active"
    }).returning();
    res.json(profile);
  } catch (error) {
    log.error("ArenaAPI", `Failed to create agent profile: ${error}`);
    res.status(500).json({
      error: error.message || "Failed to create agent profile"
    });
  }
});
router6.get(
  "/profiles/:id",
  requireAuth,
  async (req, res) => {
    try {
      const profile = await db.query.aiAgentProfiles.findFirst({
        where: eq21(aiAgentProfiles.id, req.params.id)
      });
      if (!profile) {
        return res.status(404).json({ error: "Agent profile not found" });
      }
      res.json(profile);
    } catch (error) {
      log.error("ArenaAPI", `Failed to get agent profile: ${error}`);
      res.status(500).json({ error: "Failed to get agent profile" });
    }
  }
);
router6.patch(
  "/profiles/:id",
  requireAuth,
  async (req, res) => {
    try {
      const {
        status,
        description,
        model,
        mode,
        temperature,
        maxTokens,
        budgetLimitPerDay,
        priority
      } = req.body;
      const updates = { updatedAt: /* @__PURE__ */ new Date() };
      if (status !== void 0) updates.status = status;
      if (description !== void 0) updates.description = description;
      if (model !== void 0) updates.model = model;
      if (mode !== void 0) updates.mode = mode;
      if (temperature !== void 0) updates.temperature = String(temperature);
      if (maxTokens !== void 0) updates.maxTokens = maxTokens;
      if (budgetLimitPerDay !== void 0)
        updates.budgetLimitPerDay = String(budgetLimitPerDay);
      if (priority !== void 0) updates.priority = priority;
      const [updated] = await db.update(aiAgentProfiles).set(updates).where(eq21(aiAgentProfiles.id, req.params.id)).returning();
      if (!updated) {
        return res.status(404).json({ error: "Agent profile not found" });
      }
      res.json(updated);
    } catch (error) {
      log.error("ArenaAPI", `Failed to update agent profile: ${error}`);
      res.status(500).json({
        error: error.message || "Failed to update agent profile"
      });
    }
  }
);
router6.delete(
  "/profiles/:id",
  requireAuth,
  async (req, res) => {
    try {
      const [deleted] = await db.update(aiAgentProfiles).set({ status: "disabled", updatedAt: /* @__PURE__ */ new Date() }).where(eq21(aiAgentProfiles.id, req.params.id)).returning();
      if (!deleted) {
        return res.status(404).json({ error: "Agent profile not found" });
      }
      res.json({ success: true, message: "Agent profile disabled" });
    } catch (error) {
      log.error("ArenaAPI", `Failed to delete agent profile: ${error}`);
      res.status(500).json({ error: "Failed to delete agent profile" });
    }
  }
);
router6.get("/stats", requireAuth, async (req, res) => {
  try {
    const today = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3);
    const [runsToday] = await db.select({ count: sql28`COUNT(*)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, today));
    const [costToday] = await db.select({ total: sql28`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, today));
    const [costWeek] = await db.select({ total: sql28`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, weekAgo));
    const [escalationsToday] = await db.select({ count: sql28`COUNT(*)` }).from(aiArenaRuns).where(
      and16(
        gte8(aiArenaRuns.createdAt, today),
        eq21(aiArenaRuns.escalationTriggered, true)
      )
    );
    const [activeProfiles] = await db.select({ count: sql28`COUNT(*)` }).from(aiAgentProfiles).where(eq21(aiAgentProfiles.status, "active"));
    res.json({
      runsToday: runsToday?.count || 0,
      costToday: parseFloat(costToday?.total || "0"),
      costWeek: parseFloat(costWeek?.total || "0"),
      escalationsToday: escalationsToday?.count || 0,
      activeProfiles: activeProfiles?.count || 0
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get arena stats: ${error}`);
    res.status(500).json({ error: "Failed to get arena stats" });
  }
});
var arena_default = router6;

// server/routes/jina.ts
import { Router as Router9 } from "express";

// server/connectors/jina.ts
init_connectorClient();
init_logger();
var JINA_EMBEDDINGS_URL = "https://api.jina.ai/v1/embeddings";
var JINA_READER_URL = "https://r.jina.ai";
var JINA_SEARCH_URL = "https://s.jina.ai";
var JINA_RERANK_URL = "https://api.jina.ai/v1/rerank";
function getApiKey() {
  const key = process.env.JINA_API_KEY;
  if (!key) {
    throw new Error("JINA_API_KEY not configured");
  }
  return key;
}
function getAuthHeaders() {
  return {
    Authorization: `Bearer ${getApiKey()}`,
    "Content-Type": "application/json"
  };
}
async function generateEmbeddings(input, options = {}) {
  const {
    model = "jina-embeddings-v3",
    task = "retrieval.passage",
    dimensions
  } = options;
  const cacheKey = buildCacheKey(
    "jina",
    "embeddings",
    model,
    task,
    dimensions?.toString(),
    typeof input === "string" ? input.slice(0, 100) : `batch-${input.length}`
  );
  const body = {
    input,
    model,
    task,
    normalized: true
  };
  if (dimensions) body.dimensions = dimensions;
  try {
    const result = await connectorFetch(
      JINA_EMBEDDINGS_URL,
      {
        provider: "jina",
        endpoint: "embeddings",
        cacheKey,
        headers: getAuthHeaders(),
        method: "POST",
        body,
        customTTLMs: 864e5
      }
    );
    log.info(
      "Jina",
      `Generated ${result.data.data.length} embeddings (${result.data.usage.total_tokens} tokens)`
    );
    return result.data;
  } catch (error) {
    log.error("Jina", `Embeddings error: ${error}`);
    throw error;
  }
}
async function readUrl(url) {
  const cacheKey = buildCacheKey("jina", "reader", url);
  const readerUrl = `${JINA_READER_URL}/${encodeURIComponent(url)}`;
  try {
    const result = await connectorFetch(readerUrl, {
      provider: "jina",
      endpoint: "reader",
      cacheKey,
      headers: {
        Authorization: `Bearer ${getApiKey()}`,
        Accept: "application/json",
        "X-Return-Format": "json"
      },
      method: "GET",
      customTTLMs: 36e5
    });
    log.info(
      "Jina",
      `Read URL: ${url} (${result.data.content?.length || 0} chars)`
    );
    return result.data;
  } catch (error) {
    log.error("Jina", `Reader error for ${url}: ${error}`);
    throw error;
  }
}
async function search(query, options = {}) {
  const { limit: limit4 = 5 } = options;
  const cacheKey = buildCacheKey("jina", "search", query, limit4.toString());
  const searchUrl = `${JINA_SEARCH_URL}/${encodeURIComponent(query)}`;
  try {
    const result = await connectorFetch(searchUrl, {
      provider: "jina",
      endpoint: "search",
      cacheKey,
      headers: {
        Authorization: `Bearer ${getApiKey()}`,
        Accept: "application/json",
        "X-Return-Format": "json"
      },
      method: "GET",
      customTTLMs: 18e5
    });
    log.info(
      "Jina",
      `Search: "${query}" returned ${result.data.results?.length || 0} results`
    );
    return result.data;
  } catch (error) {
    log.error("Jina", `Search error for "${query}": ${error}`);
    throw error;
  }
}
async function rerank(query, documents, options = {}) {
  const { model = "jina-reranker-v2-base-multilingual", top_n = 10 } = options;
  const cacheKey = buildCacheKey(
    "jina",
    "rerank",
    query.slice(0, 50),
    documents.length.toString()
  );
  const body = {
    model,
    query,
    documents,
    top_n: Math.min(top_n, documents.length),
    return_documents: true
  };
  try {
    const result = await connectorFetch(JINA_RERANK_URL, {
      provider: "jina",
      endpoint: "rerank",
      cacheKey,
      headers: getAuthHeaders(),
      method: "POST",
      body,
      customTTLMs: 864e5
    });
    log.info(
      "Jina",
      `Reranked ${documents.length} docs, top score: ${result.data.results[0]?.relevance_score?.toFixed(3)}`
    );
    return result.data;
  } catch (error) {
    log.error("Jina", `Rerank error: ${error}`);
    throw error;
  }
}
async function semanticSearch(query, corpus, options = {}) {
  const { topK = 5 } = options;
  const queryEmbedding = await generateEmbeddings(query, {
    task: "retrieval.query"
  });
  const queryVector = queryEmbedding.data[0].embedding;
  const corpusTexts = corpus.map((c) => c.text);
  const corpusEmbeddings = await generateEmbeddings(corpusTexts, {
    task: "retrieval.passage"
  });
  const similarities = corpus.map((doc, i) => {
    const docVector = corpusEmbeddings.data[i].embedding;
    const score = cosineSimilarity(queryVector, docVector);
    return { id: doc.id, text: doc.text, score };
  });
  similarities.sort((a, b) => b.score - a.score);
  return similarities.slice(0, topK);
}
function cosineSimilarity(a, b) {
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}
var jina = {
  generateEmbeddings,
  readUrl,
  search,
  rerank,
  semanticSearch
};

// server/routes/jina.ts
init_logger();
var router7 = Router9();
router7.post("/embeddings", requireAuth, async (req, res) => {
  try {
    const { input, model, task, dimensions } = req.body;
    if (!input) {
      return res.status(400).json({ error: "input is required" });
    }
    const result = await jina.generateEmbeddings(input, {
      model,
      task,
      dimensions
    });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Embeddings error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.get("/read", requireAuth, async (req, res) => {
  try {
    const { url } = req.query;
    if (!url || typeof url !== "string") {
      return res.status(400).json({ error: "url query parameter is required" });
    }
    const normalizedUrl = url.startsWith("http://") || url.startsWith("https://") ? url : `https://${url}`;
    const result = await jina.readUrl(normalizedUrl);
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Reader error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.get("/search", requireAuth, async (req, res) => {
  try {
    const { query, limit: limit4 } = req.query;
    if (!query || typeof query !== "string") {
      return res.status(400).json({ error: "query parameter is required" });
    }
    const result = await jina.search(query, {
      limit: limit4 ? parseInt(limit4, 10) : 5
    });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Search error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.post("/rerank", requireAuth, async (req, res) => {
  try {
    const { query, documents, model, top_n } = req.body;
    if (!query || !documents || !Array.isArray(documents)) {
      return res.status(400).json({ error: "query and documents array are required" });
    }
    const result = await jina.rerank(query, documents, { model, top_n });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Rerank error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.post(
  "/semantic-search",
  requireAuth,
  async (req, res) => {
    try {
      const { query, corpus, topK } = req.body;
      if (!query || !corpus || !Array.isArray(corpus)) {
        return res.status(400).json({ error: "query and corpus array are required" });
      }
      if (corpus.length > 100) {
        return res.status(413).json({ error: "corpus exceeds maximum size of 100 documents" });
      }
      if (query.length > 1e4) {
        return res.status(413).json({ error: "query exceeds maximum length of 10000 characters" });
      }
      const result = await jina.semanticSearch(query, corpus, { topK });
      res.json(result);
    } catch (error) {
      log.error("JinaRoutes", `Semantic search error: ${error}`);
      res.status(500).json({ error: String(error) });
    }
  }
);
router7.get("/health", requireAuth, async (_req, res) => {
  const hasKey = !!process.env.JINA_API_KEY;
  res.json({
    status: hasKey ? "configured" : "missing_api_key",
    provider: "jina",
    capabilities: [
      "embeddings",
      "reader",
      "search",
      "rerank",
      "semantic-search"
    ]
  });
});
var jina_default = router7;

// server/routes/macro.ts
init_fred();
import { Router as Router10 } from "express";

// server/services/macro-indicators-service.ts
init_db();
init_schema2();
init_fred();
init_logger();
import { eq as eq22 } from "drizzle-orm";
var MacroIndicatorsService = class {
  async refreshAllIndicators() {
    log.info(
      "MacroIndicatorsService",
      "Starting full macro indicators refresh from FRED"
    );
    const allData = await fred.getAllIndicators();
    let updated = 0;
    let failed = 0;
    const errors = [];
    for (const data of allData) {
      try {
        await this.upsertIndicator(data);
        updated++;
      } catch (error) {
        failed++;
        errors.push(
          `${data.indicatorId}: ${error instanceof Error ? error.message : "Unknown error"}`
        );
      }
    }
    log.info(
      "MacroIndicatorsService",
      `Refresh complete: ${updated} updated, ${failed} failed`
    );
    return { success: failed === 0, updated, failed, errors };
  }
  async refreshCriticalIndicators() {
    log.info(
      "MacroIndicatorsService",
      "Refreshing critical macro indicators from FRED"
    );
    const criticalData = await fred.getCriticalIndicators();
    let updated = 0;
    for (const data of criticalData) {
      try {
        await this.upsertIndicator(data);
        updated++;
      } catch (error) {
        log.error(
          "MacroIndicatorsService",
          `Failed to upsert ${data.indicatorId}`,
          { error }
        );
      }
    }
    return { success: true, updated, data: criticalData };
  }
  async upsertIndicator(data) {
    const existing = await db.select().from(macroIndicators).where(eq22(macroIndicators.indicatorId, data.indicatorId)).limit(1);
    if (existing.length > 0) {
      await db.update(macroIndicators).set({
        latestValue: data.latestValue?.toString() || null,
        previousValue: data.previousValue?.toString() || null,
        changePercent: data.changePercent?.toString() || null,
        lastUpdatedAt: /* @__PURE__ */ new Date(),
        rawJson: data.rawJson
      }).where(eq22(macroIndicators.indicatorId, data.indicatorId));
    } else {
      await db.insert(macroIndicators).values({
        indicatorId: data.indicatorId,
        name: data.name,
        category: data.category,
        latestValue: data.latestValue?.toString() || null,
        previousValue: data.previousValue?.toString() || null,
        changePercent: data.changePercent?.toString() || null,
        frequency: data.frequency,
        lastUpdatedAt: /* @__PURE__ */ new Date(),
        source: "FRED",
        rawJson: data.rawJson
      });
    }
  }
  async getLatestIndicators() {
    return db.select().from(macroIndicators).orderBy(macroIndicators.lastUpdatedAt);
  }
  async getIndicatorsByCategory(category) {
    return db.select().from(macroIndicators).where(eq22(macroIndicators.category, category));
  }
  async getIndicator(indicatorId) {
    const result = await db.select().from(macroIndicators).where(eq22(macroIndicators.indicatorId, indicatorId)).limit(1);
    return result[0] || null;
  }
  async getMacroSummary() {
    const all = await this.getLatestIndicators();
    const byCategory = {
      treasury_yields: 0,
      inflation: 0,
      employment: 0,
      volatility: 0,
      interest_rates: 0,
      money_supply: 0,
      gdp: 0,
      consumer: 0,
      housing: 0,
      manufacturing: 0
    };
    for (const indicator of all) {
      const cat = indicator.category;
      if (cat in byCategory) {
        byCategory[cat]++;
      }
    }
    const criticalAlerts = this.detectAlerts(all);
    return {
      totalIndicators: all.length,
      lastUpdated: all.length > 0 ? all[0].lastUpdatedAt : /* @__PURE__ */ new Date(),
      byCategory,
      criticalAlerts
    };
  }
  detectAlerts(indicators) {
    const alerts = [];
    for (const indicator of indicators) {
      const value = parseFloat(indicator.latestValue || "0");
      if (indicator.indicatorId === "T10Y2Y" && value < 0) {
        alerts.push({
          indicatorId: indicator.indicatorId,
          name: indicator.name,
          type: "yield_curve_inversion",
          severity: "high",
          message: "Yield curve is inverted - potential recession signal",
          value,
          threshold: 0
        });
      }
      if (indicator.indicatorId === "VIXCLS" && value > 30) {
        alerts.push({
          indicatorId: indicator.indicatorId,
          name: indicator.name,
          type: "high_volatility",
          severity: value > 40 ? "high" : "medium",
          message: `VIX at ${value.toFixed(2)} indicates elevated market fear`,
          value,
          threshold: 30
        });
      }
      if (indicator.indicatorId === "CPIAUCSL") {
        const change = parseFloat(indicator.changePercent || "0");
        if (Math.abs(change) > 0.5) {
          alerts.push({
            indicatorId: indicator.indicatorId,
            name: indicator.name,
            type: "inflation_spike",
            severity: Math.abs(change) > 1 ? "high" : "medium",
            message: `CPI changed ${change.toFixed(2)}% - notable inflation movement`,
            value: change,
            threshold: 0.5
          });
        }
      }
      if (indicator.indicatorId === "FEDFUNDS") {
        const change = parseFloat(indicator.changePercent || "0");
        if (Math.abs(change) > 5) {
          alerts.push({
            indicatorId: indicator.indicatorId,
            name: indicator.name,
            type: "rate_change",
            severity: "high",
            message: `Fed Funds rate changed significantly (${change.toFixed(2)}%)`,
            value: change,
            threshold: 5
          });
        }
      }
    }
    return alerts;
  }
  getMarketRegimeFromMacro(indicators) {
    const signals = [];
    let riskOnScore = 0;
    let riskOffScore = 0;
    for (const indicator of indicators) {
      const value = parseFloat(indicator.latestValue || "0");
      if (indicator.indicatorId === "VIXCLS") {
        if (value < 15) {
          riskOnScore += 2;
          signals.push("Low VIX indicates market complacency");
        } else if (value > 25) {
          riskOffScore += 2;
          signals.push("Elevated VIX indicates fear");
        }
      }
      if (indicator.indicatorId === "T10Y2Y") {
        if (value < 0) {
          riskOffScore += 3;
          signals.push("Yield curve inversion - recession warning");
        } else if (value > 1) {
          riskOnScore += 1;
          signals.push("Steep yield curve - healthy growth outlook");
        }
      }
      if (indicator.indicatorId === "UMCSENT") {
        if (value > 80) {
          riskOnScore += 1;
          signals.push("Strong consumer sentiment");
        } else if (value < 60) {
          riskOffScore += 1;
          signals.push("Weak consumer sentiment");
        }
      }
    }
    const totalScore = Math.abs(riskOnScore - riskOffScore);
    const confidence = Math.min(totalScore * 0.15, 1);
    let regime;
    if (riskOnScore > riskOffScore + 2) {
      regime = "risk_on";
    } else if (riskOffScore > riskOnScore + 2) {
      regime = "risk_off";
    } else if (indicators.length < 3) {
      regime = "uncertain";
    } else {
      regime = "neutral";
    }
    return { regime, confidence, signals };
  }
  isConfigured() {
    return fred.isConfigured();
  }
};
var macroIndicatorsService = new MacroIndicatorsService();

// server/routes/macro.ts
init_logger();
var router8 = Router10();
router8.get("/indicators", requireAuth, async (_req, res) => {
  try {
    const indicators = await macroIndicatorsService.getLatestIndicators();
    res.json({ success: true, data: indicators });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get indicators", { error });
    return serverError(res, "Failed to fetch indicators");
  }
});
router8.get(
  "/indicators/:id",
  requireAuth,
  async (req, res) => {
    try {
      const indicator = await macroIndicatorsService.getIndicator(
        req.params.id
      );
      if (!indicator) {
        return notFound(res, "Indicator not found");
      }
      res.json({ success: true, data: indicator });
    } catch (error) {
      log.error("MacroRoutes", "Failed to get indicator", { error });
      return serverError(res, "Failed to fetch indicator");
    }
  }
);
router8.get(
  "/category/:category",
  requireAuth,
  async (req, res) => {
    try {
      const category = req.params.category;
      const validCategories = [
        "treasury_yields",
        "inflation",
        "employment",
        "volatility",
        "interest_rates",
        "money_supply",
        "gdp",
        "consumer",
        "housing",
        "manufacturing"
      ];
      if (!validCategories.includes(category)) {
        return badRequest(res, "Invalid category");
      }
      const indicators = await macroIndicatorsService.getIndicatorsByCategory(category);
      res.json({ success: true, data: indicators });
    } catch (error) {
      log.error("MacroRoutes", "Failed to get indicators by category", {
        error
      });
      return serverError(res, "Failed to fetch indicators");
    }
  }
);
router8.get("/summary", requireAuth, async (_req, res) => {
  try {
    const summary = await macroIndicatorsService.getMacroSummary();
    res.json({ success: true, data: summary });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get summary", { error });
    res.status(500).json({ success: false, error: "Failed to fetch summary" });
  }
});
router8.post("/refresh", requireAuth, async (_req, res) => {
  try {
    const result = await macroIndicatorsService.refreshCriticalIndicators();
    res.json({ success: true, data: result });
  } catch (error) {
    log.error("MacroRoutes", "Failed to refresh indicators", { error });
    res.status(500).json({ success: false, error: "Failed to refresh indicators" });
  }
});
router8.post(
  "/refresh/all",
  requireAuth,
  async (_req, res) => {
    try {
      const result = await macroIndicatorsService.refreshAllIndicators();
      res.json({ success: true, data: result });
    } catch (error) {
      log.error("MacroRoutes", "Failed to refresh all indicators", { error });
      res.status(500).json({ success: false, error: "Failed to refresh indicators" });
    }
  }
);
router8.get("/regime", requireAuth, async (_req, res) => {
  try {
    const indicators = await macroIndicatorsService.getLatestIndicators();
    const regime = macroIndicatorsService.getMarketRegimeFromMacro(indicators);
    res.json({ success: true, data: regime });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get market regime", { error });
    res.status(500).json({ success: false, error: "Failed to determine regime" });
  }
});
router8.get("/series", requireAuth, async (_req, res) => {
  try {
    const series = Object.entries(FRED_SERIES).map(([id, config2]) => ({
      id,
      name: config2.name,
      category: config2.category
    }));
    res.json({ success: true, data: series });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get series list", { error });
    res.status(500).json({ success: false, error: "Failed to fetch series" });
  }
});
router8.get("/status", requireAuth, async (_req, res) => {
  try {
    const isConfigured = macroIndicatorsService.isConfigured();
    const indicators = await macroIndicatorsService.getLatestIndicators();
    res.json({
      success: true,
      data: {
        configured: isConfigured,
        hasApiKey: isConfigured,
        cachedIndicators: indicators.length,
        availableSeries: Object.keys(FRED_SERIES).length
      }
    });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get status", { error });
    res.status(500).json({ success: false, error: "Failed to get status" });
  }
});
var macro_default = router8;

// server/routes/enrichment.ts
import { Router as Router11 } from "express";

// server/services/enrichment-scheduler.ts
init_logger();
init_fundamentalsService();
init_db();
init_schema2();
init_finnhub();
init_alpaca();
init_technical_indicators();
import { eq as eq23, sql as sql29 } from "drizzle-orm";
var DEFAULT_CONFIG3 = {
  macroIndicatorsIntervalMs: 4 * 60 * 60 * 1e3,
  fundamentalsIntervalMs: 24 * 60 * 60 * 1e3,
  technicalsIntervalMs: 60 * 60 * 1e3,
  enabled: true
};
var EnrichmentScheduler = class {
  config = DEFAULT_CONFIG3;
  intervals = /* @__PURE__ */ new Map();
  jobStatus = /* @__PURE__ */ new Map();
  isStarted = false;
  constructor() {
    this.initJobStatus();
  }
  initJobStatus() {
    const jobs = ["macro_indicators", "fundamentals", "technicals"];
    for (const job of jobs) {
      this.jobStatus.set(job, {
        name: job,
        lastRun: null,
        lastSuccess: false,
        nextRun: null,
        isRunning: false
      });
    }
  }
  start() {
    if (this.isStarted) {
      log.warn("EnrichmentScheduler", "Scheduler already started");
      return;
    }
    if (!this.config.enabled) {
      log.info("EnrichmentScheduler", "Scheduler disabled by config");
      return;
    }
    log.info("EnrichmentScheduler", "Starting enrichment scheduler", {
      macroIntervalHours: this.config.macroIndicatorsIntervalMs / (60 * 60 * 1e3),
      fundamentalsIntervalHours: this.config.fundamentalsIntervalMs / (60 * 60 * 1e3),
      technicalsIntervalHours: this.config.technicalsIntervalMs / (60 * 60 * 1e3)
    });
    this.scheduleJob(
      "macro_indicators",
      this.config.macroIndicatorsIntervalMs,
      () => this.runMacroIndicatorsJob()
    );
    this.scheduleJob(
      "fundamentals",
      this.config.fundamentalsIntervalMs,
      () => this.runFundamentalsJob()
    );
    this.scheduleJob(
      "technicals",
      this.config.technicalsIntervalMs,
      () => this.runTechnicalsJob()
    );
    this.isStarted = true;
    setTimeout(() => this.runInitialEnrichment(), 3e4);
  }
  async runInitialEnrichment() {
    log.info("EnrichmentScheduler", "Running initial enrichment check");
    const [macroCount] = await db.select({ count: sql29`count(*)` }).from(sql29`macro_indicators`);
    if (Number(macroCount?.count || 0) === 0) {
      log.info(
        "EnrichmentScheduler",
        "Macro indicators empty, running initial sync"
      );
      this.runMacroIndicatorsJob().catch(
        (e) => log.error("EnrichmentScheduler", "Initial macro sync failed", {
          error: e
        })
      );
    }
    const [technicalsCount] = await db.select({ count: sql29`count(*)` }).from(universeTechnicals);
    const [brokerAssetsCount] = await db.select({ count: sql29`count(*)` }).from(brokerAssets).where(eq23(brokerAssets.tradable, true));
    const techCount = Number(technicalsCount?.count || 0);
    const assetCount = Number(brokerAssetsCount?.count || 0);
    const coverageThreshold = Math.min(assetCount, 50) * 0.5;
    if (techCount < coverageThreshold) {
      log.info(
        "EnrichmentScheduler",
        "Technicals coverage low, running initial sync",
        {
          currentCount: techCount,
          threshold: coverageThreshold,
          brokerAssets: assetCount
        }
      );
      this.runTechnicalsJob().catch(
        (e) => log.error("EnrichmentScheduler", "Initial technicals sync failed", {
          error: e
        })
      );
    }
  }
  stop() {
    log.info("EnrichmentScheduler", "Stopping enrichment scheduler");
    for (const [name, interval] of this.intervals) {
      clearInterval(interval);
      log.info("EnrichmentScheduler", `Stopped job: ${name}`);
    }
    this.intervals.clear();
    this.isStarted = false;
  }
  scheduleJob(name, intervalMs, job) {
    const status = this.jobStatus.get(name);
    if (status) {
      status.nextRun = new Date(Date.now() + intervalMs);
    }
    const interval = setInterval(async () => {
      await this.executeJob(name, job);
    }, intervalMs);
    this.intervals.set(name, interval);
    log.info("EnrichmentScheduler", `Scheduled job: ${name}`, { intervalMs });
  }
  async executeJob(name, job) {
    const status = this.jobStatus.get(name);
    if (!status) return;
    if (status.isRunning) {
      log.warn("EnrichmentScheduler", `Job ${name} already running, skipping`);
      return;
    }
    status.isRunning = true;
    status.lastRun = /* @__PURE__ */ new Date();
    try {
      log.info("EnrichmentScheduler", `Starting job: ${name}`);
      await job();
      status.lastSuccess = true;
      status.lastError = void 0;
      log.info("EnrichmentScheduler", `Completed job: ${name}`);
    } catch (error) {
      status.lastSuccess = false;
      status.lastError = error instanceof Error ? error.message : "Unknown error";
      log.error("EnrichmentScheduler", `Failed job: ${name}`, { error });
    } finally {
      status.isRunning = false;
      const intervalMs = this.getIntervalForJob(name);
      status.nextRun = new Date(Date.now() + intervalMs);
    }
  }
  getIntervalForJob(name) {
    switch (name) {
      case "macro_indicators":
        return this.config.macroIndicatorsIntervalMs;
      case "fundamentals":
        return this.config.fundamentalsIntervalMs;
      case "technicals":
        return this.config.technicalsIntervalMs;
      default:
        return 60 * 60 * 1e3;
    }
  }
  async runMacroIndicatorsJob() {
    const result = await macroIndicatorsService.refreshAllIndicators();
    const status = this.jobStatus.get("macro_indicators");
    if (status) {
      status.itemsProcessed = result.updated;
    }
  }
  async runFundamentalsJob() {
    const result = await fundamentalsService.fetchAndStoreFundamentals({
      batchSize: 10,
      traceId: `enrichment-${Date.now()}`
    });
    const status = this.jobStatus.get("fundamentals");
    if (status) {
      status.itemsProcessed = result.computed;
    }
  }
  async runTechnicalsJob() {
    const assets = await db.select({
      symbol: brokerAssets.symbol,
      assetClass: brokerAssets.assetClass
    }).from(brokerAssets).where(eq23(brokerAssets.tradable, true)).limit(50);
    let processed = 0;
    const endDate = /* @__PURE__ */ new Date();
    const startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1e3);
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    for (const { symbol, assetClass } of assets) {
      try {
        const barsResponse = await alpaca.getBars(
          [symbol],
          "1Day",
          startDate.toISOString().split("T")[0],
          endDate.toISOString().split("T")[0],
          400
        );
        const bars = barsResponse.bars[symbol];
        if (!bars || bars.length < 200) {
          log.warn(
            "EnrichmentScheduler",
            `Insufficient bars for ${symbol}: ${bars?.length || 0}`
          );
          continue;
        }
        const ohlcBars = bars.map((b) => ({
          open: b.o,
          high: b.h,
          low: b.l,
          close: b.c,
          volume: b.v
        }));
        const indicators = computeAllIndicators(ohlcBars);
        if (!indicators) {
          continue;
        }
        const lastBar = bars[bars.length - 1];
        const technicalSignals = await finnhub.getTechnicalSignals(symbol).catch(() => ({ adx: null }));
        await db.insert(universeTechnicals).values({
          symbol,
          date: today,
          open: lastBar.o?.toString(),
          high: lastBar.h?.toString(),
          low: lastBar.l?.toString(),
          close: lastBar.c?.toString(),
          volume: lastBar.v?.toString(),
          sma20: indicators.sma20?.toString(),
          sma50: indicators.sma50?.toString(),
          sma200: indicators.sma200?.toString(),
          ema12: indicators.ema12?.toString(),
          ema26: indicators.ema26?.toString(),
          rsi14: indicators.rsi14?.toString(),
          macd: indicators.macd?.toString(),
          macdSignal: indicators.macdSignal?.toString(),
          macdHistogram: indicators.macdHistogram?.toString(),
          atr14: indicators.atr14?.toString(),
          bollingerUpper: indicators.bollingerUpper?.toString(),
          bollingerLower: indicators.bollingerLower?.toString(),
          adx14: technicalSignals.adx?.toString(),
          source: "alpaca+computed",
          lastUpdatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: [universeTechnicals.symbol, universeTechnicals.date],
          set: {
            open: lastBar.o?.toString(),
            high: lastBar.h?.toString(),
            low: lastBar.l?.toString(),
            close: lastBar.c?.toString(),
            volume: lastBar.v?.toString(),
            sma20: indicators.sma20?.toString(),
            sma50: indicators.sma50?.toString(),
            sma200: indicators.sma200?.toString(),
            ema12: indicators.ema12?.toString(),
            ema26: indicators.ema26?.toString(),
            rsi14: indicators.rsi14?.toString(),
            macd: indicators.macd?.toString(),
            macdSignal: indicators.macdSignal?.toString(),
            macdHistogram: indicators.macdHistogram?.toString(),
            atr14: indicators.atr14?.toString(),
            bollingerUpper: indicators.bollingerUpper?.toString(),
            bollingerLower: indicators.bollingerLower?.toString(),
            adx14: technicalSignals.adx?.toString(),
            lastUpdatedAt: /* @__PURE__ */ new Date()
          }
        });
        processed++;
        log.info("EnrichmentScheduler", `Computed technicals for ${symbol}`, {
          rsi14: indicators.rsi14?.toFixed(2),
          sma20: indicators.sma20?.toFixed(2)
        });
      } catch (error) {
        const errorDetails = error instanceof Error ? {
          message: error.message,
          name: error.name,
          stack: error.stack?.split("\n").slice(0, 3).join(" | ")
        } : { raw: String(error) };
        log.warn(
          "EnrichmentScheduler",
          `Failed to compute technicals for ${symbol}`,
          errorDetails
        );
      }
    }
    const status = this.jobStatus.get("technicals");
    if (status) {
      status.itemsProcessed = processed;
    }
  }
  async runJobManually(jobName) {
    const status = this.jobStatus.get(jobName);
    if (!status) {
      return {
        success: false,
        message: `Unknown job: ${jobName}`,
        statusCode: 400
      };
    }
    if (status.isRunning) {
      return {
        success: false,
        message: `Job ${jobName} is already running`,
        statusCode: 409
      };
    }
    try {
      switch (jobName) {
        case "macro_indicators":
          await this.executeJob(jobName, () => this.runMacroIndicatorsJob());
          break;
        case "fundamentals":
          await this.executeJob(jobName, () => this.runFundamentalsJob());
          break;
        case "technicals":
          await this.executeJob(jobName, () => this.runTechnicalsJob());
          break;
        default:
          return {
            success: false,
            message: `Unknown job: ${jobName}`,
            statusCode: 400
          };
      }
      return {
        success: true,
        message: `Job ${jobName} completed successfully`,
        statusCode: 200
      };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : "Unknown error",
        statusCode: 500
      };
    }
  }
  getStatus() {
    return Array.from(this.jobStatus.values());
  }
  getJobStatus(name) {
    return this.jobStatus.get(name);
  }
  updateConfig(config2) {
    this.config = { ...this.config, ...config2 };
    log.info("EnrichmentScheduler", "Config updated", { config: this.config });
    if (this.isStarted) {
      this.stop();
      this.start();
    }
  }
};
var enrichmentScheduler = new EnrichmentScheduler();

// server/routes/enrichment.ts
init_logger();
init_db();
import { sql as sql30 } from "drizzle-orm";
var router9 = Router11();
router9.get("/status", requireAuth, async (_req, res) => {
  try {
    const status = enrichmentScheduler.getStatus();
    res.json({ success: true, data: status });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to get status", { error });
    res.status(500).json({ success: false, error: "Failed to get enrichment status" });
  }
});
router9.get(
  "/status/:jobName",
  requireAuth,
  async (req, res) => {
    try {
      const status = enrichmentScheduler.getJobStatus(req.params.jobName);
      if (!status) {
        return res.status(404).json({ success: false, error: "Job not found" });
      }
      res.json({ success: true, data: status });
    } catch (error) {
      log.error("EnrichmentRoutes", "Failed to get job status", { error });
      res.status(500).json({ success: false, error: "Failed to get job status" });
    }
  }
);
router9.post(
  "/run/:jobName",
  requireAuth,
  async (req, res) => {
    try {
      const result = await enrichmentScheduler.runJobManually(
        req.params.jobName
      );
      res.status(result.statusCode).json({ success: result.success, message: result.message });
    } catch (error) {
      log.error("EnrichmentRoutes", "Failed to run job", { error });
      res.status(500).json({ success: false, error: "Failed to run job" });
    }
  }
);
router9.get("/stats", requireAuth, async (_req, res) => {
  try {
    const technicals = await db.execute(
      sql30`SELECT COUNT(*) as count FROM universe_technicals`
    );
    const macro = await db.execute(
      sql30`SELECT COUNT(*) as count FROM macro_indicators`
    );
    const fundamentals = await db.execute(
      sql30`SELECT COUNT(*) as count FROM universe_fundamentals`
    );
    const classifications = await db.execute(
      sql30`SELECT COUNT(*) as count FROM asset_classifications`
    );
    const assets = await db.execute(
      sql30`SELECT COUNT(*) as count FROM broker_assets`
    );
    res.json({
      success: true,
      data: {
        universe_technicals: Number(technicals.rows[0]?.count || 0),
        macro_indicators: Number(macro.rows[0]?.count || 0),
        universe_fundamentals: Number(fundamentals.rows[0]?.count || 0),
        asset_classifications: Number(classifications.rows[0]?.count || 0),
        broker_assets: Number(assets.rows[0]?.count || 0)
      }
    });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to get stats", { error });
    res.status(500).json({ success: false, error: "Failed to get stats" });
  }
});
var enrichment_default = router9;

// server/routes/providers.ts
init_logger();
init_trading_config();
import { Router as Router12 } from "express";
import { randomUUID as randomUUID3 } from "crypto";
var router10 = Router12();
var providers2 = [
  {
    id: "alpaca-trading",
    type: "broker",
    name: `Alpaca ${tradingConfig.alpaca.tradingMode === "live" ? "Live" : "Paper"} Trading`,
    baseUrl: getAlpacaBaseUrl(),
    status: "active",
    tags: ["trading", tradingConfig.alpaca.tradingMode],
    metadata: { mode: tradingConfig.alpaca.tradingMode },
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  },
  {
    id: "openrouter",
    type: "llm",
    name: "OpenRouter",
    baseUrl: "https://openrouter.ai/api/v1",
    status: "active",
    tags: ["llm", "ai"],
    metadata: {},
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  },
  {
    id: "finnhub",
    type: "data",
    name: "Finnhub",
    baseUrl: "https://finnhub.io/api/v1",
    status: "active",
    tags: ["market-data", "news"],
    metadata: {},
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  }
];
var credentials = /* @__PURE__ */ new Map();
var budgets = /* @__PURE__ */ new Map();
var apiFunctions = /* @__PURE__ */ new Map();
router10.get("/", requireAuth, async (req, res) => {
  try {
    res.json(providers2);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to get providers", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to get providers" });
  }
});
router10.post("/", requireAuth, async (req, res) => {
  try {
    const provider = {
      id: randomUUID3(),
      ...req.body,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    providers2.push(provider);
    res.status(201).json(provider);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to create provider", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to create provider" });
  }
});
router10.get("/:id", requireAuth, async (req, res) => {
  try {
    const provider = providers2.find((p) => p.id === req.params.id);
    if (!provider) {
      return res.status(404).json({ error: "Provider not found" });
    }
    res.json(provider);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to get provider", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to get provider" });
  }
});
router10.patch("/:id", requireAuth, async (req, res) => {
  try {
    const index18 = providers2.findIndex((p) => p.id === req.params.id);
    if (index18 === -1) {
      return res.status(404).json({ error: "Provider not found" });
    }
    providers2[index18] = {
      ...providers2[index18],
      ...req.body,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    res.json(providers2[index18]);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to update provider", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to update provider" });
  }
});
router10.delete("/:id", requireAuth, async (req, res) => {
  try {
    const index18 = providers2.findIndex((p) => p.id === req.params.id);
    if (index18 === -1) {
      return res.status(404).json({ error: "Provider not found" });
    }
    providers2.splice(index18, 1);
    credentials.delete(req.params.id);
    budgets.delete(req.params.id);
    apiFunctions.delete(req.params.id);
    res.status(204).send();
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to delete provider", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to delete provider" });
  }
});
router10.post("/:id/test", requireAuth, async (req, res) => {
  try {
    const provider = providers2.find((p) => p.id === req.params.id);
    if (!provider) {
      return res.status(404).json({ error: "Provider not found" });
    }
    const startTime = Date.now();
    await new Promise((resolve2) => setTimeout(resolve2, 100));
    const latency = Date.now() - startTime;
    res.json({
      success: true,
      latency,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to test provider", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({
      success: false,
      error: "Connection test failed",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
});
router10.get(
  "/:id/credentials",
  requireAuth,
  async (req, res) => {
    try {
      const creds = credentials.get(req.params.id) || [];
      const maskedCreds = creds.map((c) => ({
        ...c,
        encryptedValue: "********"
      }));
      res.json(maskedCreds);
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to get credentials", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get credentials" });
    }
  }
);
router10.post(
  "/:id/credentials",
  requireAuth,
  async (req, res) => {
    try {
      const credential = {
        id: randomUUID3(),
        providerId: req.params.id,
        kind: req.body.kind,
        encryptedValue: req.body.value,
        // In production, encrypt this
        lastRotatedAt: (/* @__PURE__ */ new Date()).toISOString(),
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      const existing = credentials.get(req.params.id) || [];
      existing.push(credential);
      credentials.set(req.params.id, existing);
      res.status(201).json({
        ...credential,
        encryptedValue: "********"
      });
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to add credential", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to add credential" });
    }
  }
);
router10.get("/:id/budget", requireAuth, async (req, res) => {
  try {
    let budget = budgets.get(req.params.id);
    if (!budget) {
      budget = {
        id: randomUUID3(),
        providerId: req.params.id,
        dailyLimit: 100,
        monthlyLimit: 1e3,
        softLimit: 80,
        hardLimit: 100,
        usageToday: 0,
        usageMonth: 0,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      budgets.set(req.params.id, budget);
    }
    res.json(budget);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to get budget", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to get budget" });
  }
});
router10.put("/:id/budget", requireAuth, async (req, res) => {
  try {
    const existing = budgets.get(req.params.id) || {
      id: randomUUID3(),
      providerId: req.params.id,
      usageToday: 0,
      usageMonth: 0,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const budget = {
      ...existing,
      ...req.body,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    budgets.set(req.params.id, budget);
    res.json(budget);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to update budget", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to update budget" });
  }
});
router10.get("/:id/usage", requireAuth, async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 30;
    const metrics = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      metrics.push({
        date: date.toISOString().split("T")[0],
        amount: Math.floor(Math.random() * 10),
        requests: Math.floor(Math.random() * 100)
      });
    }
    res.json(metrics);
  } catch (error) {
    log.error("ProvidersRoutes", "Failed to get usage metrics", {
      error: error instanceof Error ? error.message : String(error)
    });
    res.status(500).json({ error: "Failed to get usage metrics" });
  }
});
router10.get(
  "/:id/functions",
  requireAuth,
  async (req, res) => {
    try {
      const funcs = apiFunctions.get(req.params.id) || [];
      res.json(funcs);
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to get API functions", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get API functions" });
    }
  }
);
router10.post(
  "/:id/discover",
  requireAuth,
  async (req, res) => {
    try {
      const { documentUrl } = req.body;
      const discovered = [
        {
          id: randomUUID3(),
          providerId: req.params.id,
          name: "getAccount",
          method: "GET",
          path: "/account",
          summary: "Get account information",
          tags: ["account"],
          parameters: [],
          responses: {},
          security: [],
          authRequired: true,
          costPerCall: 1e-3,
          isEnabled: true,
          isDeprecated: false,
          metadata: {},
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
      const existing = apiFunctions.get(req.params.id) || [];
      existing.push(...discovered);
      apiFunctions.set(req.params.id, existing);
      res.json({
        success: true,
        functionsDiscovered: discovered.length,
        schemasDiscovered: 0,
        functions: discovered,
        schemas: []
      });
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to discover APIs", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({
        success: false,
        error: "API discovery failed"
      });
    }
  }
);
router10.patch(
  "/:id/functions/:funcId",
  requireAuth,
  async (req, res) => {
    try {
      const funcs = apiFunctions.get(req.params.id) || [];
      const index18 = funcs.findIndex((f) => f.id === req.params.funcId);
      if (index18 === -1) {
        return res.status(404).json({ error: "Function not found" });
      }
      funcs[index18] = {
        ...funcs[index18],
        ...req.body,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      apiFunctions.set(req.params.id, funcs);
      res.json(funcs[index18]);
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to update function", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to update function" });
    }
  }
);
router10.post(
  "/:id/functions/:funcId/test",
  async (req, res) => {
    try {
      const funcs = apiFunctions.get(req.params.id) || [];
      const func = funcs.find((f) => f.id === req.params.funcId);
      if (!func) {
        return res.status(404).json({ error: "Function not found" });
      }
      const startTime = Date.now();
      await new Promise((resolve2) => setTimeout(resolve2, 50));
      const latencyMs = Date.now() - startTime;
      func.lastTestedAt = (/* @__PURE__ */ new Date()).toISOString();
      func.lastTestSuccess = true;
      func.lastTestLatencyMs = latencyMs;
      res.json({
        success: true,
        latencyMs
      });
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to test function", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({
        success: false,
        error: "Function test failed"
      });
    }
  }
);
router10.delete(
  "/:id/functions/:funcId",
  requireAuth,
  async (req, res) => {
    try {
      const funcs = apiFunctions.get(req.params.id) || [];
      const index18 = funcs.findIndex((f) => f.id === req.params.funcId);
      if (index18 === -1) {
        return res.status(404).json({ error: "Function not found" });
      }
      funcs.splice(index18, 1);
      apiFunctions.set(req.params.id, funcs);
      res.status(204).send();
    } catch (error) {
      log.error("ProvidersRoutes", "Failed to delete function", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to delete function" });
    }
  }
);
var providers_default = router10;

// server/routes/auth.ts
import { Router as Router13 } from "express";
import bcrypt from "bcryptjs";
import crypto4 from "crypto";
import rateLimit from "express-rate-limit";
init_storage();
init_logger();
init_sanitization();
init_schema2();
init_email_service();
var router11 = Router13();
var authLimiter = rateLimit({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 5,
  // 5 attempts per window per IP
  message: {
    error: "Too many authentication attempts, please try again later"
  },
  standardHeaders: true,
  // Return rate limit info in `RateLimit-*` headers
  legacyHeaders: false,
  // Disable the `X-RateLimit-*` headers
  handler: (req, res) => {
    log.warn("AuthAPI", "Rate limit exceeded", {
      ip: req.ip,
      path: req.path
    });
    res.status(429).json({
      error: "Too many authentication attempts, please try again later"
    });
  }
});
function getCookieOptions() {
  return {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 7 * 24 * 60 * 60 * 1e3
    // 7 days
  };
}
router11.post("/signup", authLimiter, async (req, res) => {
  try {
    const parsed = insertUserSchema.safeParse(req.body);
    if (!parsed.success) {
      return fromZodError(res, parsed.error);
    }
    const { username, password } = parsed.data;
    const sanitizedUsername = sanitizeInput(username);
    if (sanitizedUsername.length < 3) {
      return badRequest(res, "Username must be at least 3 characters");
    }
    if (password.length < 6) {
      return badRequest(res, "Password must be at least 6 characters");
    }
    const existingUser = await storage.getUserByUsername(sanitizedUsername);
    if (existingUser) {
      return badRequest(res, "Username already taken");
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await storage.createUser({
      username: sanitizedUsername,
      password: hashedPassword
    });
    const sessionId = await createSession(user.id);
    res.cookie("session", sessionId, getCookieOptions());
    log.info("AuthAPI", `User registered: ${sanitizedUsername}`);
    res.status(201).json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Signup error: ${error}`);
    return serverError(res, "Failed to create account");
  }
});
router11.post("/login", authLimiter, async (req, res) => {
  try {
    const { username, password } = req.body;
    const sanitizedUsername = sanitizeInput(username);
    if (!username || !password) {
      return badRequest(res, "Username and password required");
    }
    const user = await storage.getUserByUsername(sanitizedUsername);
    if (!user) {
      return unauthorized(res, "Invalid username or password");
    }
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return unauthorized(res, "Invalid username or password");
    }
    const sessionId = await createSession(user.id);
    res.cookie("session", sessionId, getCookieOptions());
    log.info("AuthAPI", `User logged in: ${sanitizedUsername}`);
    res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Login error: ${error}`);
    return serverError(res, "Failed to login");
  }
});
router11.post("/logout", async (req, res) => {
  try {
    const sessionId = req.cookies?.session;
    if (sessionId) {
      await deleteSession(sessionId);
    }
    const { maxAge, ...clearOptions } = getCookieOptions();
    res.clearCookie("session", clearOptions);
    log.info("AuthAPI", "User logged out");
    res.json({ success: true });
  } catch (error) {
    log.error("AuthAPI", `Logout error: ${error}`);
    res.status(500).json({ error: "Failed to logout" });
  }
});
router11.get("/me", async (req, res) => {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const session = await getSession(sessionId);
    if (!session) {
      return res.status(401).json({ error: "Session expired" });
    }
    const user = await storage.getUser(session.userId);
    if (!user) {
      await deleteSession(sessionId);
      return res.status(401).json({ error: "User not found" });
    }
    res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Get user error: ${error}`);
    res.status(500).json({ error: "Failed to get user" });
  }
});
router11.post(
  "/forgot-password",
  authLimiter,
  async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return badRequest(res, "Email is required");
      }
      if (!isEmailConfigured2()) {
        log.warn(
          "AuthAPI",
          "Password reset requested but email service not configured"
        );
        return res.json({
          message: "If an account with that email exists, a password reset link has been sent"
        });
      }
      const sanitizedEmail = sanitizeInput(email.toLowerCase().trim());
      const user = await storage.getUserByEmail(sanitizedEmail);
      if (!user) {
        log.info(
          "AuthAPI",
          `Password reset requested for non-existent email: ${sanitizedEmail}`
        );
        return res.json({
          message: "If an account with that email exists, a password reset link has been sent"
        });
      }
      const token = crypto4.randomBytes(32).toString("hex");
      const expiresAt = new Date(Date.now() + 60 * 60 * 1e3);
      await storage.createPasswordResetToken(user.id, token, expiresAt);
      const baseUrl = process.env.BASE_URL || "http://localhost:5000";
      const resetUrl = `${baseUrl}/reset-password`;
      const fromEmail = process.env.SENDGRID_FROM_EMAIL || "noreply@alphaflow.com";
      const result = await sendPasswordResetEmail({
        to: sanitizedEmail,
        from: fromEmail,
        username: user.username,
        resetToken: token,
        resetUrl
      });
      if (result.success) {
        log.info("AuthAPI", `Password reset email sent to: ${sanitizedEmail}`);
      } else {
        log.error(
          "AuthAPI",
          `Failed to send password reset email: ${result.error}`
        );
      }
      res.json({
        message: "If an account with that email exists, a password reset link has been sent"
      });
    } catch (error) {
      log.error("AuthAPI", `Forgot password error: ${error}`);
      return serverError(res, "Failed to process password reset request");
    }
  }
);
router11.post(
  "/reset-password",
  authLimiter,
  async (req, res) => {
    try {
      const { token, password } = req.body;
      if (!token || !password) {
        return badRequest(res, "Token and new password are required");
      }
      if (password.length < 6) {
        return badRequest(res, "Password must be at least 6 characters");
      }
      const resetToken = await storage.getPasswordResetToken(token);
      if (!resetToken) {
        log.warn("AuthAPI", "Invalid password reset token attempted");
        return badRequest(res, "Invalid or expired reset token");
      }
      if (/* @__PURE__ */ new Date() > resetToken.expiresAt) {
        log.warn("AuthAPI", "Expired password reset token attempted");
        return badRequest(res, "Invalid or expired reset token");
      }
      if (resetToken.used) {
        log.warn("AuthAPI", "Already used password reset token attempted");
        return badRequest(res, "Invalid or expired reset token");
      }
      const user = await storage.getUser(resetToken.userId);
      if (!user) {
        log.error(
          "AuthAPI",
          `Password reset token refers to non-existent user: ${resetToken.userId}`
        );
        return badRequest(res, "Invalid or expired reset token");
      }
      const hashedPassword = await bcrypt.hash(password, 10);
      await storage.updateUser(user.id, { password: hashedPassword });
      await storage.markPasswordResetTokenUsed(token);
      await storage.deleteExpiredPasswordResetTokens();
      log.info(
        "AuthAPI",
        `Password reset successful for user: ${user.username}`
      );
      res.json({ message: "Password has been reset successfully" });
    } catch (error) {
      log.error("AuthAPI", `Reset password error: ${error}`);
      return serverError(res, "Failed to reset password");
    }
  }
);
router11.post("/update-email", async (req, res) => {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      return unauthorized(res, "Not authenticated");
    }
    const session = await getSession(sessionId);
    if (!session) {
      return unauthorized(res, "Session expired");
    }
    const { email } = req.body;
    if (!email) {
      return badRequest(res, "Email is required");
    }
    const sanitizedEmail = sanitizeInput(email.toLowerCase().trim());
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(sanitizedEmail)) {
      return badRequest(res, "Invalid email format");
    }
    const existingUser = await storage.getUserByEmail(sanitizedEmail);
    if (existingUser && existingUser.id !== session.userId) {
      return badRequest(res, "Email is already in use");
    }
    const updatedUser = await storage.updateUser(session.userId, {
      email: sanitizedEmail
    });
    if (!updatedUser) {
      return serverError(res, "Failed to update email");
    }
    log.info("AuthAPI", `Email updated for user: ${updatedUser.username}`);
    res.json({ message: "Email updated successfully" });
  } catch (error) {
    log.error("AuthAPI", `Update email error: ${error}`);
    return serverError(res, "Failed to update email");
  }
});
var auth_default = router11;

// server/routes/positions.ts
init_storage();
init_logger();
import { Router as Router14 } from "express";
init_schema2();
init_alpaca();
init_alpaca_trading_engine();

// shared/position-mapper.ts
function safeParseFloat2(value, fallback = 0) {
  if (value === null || value === void 0) return fallback;
  const parsed = typeof value === "number" ? value : parseFloat(value);
  return isNaN(parsed) ? fallback : parsed;
}
function mapAlpacaPositionToEnriched(position, fetchedAt = /* @__PURE__ */ new Date()) {
  const qtyValue = safeParseFloat2(position.qty);
  const unrealizedPlValue = safeParseFloat2(position.unrealized_pl);
  const unrealizedPlPctValue = safeParseFloat2(position.unrealized_plpc) * 100;
  return {
    id: position.asset_id,
    symbol: position.symbol,
    // SYNC FIX: Provide both field names for backward compatibility
    qty: qtyValue,
    quantity: qtyValue,
    // Deprecated alias
    entryPrice: safeParseFloat2(position.avg_entry_price),
    currentPrice: safeParseFloat2(position.current_price),
    // SYNC FIX: Provide both field names for backward compatibility
    unrealizedPl: unrealizedPlValue,
    unrealizedPnl: unrealizedPlValue,
    // Deprecated alias
    // SYNC FIX: Provide both field names for backward compatibility
    unrealizedPlPct: unrealizedPlPctValue,
    unrealizedPnlPercent: unrealizedPlPctValue,
    // Deprecated alias
    side: qtyValue > 0 ? "long" : "short",
    marketValue: safeParseFloat2(position.market_value),
    costBasis: safeParseFloat2(position.cost_basis),
    changeToday: safeParseFloat2(position.change_today) * 100,
    assetClass: position.asset_class,
    exchange: position.exchange,
    _source: {
      source: "alpaca_live",
      fetchedAt: fetchedAt.toISOString(),
      isStale: false
    }
  };
}
function mapAlpacaOrderToEnriched(order, fetchedAt = /* @__PURE__ */ new Date()) {
  return {
    id: order.id,
    clientOrderId: order.client_order_id,
    symbol: order.symbol,
    quantity: safeParseFloat2(order.qty),
    filledQuantity: safeParseFloat2(order.filled_qty),
    side: order.side,
    type: order.type,
    status: order.status,
    limitPrice: order.limit_price ? safeParseFloat2(order.limit_price) : null,
    stopPrice: order.stop_price ? safeParseFloat2(order.stop_price) : null,
    filledAvgPrice: order.filled_avg_price ? safeParseFloat2(order.filled_avg_price) : null,
    createdAt: order.created_at,
    filledAt: order.filled_at,
    timeInForce: order.time_in_force,
    extendedHours: order.extended_hours,
    _source: {
      source: "alpaca_live",
      fetchedAt: fetchedAt.toISOString(),
      isStale: false
    }
  };
}
function createUnavailableSourceMetadata(error) {
  return {
    source: "unavailable",
    fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
    isStale: true
  };
}
function createLiveSourceMetadata() {
  return {
    source: "alpaca_live",
    fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
    isStale: false
  };
}

// server/routes/positions.ts
init_order_execution_flow();
var router12 = Router14();
router12.get("/snapshot", requireAuth, async (req, res) => {
  try {
    const [alpacaAccount, alpacaPositions] = await Promise.all([
      alpaca.getAccount(),
      alpaca.getPositions()
    ]);
    const equity = parseFloat(alpacaAccount.equity);
    const lastEquity = parseFloat(alpacaAccount.last_equity);
    const buyingPower = parseFloat(alpacaAccount.buying_power);
    const cash = parseFloat(alpacaAccount.cash);
    const portfolioValue = parseFloat(alpacaAccount.portfolio_value);
    const dailyPl = equity - lastEquity;
    const dailyPlPct = lastEquity > 0 ? dailyPl / lastEquity * 100 : 0;
    const positions2 = alpacaPositions.map(
      (pos) => ({
        id: pos.asset_id,
        symbol: pos.symbol,
        side: pos.side === "long" ? "long" : "short",
        qty: parseFloat(pos.qty),
        entryPrice: parseFloat(pos.avg_entry_price),
        currentPrice: parseFloat(pos.current_price),
        marketValue: parseFloat(pos.market_value),
        unrealizedPl: parseFloat(pos.unrealized_pl),
        unrealizedPlPct: parseFloat(pos.unrealized_plpc) * 100,
        costBasis: parseFloat(pos.cost_basis),
        assetClass: pos.asset_class === "crypto" ? "crypto" : "us_equity"
      })
    );
    const totalUnrealizedPl = positions2.reduce(
      (sum, pos) => sum + pos.unrealizedPl,
      0
    );
    for (const position of positions2) {
      if (position.unrealizedPlPct < -5) {
        checkPositionForLargeLoss(position.symbol, position.currentPrice).catch(
          (err) => log.error(
            "PositionsAPI",
            "Failed to check position for loss alert",
            {
              error: err.message,
              symbol: position.symbol
            }
          )
        );
      }
    }
    const trades3 = await storage.getTrades(void 0, 100);
    const closedTrades = trades3.filter((t) => t.pnl !== null && t.pnl !== "");
    const totalRealizedPl = closedTrades.reduce(
      (sum, t) => sum + parseFloat(t.pnl || "0"),
      0
    );
    const snapshot = {
      totalEquity: equity,
      buyingPower,
      cash,
      portfolioValue,
      dailyPl,
      dailyPlPct,
      totalPl: totalRealizedPl + totalUnrealizedPl,
      totalPlPct: lastEquity > 0 ? (totalRealizedPl + totalUnrealizedPl) / lastEquity * 100 : 0,
      positions: positions2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      positionCount: positions2.length,
      longPositions: positions2.filter((p) => p.side === "long").length,
      shortPositions: positions2.filter((p) => p.side === "short").length,
      totalRealizedPl,
      totalUnrealizedPl
    };
    res.json(snapshot);
  } catch (error) {
    log.error("PositionsAPI", `Failed to get portfolio snapshot: ${error}`);
    res.status(500).json({
      error: "Failed to get portfolio snapshot",
      message: error.message
    });
  }
});
router12.get("/", requireAuth, async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  const DUST_THRESHOLD = 1e-4;
  try {
    const positions2 = await alpaca.getPositions();
    const filteredPositions = positions2.filter((p) => {
      const qty = Math.abs(parseFloat(p.qty || "0"));
      return qty >= DUST_THRESHOLD;
    });
    storage.syncPositionsFromAlpaca(req.userId, filteredPositions).catch(
      (err) => log.error(
        "PositionsAPI",
        `Failed to sync positions to database: ${err}`
      )
    );
    const enrichedPositions = filteredPositions.map(
      (p) => mapAlpacaPositionToEnriched(p, fetchedAt)
    );
    res.json({
      positions: enrichedPositions,
      _source: createLiveSourceMetadata()
    });
  } catch (error) {
    log.error(
      "PositionsAPI",
      `Failed to fetch positions from Alpaca: ${error}`
    );
    res.status(503).json({
      error: "Live position data unavailable from Alpaca",
      _source: createUnavailableSourceMetadata(),
      message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
    });
  }
});
router12.get("/broker", requireAuth, async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  const DUST_THRESHOLD = 1e-4;
  try {
    const positions2 = await alpaca.getPositions();
    const filteredPositions = positions2.filter((p) => {
      const qty = Math.abs(parseFloat(p.qty || "0"));
      return qty >= DUST_THRESHOLD;
    });
    const enrichedPositions = filteredPositions.map(
      (p) => mapAlpacaPositionToEnriched(p, fetchedAt)
    );
    res.json({
      positions: enrichedPositions,
      _source: createLiveSourceMetadata()
    });
  } catch (error) {
    log.error("PositionsAPI", `Failed to fetch broker positions: ${error}`);
    res.status(503).json({
      error: "Failed to fetch positions from broker",
      _source: createUnavailableSourceMetadata(),
      message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
    });
  }
});
router12.get("/:id", requireAuth, async (req, res) => {
  try {
    const position = await storage.getPosition(req.params.id);
    if (!position) {
      return notFound(res, "Position not found");
    }
    res.json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to get position: ${error}`);
    res.status(500).json({ error: "Failed to get position" });
  }
});
router12.post("/", requireAuth, async (req, res) => {
  try {
    const parsed = insertPositionSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const position = await storage.createPosition(parsed.data);
    res.status(201).json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to create position: ${error}`);
    res.status(500).json({ error: "Failed to create position" });
  }
});
router12.patch("/:id", requireAuth, async (req, res) => {
  try {
    const position = await storage.updatePosition(req.params.id, req.body);
    if (!position) {
      return notFound(res, "Position not found");
    }
    res.json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to update position: ${error}`);
    res.status(500).json({ error: "Failed to update position" });
  }
});
router12.delete("/:id", requireAuth, async (req, res) => {
  try {
    const deleted = await storage.deletePosition(req.params.id);
    if (!deleted) {
      return notFound(res, "Position not found");
    }
    res.status(204).send();
  } catch (error) {
    log.error("PositionsAPI", `Failed to delete position: ${error}`);
    res.status(500).json({ error: "Failed to delete position" });
  }
});
router12.post("/reconcile", requireAuth, async (req, res) => {
  try {
    const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
    const force = req.query.force === "true";
    const result = await positionReconciler2.reconcile(force);
    res.json(result);
  } catch (error) {
    log.error("PositionsAPI", `Position reconciliation failed: ${error}`);
    res.status(500).json({ error: "Failed to reconcile positions" });
  }
});
router12.get(
  "/reconcile/status",
  requireAuth,
  async (req, res) => {
    try {
      const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
      const status = positionReconciler2.getStatus();
      res.json(status);
    } catch (error) {
      log.error(
        "PositionsAPI",
        `Failed to get reconciliation status: ${error}`
      );
      res.status(500).json({ error: "Failed to get reconciliation status" });
    }
  }
);
router12.post(
  "/close/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      if (!symbol) {
        return badRequest(res, "Symbol is required");
      }
      const result = await alpacaTradingEngine.closeAlpacaPosition(
        symbol,
        void 0,
        {
          authorizedByOrchestrator: true
        }
      );
      if (result.success) {
        res.json({
          success: true,
          message: `Position ${symbol} closed successfully`,
          result
        });
      } else {
        res.status(400).json({
          success: false,
          error: result.error || "Failed to close position"
        });
      }
    } catch (error) {
      log.error("PositionsAPI", `Failed to close position: ${error}`);
      res.status(500).json({ error: String(error) });
    }
  }
);
router12.post("/close-all", requireAuth, async (req, res) => {
  try {
    const result = await alpacaTradingEngine.closeAllPositions({
      authorizedByOrchestrator: true,
      isEmergencyStop: true
    });
    res.json({ success: true, ...result });
  } catch (error) {
    log.error("PositionsAPI", `Failed to close all positions: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
var positions_default = router12;

// server/routes/orders.ts
init_storage();
init_alpaca();
init_order_execution_flow();
import { Router as Router15 } from "express";
init_work_queue();
var router13 = Router15();
router13.get(
  "/unreal",
  requireAuth,
  asyncHandler(async (req, res) => {
    const unrealOrders = await identifyUnrealOrders();
    res.json({
      count: unrealOrders.length,
      orders: unrealOrders
    });
  })
);
router13.post(
  "/cleanup",
  requireAuth,
  asyncHandler(async (req, res) => {
    const result = await cleanupUnrealOrders();
    res.json({
      success: result.errors.length === 0,
      identified: result.identified,
      canceled: result.canceled,
      errors: result.errors
    });
  })
);
router13.post(
  "/reconcile",
  requireAuth,
  asyncHandler(async (req, res) => {
    const result = await reconcileOrderBook();
    res.json({
      success: true,
      alpacaOrders: result.alpacaOrders,
      localTrades: result.localTrades,
      missingLocal: result.missingLocal,
      orphanedLocal: result.orphanedLocal,
      synced: result.synced
    });
  })
);
router13.get(
  "/execution-engine/status",
  requireAuth,
  asyncHandler(async (req, res) => {
    const activeExecutions = orderExecutionEngine.getActiveExecutions();
    const executions = Array.from(activeExecutions.entries()).map(
      ([id, state]) => ({
        clientOrderId: id,
        orderId: state.orderId,
        symbol: state.symbol,
        side: state.side,
        status: state.status,
        attempts: state.attempts,
        createdAt: state.createdAt.toISOString(),
        updatedAt: state.updatedAt.toISOString()
      })
    );
    res.json({
      activeCount: executions.length,
      executions
    });
  })
);
router13.get(
  "/",
  requireAuth,
  asyncHandler(async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    const limit4 = parseInt(req.query.limit) || 50;
    const status = req.query.status;
    let orders2;
    if (status) {
      orders2 = await storage.getOrdersByStatus(req.userId, status, limit4);
    } else {
      orders2 = await storage.getRecentOrders(req.userId, limit4);
    }
    res.json({
      orders: orders2,
      _source: {
        type: "database",
        table: "orders",
        fetchedAt: fetchedAt.toISOString(),
        note: "Orders stored in local database, synced from broker"
      }
    });
  })
);
router13.post(
  "/sync",
  requireAuth,
  asyncHandler(async (req, res) => {
    const traceId = `api-sync-${Date.now()}`;
    const workItem = await workQueue.enqueue({
      type: "ORDER_SYNC",
      payload: JSON.stringify({ traceId }),
      maxAttempts: 3
    });
    res.json({
      success: true,
      workItemId: workItem.id,
      message: "Order sync enqueued",
      traceId
    });
  })
);
router13.get(
  "/recent",
  requireAuth,
  asyncHandler(async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    const limit4 = parseInt(req.query.limit) || 50;
    const orders2 = await alpaca.getOrders("all", limit4);
    const enrichedOrders = orders2.map((o) => ({
      ...mapAlpacaOrderToEnriched(o, fetchedAt),
      assetClass: o.asset_class,
      submittedAt: o.submitted_at,
      isAI: true
    }));
    res.json({
      orders: enrichedOrders,
      _source: createLiveSourceMetadata()
    });
  })
);
router13.get(
  "/fills",
  requireAuth,
  asyncHandler(async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    const limit4 = parseInt(req.query.limit) || 50;
    const orders2 = await storage.getRecentOrders(req.userId, 100);
    const orderIds = orders2.map((o) => o.id);
    let allFills = await storage.getFillsByOrderIds(orderIds);
    allFills = allFills.slice(0, limit4);
    res.json({
      fills: allFills,
      _source: {
        type: "database",
        table: "fills",
        fetchedAt: fetchedAt.toISOString()
      }
    });
  })
);
router13.get(
  "/fills/order/:orderId",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { orderId } = req.params;
    let fills2 = await storage.getFillsByOrderId(orderId);
    if (fills2.length === 0) {
      fills2 = await storage.getFillsByBrokerOrderId(orderId);
    }
    res.json({
      fills: fills2,
      _source: {
        type: "database",
        table: "fills",
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  })
);
router13.get(
  "/:id",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    let order = await storage.getOrderById(id);
    if (!order) {
      order = await storage.getOrderByBrokerOrderId(id);
    }
    if (!order) {
      throw notFoundError("Order not found");
    }
    const fills2 = await storage.getFillsByOrderId(order.id);
    res.json({
      order,
      fills: fills2,
      _source: {
        type: "database",
        table: "orders",
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  })
);
var orders_default = router13;

// server/routes/trades.ts
init_storage();
init_alpaca();
init_numeric();
import { Router as Router16 } from "express";
init_schema2();
init_logger();
var router14 = Router16();
router14.get("/", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const trades3 = await storage.getTrades(req.userId, limit4);
    res.json(trades3);
  } catch (error) {
    log.error("TradesAPI", "Failed to get trades", {
      error: error instanceof Error ? error.message : String(error)
    });
    return serverError(res, "Failed to get trades");
  }
});
router14.get("/enriched", requireAuth, async (req, res) => {
  try {
    const filters = {
      limit: parseInt(req.query.limit) || 20,
      offset: parseInt(req.query.offset) || 0,
      symbol: req.query.symbol,
      strategyId: req.query.strategyId,
      pnlDirection: req.query.pnlDirection || "all",
      startDate: req.query.startDate ? new Date(req.query.startDate) : void 0,
      endDate: req.query.endDate ? new Date(req.query.endDate) : void 0
    };
    const result = await storage.getTradesFiltered(req.userId, filters);
    res.json(result);
  } catch (error) {
    log.error("TradesAPI", "Failed to get enriched trades", {
      error: error instanceof Error ? error.message : String(error)
    });
    return serverError(res, "Failed to get enriched trades");
  }
});
router14.get("/symbols", requireAuth, async (req, res) => {
  try {
    const symbols = await storage.getDistinctSymbols();
    res.json(symbols);
  } catch (error) {
    log.error("TradesAPI", "Failed to get symbols", {
      error: error instanceof Error ? error.message : String(error)
    });
    return serverError(res, "Failed to get symbols");
  }
});
router14.get("/:id", requireAuth, async (req, res) => {
  try {
    const trade = await storage.getTrade(req.params.id);
    if (!trade) {
      return notFound(res, "Trade not found");
    }
    res.json(trade);
  } catch (error) {
    log.error("TradesAPI", "Failed to get trade", {
      error: error instanceof Error ? error.message : String(error)
    });
    return serverError(res, "Failed to get trade");
  }
});
router14.get(
  "/:id/enriched",
  requireAuth,
  async (req, res) => {
    try {
      const trade = await storage.getEnrichedTrade(req.params.id);
      if (!trade) {
        return notFound(res, "Trade not found");
      }
      res.json(trade);
    } catch (error) {
      log.error("TradesAPI", "Failed to get enriched trade", {
        error: error instanceof Error ? error.message : String(error)
      });
      return serverError(res, "Failed to get enriched trade");
    }
  }
);
router14.post("/", requireAuth, async (req, res) => {
  try {
    const parsed = insertTradeSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const trade = await storage.createTrade(parsed.data);
    res.status(201).json(trade);
  } catch (error) {
    log.error("TradesAPI", "Failed to create trade", {
      error: error instanceof Error ? error.message : String(error)
    });
    return serverError(res, "Failed to create trade");
  }
});
router14.post(
  "/backfill-prices",
  requireAuth,
  async (req, res) => {
    try {
      const trades3 = await storage.getTrades(void 0, 500);
      const zeroTrades = trades3.filter((t) => safeParseFloat(t.price, 0) === 0);
      if (zeroTrades.length === 0) {
        return res.json({ message: "No trades need backfilling", updated: 0 });
      }
      let orders2 = [];
      try {
        orders2 = await alpaca.getOrders("all", 500);
      } catch (e) {
        log.error("TradesAPI", "Failed to fetch Alpaca orders for backfill", {
          error: e instanceof Error ? e.message : String(e)
        });
        return serverError(res, "Failed to fetch order history from broker");
      }
      let updated = 0;
      for (const trade of zeroTrades) {
        const matchingOrder = orders2.find(
          (o) => o.symbol === trade.symbol && o.side === trade.side && o.status === "filled" && safeParseFloat(o.filled_avg_price, 0) > 0 && Math.abs(
            new Date(o.filled_at).getTime() - new Date(trade.executedAt).getTime()
          ) < 6e4
        );
        if (matchingOrder) {
          const filledPrice = safeParseFloat(matchingOrder.filled_avg_price, 0);
          const filledQty = safeParseFloat(matchingOrder.filled_qty, 0);
          await storage.updateTrade(trade.id, {
            price: filledPrice.toString(),
            quantity: filledQty.toString(),
            status: "filled"
          });
          updated++;
        }
      }
      res.json({
        message: `Backfilled ${updated} of ${zeroTrades.length} trades`,
        updated,
        remaining: zeroTrades.length - updated
      });
    } catch (error) {
      log.error("TradesAPI", "Trade backfill error", {
        error: error instanceof Error ? error.message : String(error)
      });
      return serverError(res, "Failed to backfill trade prices");
    }
  }
);
var trades_default = router14;

// server/routes/market-data.ts
init_logger();
import { Router as Router17 } from "express";
init_coingecko();
init_finnhub();
init_alpaca();
init_newsapi();
var router15 = Router17();
router15.get(
  "/crypto/markets",
  requireAuth,
  async (req, res) => {
    try {
      const perPage = parseInt(req.query.per_page) || 20;
      const page = parseInt(req.query.page) || 1;
      const order = req.query.order || "market_cap_desc";
      const markets = await coingecko.getMarkets("usd", perPage, page, order);
      res.json(markets);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch crypto markets: ${error}`);
      return serverError(res, "Failed to fetch crypto market data");
    }
  }
);
router15.get(
  "/crypto/prices",
  requireAuth,
  async (req, res) => {
    try {
      const ids = req.query.ids || "bitcoin,ethereum,solana";
      const coinIds = ids.split(",").map((id) => id.trim());
      const prices = await coingecko.getSimplePrice(coinIds);
      res.json(prices);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch crypto prices: ${error}`);
      return serverError(res, "Failed to fetch crypto prices");
    }
  }
);
router15.get(
  "/crypto/chart/:coinId",
  requireAuth,
  async (req, res) => {
    try {
      const { coinId } = req.params;
      const days = req.query.days || "7";
      const chart = await coingecko.getMarketChart(coinId, "usd", days);
      res.json(chart);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch crypto chart: ${error}`);
      return serverError(res, "Failed to fetch crypto chart data");
    }
  }
);
router15.get(
  "/crypto/trending",
  requireAuth,
  async (req, res) => {
    try {
      const trending = await coingecko.getTrending();
      res.json(trending);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch trending coins: ${error}`);
      return serverError(res, "Failed to fetch trending coins");
    }
  }
);
router15.get(
  "/crypto/global",
  requireAuth,
  async (req, res) => {
    try {
      const global2 = await coingecko.getGlobalData();
      res.json(global2);
    } catch (error) {
      log.error(
        "MarketDataAPI",
        `Failed to fetch global market data: ${error}`
      );
      return serverError(res, "Failed to fetch global market data");
    }
  }
);
router15.get(
  "/crypto/search",
  requireAuth,
  async (req, res) => {
    try {
      const query = req.query.q || "";
      if (!query) {
        return badRequest(res, "Search query required");
      }
      const results = await coingecko.searchCoins(query);
      res.json(results);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to search coins: ${error}`);
      return serverError(res, "Failed to search coins");
    }
  }
);
router15.get(
  "/stock/quote/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const quote = await finnhub.getQuote(symbol);
      res.json(quote);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch stock quote: ${error}`);
      return serverError(res, "Failed to fetch stock quote");
    }
  }
);
router15.get(
  "/stock/quotes",
  requireAuth,
  async (req, res) => {
    try {
      const symbols = req.query.symbols || "AAPL,GOOGL,MSFT,AMZN,TSLA";
      const symbolList = symbols.split(",").map((s) => s.trim().toUpperCase());
      const quotes = await finnhub.getMultipleQuotes(symbolList);
      const result = {};
      quotes.forEach((quote, symbol) => {
        result[symbol] = quote;
      });
      res.json(result);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch stock quotes: ${error}`);
      return serverError(res, "Failed to fetch stock quotes");
    }
  }
);
router15.get(
  "/stock/candles/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const resolution = req.query.resolution || "D";
      const from = req.query.from ? parseInt(req.query.from) : void 0;
      const to = req.query.to ? parseInt(req.query.to) : void 0;
      const candles = await finnhub.getCandles(symbol, resolution, from, to);
      res.json(candles);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch stock candles: ${error}`);
      return serverError(res, "Failed to fetch stock candles");
    }
  }
);
router15.get(
  "/stock/profile/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const profile = await finnhub.getCompanyProfile(symbol);
      res.json(profile);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to fetch company profile: ${error}`);
      return serverError(res, "Failed to fetch company profile");
    }
  }
);
router15.get(
  "/stock/search",
  requireAuth,
  async (req, res) => {
    try {
      const query = req.query.q || "";
      if (!query) {
        return badRequest(res, "Search query required");
      }
      const results = await finnhub.searchSymbols(query);
      res.json(results);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to search stocks: ${error}`);
      return serverError(res, "Failed to search stocks");
    }
  }
);
router15.get("/stock/news", requireAuth, async (req, res) => {
  try {
    const category = req.query.category || "general";
    const news = await finnhub.getMarketNews(category);
    res.json(news);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch market news: ${error}`);
    return serverError(res, "Failed to fetch market news");
  }
});
router15.get(
  "/market/quotes",
  requireAuth,
  async (req, res) => {
    try {
      const symbolsParam = req.query.symbols;
      if (!symbolsParam) {
        return badRequest(res, "symbols parameter required");
      }
      const symbols = symbolsParam.split(",").map((s) => s.trim().toUpperCase());
      const snapshots = await alpaca.getSnapshots(symbols);
      const quotes = symbols.map((symbol) => {
        const snap = snapshots[symbol];
        if (!snap) {
          return { symbol, price: null, change: null, changePercent: null };
        }
        const price = snap.latestTrade?.p || snap.dailyBar?.c || 0;
        const prevClose = snap.prevDailyBar?.c || price;
        const change = price - prevClose;
        const changePercent = prevClose ? change / prevClose * 100 : 0;
        return {
          symbol,
          price,
          change,
          changePercent,
          volume: snap.dailyBar?.v || 0,
          high: snap.dailyBar?.h || 0,
          low: snap.dailyBar?.l || 0,
          open: snap.dailyBar?.o || 0
        };
      });
      res.json(quotes);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to get market quotes: ${error}`);
      return serverError(res, "Failed to get market quotes");
    }
  }
);
router15.get(
  "/news/headlines",
  requireAuth,
  async (req, res) => {
    try {
      const category = req.query.category || "business";
      const country = req.query.country || "us";
      const pageSize = parseInt(req.query.pageSize) || 20;
      const headlines = await newsapi.getTopHeadlines(
        category,
        country,
        pageSize
      );
      res.json(headlines);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to get news headlines: ${error}`);
      return serverError(res, "Failed to get news headlines");
    }
  }
);
router15.get("/news/search", requireAuth, async (req, res) => {
  try {
    const query = req.query.q;
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const sortBy = req.query.sortBy || "publishedAt";
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.searchNews(query, sortBy, pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to search news: ${error}`);
    return serverError(res, "Failed to search news");
  }
});
router15.get("/news/market", requireAuth, async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getMarketNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get market news: ${error}`);
    return serverError(res, "Failed to get market news");
  }
});
router15.get("/news/crypto", requireAuth, async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getCryptoNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get crypto news: ${error}`);
    return serverError(res, "Failed to get crypto news");
  }
});
router15.get(
  "/news/stock/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const pageSize = parseInt(req.query.pageSize) || 10;
      const articles = await newsapi.getStockNews(symbol, pageSize);
      res.json(articles);
    } catch (error) {
      log.error("MarketDataAPI", `Failed to get stock news: ${error}`);
      return serverError(res, "Failed to get stock news");
    }
  }
);
var market_data_default = router15;

// server/routes/webhooks.ts
init_webhook_emitter();
init_logger();
import { Router as Router18 } from "express";
var router16 = Router18();
var redactWebhook = (webhook) => ({
  ...webhook,
  secret: webhook.secret ? "***REDACTED***" : void 0,
  headers: webhook.headers ? Object.fromEntries(
    Object.entries(webhook.headers).map(
      ([k, v]) => k.toLowerCase().includes("auth") || k.toLowerCase().includes("token") || k.toLowerCase().includes("key") ? [k, "***REDACTED***"] : [k, v]
    )
  ) : void 0
});
router16.get("/", (req, res) => {
  const webhooks2 = getWebhooks().map(redactWebhook);
  res.json({ webhooks: webhooks2, supportedEvents: SUPPORTED_EVENTS });
});
router16.post("/", (req, res) => {
  try {
    const { name, url, eventTypes, enabled, headers, secret } = req.body;
    if (!name || !url) {
      return res.status(400).json({ error: "name and url are required" });
    }
    if (!url.startsWith("https://") && process.env.NODE_ENV === "production") {
      return res.status(400).json({ error: "Webhook URL must use HTTPS in production" });
    }
    const id = `wh_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const config2 = {
      id,
      name,
      url,
      eventTypes: eventTypes || ["*"],
      enabled: enabled !== false,
      headers,
      secret
    };
    registerWebhook(config2);
    res.status(201).json(redactWebhook(config2));
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.error("Webhooks", "Webhook creation error", { error: errorMessage });
    res.status(500).json({ error: "Failed to create webhook" });
  }
});
router16.get("/:id", (req, res) => {
  const webhook = getWebhook(req.params.id);
  if (!webhook) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json(redactWebhook(webhook));
});
router16.put("/:id", (req, res) => {
  const updated = updateWebhook(req.params.id, req.body);
  if (!updated) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json(redactWebhook(updated));
});
router16.delete("/:id", (req, res) => {
  const result = unregisterWebhook(req.params.id);
  if (!result) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json({ success: true });
});
router16.post("/test", requireAuth, async (req, res) => {
  try {
    const { eventType, payload } = req.body;
    const results = await emitEvent(
      eventType || "system.test",
      payload || { test: true, timestamp: (/* @__PURE__ */ new Date()).toISOString() }
    );
    res.json({ deliveries: results.length, results });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.error("Webhooks", "Webhook test error", { error: errorMessage });
    res.status(500).json({ error: "Failed to send test event" });
  }
});
router16.get("/stats/overview", (req, res) => {
  res.json(getWebhookStats());
});
router16.get("/history/deliveries", (req, res) => {
  const limit4 = parseInt(req.query.limit) || 50;
  res.json({ deliveries: getDeliveryHistory(limit4) });
});
var webhooks_default = router16;

// server/routes/ai-decisions.ts
init_storage();
init_logger();
import { Router as Router19 } from "express";
init_decision_engine();
init_llmGateway();
init_alpaca_trading_engine();
init_alpaca();

// server/services/sentiment-aggregator.ts
init_gdelt();
init_newsapi();
init_huggingface();
init_api_cache();
init_logger();
var DEFAULT_CONFIG4 = {
  weights: {
    gdelt: 0.4,
    // Priority 1: Free, high-volume global news
    newsapi: 0.35,
    // Priority 2: Curated sources, budget-limited
    huggingface: 0.25
    // Priority 3: ML classification, slower
  },
  minSources: 2,
  conflictThreshold: 0.5,
  // Conflict if std dev > 0.5
  cacheTTLMinutes: 30,
  enableParallelFetch: true
};
var SentimentAggregatorService = class {
  config;
  cache;
  stats;
  constructor(config2 = {}) {
    this.config = { ...DEFAULT_CONFIG4, ...config2 };
    this.cache = new ApiCache({
      freshDuration: this.config.cacheTTLMinutes * 60 * 1e3,
      staleDuration: 2 * 60 * 60 * 1e3
    });
    this.stats = {
      totalRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      apiCalls: { gdelt: 0, newsapi: 0, huggingface: 0 },
      averageLatencyMs: 0,
      errors: { gdelt: 0, newsapi: 0, huggingface: 0 }
    };
    log.info("SentimentAggregator", "Service initialized", {
      cacheTTL: this.config.cacheTTLMinutes,
      weights: this.config.weights
    });
  }
  // --------------------------------------------------------------------------
  // Public API
  // --------------------------------------------------------------------------
  /**
   * Get aggregated sentiment for a single symbol
   * Returns cached result if available and fresh
   */
  async getSentiment(symbol) {
    this.stats.totalRequests++;
    const startTime = Date.now();
    const cacheKey = this.buildCacheKey(symbol);
    const cached = this.cache.get(cacheKey);
    if (cached?.isFresh) {
      this.stats.cacheHits++;
      log.debug("SentimentAggregator", "Cache hit", {
        symbol,
        age: Date.now() - cached.data.timestamp.getTime()
      });
      return { ...cached.data, cacheHit: true };
    }
    this.stats.cacheMisses++;
    const sources = await this.fetchAllSources(symbol);
    const aggregated = this.aggregateSources(symbol, sources);
    aggregated.cacheHit = false;
    this.cache.set(cacheKey, aggregated);
    const latency = Date.now() - startTime;
    this.updateLatencyStats(latency);
    log.info("SentimentAggregator", "Sentiment aggregated", {
      symbol,
      score: aggregated.overallScore.toFixed(3),
      confidence: aggregated.overallConfidence.toFixed(3),
      recommendation: aggregated.recommendation,
      sources: aggregated.sources.length,
      latencyMs: latency
    });
    return aggregated;
  }
  /**
   * Get sentiment with detailed source breakdown
   * Useful for debugging and transparency
   */
  async getSentimentWithSources(symbol) {
    return this.getSentiment(symbol);
  }
  /**
   * Batch get sentiment for multiple symbols
   * More efficient than calling getSentiment multiple times
   */
  async batchGetSentiment(symbols) {
    log.info("SentimentAggregator", "Batch sentiment request", {
      count: symbols.length
    });
    const results = /* @__PURE__ */ new Map();
    const BATCH_SIZE = 5;
    for (let i = 0; i < symbols.length; i += BATCH_SIZE) {
      const batch = symbols.slice(i, i + BATCH_SIZE);
      const batchResults = await Promise.allSettled(
        batch.map((symbol) => this.getSentiment(symbol))
      );
      batch.forEach((symbol, idx) => {
        const result = batchResults[idx];
        if (result.status === "fulfilled") {
          results.set(symbol, result.value);
        } else {
          log.warn("SentimentAggregator", "Batch item failed", {
            symbol,
            error: String(result.reason)
          });
        }
      });
    }
    return results;
  }
  /**
   * Get service statistics
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Clear cache and reset stats
   */
  clearCache() {
    this.cache.clear();
    log.info("SentimentAggregator", "Cache cleared");
  }
  /**
   * Update configuration dynamically
   */
  updateConfig(config2) {
    this.config = { ...this.config, ...config2 };
    log.info("SentimentAggregator", "Configuration updated", {
      config: this.config
    });
  }
  // --------------------------------------------------------------------------
  // Private Methods - Source Fetching
  // --------------------------------------------------------------------------
  async fetchAllSources(symbol) {
    if (this.config.enableParallelFetch) {
      return this.fetchSourcesParallel(symbol);
    } else {
      return this.fetchSourcesSequential(symbol);
    }
  }
  async fetchSourcesParallel(symbol) {
    const [gdeltResult, newsapiResult, huggingfaceResult] = await Promise.allSettled([
      this.fetchGDELTSentiment(symbol),
      this.fetchNewsAPISentiment(symbol),
      this.fetchHuggingFaceSentiment(symbol)
    ]);
    const sources = [];
    if (gdeltResult.status === "fulfilled") {
      sources.push(gdeltResult.value);
    }
    if (newsapiResult.status === "fulfilled") {
      sources.push(newsapiResult.value);
    }
    if (huggingfaceResult.status === "fulfilled") {
      sources.push(huggingfaceResult.value);
    }
    return sources;
  }
  async fetchSourcesSequential(symbol) {
    const sources = [];
    try {
      const gdeltSource = await this.fetchGDELTSentiment(symbol);
      if (gdeltSource.confidence > 0) {
        sources.push(gdeltSource);
      }
    } catch (error) {
      log.warn("SentimentAggregator", "GDELT fetch failed", {
        error: String(error)
      });
    }
    try {
      const newsapiSource = await this.fetchNewsAPISentiment(symbol);
      if (newsapiSource.confidence > 0) {
        sources.push(newsapiSource);
      }
    } catch (error) {
      log.warn("SentimentAggregator", "NewsAPI fetch failed", {
        error: String(error)
      });
    }
    try {
      const hfSource = await this.fetchHuggingFaceSentiment(symbol);
      if (hfSource.confidence > 0) {
        sources.push(hfSource);
      }
    } catch (error) {
      log.warn("SentimentAggregator", "HuggingFace fetch failed", {
        error: String(error)
      });
    }
    return sources;
  }
  async fetchGDELTSentiment(symbol) {
    const startTime = Date.now();
    this.stats.apiCalls.gdelt++;
    try {
      const sentiment = await gdelt.analyzeSymbolSentiment(symbol);
      const latencyMs = Date.now() - startTime;
      const normalizedScore = Math.max(
        -1,
        Math.min(1, sentiment.averageTone / 10)
      );
      const confidence = Math.min(1, sentiment.articleCount / 20);
      return {
        name: "gdelt",
        score: normalizedScore,
        confidence,
        articleCount: sentiment.articleCount,
        timestamp: /* @__PURE__ */ new Date(),
        latencyMs
      };
    } catch (error) {
      this.stats.errors.gdelt++;
      log.error("SentimentAggregator", "GDELT error", {
        symbol,
        error: String(error)
      });
      return {
        name: "gdelt",
        score: 0,
        confidence: 0,
        articleCount: 0,
        timestamp: /* @__PURE__ */ new Date(),
        error: error instanceof Error ? error.message : String(error),
        latencyMs: Date.now() - startTime
      };
    }
  }
  async fetchNewsAPISentiment(symbol) {
    const startTime = Date.now();
    this.stats.apiCalls.newsapi++;
    try {
      const articles = await newsapi.getStockNews(symbol, 20);
      const latencyMs = Date.now() - startTime;
      if (articles.length === 0) {
        return {
          name: "newsapi",
          score: 0,
          confidence: 0,
          articleCount: 0,
          timestamp: /* @__PURE__ */ new Date(),
          latencyMs
        };
      }
      const sentimentScore = this.analyzeArticlesSentiment(articles);
      const confidence = Math.min(1, articles.length / 10);
      return {
        name: "newsapi",
        score: sentimentScore,
        confidence,
        articleCount: articles.length,
        timestamp: /* @__PURE__ */ new Date(),
        latencyMs
      };
    } catch (error) {
      this.stats.errors.newsapi++;
      log.error("SentimentAggregator", "NewsAPI error", {
        symbol,
        error: String(error)
      });
      return {
        name: "newsapi",
        score: 0,
        confidence: 0,
        articleCount: 0,
        timestamp: /* @__PURE__ */ new Date(),
        error: error instanceof Error ? error.message : String(error),
        latencyMs: Date.now() - startTime
      };
    }
  }
  async fetchHuggingFaceSentiment(symbol) {
    const startTime = Date.now();
    this.stats.apiCalls.huggingface++;
    try {
      if (!huggingface.isAvailable()) {
        return {
          name: "huggingface",
          score: 0,
          confidence: 0,
          articleCount: 0,
          timestamp: /* @__PURE__ */ new Date(),
          error: "HuggingFace API key not configured",
          latencyMs: Date.now() - startTime
        };
      }
      const articles = await newsapi.getStockNews(symbol, 5).catch(() => []);
      const headlines = articles.map((a) => a.title).filter(Boolean).slice(0, 5);
      if (headlines.length === 0) {
        return {
          name: "huggingface",
          score: 0,
          confidence: 0,
          articleCount: 0,
          timestamp: /* @__PURE__ */ new Date(),
          latencyMs: Date.now() - startTime
        };
      }
      const enrichment = await huggingface.generateEnrichmentSignal(
        symbol,
        headlines
      );
      const latencyMs = Date.now() - startTime;
      return {
        name: "huggingface",
        score: enrichment.sentimentScore,
        confidence: enrichment.confidence,
        articleCount: headlines.length,
        timestamp: /* @__PURE__ */ new Date(),
        latencyMs
      };
    } catch (error) {
      this.stats.errors.huggingface++;
      log.error("SentimentAggregator", "HuggingFace error", {
        symbol,
        error: String(error)
      });
      return {
        name: "huggingface",
        score: 0,
        confidence: 0,
        articleCount: 0,
        timestamp: /* @__PURE__ */ new Date(),
        error: error instanceof Error ? error.message : String(error),
        latencyMs: Date.now() - startTime
      };
    }
  }
  // --------------------------------------------------------------------------
  // Private Methods - Sentiment Analysis
  // --------------------------------------------------------------------------
  analyzeArticlesSentiment(articles) {
    let positiveCount = 0;
    let negativeCount = 0;
    const positiveKeywords = [
      "surge",
      "surges",
      "surged",
      "surging",
      "gain",
      "gains",
      "gained",
      "gaining",
      "rise",
      "rises",
      "rose",
      "rising",
      "rally",
      "rallies",
      "rallied",
      "rallying",
      "up",
      "bullish",
      "bull",
      "growth",
      "growing",
      "grew",
      "profit",
      "profitable",
      "profits",
      "beat",
      "beats",
      "beating",
      "outperform",
      "strong",
      "strength",
      "strengthen",
      "boost",
      "boosted",
      "boosting",
      "soar",
      "soared",
      "soaring",
      "jump",
      "jumped",
      "jumping",
      "climb",
      "climbed",
      "climbing",
      "advance",
      "advanced",
      "advancing",
      "positive",
      "optimistic",
      "confident",
      "success",
      "successful",
      "win",
      "winning"
    ];
    const negativeKeywords = [
      "fall",
      "falls",
      "fell",
      "falling",
      "drop",
      "drops",
      "dropped",
      "dropping",
      "decline",
      "declines",
      "declined",
      "declining",
      "plunge",
      "plunged",
      "plunging",
      "down",
      "bearish",
      "bear",
      "loss",
      "losses",
      "losing",
      "lost",
      "miss",
      "missed",
      "missing",
      "underperform",
      "weak",
      "weakness",
      "weaken",
      "crash",
      "crashed",
      "crashing",
      "sink",
      "sank",
      "sinking",
      "tumble",
      "tumbled",
      "tumbling",
      "slide",
      "slid",
      "sliding",
      "slump",
      "slumped",
      "slumping",
      "negative",
      "pessimistic",
      "concern",
      "worried",
      "fail",
      "failed",
      "failure",
      "risk",
      "risky"
    ];
    articles.forEach((article) => {
      const text17 = `${article.title || ""} ${article.description || ""}`.toLowerCase();
      positiveKeywords.forEach((keyword) => {
        if (text17.includes(keyword)) positiveCount++;
      });
      negativeKeywords.forEach((keyword) => {
        if (text17.includes(keyword)) negativeCount++;
      });
    });
    const total = positiveCount + negativeCount;
    if (total === 0) return 0;
    return (positiveCount - negativeCount) / total;
  }
  // --------------------------------------------------------------------------
  // Private Methods - Aggregation
  // --------------------------------------------------------------------------
  aggregateSources(symbol, sources) {
    const validSources = sources.filter((s) => !s.error && s.confidence > 0);
    if (validSources.length === 0) {
      log.warn("SentimentAggregator", "No valid sources", { symbol });
      return {
        symbol,
        overallScore: 0,
        overallConfidence: 0,
        sources,
        conflictDetected: false,
        conflictSeverity: 0,
        recommendation: "neutral",
        timestamp: /* @__PURE__ */ new Date(),
        cacheHit: false
      };
    }
    let weightedSum = 0;
    let weightSum = 0;
    let confidenceSum = 0;
    validSources.forEach((source) => {
      const weight = this.config.weights[source.name] * source.confidence;
      weightedSum += source.score * weight;
      weightSum += weight;
      confidenceSum += source.confidence;
    });
    const overallScore = weightSum > 0 ? weightedSum / weightSum : 0;
    const baseConfidence = confidenceSum / validSources.length;
    const sourceCountPenalty = validSources.length < this.config.minSources ? 0.7 : 1;
    const overallConfidence = baseConfidence * sourceCountPenalty;
    const { variance: variance4, stdDev: stdDev2 } = this.calculateVariance(
      validSources.map((s) => s.score)
    );
    const conflictDetected = stdDev2 > this.config.conflictThreshold;
    const conflictSeverity = Math.min(
      1,
      stdDev2 / this.config.conflictThreshold
    );
    const recommendation = this.generateRecommendation(
      overallScore,
      conflictDetected,
      conflictSeverity
    );
    return {
      symbol,
      overallScore,
      overallConfidence,
      sources,
      conflictDetected,
      conflictSeverity,
      recommendation,
      timestamp: /* @__PURE__ */ new Date(),
      cacheHit: false
    };
  }
  calculateVariance(values) {
    if (values.length < 2) {
      return { variance: 0, stdDev: 0 };
    }
    const mean4 = values.reduce((sum, val) => sum + val, 0) / values.length;
    const squaredDiffs = values.map((val) => Math.pow(val - mean4, 2));
    const variance4 = squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
    const stdDev2 = Math.sqrt(variance4);
    return { variance: variance4, stdDev: stdDev2 };
  }
  generateRecommendation(score, conflictDetected, conflictSeverity) {
    if (conflictDetected && conflictSeverity > 0.7) {
      return "conflicted";
    }
    if (score > 0.25) return "bullish";
    if (score < -0.25) return "bearish";
    return "neutral";
  }
  // --------------------------------------------------------------------------
  // Private Methods - Utilities
  // --------------------------------------------------------------------------
  buildCacheKey(symbol) {
    return `sentiment_${symbol.toUpperCase()}`;
  }
  updateLatencyStats(latencyMs) {
    const totalLatency = this.stats.averageLatencyMs * (this.stats.totalRequests - 1);
    this.stats.averageLatencyMs = (totalLatency + latencyMs) / this.stats.totalRequests;
  }
};
var sentimentAggregator = new SentimentAggregatorService();

// server/routes/ai-decisions.ts
init_schema2();
var router17 = Router19();
router17.get("/", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 20;
    const decisions = await storage.getAiDecisions(req.userId, limit4);
    res.json(decisions);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI decisions: ${error}`);
    res.status(500).json({ error: "Failed to get AI decisions" });
  }
});
router17.get("/history", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 100;
    const offset = parseInt(req.query.offset) || 0;
    const statusFilter = req.query.status;
    const actionFilter = req.query.action;
    const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
    let filtered = decisions.slice(offset, offset + limit4);
    if (statusFilter) {
      filtered = filtered.filter((d) => d.status === statusFilter);
    }
    if (actionFilter) {
      filtered = filtered.filter((d) => d.action === actionFilter);
    }
    const pendingAnalysis = orchestrator.getPendingAnalysis?.() || [];
    res.json({
      decisions: filtered,
      total: decisions.length,
      hasMore: offset + limit4 < decisions.length,
      pendingAnalysis
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI decision history: ${error}`);
    res.status(500).json({ error: "Failed to get AI decision history" });
  }
});
router17.post("/", requireAuth, async (req, res) => {
  try {
    const parsed = insertAiDecisionSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const decision = await storage.createAiDecision(parsed.data);
    res.status(201).json(decision);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to create AI decision: ${error}`);
    res.status(500).json({ error: "Failed to create AI decision" });
  }
});
router17.get("/enriched", requireAuth, async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    const statusFilter = req.query.status;
    const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
    const enrichedDecisions = await Promise.all(
      decisions.slice(offset, offset + limit4).map(async (decision) => {
        const enriched = {
          decision,
          linkedOrder: null,
          linkedTrade: null,
          linkedPosition: null,
          timeline: []
        };
        enriched.timeline.push({
          stage: "decision",
          status: "completed",
          timestamp: decision.createdAt,
          details: `${decision.action.toUpperCase()} signal with ${parseFloat(decision.confidence || "0").toFixed(1)}% confidence`
        });
        if (decision.status === "skipped") {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "skipped",
            timestamp: decision.createdAt,
            details: decision.skipReason || "Trade blocked by risk rules"
          });
        } else if (decision.status === "executed" || decision.executedTradeId) {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "completed",
            timestamp: decision.createdAt,
            details: "Risk check passed"
          });
        } else if (decision.status === "pending") {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "pending",
            timestamp: null,
            details: "Awaiting risk evaluation"
          });
        }
        if (decision.id) {
          try {
            const linkedOrders = await storage.getOrdersByDecisionId(
              decision.id
            );
            if (linkedOrders.length > 0) {
              const order = linkedOrders[0];
              enriched.linkedOrder = order;
              enriched.timeline.push({
                stage: "order",
                status: order.status === "filled" || order.status === "partially_filled" ? "completed" : order.status === "pending_new" || order.status === "accepted" ? "pending" : "failed",
                timestamp: order.submittedAt,
                details: `${order.side.toUpperCase()} ${order.qty || order.notional} @ ${order.type}`
              });
              if (order.filledAt) {
                enriched.timeline.push({
                  stage: "fill",
                  status: "completed",
                  timestamp: order.filledAt,
                  details: `Filled ${order.filledQty} @ ${order.filledAvgPrice}`
                });
              } else if (order.status === "pending_new" || order.status === "accepted") {
                enriched.timeline.push({
                  stage: "fill",
                  status: "pending",
                  timestamp: null,
                  details: "Awaiting fill"
                });
              }
            }
          } catch (e) {
          }
        }
        if (decision.executedTradeId) {
          try {
            const trade = await storage.getTrade(decision.executedTradeId);
            if (trade) {
              enriched.linkedTrade = trade;
            }
          } catch (e) {
          }
        }
        try {
          const positions2 = await storage.getPositions();
          const symbolPosition = positions2.find(
            (p) => p.symbol.toUpperCase() === decision.symbol.toUpperCase()
          );
          if (symbolPosition) {
            enriched.linkedPosition = symbolPosition;
            enriched.timeline.push({
              stage: "position",
              status: "completed",
              timestamp: symbolPosition.openedAt,
              details: `${symbolPosition.side} ${symbolPosition.quantity} @ ${symbolPosition.entryPrice}`
            });
          }
        } catch (e) {
        }
        return enriched;
      })
    );
    let filtered = enrichedDecisions;
    if (statusFilter) {
      filtered = enrichedDecisions.filter(
        (e) => e.decision.status === statusFilter
      );
    }
    res.json({
      enrichedDecisions: filtered,
      total: decisions.length,
      hasMore: offset + limit4 < decisions.length
    });
  } catch (error) {
    log.error(
      "AiDecisionsAPI",
      `Failed to get enriched AI decisions: ${error}`
    );
    res.status(500).json({ error: "Failed to get enriched AI decisions" });
  }
});
router17.post("/analyze", requireAuth, async (req, res) => {
  try {
    const { symbol, marketData, newsContext, strategyId } = req.body;
    if (!symbol || !marketData) {
      return badRequest(res, "Symbol and market data are required");
    }
    let strategy;
    if (strategyId) {
      const dbStrategy = await storage.getStrategy(strategyId);
      if (dbStrategy) {
        strategy = {
          id: dbStrategy.id,
          name: dbStrategy.name,
          type: dbStrategy.type,
          parameters: dbStrategy.parameters ? JSON.parse(dbStrategy.parameters) : void 0
        };
      }
    }
    const traceId = generateTraceId();
    const decision = await aiDecisionEngine.analyzeOpportunity(
      symbol,
      marketData,
      newsContext,
      strategy,
      { traceId }
    );
    const aiDecisionRecord = await storage.createAiDecision({
      strategyId: strategyId || null,
      symbol,
      action: decision.action,
      confidence: decision.confidence.toString(),
      reasoning: decision.reasoning,
      traceId,
      marketContext: JSON.stringify({
        marketData,
        newsContext,
        riskLevel: decision.riskLevel,
        suggestedQuantity: decision.suggestedQuantity,
        targetPrice: decision.targetPrice,
        stopLoss: decision.stopLoss
      })
    });
    res.json({
      id: aiDecisionRecord.id,
      ...decision,
      createdAt: aiDecisionRecord.createdAt
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `AI analysis error: ${error}`);
    res.status(500).json({ error: "Failed to analyze trading opportunity" });
  }
});
router17.get("/status", requireAuth, async (req, res) => {
  try {
    const status = aiDecisionEngine.getStatus();
    res.json(status);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI status: ${error}`);
    res.status(500).json({ error: "Failed to get AI status" });
  }
});
router17.get("/events", requireAuth, async (req, res) => {
  try {
    const limit4 = Math.min(parseInt(req.query.limit) || 20, 100);
    const type = req.query.type;
    const decisions = await storage.getAiDecisions(void 0, limit4 * 2);
    const events = decisions.filter((d) => !type || d.action === type).slice(0, limit4).map((d) => ({
      id: d.id,
      type: d.action || "signal",
      title: `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol || "Market"}`,
      headline: `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol || "Market"}`,
      description: d.reasoning,
      explanation: d.reasoning,
      symbol: d.symbol,
      confidence: typeof d.confidence === "string" ? parseFloat(d.confidence) : d.confidence,
      action: d.action,
      time: d.createdAt,
      createdAt: d.createdAt,
      metadata: {
        strategyId: d.strategyId,
        signals: null
      }
    }));
    res.json(events);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI events: ${error}`);
    res.json([]);
  }
});
router17.get("/sentiment", requireAuth, async (req, res) => {
  try {
    const symbols = req.query.symbols?.split(",") || [
      "SPY",
      "QQQ",
      "AAPL",
      "TSLA",
      "NVDA"
    ];
    const sentimentResults = await sentimentAggregator.batchGetSentiment(symbols);
    const sentiments = symbols.map((symbol) => {
      const result = sentimentResults.get(symbol);
      if (!result) {
        return {
          id: `sent-${symbol}-${Date.now()}`,
          sourceId: "sentiment-aggregator",
          sourceName: "Sentiment Aggregator",
          symbol,
          score: 0,
          trend: "neutral",
          explanation: `No sentiment data available for ${symbol}`,
          sources: [],
          confidence: 0,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      const uiScore = result.overallScore * 50;
      const trendMap = {
        bullish: "up",
        bearish: "down",
        neutral: "neutral",
        conflicted: "neutral"
      };
      return {
        id: `sent-${symbol}-${Date.now()}`,
        sourceId: "sentiment-aggregator",
        sourceName: "Sentiment Aggregator",
        symbol,
        score: uiScore,
        trend: trendMap[result.recommendation] || "neutral",
        explanation: generateExplanation(result),
        sources: result.sources.map((s) => ({
          name: s.name,
          score: s.score * 50,
          confidence: s.confidence,
          articleCount: s.articleCount
        })),
        confidence: result.overallConfidence,
        conflictDetected: result.conflictDetected,
        recommendation: result.recommendation,
        cacheHit: result.cacheHit,
        timestamp: result.timestamp.toISOString()
      };
    });
    res.json(sentiments);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get sentiment signals: ${error}`);
    const symbols = req.query.symbols?.split(",") || [
      "SPY",
      "QQQ",
      "AAPL",
      "TSLA",
      "NVDA"
    ];
    const fallback = symbols.map((symbol) => ({
      id: `sent-${symbol}-${Date.now()}`,
      sourceId: "fallback",
      sourceName: "Fallback",
      symbol,
      score: 0,
      trend: "neutral",
      explanation: "Sentiment data temporarily unavailable",
      sources: [],
      confidence: 0,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }));
    res.json(fallback);
  }
});
function generateExplanation(result) {
  const validSources = result.sources.filter(
    (s) => !s.error && s.confidence > 0
  );
  const sourceNames = validSources.map((s) => s.name).join(", ");
  if (validSources.length === 0) {
    return `No sentiment data available for ${result.symbol}`;
  }
  const scoreText = result.overallScore > 0.25 ? "positive" : result.overallScore < -0.25 ? "negative" : "neutral";
  const confidenceText = result.overallConfidence > 0.7 ? "high" : result.overallConfidence > 0.4 ? "moderate" : "low";
  let explanation = `${result.recommendation.charAt(0).toUpperCase() + result.recommendation.slice(1)} sentiment for ${result.symbol} based on ${validSources.length} source(s): ${sourceNames}. `;
  explanation += `Overall ${scoreText} score (${(result.overallScore * 100).toFixed(1)}%) with ${confidenceText} confidence.`;
  if (result.conflictDetected) {
    explanation += ` Note: Conflicting signals detected between sources.`;
  }
  return explanation;
}
router17.get("/cache/stats", requireAuth, async (req, res) => {
  try {
    const stats = getLLMCacheStats();
    res.json(stats);
  } catch (error) {
    log.error("AiDecisionsAPI", `Error getting LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get cache stats" });
  }
});
router17.post(
  "/cache/clear",
  requireAuth,
  async (req, res) => {
    try {
      clearLLMCache();
      res.json({ success: true, message: "LLM cache cleared" });
    } catch (error) {
      log.error("AiDecisionsAPI", `Error clearing LLM cache: ${error}`);
      res.status(500).json({ error: "Failed to clear cache" });
    }
  }
);
router17.post(
  "/cache/clear/:role",
  requireAuth,
  async (req, res) => {
    try {
      const { role } = req.params;
      clearLLMCacheForRole(role);
      res.json({ success: true, message: `Cache cleared for role: ${role}` });
    } catch (error) {
      log.error(
        "AiDecisionsAPI",
        `Error clearing LLM cache for role: ${error}`
      );
      res.status(500).json({ error: "Failed to clear cache for role" });
    }
  }
);
router17.post(
  "/cache/reset-stats",
  requireAuth,
  async (req, res) => {
    try {
      resetLLMCacheStats();
      res.json({ success: true, message: "Cache statistics reset" });
    } catch (error) {
      log.error("AiDecisionsAPI", `Error resetting LLM cache stats: ${error}`);
      res.status(500).json({ error: "Failed to reset cache stats" });
    }
  }
);
router17.get(
  "/agent/status",
  requireAuth,
  async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      if (!status) {
        const defaultStatus = await storage.updateAgentStatus({
          isRunning: false,
          totalTrades: 0,
          totalPnl: "0"
        });
        return res.json(defaultStatus);
      }
      res.json(status);
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to get agent status: ${error}`);
      res.status(500).json({ error: "Failed to get agent status" });
    }
  }
);
router17.post(
  "/agent/toggle",
  requireAuth,
  async (req, res) => {
    try {
      const currentStatus = await storage.getAgentStatus();
      const newIsRunning = !(currentStatus?.isRunning ?? false);
      if (newIsRunning) {
        await alpacaTradingEngine.resumeAgent();
      } else {
        await alpacaTradingEngine.stopAllStrategies();
      }
      const status = await storage.getAgentStatus();
      res.json(status);
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to toggle agent: ${error}`);
      res.status(500).json({ error: "Failed to toggle agent" });
    }
  }
);
router17.get(
  "/agent/market-analysis",
  requireAuth,
  async (req, res) => {
    try {
      const analyzerStatus = marketConditionAnalyzer.getStatus();
      const lastAnalysis = marketConditionAnalyzer.getLastAnalysis();
      res.json({
        isRunning: analyzerStatus.isRunning,
        lastAnalysis,
        lastAnalysisTime: analyzerStatus.lastAnalysisTime,
        currentOrderLimit: analyzerStatus.currentOrderLimit
      });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to get market analysis: ${error}`);
      res.status(500).json({ error: "Failed to get market analysis" });
    }
  }
);
router17.post(
  "/agent/market-analysis/refresh",
  async (req, res) => {
    try {
      const analysis = await marketConditionAnalyzer.runAnalysis();
      res.json({ success: true, analysis });
    } catch (error) {
      log.error(
        "AiDecisionsAPI",
        `Failed to refresh market analysis: ${error}`
      );
      res.status(500).json({ error: "Failed to refresh market analysis" });
    }
  }
);
router17.get(
  "/agent/dynamic-limits",
  requireAuth,
  async (req, res) => {
    try {
      const agentStatus2 = await storage.getAgentStatus();
      const analyzerStatus = marketConditionAnalyzer.getStatus();
      const minLimit = agentStatus2?.minOrderLimit ?? 10;
      const maxLimit = agentStatus2?.maxOrderLimit ?? 50;
      let currentLimit = agentStatus2?.dynamicOrderLimit ?? analyzerStatus.currentOrderLimit ?? 25;
      currentLimit = Math.max(minLimit, Math.min(maxLimit, currentLimit));
      res.json({
        currentDynamicLimit: currentLimit,
        minOrderLimit: minLimit,
        maxOrderLimit: maxLimit,
        marketCondition: agentStatus2?.marketCondition || "neutral",
        aiConfidenceScore: agentStatus2?.aiConfidenceScore || "0.5",
        lastMarketAnalysis: agentStatus2?.lastMarketAnalysis
      });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to get dynamic limits: ${error}`);
      res.status(500).json({ error: "Failed to get dynamic limits" });
    }
  }
);
router17.post(
  "/agent/set-limits",
  requireAuth,
  async (req, res) => {
    try {
      const { minOrderLimit, maxOrderLimit } = req.body;
      const updates = {};
      if (minOrderLimit !== void 0) {
        if (minOrderLimit < 1 || minOrderLimit > 100) {
          return badRequest(res, "minOrderLimit must be between 1 and 100");
        }
        updates.minOrderLimit = minOrderLimit;
      }
      if (maxOrderLimit !== void 0) {
        if (maxOrderLimit < 1 || maxOrderLimit > 100) {
          return badRequest(res, "maxOrderLimit must be between 1 and 100");
        }
        updates.maxOrderLimit = maxOrderLimit;
      }
      if (updates.minOrderLimit && updates.maxOrderLimit && updates.minOrderLimit > updates.maxOrderLimit) {
        return badRequest(
          res,
          "minOrderLimit cannot be greater than maxOrderLimit"
        );
      }
      await storage.updateAgentStatus(updates);
      const updatedStatus = await storage.getAgentStatus();
      res.json({
        success: true,
        minOrderLimit: updatedStatus?.minOrderLimit,
        maxOrderLimit: updatedStatus?.maxOrderLimit
      });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to set limits: ${error}`);
      res.status(500).json({ error: "Failed to set limits" });
    }
  }
);
router17.get(
  "/agent/health",
  requireAuth,
  async (req, res) => {
    try {
      const healthStatus = orchestrator.getHealthStatus();
      const agentStatus2 = await storage.getAgentStatus();
      res.json({
        ...healthStatus,
        autoStartEnabled: agentStatus2?.autoStartEnabled ?? true,
        lastHeartbeatFromDb: agentStatus2?.lastHeartbeat
      });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to get agent health: ${error}`);
      res.status(500).json({ error: "Failed to get agent health" });
    }
  }
);
router17.post(
  "/agent/auto-start",
  requireAuth,
  async (req, res) => {
    try {
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return badRequest(res, "enabled must be a boolean");
      }
      await orchestrator.setAutoStartEnabled(enabled);
      res.json({ success: true, autoStartEnabled: enabled });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to set auto-start: ${error}`);
      res.status(500).json({ error: "Failed to set auto-start" });
    }
  }
);
router17.post(
  "/autonomous/execute-trades",
  async (req, res) => {
    try {
      const { decisionIds } = req.body;
      if (!decisionIds || !Array.isArray(decisionIds) || decisionIds.length === 0) {
        return badRequest(res, "Decision IDs array is required");
      }
      const results = [];
      for (const decisionId of decisionIds) {
        const decisions = await storage.getAiDecisions(void 0, 100);
        const decision = decisions.find((d) => d.id === decisionId);
        if (!decision) {
          results.push({
            decisionId,
            success: false,
            error: "Decision not found"
          });
          continue;
        }
        try {
          const metadata = decision.metadata ? JSON.parse(decision.metadata) : {};
          const suggestedPct = metadata?.suggestedQuantity ? parseFloat(String(metadata.suggestedQuantity)) : 0.05;
          const account = await alpaca.getAccount();
          const buyingPower = parseFloat(account.buying_power);
          const price = parseFloat(decision.entryPrice || "0");
          if (!price) {
            results.push({
              decisionId,
              success: false,
              error: "No entry price available"
            });
            continue;
          }
          const tradeValue = buyingPower * Math.min(Math.max(suggestedPct, 0.01), 0.1);
          const quantity = Math.floor(tradeValue / price);
          if (quantity < 1) {
            results.push({
              decisionId,
              success: false,
              error: "Calculated quantity less than 1 share"
            });
            continue;
          }
          const orderResult = await alpacaTradingEngine.executeAlpacaTrade({
            symbol: decision.symbol,
            side: decision.action,
            quantity,
            authorizedByOrchestrator: true
          });
          if (orderResult.success) {
            results.push({
              decisionId,
              success: true,
              order: orderResult.order
            });
          } else {
            results.push({
              decisionId,
              success: false,
              error: orderResult.error
            });
          }
        } catch (err) {
          results.push({ decisionId, success: false, error: String(err) });
        }
      }
      const successCount = results.filter((r) => r.success).length;
      res.json({
        success: successCount > 0,
        message: `Executed ${successCount}/${decisionIds.length} trades`,
        results
      });
    } catch (error) {
      log.error("AiDecisionsAPI", `Failed to execute trades: ${error}`);
      res.status(500).json({ error: String(error) });
    }
  }
);
var ai_decisions_default = router17;

// server/routes/autonomous.ts
init_alpaca_trading_engine();
init_storage();
init_alpaca();
init_orchestration2();
init_logger();
function registerAutonomousRoutes(app2, authMiddleware4) {
  app2.get("/api/autonomous/state", authMiddleware4, async (req, res) => {
    try {
      const state = orchestrator.getState();
      const riskLimits = orchestrator.getRiskLimits();
      res.json({
        ...state,
        riskLimits,
        activePositions: Array.from(state.activePositions.entries()).map(
          ([key, pos]) => ({
            ...pos,
            symbol: key
          })
        ),
        pendingSignals: Array.from(state.pendingSignals.entries()).map(
          ([symbol, signal]) => ({
            symbol,
            ...signal
          })
        )
      });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to get autonomous state", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get autonomous state" });
    }
  });
  app2.get("/api/autonomous/status", authMiddleware4, async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      if (!status) {
        return res.json({
          isRunning: false,
          killSwitchActive: false,
          lastRunTime: null,
          consecutiveErrors: 0,
          activePositions: 0,
          recentDecisions: 0,
          lastDecisionTime: null,
          config: {}
        });
      }
      const userId = req.userId;
      const recentDecisions = await storage.getAiDecisions(userId, 10);
      const positions2 = await storage.getPositions(userId);
      res.json({
        isRunning: status.isRunning,
        killSwitchActive: status.killSwitchActive,
        lastRunTime: status.lastHeartbeat,
        // Use lastHeartbeat as lastRunTime
        consecutiveErrors: 0,
        // Not tracked in schema, default to 0
        activePositions: positions2.length,
        recentDecisions: recentDecisions.length,
        lastDecisionTime: recentDecisions[0]?.createdAt || null,
        config: {
          maxPositionSizePercent: status.maxPositionSizePercent,
          maxTotalExposurePercent: status.maxTotalExposurePercent,
          maxPositionsCount: status.maxPositionsCount,
          dailyLossLimitPercent: status.dailyLossLimitPercent,
          autoExecuteTrades: status.autoExecuteTrades,
          conservativeMode: status.conservativeMode
        }
      });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to get autonomous status", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get autonomous status" });
    }
  });
  app2.post("/api/autonomous/start", authMiddleware4, async (req, res) => {
    try {
      await orchestrator.start();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to start autonomous mode", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/stop", authMiddleware4, async (req, res) => {
    try {
      await orchestrator.stop();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to stop autonomous mode", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to stop autonomous mode" });
    }
  });
  app2.post("/api/autonomous/mode", authMiddleware4, async (req, res) => {
    try {
      const { mode } = req.body;
      if (!["autonomous", "semi-auto", "manual"].includes(mode)) {
        return res.status(400).json({
          error: "Invalid mode. Use: autonomous, semi-auto, or manual"
        });
      }
      await orchestrator.setMode(mode);
      res.json({ success: true, mode: orchestrator.getMode() });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to set mode", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to set mode" });
    }
  });
  app2.post("/api/autonomous/kill-switch", authMiddleware4, async (req, res) => {
    try {
      const { activate, reason } = req.body;
      if (activate) {
        await orchestrator.activateKillSwitch(reason || "Manual activation");
      } else {
        await orchestrator.deactivateKillSwitch();
      }
      const state = orchestrator.getState();
      res.json({
        success: true,
        killSwitchActive: orchestrator.getRiskLimits().killSwitchActive,
        state
      });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to toggle kill switch", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to toggle kill switch" });
    }
  });
  app2.put("/api/autonomous/risk-limits", authMiddleware4, async (req, res) => {
    try {
      const {
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      } = req.body;
      await orchestrator.updateRiskLimits({
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      });
      res.json({ success: true, riskLimits: orchestrator.getRiskLimits() });
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to update risk limits", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to update risk limits" });
    }
  });
  app2.get(
    "/api/autonomous/execution-history",
    authMiddleware4,
    async (req, res) => {
      try {
        const state = orchestrator.getState();
        res.json(state.executionHistory);
      } catch (error) {
        res.status(500).json({ error: "Failed to get execution history" });
      }
    }
  );
  app2.post(
    "/api/autonomous/close-position",
    authMiddleware4,
    async (req, res) => {
      try {
        const { symbol } = req.body;
        if (!symbol) {
          return res.status(400).json({ error: "Symbol is required" });
        }
        const result = await alpacaTradingEngine.closeAlpacaPosition(
          symbol,
          void 0,
          {
            authorizedByOrchestrator: true
          }
        );
        if (result.success) {
          res.json({
            success: true,
            message: `Position ${symbol} closed successfully`,
            result
          });
        } else {
          res.status(400).json({
            success: false,
            error: result.error || "Failed to close position"
          });
        }
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to close position", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.post(
    "/api/autonomous/close-all-positions",
    authMiddleware4,
    async (req, res) => {
      try {
        const result = await alpacaTradingEngine.closeAllPositions({
          authorizedByOrchestrator: true,
          isEmergencyStop: true
        });
        res.json({ success: true, ...result });
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to close all positions", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.get(
    "/api/autonomous/reconcile-positions",
    authMiddleware4,
    async (req, res) => {
      try {
        const result = await alpacaTradingEngine.reconcilePositions();
        res.json(result);
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to reconcile positions", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.post(
    "/api/autonomous/sync-positions",
    authMiddleware4,
    async (req, res) => {
      try {
        const userId = req.userId;
        const result = await alpacaTradingEngine.syncPositionsFromAlpaca(userId);
        res.json({ success: true, ...result });
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to sync positions", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.post(
    "/api/autonomous/execute-trades",
    authMiddleware4,
    async (req, res) => {
      try {
        const { decisionIds } = req.body;
        if (!decisionIds || !Array.isArray(decisionIds) || decisionIds.length === 0) {
          return res.status(400).json({ error: "Decision IDs array is required" });
        }
        const results = [];
        for (const decisionId of decisionIds) {
          const decisions = await storage.getAiDecisions(void 0, 100);
          const decision = decisions.find((d) => d.id === decisionId);
          if (!decision) {
            results.push({
              decisionId,
              success: false,
              error: "Decision not found"
            });
            continue;
          }
          try {
            const metadata = decision.metadata ? JSON.parse(decision.metadata) : {};
            const suggestedPct = metadata?.suggestedQuantity ? parseFloat(String(metadata.suggestedQuantity)) : 0.05;
            const account = await alpaca.getAccount();
            const buyingPower = parseFloat(account.buying_power);
            const price = parseFloat(decision.entryPrice || "0");
            if (!price) {
              results.push({
                decisionId,
                success: false,
                error: "No entry price available"
              });
              continue;
            }
            const tradeValue = buyingPower * Math.min(Math.max(suggestedPct, 0.01), 0.1);
            const quantity = Math.floor(tradeValue / price);
            if (quantity < 1) {
              results.push({
                decisionId,
                success: false,
                error: "Calculated quantity less than 1 share"
              });
              continue;
            }
            const orderResult = await alpacaTradingEngine.executeAlpacaTrade({
              symbol: decision.symbol,
              side: decision.action,
              quantity,
              authorizedByOrchestrator: true
            });
            if (orderResult.success) {
              results.push({
                decisionId,
                success: true,
                order: orderResult.order
              });
            } else {
              results.push({
                decisionId,
                success: false,
                error: orderResult.error
              });
            }
          } catch (err) {
            results.push({ decisionId, success: false, error: String(err) });
          }
        }
        const successCount = results.filter((r) => r.success).length;
        res.json({
          success: successCount > 0,
          message: `Executed ${successCount}/${decisionIds.length} trades`,
          results
        });
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to execute trades", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.get("/api/autonomous/open-orders", authMiddleware4, async (req, res) => {
    try {
      const orders2 = await alpacaTradingEngine.getOpenOrders();
      res.json(orders2);
    } catch (error) {
      log.error("AutonomousRoutes", "Failed to get open orders", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post(
    "/api/autonomous/cancel-stale-orders",
    authMiddleware4,
    async (req, res) => {
      try {
        const { maxAgeMinutes } = req.body;
        const result = await alpacaTradingEngine.cancelStaleOrders(
          maxAgeMinutes || 60
        );
        res.json({ success: true, ...result });
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to cancel stale orders", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.post(
    "/api/autonomous/cancel-all-orders",
    authMiddleware4,
    async (req, res) => {
      try {
        const result = await alpacaTradingEngine.cancelAllOpenOrders();
        res.json({ success: result.cancelled > 0, ...result });
      } catch (error) {
        log.error("AutonomousRoutes", "Failed to cancel all orders", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: String(error) });
      }
    }
  );
  app2.get("/api/orchestration/status", authMiddleware4, async (req, res) => {
    try {
      const status = coordinator.getStatus();
      const config2 = coordinator.getConfig();
      res.json({ status, config: config2 });
    } catch (error) {
      log.error("AutonomousRoutes", "Get orchestration status error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get orchestration status" });
    }
  });
  app2.post("/api/orchestration/start", authMiddleware4, async (req, res) => {
    try {
      await coordinator.start();
      res.json({ success: true, message: "Coordinator started" });
    } catch (error) {
      log.error("AutonomousRoutes", "Start coordinator error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to start coordinator" });
    }
  });
  app2.post("/api/orchestration/stop", authMiddleware4, async (req, res) => {
    try {
      await coordinator.stop();
      res.json({ success: true, message: "Coordinator stopped" });
    } catch (error) {
      log.error("AutonomousRoutes", "Stop coordinator error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to stop coordinator" });
    }
  });
  app2.put("/api/orchestration/config", authMiddleware4, async (req, res) => {
    try {
      const updates = req.body;
      coordinator.updateConfig(updates);
      res.json({ success: true, config: coordinator.getConfig() });
    } catch (error) {
      log.error("AutonomousRoutes", "Update orchestration config error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to update configuration" });
    }
  });
  app2.get("/api/orchestration/logs", authMiddleware4, async (req, res) => {
    try {
      const { level, category, limit: limit4 } = req.query;
      const logs = logger.getLogs({
        level,
        category,
        limit: limit4 ? parseInt(limit4) : 100
      });
      res.json({ logs, stats: logger.getStats() });
    } catch (error) {
      log.error("AutonomousRoutes", "Get logs error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get logs" });
    }
  });
  app2.get(
    "/api/orchestration/logs/errors",
    authMiddleware4,
    async (req, res) => {
      try {
        const { limit: limit4 } = req.query;
        const errors = logger.getErrorLogs(
          limit4 ? parseInt(limit4) : 50
        );
        res.json({ errors });
      } catch (error) {
        log.error("AutonomousRoutes", "Get error logs error", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: "Failed to get error logs" });
      }
    }
  );
  app2.get("/api/orchestration/events", authMiddleware4, async (req, res) => {
    try {
      const { type, source, limit: limit4 } = req.query;
      const events = eventBus.getEventHistory({
        type,
        source,
        limit: limit4 ? parseInt(limit4) : 50
      });
      res.json({ events, stats: eventBus.getStats() });
    } catch (error) {
      log.error("AutonomousRoutes", "Get events error", {
        error: error instanceof Error ? error.message : String(error)
      });
      res.status(500).json({ error: "Failed to get events" });
    }
  });
  app2.post(
    "/api/orchestration/reset-stats",
    authMiddleware4,
    async (req, res) => {
      try {
        coordinator.resetStats();
        res.json({ success: true, message: "Statistics reset" });
      } catch (error) {
        log.error("AutonomousRoutes", "Reset stats error", {
          error: error instanceof Error ? error.message : String(error)
        });
        res.status(500).json({ error: "Failed to reset statistics" });
      }
    }
  );
}

// server/routes/cache.ts
init_logger();
import { Router as Router20 } from "express";
init_persistentApiCache();
init_llmGateway();
var router18 = Router20();
router18.get("/llm/stats", requireAuth, async (req, res) => {
  try {
    const stats = getLLMCacheStats();
    res.json(stats);
  } catch (error) {
    log.error("CacheAPI", `Failed to get LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get cache stats" });
  }
});
router18.post("/llm/clear", requireAuth, async (req, res) => {
  try {
    clearLLMCache();
    res.json({ success: true, message: "LLM cache cleared" });
  } catch (error) {
    log.error("CacheAPI", `Failed to clear LLM cache: ${error}`);
    res.status(500).json({ error: "Failed to clear cache" });
  }
});
router18.post(
  "/llm/clear/:role",
  requireAuth,
  async (req, res) => {
    try {
      const { role } = req.params;
      if (!role) {
        return badRequest(res, "Role parameter is required");
      }
      clearLLMCacheForRole(role);
      res.json({ success: true, message: `Cache cleared for role: ${role}` });
    } catch (error) {
      log.error("CacheAPI", `Failed to clear LLM cache for role: ${error}`);
      res.status(500).json({ error: "Failed to clear cache for role" });
    }
  }
);
router18.post(
  "/llm/reset-stats",
  requireAuth,
  async (req, res) => {
    try {
      resetLLMCacheStats();
      res.json({ success: true, message: "Cache statistics reset" });
    } catch (error) {
      log.error("CacheAPI", `Failed to reset LLM cache stats: ${error}`);
      res.status(500).json({ error: "Failed to reset cache stats" });
    }
  }
);
router18.get("/api", requireAuth, async (req, res) => {
  try {
    const { provider } = req.query;
    const providerFilter = typeof provider === "string" ? provider : void 0;
    const stats = await getCacheStats(providerFilter);
    const entries = await getAllCacheEntries(providerFilter);
    res.json({ stats, entries });
  } catch (error) {
    log.error("CacheAPI", `Failed to get API cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get API cache stats" });
  }
});
router18.post("/api/purge", requireAuth, async (req, res) => {
  try {
    const { provider, key, expiredOnly } = req.body;
    if (!provider && !expiredOnly) {
      return badRequest(
        res,
        "Either 'provider' or 'expiredOnly' must be specified"
      );
    }
    let purgedCount = 0;
    let message = "";
    if (provider && key) {
      purgedCount = await invalidateCache(provider, key);
      message = `Invalidated cache for ${provider}:${key}`;
    } else if (provider && !expiredOnly) {
      purgedCount = await invalidateCache(provider);
      message = `Invalidated all cache entries for ${provider}`;
    } else {
      purgedCount = await purgeExpiredCache();
      message = provider ? `Purged expired cache entries (provider filter not supported for expired purge)` : "Purged all expired cache entries";
    }
    res.json({ success: true, purgedCount, message });
  } catch (error) {
    log.error("CacheAPI", `Failed to purge API cache: ${error}`);
    res.status(500).json({ error: "Failed to purge API cache" });
  }
});
var cache_default = router18;

// server/routes/llm.ts
init_logger();
import { Router as Router21 } from "express";

// server/ai/roleBasedRouter.ts
init_logger();
init_openaiClient();
init_groqClient();
init_togetherClient();
init_aimlClient();
init_openrouterClient();
init_db();
init_schema2();
import { eq as eq24, desc as desc17 } from "drizzle-orm";
var PROVIDER_CLIENTS2 = {
  openai: {
    client: openaiClient,
    isAvailable: () => openaiClient.isAvailable()
  },
  groq: { client: groqClient, isAvailable: () => groqClient.isAvailable() },
  together: {
    client: togetherClient,
    isAvailable: () => togetherClient.isAvailable()
  },
  aimlapi: { client: aimlClient, isAvailable: () => aimlClient.isAvailable() },
  openrouter: {
    client: openrouterClient,
    isAvailable: () => openrouterClient.isAvailable()
  }
};
var DEFAULT_ROLE_CONFIGS = {
  market_news_summarizer: {
    role: "market_news_summarizer",
    description: "Cheap + fast model for summarizing market news",
    fallbackChain: [
      {
        provider: "groq",
        model: "llama-3.1-8b-instant",
        costPer1kTokens: 5e-5
      },
      {
        provider: "together",
        model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
        costPer1kTokens: 1e-4
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 500,
    temperature: 0.3
  },
  technical_analyst: {
    role: "technical_analyst",
    description: "Strong reasoning model for technical analysis",
    fallbackChain: [
      {
        provider: "openrouter",
        model: "deepseek/deepseek-r1",
        costPer1kTokens: 55e-5
      },
      {
        provider: "groq",
        model: "llama-3.3-70b-versatile",
        costPer1kTokens: 59e-5
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 2e3,
    temperature: 0.2
  },
  risk_manager: {
    role: "risk_manager",
    description: "Conservative, instruction-following model for risk assessment",
    fallbackChain: [
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
      {
        provider: "openrouter",
        model: "anthropic/claude-3.5-sonnet",
        costPer1kTokens: 3e-3
      },
      {
        provider: "openrouter",
        model: "google/gemini-pro-1.5",
        costPer1kTokens: 125e-5
      }
    ],
    maxTokens: 1500,
    temperature: 0.1,
    enableCitations: true
  },
  execution_planner: {
    role: "execution_planner",
    description: "Deterministic, tool-use friendly model for trade execution",
    fallbackChain: [
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
      {
        provider: "groq",
        model: "llama-3.1-70b-versatile",
        costPer1kTokens: 59e-5
      },
      {
        provider: "together",
        model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
        costPer1kTokens: 1e-4
      }
    ],
    maxTokens: 1e3,
    temperature: 0
  },
  post_trade_reporter: {
    role: "post_trade_reporter",
    description: "Cheap summarizer for post-trade reports",
    fallbackChain: [
      {
        provider: "groq",
        model: "llama-3.1-8b-instant",
        costPer1kTokens: 5e-5
      },
      {
        provider: "together",
        model: "meta-llama/Llama-3.2-3B-Instruct-Turbo",
        costPer1kTokens: 1e-4
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 800,
    temperature: 0.4
  },
  // New roles added for enhanced trading capabilities
  position_sizer: {
    role: "position_sizer",
    description: "Optimal position sizing based on risk and market conditions",
    fallbackChain: [
      {
        provider: "openrouter",
        model: "anthropic/claude-3.5-sonnet",
        costPer1kTokens: 3e-3
      },
      {
        provider: "openrouter",
        model: "deepseek/deepseek-r1",
        costPer1kTokens: 55e-5
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 1500,
    temperature: 0.2
  },
  sentiment_analyst: {
    role: "sentiment_analyst",
    description: "Dedicated sentiment analysis from news and social sources",
    fallbackChain: [
      {
        provider: "groq",
        model: "llama-3.3-70b-versatile",
        costPer1kTokens: 59e-5
      },
      {
        provider: "openrouter",
        model: "deepseek/deepseek-r1",
        costPer1kTokens: 55e-5
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 1200,
    temperature: 0.3
  },
  post_trade_analyzer: {
    role: "post_trade_analyzer",
    description: "Detailed trade performance analysis and learning",
    fallbackChain: [
      {
        provider: "openrouter",
        model: "deepseek/deepseek-r1",
        costPer1kTokens: 55e-5
      },
      {
        provider: "groq",
        model: "llama-3.3-70b-versatile",
        costPer1kTokens: 59e-5
      },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 2e3,
    temperature: 0.3
  },
  futures_analyst: {
    role: "futures_analyst",
    description: "Specialized futures market analysis and recommendations",
    fallbackChain: [
      {
        provider: "openrouter",
        model: "anthropic/claude-3.5-sonnet",
        costPer1kTokens: 3e-3
      },
      {
        provider: "openrouter",
        model: "deepseek/deepseek-r1",
        costPer1kTokens: 55e-5
      },
      {
        provider: "groq",
        model: "llama-3.3-70b-versatile",
        costPer1kTokens: 59e-5
      }
    ],
    maxTokens: 2500,
    temperature: 0.2
  }
};
function estimateCost2(tokens, costPer1kTokens) {
  return tokens / 1e3 * costPer1kTokens;
}
function parseFallbackChain(chainJson) {
  try {
    return JSON.parse(chainJson);
  } catch {
    return [];
  }
}
async function getRoleConfig(role) {
  try {
    const [dbConfig] = await db.select().from(llmRoleConfigs).where(eq24(llmRoleConfigs.role, role)).limit(1);
    if (dbConfig && dbConfig.isActive) {
      return {
        role,
        description: dbConfig.description || DEFAULT_ROLE_CONFIGS[role].description,
        fallbackChain: parseFallbackChain(dbConfig.fallbackChain),
        maxTokens: dbConfig.maxTokens || DEFAULT_ROLE_CONFIGS[role].maxTokens,
        temperature: parseFloat(dbConfig.temperature || "0.3"),
        enableCitations: dbConfig.enableCitations
      };
    }
  } catch (error) {
    log.warn(
      "RoleBasedRouter",
      `Failed to load config for ${role}, using defaults`,
      { error: String(error) }
    );
  }
  return DEFAULT_ROLE_CONFIGS[role];
}
async function logCall2(callData) {
  try {
    await db.insert(llmCalls).values(callData);
  } catch (error) {
    log.warn("RoleBasedRouter", "Failed to log LLM call", {
      error: String(error)
    });
  }
}
async function roleBasedLLMCall(req) {
  const startTime = Date.now();
  const config2 = await getRoleConfig(req.role);
  let fallbackUsed = false;
  let fallbackReason;
  let lastError;
  for (let i = 0; i < config2.fallbackChain.length; i++) {
    const modelConfig = config2.fallbackChain[i];
    const providerEntry = PROVIDER_CLIENTS2[modelConfig.provider];
    if (!providerEntry || !providerEntry.isAvailable()) {
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = `Primary provider ${modelConfig.provider} not available`;
      }
      continue;
    }
    try {
      const llmRequest = {
        ...req,
        model: modelConfig.model,
        maxTokens: req.maxTokens || config2.maxTokens,
        temperature: req.temperature ?? config2.temperature
      };
      if (config2.enableCitations && llmRequest.system) {
        llmRequest.system = `${llmRequest.system}

IMPORTANT: Always cite your sources. Reference internal data (market data, news feeds, analysis) rather than external knowledge. Format citations as [Source: X].`;
      }
      const response = await providerEntry.client.call(llmRequest);
      const latencyMs2 = Date.now() - startTime;
      const totalTokens = response.tokensUsed?.total || 0;
      const estimatedCost = estimateCost2(
        totalTokens,
        modelConfig.costPer1kTokens || 1e-4
      );
      await logCall2({
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        promptTokens: response.tokensUsed?.prompt || null,
        completionTokens: response.tokensUsed?.completion || null,
        totalTokens: totalTokens || null,
        estimatedCost: estimatedCost.toFixed(6),
        latencyMs: latencyMs2,
        status: "success",
        systemPrompt: req.system || null,
        userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
        response: response.content?.slice(0, 2e3) || null,
        cacheHit: false,
        fallbackUsed,
        fallbackReason: fallbackReason || null
      });
      log.ai(`RoleBasedRouter: ${req.role} succeeded`, {
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed: totalTokens,
        estimatedCost,
        latencyMs: latencyMs2,
        fallbackUsed
      });
      return {
        ...response,
        role: req.role,
        provider: modelConfig.provider,
        estimatedCost,
        fallbackUsed,
        fallbackReason
      };
    } catch (error) {
      lastError = error;
      const llmError = error;
      log.warn(
        "RoleBasedRouter",
        `${modelConfig.provider}/${modelConfig.model} failed for ${req.role}`,
        {
          isRateLimit: llmError?.isRateLimit,
          isAuthError: llmError?.isAuthError,
          error: String(error)
        }
      );
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = llmError?.isRateLimit ? "Rate limit exceeded" : llmError?.isAuthError ? "Auth error" : "Provider error";
      }
      if (llmError?.isRateLimit) {
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
  }
  const latencyMs = Date.now() - startTime;
  await logCall2({
    role: req.role,
    provider: "none",
    model: "none",
    status: "error",
    errorMessage: String(lastError),
    latencyMs,
    systemPrompt: req.system || null,
    userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
    fallbackUsed: true,
    fallbackReason: "All providers failed"
  });
  log.error("RoleBasedRouter", `All providers failed for ${req.role}`, {
    role: req.role,
    triedProviders: config2.fallbackChain.map((c) => c.provider),
    lastError: String(lastError)
  });
  throw lastError || new Error(`All LLM providers failed for role: ${req.role}`);
}
async function getAllRoleConfigs() {
  const configs = [];
  for (const role of Object.keys(DEFAULT_ROLE_CONFIGS)) {
    const config2 = await getRoleConfig(role);
    configs.push(config2);
  }
  return configs;
}
async function updateRoleConfig(role, updates) {
  const fallbackChainJson = updates.fallbackChain ? JSON.stringify(updates.fallbackChain) : JSON.stringify(DEFAULT_ROLE_CONFIGS[role].fallbackChain);
  const existing = await db.select().from(llmRoleConfigs).where(eq24(llmRoleConfigs.role, role)).limit(1);
  if (existing.length > 0) {
    const [updated] = await db.update(llmRoleConfigs).set({
      description: updates.description,
      fallbackChain: fallbackChainJson,
      maxTokens: updates.maxTokens,
      temperature: updates.temperature?.toString(),
      enableCitations: updates.enableCitations,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq24(llmRoleConfigs.role, role)).returning();
    return updated;
  }
  const [inserted] = await db.insert(llmRoleConfigs).values({
    role,
    description: updates.description || DEFAULT_ROLE_CONFIGS[role].description,
    fallbackChain: fallbackChainJson,
    maxTokens: updates.maxTokens || DEFAULT_ROLE_CONFIGS[role].maxTokens,
    temperature: (updates.temperature ?? DEFAULT_ROLE_CONFIGS[role].temperature)?.toString(),
    enableCitations: updates.enableCitations ?? DEFAULT_ROLE_CONFIGS[role].enableCitations ?? false,
    isActive: true
  }).returning();
  return inserted;
}
async function getRecentCalls(limit4 = 20, role) {
  if (role) {
    return db.select().from(llmCalls).where(eq24(llmCalls.role, role)).orderBy(desc17(llmCalls.createdAt)).limit(limit4);
  }
  return db.select().from(llmCalls).orderBy(desc17(llmCalls.createdAt)).limit(limit4);
}
async function getCallStats() {
  const calls = await db.select().from(llmCalls).orderBy(desc17(llmCalls.createdAt)).limit(1e3);
  const stats = {
    total: calls.length,
    byRole: {},
    byProvider: {},
    totalCost: 0
  };
  for (const call of calls) {
    const cost = parseFloat(call.estimatedCost || "0");
    stats.totalCost += cost;
    if (!stats.byRole[call.role]) {
      stats.byRole[call.role] = { count: 0, totalCost: 0, avgLatency: 0 };
    }
    stats.byRole[call.role].count++;
    stats.byRole[call.role].totalCost += cost;
    stats.byRole[call.role].avgLatency += call.latencyMs || 0;
    if (!stats.byProvider[call.provider]) {
      stats.byProvider[call.provider] = {
        count: 0,
        totalCost: 0,
        successRate: 0
      };
    }
    stats.byProvider[call.provider].count++;
    stats.byProvider[call.provider].totalCost += cost;
    if (call.status === "success") {
      stats.byProvider[call.provider].successRate++;
    }
  }
  for (const role of Object.keys(stats.byRole)) {
    stats.byRole[role].avgLatency /= stats.byRole[role].count;
  }
  for (const provider of Object.keys(stats.byProvider)) {
    stats.byProvider[provider].successRate = stats.byProvider[provider].successRate / stats.byProvider[provider].count * 100;
  }
  return stats;
}
var roleBasedRouter = {
  call: roleBasedLLMCall,
  getAllConfigs: getAllRoleConfigs,
  updateConfig: updateRoleConfig,
  getRecentCalls,
  getCallStats,
  getAvailableProviders: () => {
    return Object.entries(PROVIDER_CLIENTS2).filter(([_, v]) => v.isAvailable()).map(([name]) => name);
  }
};

// server/routes/llm.ts
var router19 = Router21();
router19.get("/configs", requireAuth, async (req, res) => {
  try {
    const configs = await getAllRoleConfigs();
    const availableProviders = roleBasedRouter.getAvailableProviders();
    res.json({ configs, availableProviders });
  } catch (error) {
    log.error("LLMAPI", `Failed to get role configs: ${error}`);
    res.status(500).json({ error: "Failed to get role configurations" });
  }
});
router19.put(
  "/configs/:role",
  requireAuth,
  async (req, res) => {
    try {
      const { role } = req.params;
      const validRoles = [
        "market_news_summarizer",
        "technical_analyst",
        "risk_manager",
        "execution_planner",
        "post_trade_reporter"
      ];
      if (!validRoles.includes(role)) {
        return badRequest(
          res,
          `Invalid role. Must be one of: ${validRoles.join(", ")}`
        );
      }
      const updates = req.body;
      const updated = await updateRoleConfig(role, updates);
      res.json({ success: true, config: updated });
    } catch (error) {
      log.error("LLMAPI", `Failed to update role config: ${error}`);
      res.status(500).json({ error: "Failed to update role configuration" });
    }
  }
);
router19.get("/calls", requireAuth, async (req, res) => {
  try {
    const { role, limit: limit4 } = req.query;
    const limitNum = parseInt(limit4) || 20;
    const roleFilter = typeof role === "string" ? role : void 0;
    const calls = await getRecentCalls(limitNum, roleFilter);
    res.json({ calls, count: calls.length });
  } catch (error) {
    log.error("LLMAPI", `Failed to get recent LLM calls: ${error}`);
    res.status(500).json({ error: "Failed to get recent LLM calls" });
  }
});
router19.get("/stats", requireAuth, async (req, res) => {
  try {
    const stats = await getCallStats();
    res.json(stats);
  } catch (error) {
    log.error("LLMAPI", `Failed to get LLM call stats: ${error}`);
    res.status(500).json({ error: "Failed to get LLM call statistics" });
  }
});
var llm_default = router19;

// server/routes/admin/index.ts
import { Router as Router27 } from "express";

// server/routes/admin/api.ts
init_apiBudget();
init_persistentApiCache();
init_apiPolicy();
init_data_fusion_engine2();
init_logger();
import { Router as Router22 } from "express";
var router20 = Router22();
router20.get("/api-usage", requireAdmin, async (req, res) => {
  try {
    const { provider } = req.query;
    if (provider && typeof provider === "string") {
      const stats = await getUsageStats(provider);
      const policy = getProviderPolicy(provider);
      res.json({ provider, stats, policy });
    } else {
      const allStats = await getAllUsageStats();
      const policies = getAllProviderPolicies();
      res.json({ usage: allStats, policies });
    }
  } catch (error) {
    log.error("AdminAPI", "Failed to get API usage stats", { error });
    res.status(500).json({ error: "Failed to get API usage stats" });
  }
});
router20.get("/api-cache", requireAdmin, async (req, res) => {
  try {
    const { provider } = req.query;
    const providerFilter = typeof provider === "string" ? provider : void 0;
    const stats = await getCacheStats(providerFilter);
    const entries = await getAllCacheEntries(providerFilter);
    res.json({ stats, entries });
  } catch (error) {
    log.error("AdminAPI", "Failed to get API cache stats", { error });
    res.status(500).json({ error: "Failed to get API cache stats" });
  }
});
router20.post(
  "/api-cache/purge",
  requireAdmin,
  async (req, res) => {
    try {
      const { provider, key, expiredOnly } = req.body;
      let purgedCount = 0;
      let message = "";
      if (provider && key) {
        purgedCount = await invalidateCache(provider, key);
        message = `Invalidated cache for ${provider}:${key}`;
      } else if (provider && !expiredOnly) {
        purgedCount = await invalidateCache(provider);
        message = `Invalidated all cache entries for ${provider}`;
      } else {
        purgedCount = await purgeExpiredCache();
        message = provider ? `Purged expired cache entries (provider filter not supported for expired purge)` : "Purged all expired cache entries";
      }
      res.json({ success: true, purgedCount, message });
    } catch (error) {
      log.error("AdminAPI", "Failed to purge API cache", { error });
      res.status(500).json({ error: "Failed to purge API cache" });
    }
  }
);
router20.get(
  "/provider-status",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const statuses = await getAllProviderStatuses2();
      res.json({ providers: statuses });
    } catch (error) {
      log.error("AdminAPI", "Failed to get provider statuses", { error });
      res.status(500).json({ error: "Failed to get provider statuses" });
    }
  }
);
router20.post(
  "/provider/:provider/force-refresh",
  async (req, res) => {
    try {
      const { provider } = req.params;
      const { cacheKey, confirmValyu } = req.body;
      if (provider.toLowerCase() === "valyu" && !confirmValyu) {
        return res.status(400).json({
          error: "Valyu force refresh requires explicit confirmation",
          message: "Set confirmValyu: true to force refresh Valyu data (1 call/week limit)"
        });
      }
      if (cacheKey) {
        await invalidateCache(provider, cacheKey);
        res.json({
          success: true,
          message: `Cache invalidated for ${provider}:${cacheKey}. Next request will fetch fresh data.`
        });
      } else {
        await invalidateCache(provider);
        res.json({
          success: true,
          message: `All cache entries invalidated for ${provider}. Next requests will fetch fresh data.`
        });
      }
    } catch (error) {
      log.error("AdminAPI", "Failed to force refresh provider", { error });
      res.status(500).json({ error: "Failed to force refresh provider" });
    }
  }
);
router20.patch(
  "/provider/:provider/toggle",
  async (req, res) => {
    try {
      const { provider } = req.params;
      const { enabled } = req.body;
      if (enabled === true) {
        enableProvider(provider);
      } else if (enabled === false) {
        disableProvider(provider);
      } else {
        return res.status(400).json({ error: "enabled must be true or false" });
      }
      const policy = getProviderPolicy(provider);
      res.json({
        success: true,
        provider,
        enabled: policy.enabled,
        message: `Provider ${provider} is now ${policy.enabled ? "enabled" : "disabled"}`
      });
    } catch (error) {
      log.error("AdminAPI", "Failed to toggle provider", { error });
      res.status(500).json({ error: "Failed to toggle provider" });
    }
  }
);
router20.get(
  "/valyu-budget",
  requireAdmin,
  async (req, res) => {
    try {
      const { getValyuBudgetStatus: getValyuBudgetStatus2, getValyuBudgetConfig: getValyuBudgetConfig2 } = await Promise.resolve().then(() => (init_valyuBudget(), valyuBudget_exports));
      const statuses = await getValyuBudgetStatus2();
      const config2 = getValyuBudgetConfig2();
      res.json({ statuses, config: config2 });
    } catch (error) {
      log.error("AdminAPI", "Failed to get Valyu budget status", { error });
      res.status(500).json({ error: "Failed to get Valyu budget status" });
    }
  }
);
router20.put(
  "/valyu-budget",
  requireAdmin,
  async (req, res) => {
    try {
      const { updateValyuBudgetConfig: updateValyuBudgetConfig2, getValyuBudgetConfig: getValyuBudgetConfig2 } = await Promise.resolve().then(() => (init_valyuBudget(), valyuBudget_exports));
      const {
        webRetrievalsPerMonth,
        financeRetrievalsPerMonth,
        proprietaryRetrievalsPerMonth
      } = req.body;
      const updates = {};
      if (webRetrievalsPerMonth !== void 0)
        updates.webRetrievalsPerMonth = webRetrievalsPerMonth;
      if (financeRetrievalsPerMonth !== void 0)
        updates.financeRetrievalsPerMonth = financeRetrievalsPerMonth;
      if (proprietaryRetrievalsPerMonth !== void 0)
        updates.proprietaryRetrievalsPerMonth = proprietaryRetrievalsPerMonth;
      updateValyuBudgetConfig2(updates);
      const config2 = getValyuBudgetConfig2();
      res.json({
        success: true,
        config: config2,
        message: "Valyu budget limits updated"
      });
    } catch (error) {
      log.error("AdminAPI", "Failed to update Valyu budget", { error });
      res.status(500).json({ error: "Failed to update Valyu budget" });
    }
  }
);
router20.get(
  "/connectors-health",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const providerStatuses = await getAllProviderStatuses2();
      const connectors = [
        {
          name: "Alpaca Paper",
          provider: "alpaca",
          type: "brokerage",
          hasApiKey: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY),
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "Finnhub",
          provider: "finnhub",
          type: "market_data",
          hasApiKey: !!process.env.FINNHUB_API_KEY,
          status: providerStatuses.finnhub?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "CoinGecko",
          provider: "coingecko",
          type: "crypto",
          hasApiKey: true,
          status: providerStatuses.coingecko?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "CoinMarketCap",
          provider: "coinmarketcap",
          type: "crypto",
          hasApiKey: !!process.env.COINMARKETCAP_API_KEY,
          status: providerStatuses.coinmarketcap?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "NewsAPI",
          provider: "newsapi",
          type: "news",
          hasApiKey: !!process.env.NEWS_API_KEY,
          status: providerStatuses.newsapi?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "GDELT",
          provider: "gdelt",
          type: "news",
          hasApiKey: true,
          status: providerStatuses.gdelt?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "Valyu",
          provider: "valyu",
          type: "research",
          hasApiKey: !!process.env.VALYU_API_KEY,
          status: providerStatuses.valyu?.enabled ? "active" : "disabled",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        }
      ];
      try {
        const { alpaca: alpaca2 } = await Promise.resolve().then(() => (init_alpaca(), alpaca_exports));
        const account = await alpaca2.getAccount();
        connectors[0].status = account.status === "ACTIVE" ? "active" : "error";
        connectors[0].healthDetails = { overall: account.status, account };
      } catch {
        connectors[0].status = "error";
      }
      res.json({
        connectors,
        summary: {
          total: connectors.length,
          active: connectors.filter((c) => c.status === "active").length,
          error: connectors.filter((c) => c.status === "error").length,
          disabled: connectors.filter((c) => c.status === "disabled").length
        }
      });
    } catch (error) {
      log.error("AdminAPI", "Failed to get connector health", { error });
      res.status(500).json({ error: "Failed to get connector health" });
    }
  }
);
router20.get(
  "/api-keys-status",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAllAvailableProviders: getAllAvailableProviders2 } = await Promise.resolve().then(() => (init_ai(), ai_exports));
      const aiProviders = getAllAvailableProviders2();
      const providerPolicies2 = getAllProviderPolicies();
      const getPolicyEnabled = (provider) => {
        const policy = providerPolicies2.find(
          (p) => p.provider.toLowerCase() === provider.toLowerCase()
        );
        return policy?.enabled ?? true;
      };
      const apiKeys = [
        {
          name: "Alpaca API",
          key: "ALPACA_API_KEY",
          category: "brokerage",
          configured: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY),
          enabled: getPolicyEnabled("alpaca")
        },
        {
          name: "Finnhub API",
          key: "FINNHUB_API_KEY",
          category: "market_data",
          configured: !!process.env.FINNHUB_API_KEY,
          enabled: getPolicyEnabled("finnhub")
        },
        {
          name: "CoinGecko API",
          key: "COINGECKO_API_KEY",
          category: "crypto",
          configured: true,
          enabled: getPolicyEnabled("coingecko")
        },
        {
          name: "CoinMarketCap API",
          key: "COINMARKETCAP_API_KEY",
          category: "crypto",
          configured: !!process.env.COINMARKETCAP_API_KEY,
          enabled: getPolicyEnabled("coinmarketcap")
        },
        {
          name: "NewsAPI",
          key: "NEWS_API_KEY",
          category: "news",
          configured: !!process.env.NEWS_API_KEY,
          enabled: getPolicyEnabled("newsapi")
        },
        {
          name: "GDELT News",
          key: "GDELT",
          category: "news",
          configured: true,
          enabled: getPolicyEnabled("gdelt")
        },
        {
          name: "Valyu API",
          key: "VALYU_API_KEY",
          category: "data",
          configured: !!process.env.VALYU_API_KEY,
          enabled: getPolicyEnabled("valyu")
        },
        {
          name: "Hugging Face API",
          key: "HUGGINGFACE_API_KEY",
          category: "ai",
          configured: !!process.env.HUGGINGFACE_API_KEY,
          enabled: getPolicyEnabled("huggingface")
        },
        {
          name: "OpenAI API",
          key: "OPENAI_API_KEY",
          category: "ai",
          configured: aiProviders.includes("openai"),
          enabled: getPolicyEnabled("openai")
        },
        {
          name: "Groq API",
          key: "GROQ_API_KEY",
          category: "ai",
          configured: aiProviders.includes("groq"),
          enabled: getPolicyEnabled("groq")
        },
        {
          name: "Together API",
          key: "TOGETHER_API_KEY",
          category: "ai",
          configured: aiProviders.includes("together"),
          enabled: getPolicyEnabled("together")
        },
        {
          name: "AIML API",
          key: "AIMLAPI_KEY",
          category: "ai",
          configured: aiProviders.includes("aimlapi"),
          enabled: true
        },
        {
          name: "OpenRouter API",
          key: "OPENROUTER_API_KEY",
          category: "ai",
          configured: !!process.env.OPENROUTER_API_KEY,
          enabled: true
        }
      ];
      const summary = {
        total: apiKeys.length,
        configured: apiKeys.filter((k) => k.configured).length,
        missing: apiKeys.filter((k) => !k.configured).length,
        enabled: apiKeys.filter((k) => k.enabled).length,
        byCategory: {
          brokerage: apiKeys.filter((k) => k.category === "brokerage"),
          market_data: apiKeys.filter((k) => k.category === "market_data"),
          crypto: apiKeys.filter((k) => k.category === "crypto"),
          news: apiKeys.filter((k) => k.category === "news"),
          data: apiKeys.filter((k) => k.category === "data"),
          ai: apiKeys.filter((k) => k.category === "ai")
        }
      };
      res.json({ apiKeys, summary });
    } catch (error) {
      log.error("AdminAPI", "Failed to get API keys status", { error });
      res.status(500).json({ error: "Failed to get API keys status" });
    }
  }
);
router20.get(
  "/data-fusion-status",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const providerStatuses = await getAllProviderStatuses2();
      const fusionEngineStatus = dataFusionEngine.getStatus();
      let marketIntelligence = null;
      try {
        marketIntelligence = await dataFusionEngine.getMarketIntelligence();
      } catch (err) {
        log.error("AdminAPI", "Failed to get market intelligence", {
          error: err
        });
      }
      const dataSources = [
        {
          name: "Market Prices",
          provider: "finnhub",
          active: !!process.env.FINNHUB_API_KEY && providerStatuses.finnhub?.enabled,
          category: "market_data"
        },
        {
          name: "Crypto Prices",
          provider: "coingecko",
          active: providerStatuses.coingecko?.enabled,
          category: "market_data"
        },
        {
          name: "Trade Execution",
          provider: "alpaca",
          active: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY) && providerStatuses.alpaca?.enabled,
          category: "brokerage"
        },
        {
          name: "SEC Filings (EDGAR)",
          provider: "sec-edgar",
          active: true,
          category: "fundamentals"
        },
        {
          name: "Financial Data",
          provider: "valyu",
          active: !!process.env.VALYU_API_KEY && providerStatuses.valyu?.enabled,
          category: "fundamentals"
        },
        {
          name: "Macro Indicators (FRED)",
          provider: "fred",
          active: !!process.env.FRED_API_KEY,
          category: "macro"
        },
        {
          name: "Short Interest (FINRA)",
          provider: "finra",
          active: true,
          category: "short_interest"
        },
        {
          name: "Forex Rates (ECB)",
          provider: "frankfurter",
          active: true,
          category: "forex"
        },
        {
          name: "News Feed",
          provider: "gdelt",
          active: providerStatuses.gdelt?.enabled,
          category: "news"
        },
        {
          name: "News Headlines",
          provider: "newsapi",
          active: !!process.env.NEWS_API_KEY && providerStatuses.newsapi?.enabled,
          category: "news"
        },
        {
          name: "Sentiment Analysis",
          provider: "huggingface",
          active: !!process.env.HUGGINGFACE_API_KEY && providerStatuses.huggingface?.enabled,
          category: "sentiment"
        }
      ];
      const activeSourcesCount = marketIntelligence?.activeSources ?? dataSources.filter((s) => s.active).length;
      const totalSources = marketIntelligence?.totalSources ?? dataSources.length;
      const intelligenceScore = marketIntelligence?.overall ?? activeSourcesCount / totalSources;
      const fusionMetrics = {
        intelligenceScore,
        activeSources: activeSourcesCount,
        totalSources,
        dataSources,
        dataQuality: marketIntelligence?.dataQuality ?? "unknown",
        components: marketIntelligence?.components ?? null,
        signals: marketIntelligence?.signals ?? [],
        embeddingsCount: fusionEngineStatus.cacheSize,
        lastFusionRun: fusionEngineStatus.lastFusionTime ? new Date(fusionEngineStatus.lastFusionTime).toISOString() : null,
        capabilities: {
          marketData: dataSources.some((s) => s.provider === "finnhub" && s.active) || dataSources.some((s) => s.provider === "coingecko" && s.active),
          newsAnalysis: dataSources.some(
            (s) => (s.provider === "gdelt" || s.provider === "newsapi") && s.active
          ),
          sentimentAnalysis: dataSources.some(
            (s) => s.provider === "huggingface" && s.active
          ),
          tradingCapability: dataSources.some(
            (s) => s.provider === "alpaca" && s.active
          ),
          fundamentals: dataSources.some(
            (s) => (s.provider === "sec-edgar" || s.provider === "valyu") && s.active
          ),
          shortInterest: dataSources.some(
            (s) => s.provider === "finra" && s.active
          ),
          macroAnalysis: dataSources.some(
            (s) => s.provider === "fred" && s.active
          ),
          forexData: dataSources.some(
            (s) => s.provider === "frankfurter" && s.active
          )
        }
      };
      res.json(fusionMetrics);
    } catch (error) {
      log.error("AdminAPI", "Failed to get data fusion status", { error });
      res.status(500).json({ error: "Failed to get data fusion status" });
    }
  }
);
router20.get(
  "/alpaca-account",
  requireAdmin,
  async (req, res) => {
    try {
      const { alpaca: alpaca2 } = await Promise.resolve().then(() => (init_alpaca(), alpaca_exports));
      const { tradingConfig: tradingConfig2 } = await Promise.resolve().then(() => (init_trading_config(), trading_config_exports));
      const fs2 = await import("fs");
      const path2 = await import("path");
      const envApiKey = process.env.ALPACA_API_KEY;
      const maskedEnvKey = envApiKey ? `${envApiKey.substring(0, 6)}...${envApiKey.substring(envApiKey.length - 4)}` : "NOT SET";
      let envFileKey = null;
      try {
        const envPath = path2.resolve(process.cwd(), ".env");
        const envContent = fs2.readFileSync(envPath, "utf-8");
        const match = envContent.match(/ALPACA_API_KEY=(.+)/);
        if (match) {
          envFileKey = match[1].trim();
        }
      } catch {
      }
      const maskedEnvFileKey = envFileKey ? `${envFileKey.substring(0, 6)}...${envFileKey.substring(envFileKey.length - 4)}` : "NOT FOUND";
      const hasMismatch = envFileKey && envApiKey && envFileKey !== envApiKey;
      let accountInfo = null;
      let connectionStatus = "unknown";
      try {
        const account = await alpaca2.getAccount();
        accountInfo = {
          id: account.id,
          status: account.status,
          buying_power: parseFloat(account.buying_power).toFixed(2),
          portfolio_value: parseFloat(account.portfolio_value).toFixed(2),
          equity: parseFloat(account.equity).toFixed(2),
          cash: parseFloat(account.cash).toFixed(2)
        };
        connectionStatus = "connected";
      } catch (error) {
        connectionStatus = "error";
        log.error("AdminAPI", "Failed to connect to Alpaca", { error });
      }
      res.json({
        configuration: {
          tradingMode: tradingConfig2.alpaca.tradingMode,
          baseUrl: tradingConfig2.alpaca.tradingMode === "live" ? tradingConfig2.alpaca.liveUrl : tradingConfig2.alpaca.paperUrl
        },
        credentials: {
          runningEnvKey: maskedEnvKey,
          envFileKey: maskedEnvFileKey,
          hasMismatch,
          mismatchWarning: hasMismatch ? "WARNING: Running environment uses different credentials than .env file. This may indicate Replit Secrets are overriding .env values." : null
        },
        account: accountInfo,
        connectionStatus
      });
    } catch (error) {
      log.error("AdminAPI", "Failed to verify Alpaca account", { error });
      res.status(500).json({ error: "Failed to verify Alpaca account" });
    }
  }
);
var api_default = router20;

// server/routes/admin/ai.ts
init_storage();
import { Router as Router23 } from "express";
init_logger();
var VALID_ROLES = [
  "market_news_summarizer",
  "technical_analyst",
  "risk_manager",
  "execution_planner",
  "post_trade_reporter"
];
function isValidRole(role) {
  return VALID_ROLES.includes(role);
}
function isValidWorkItemStatus(status) {
  return ["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "DEAD_LETTER"].includes(
    status
  );
}
var router21 = Router23();
router21.get("/ai-config", requireAdmin, async (req, res) => {
  try {
    const agentStatus2 = await storage.getAgentStatus();
    res.json({
      autoExecuteTrades: agentStatus2?.autoExecuteTrades ?? false,
      conservativeMode: agentStatus2?.conservativeMode ?? false
    });
  } catch (error) {
    log.error("AdminAI", "Failed to get AI config", { error });
    res.status(500).json({ error: "Failed to get AI config" });
  }
});
router21.put("/ai-config", requireAdmin, async (req, res) => {
  try {
    const { autoExecuteTrades, conservativeMode } = req.body;
    const updates = {};
    if (typeof autoExecuteTrades === "boolean")
      updates.autoExecuteTrades = autoExecuteTrades;
    if (typeof conservativeMode === "boolean")
      updates.conservativeMode = conservativeMode;
    await storage.updateAgentStatus(updates);
    const status = await storage.getAgentStatus();
    res.json({
      autoExecuteTrades: status?.autoExecuteTrades ?? false,
      conservativeMode: status?.conservativeMode ?? false
    });
  } catch (error) {
    log.error("AdminAI", "Failed to update AI config", { error });
    res.status(500).json({ error: "Failed to update AI config" });
  }
});
router21.get(
  "/model-router/configs",
  requireAdmin,
  async (req, res) => {
    try {
      const configs = await getAllRoleConfigs();
      const availableProviders = roleBasedRouter.getAvailableProviders();
      res.json({ configs, availableProviders });
    } catch (error) {
      log.error("AdminAI", "Failed to get role configs", { error });
      res.status(500).json({ error: "Failed to get role configurations" });
    }
  }
);
router21.put(
  "/model-router/configs/:role",
  async (req, res) => {
    try {
      const { role } = req.params;
      if (!isValidRole(role)) {
        return res.status(400).json({
          error: `Invalid role. Must be one of: ${VALID_ROLES.join(", ")}`
        });
      }
      const updates = req.body;
      const updated = await updateRoleConfig(role, updates);
      res.json({ success: true, config: updated });
    } catch (error) {
      log.error("AdminAI", "Failed to update role config", { error });
      res.status(500).json({ error: "Failed to update role configuration" });
    }
  }
);
router21.get(
  "/model-router/calls",
  requireAdmin,
  async (req, res) => {
    try {
      const { role, limit: limit4 } = req.query;
      const limitNum = parseInt(limit4) || 20;
      const roleFilter = typeof role === "string" && isValidRole(role) ? role : void 0;
      const calls = await getRecentCalls(limitNum, roleFilter);
      res.json({ calls, count: calls.length });
    } catch (error) {
      log.error("AdminAI", "Failed to get recent LLM calls", { error });
      res.status(500).json({ error: "Failed to get recent LLM calls" });
    }
  }
);
router21.get(
  "/model-router/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await getCallStats();
      res.json(stats);
    } catch (error) {
      log.error("AdminAI", "Failed to get LLM call stats", { error });
      res.status(500).json({ error: "Failed to get LLM call statistics" });
    }
  }
);
router21.get("/work-items", requireAdmin, async (req, res) => {
  try {
    const { status, type, limit: limit4 } = req.query;
    const limitNum = parseInt(limit4) || 50;
    const statusFilter = typeof status === "string" && isValidWorkItemStatus(status) ? status : void 0;
    const items = await storage.getWorkItems(limitNum, statusFilter);
    const filteredItems = type ? items.filter((i) => i.type === type) : items;
    const counts = {
      PENDING: await storage.getWorkItemCount("PENDING"),
      RUNNING: await storage.getWorkItemCount("RUNNING"),
      SUCCEEDED: await storage.getWorkItemCount("SUCCEEDED"),
      FAILED: await storage.getWorkItemCount("FAILED"),
      DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
    };
    res.json({
      items: filteredItems,
      counts,
      total: items.length
    });
  } catch (error) {
    log.error("AdminAI", "Failed to get work items", { error });
    res.status(500).json({ error: "Failed to get work items" });
  }
});
router21.post(
  "/work-items/retry",
  requireAdmin,
  async (req, res) => {
    try {
      const { id } = req.body;
      if (!id) {
        return res.status(400).json({ error: "Work item ID required" });
      }
      const item = await storage.getWorkItem(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      if (item.status !== "DEAD_LETTER" && item.status !== "FAILED") {
        return res.status(400).json({ error: "Can only retry DEAD_LETTER or FAILED items" });
      }
      await storage.updateWorkItem(id, {
        status: "PENDING",
        attempts: 0,
        nextRunAt: /* @__PURE__ */ new Date(),
        lastError: null
      });
      res.json({ success: true, message: "Work item queued for retry" });
    } catch (error) {
      log.error("AdminAI", "Failed to retry work item", { error });
      res.status(500).json({ error: "Failed to retry work item" });
    }
  }
);
router21.post(
  "/work-items/dead-letter",
  requireAdmin,
  async (req, res) => {
    try {
      const { id, reason } = req.body;
      if (!id) {
        return res.status(400).json({ error: "Work item ID required" });
      }
      const item = await storage.getWorkItem(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      await storage.updateWorkItem(id, {
        status: "DEAD_LETTER",
        lastError: reason || "Manually moved to dead letter"
      });
      res.json({ success: true, message: "Work item moved to dead letter" });
    } catch (error) {
      log.error("AdminAI", "Failed to dead-letter work item", { error });
      res.status(500).json({ error: "Failed to dead-letter work item" });
    }
  }
);
router21.get(
  "/orchestrator-health",
  requireAdmin,
  async (req, res) => {
    try {
      const agentStatusData = await storage.getAgentStatus();
      const counts = {
        PENDING: await storage.getWorkItemCount("PENDING"),
        RUNNING: await storage.getWorkItemCount("RUNNING"),
        FAILED: await storage.getWorkItemCount("FAILED"),
        DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
      };
      const recentErrors = await storage.getWorkItems(5, "FAILED");
      res.json({
        isRunning: agentStatusData?.isRunning || false,
        killSwitchActive: agentStatusData?.killSwitchActive || false,
        lastHeartbeat: agentStatusData?.lastHeartbeat || null,
        queueDepth: counts,
        totalPending: counts.PENDING + counts.RUNNING,
        recentErrors: recentErrors.map((e) => ({
          id: e.id,
          type: e.type,
          symbol: e.symbol,
          error: e.lastError,
          createdAt: e.createdAt
        })),
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminAI", "Failed to get orchestrator health", { error });
      res.status(500).json({ error: "Failed to get orchestrator health" });
    }
  }
);
var ai_default = router21;

// server/routes/admin/system.ts
init_storage();
import { Router as Router24 } from "express";

// server/admin/registry.ts
init_logger();
var moduleRegistry = /* @__PURE__ */ new Map();
function registerAdminModule(module) {
  if (moduleRegistry.has(module.id)) {
    log.warn(
      "AdminRegistry",
      `Module ${module.id} already registered, overwriting`
    );
  }
  const registeredModule = {
    ...module,
    enabled: module.enabled ?? true,
    priority: module.priority ?? 100,
    version: module.version ?? "1.0.0"
  };
  moduleRegistry.set(module.id, registeredModule);
  log.info("AdminRegistry", `Registered module: ${module.id}`, {
    title: module.title,
    navGroup: module.navGroup
  });
  return { success: true, moduleId: module.id };
}
function getModules() {
  return Array.from(moduleRegistry.values()).filter((m) => m.enabled).sort((a, b) => (a.priority ?? 100) - (b.priority ?? 100));
}
function getModule(moduleId) {
  return moduleRegistry.get(moduleId);
}
async function getAdminOverview() {
  const modules = getModules();
  const moduleStatuses = modules.map((m) => ({
    id: m.id,
    title: m.title,
    navGroup: m.navGroup,
    enabled: m.enabled ?? true,
    health: void 0
  }));
  const unhealthyCount = moduleStatuses.filter(
    (m) => m.health?.status === "unhealthy"
  ).length;
  const degradedCount = moduleStatuses.filter(
    (m) => m.health?.status === "degraded"
  ).length;
  let overall = "healthy";
  if (unhealthyCount > 0) overall = "unhealthy";
  else if (degradedCount > 0) overall = "degraded";
  return {
    modules: moduleStatuses,
    systemHealth: {
      overall,
      unhealthyCount,
      degradedCount
    }
  };
}
function initializeDefaultModules() {
  registerAdminModule({
    id: "api-budget",
    title: "API Budgets",
    description: "Monitor rate limits, budget usage, and cache status for all providers",
    icon: "activity",
    navGroup: "system",
    capability: "admin:read",
    route: "ApiBudget",
    apiEndpoints: [
      "/api/admin/api-usage",
      "/api/admin/api-cache",
      "/api/admin/provider-status"
    ],
    priority: 10
  });
  registerAdminModule({
    id: "model-router",
    title: "LLM Model Router",
    description: "Role-based routing, fallback chains, cost tracking, and call logs",
    icon: "git-branch",
    navGroup: "ai",
    capability: "admin:read",
    route: "ModelRouter",
    apiEndpoints: [
      "/api/admin/model-router/configs",
      "/api/admin/model-router/calls",
      "/api/admin/model-router/stats"
    ],
    priority: 10
  });
  registerAdminModule({
    id: "connector-health",
    title: "Connector Health",
    description: "Monitor external API connector status and sync times",
    icon: "database",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/connectors-health"],
    priority: 20
  });
  registerAdminModule({
    id: "data-fusion",
    title: "Data Fusion Engine",
    description: "Intelligence score, active sources, and capabilities overview",
    icon: "layers",
    navGroup: "ai",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/data-fusion-status"],
    priority: 20
  });
  registerAdminModule({
    id: "ai-config",
    title: "AI Configuration",
    description: "Auto-execute trades, conservative mode, and confidence thresholds",
    icon: "cpu",
    navGroup: "ai",
    capability: "admin:write",
    apiEndpoints: ["/api/admin/ai-config"],
    settingsSchema: {
      sections: [
        {
          id: "trading",
          title: "Trading Settings",
          fields: [
            {
              key: "autoExecuteTrades",
              label: "Auto-Execute Trades",
              type: "boolean",
              description: "Allow AI to execute trades automatically without approval",
              defaultValue: false
            },
            {
              key: "conservativeMode",
              label: "Conservative Mode",
              type: "boolean",
              description: "Require 85% confidence instead of 70%",
              defaultValue: false
            }
          ]
        }
      ]
    },
    priority: 30
  });
  registerAdminModule({
    id: "api-keys",
    title: "API Keys",
    description: "View configured API keys status across all providers",
    icon: "key",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/api-keys-status"],
    priority: 30
  });
  registerAdminModule({
    id: "work-queue",
    title: "Work Queue",
    description: "Monitor pending, processing, and failed work items",
    icon: "list",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: [
      "/api/admin/work-items",
      "/api/admin/work-items/retry",
      "/api/admin/work-items/dead-letter"
    ],
    priority: 15
  });
  registerAdminModule({
    id: "orchestrator",
    title: "Orchestrator",
    description: "Trading agent status, cycle management, and kill switch",
    icon: "play-circle",
    navGroup: "trading",
    capability: "trading:manage",
    apiEndpoints: ["/api/admin/orchestrator-health"],
    priority: 5
  });
  registerAdminModule({
    id: "debate-arena",
    title: "AI Debate Arena",
    description: "Multi-role AI consensus system with debate sessions and voting",
    icon: "message-circle",
    navGroup: "ai",
    capability: "admin:read",
    route: "Debate",
    apiEndpoints: ["/api/debate/sessions", "/api/debate/sessions/:id"],
    priority: 25
  });
  registerAdminModule({
    id: "competition",
    title: "Competition Mode",
    description: "AI trader profiles competing with performance tracking",
    icon: "award",
    navGroup: "ai",
    capability: "admin:read",
    route: "Competition",
    apiEndpoints: ["/api/competition/traders", "/api/competition/runs"],
    priority: 26
  });
  registerAdminModule({
    id: "strategy-studio",
    title: "Strategy Studio",
    description: "Strategy versioning, activation, and configuration",
    icon: "layers",
    navGroup: "trading",
    capability: "trading:manage",
    route: "Strategies",
    apiEndpoints: ["/api/strategies/versions"],
    priority: 6
  });
  registerAdminModule({
    id: "tool-router",
    title: "Tool Registry",
    description: "MCP-style tool router with invocation audit trail",
    icon: "tool",
    navGroup: "ai",
    capability: "admin:read",
    route: "Tools",
    apiEndpoints: ["/api/tools", "/api/tools/invoke", "/api/tools/invocations"],
    priority: 27
  });
  log.info(
    "AdminRegistry",
    `Initialized ${moduleRegistry.size} default modules`
  );
}

// server/admin/rbac.ts
var ROLE_CAPABILITIES = {
  admin: [
    "admin:read",
    "admin:write",
    "admin:danger",
    "trading:read",
    "trading:write",
    "trading:manage",
    "system:read",
    "system:write",
    "ai:read",
    "ai:write"
  ],
  operator: [
    "admin:read",
    "admin:write",
    "trading:read",
    "trading:write",
    "trading:manage",
    "system:read",
    "ai:read",
    "ai:write"
  ],
  viewer: ["admin:read", "trading:read", "system:read", "ai:read"],
  guest: []
};
function getRoleFromUser(user) {
  return user.isAdmin ? "admin" : "viewer";
}
function getCapabilitiesForRole(role) {
  return ROLE_CAPABILITIES[role] || [];
}
function hasCapability(context, capability) {
  return context.capabilities.includes(capability);
}
function createRBACContext(user) {
  const role = getRoleFromUser(user);
  return {
    userId: user.id,
    username: user.username,
    isAdmin: user.isAdmin,
    role,
    capabilities: getCapabilitiesForRole(role)
  };
}
function filterModulesByCapability(modules, context) {
  return modules.filter((module) => hasCapability(context, module.capability));
}
function getAllRoles() {
  return ["admin", "operator", "viewer", "guest"];
}

// server/routes/admin/system.ts
init_settings();

// server/admin/global-search.ts
init_db();
init_schema2();
import { like as like5, or as or4, eq as eq26, desc as desc18 } from "drizzle-orm";
async function globalSearch(query, limit4 = 50) {
  if (!query || query.length < 2) {
    return { query, totalResults: 0, results: [], byType: {} };
  }
  const likePattern = `%${query}%`;
  const results = [];
  const aiDecisionResults = await db.select().from(aiDecisions).where(
    or4(
      like5(aiDecisions.traceId, likePattern),
      like5(aiDecisions.symbol, likePattern),
      like5(aiDecisions.id, likePattern)
    )
  ).orderBy(desc18(aiDecisions.createdAt)).limit(limit4);
  for (const r of aiDecisionResults) {
    results.push({
      type: "ai_decision",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.action} ${r.symbol} - ${r.reasoning?.substring(0, 50) || "No reason"}`
    });
  }
  const tradeResults = await db.select().from(trades).where(
    or4(
      like5(trades.traceId, likePattern),
      like5(trades.symbol, likePattern),
      like5(trades.id, likePattern)
    )
  ).orderBy(desc18(trades.executedAt)).limit(limit4);
  for (const r of tradeResults) {
    results.push({
      type: "trade",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.executedAt,
      summary: `${r.side} ${r.quantity} ${r.symbol} @ $${r.price}`
    });
  }
  const orderResults = await db.select().from(orders).where(
    or4(
      like5(orders.traceId, likePattern),
      like5(orders.symbol, likePattern),
      like5(orders.id, likePattern),
      like5(orders.brokerOrderId, likePattern),
      like5(orders.clientOrderId, likePattern)
    )
  ).orderBy(desc18(orders.createdAt)).limit(limit4);
  for (const r of orderResults) {
    results.push({
      type: "order",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.side} ${r.qty || r.notional} ${r.symbol} - ${r.status}`
    });
  }
  const fillResults = await db.select().from(fills).where(
    or4(
      like5(fills.traceId, likePattern),
      like5(fills.symbol, likePattern),
      like5(fills.id, likePattern),
      like5(fills.brokerOrderId, likePattern)
    )
  ).orderBy(desc18(fills.createdAt)).limit(limit4);
  for (const r of fillResults) {
    results.push({
      type: "fill",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.side} ${r.qty} ${r.symbol} @ $${r.price}`
    });
  }
  const workItemResults = await db.select().from(workItems).where(
    or4(
      like5(workItems.id, likePattern),
      like5(workItems.idempotencyKey, likePattern),
      like5(workItems.symbol, likePattern)
    )
  ).orderBy(desc18(workItems.createdAt)).limit(limit4);
  for (const r of workItemResults) {
    results.push({
      type: "work_item",
      id: r.id,
      traceId: null,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.type} - ${r.status}`
    });
  }
  const llmCallResults = await db.select().from(llmCalls).where(
    or4(like5(llmCalls.traceId, likePattern), like5(llmCalls.id, likePattern))
  ).orderBy(desc18(llmCalls.createdAt)).limit(limit4);
  for (const r of llmCallResults) {
    results.push({
      type: "llm_call",
      id: r.id,
      traceId: r.traceId,
      symbol: null,
      createdAt: r.createdAt,
      summary: `${r.role} via ${r.provider} - ${r.status}`
    });
  }
  results.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  const limitedResults = results.slice(0, limit4);
  const byType = {};
  for (const r of limitedResults) {
    byType[r.type] = (byType[r.type] || 0) + 1;
  }
  return {
    query,
    totalResults: limitedResults.length,
    results: limitedResults,
    byType
  };
}
async function getRelatedEntities(traceId) {
  const [
    aiDecisionResults,
    tradeResults,
    orderResults,
    fillResults,
    llmCallResults
  ] = await Promise.all([
    db.select().from(aiDecisions).where(eq26(aiDecisions.traceId, traceId)),
    db.select().from(trades).where(eq26(trades.traceId, traceId)),
    db.select().from(orders).where(eq26(orders.traceId, traceId)),
    db.select().from(fills).where(eq26(fills.traceId, traceId)),
    db.select().from(llmCalls).where(eq26(llmCalls.traceId, traceId))
  ]);
  return {
    aiDecisions: aiDecisionResults,
    trades: tradeResults,
    orders: orderResults,
    fills: fillResults,
    llmCalls: llmCallResults
  };
}

// server/routes/admin/system.ts
init_apiBudget();
init_alpaca_trading_engine();
init_logger();
var router22 = Router24();
router22.get("/modules", requireAdmin, async (req, res) => {
  try {
    const modules = getModules();
    res.json({
      modules,
      count: modules.length
    });
  } catch (error) {
    log.error("AdminSystem", "Failed to get admin modules", { error });
    res.status(500).json({ error: "Failed to get admin modules" });
  }
});
router22.get(
  "/modules/accessible",
  requireAdmin,
  async (req, res) => {
    try {
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const rbacContext = createRBACContext(user);
      const allModules = getModules();
      const accessibleModules = filterModulesByCapability(
        allModules,
        rbacContext
      );
      res.json({
        modules: accessibleModules,
        count: accessibleModules.length,
        totalModules: allModules.length,
        userRole: rbacContext.role
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to get accessible modules", { error });
      res.status(500).json({ error: "Failed to get accessible modules" });
    }
  }
);
router22.get(
  "/modules/:id",
  requireAdmin,
  async (req, res) => {
    try {
      const module = getModule(req.params.id);
      if (!module) {
        return res.status(404).json({ error: "Module not found" });
      }
      res.json(module);
    } catch (error) {
      log.error("AdminSystem", "Failed to get admin module", { error });
      res.status(500).json({ error: "Failed to get admin module" });
    }
  }
);
router22.get("/overview", requireAdmin, async (req, res) => {
  try {
    const overview = await getAdminOverview();
    const agentStatusData = await storage.getAgentStatus();
    const queueCounts = {
      PENDING: await storage.getWorkItemCount("PENDING"),
      RUNNING: await storage.getWorkItemCount("RUNNING"),
      FAILED: await storage.getWorkItemCount("FAILED"),
      DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
    };
    const llmStats = await getCallStats();
    const allUsage = await getAllUsageStats();
    res.json({
      ...overview,
      agent: {
        isRunning: agentStatusData?.isRunning ?? false,
        killSwitchActive: agentStatusData?.killSwitchActive ?? false,
        lastHeartbeat: agentStatusData?.lastHeartbeat ?? null
      },
      queue: queueCounts,
      llm: {
        totalCalls: llmStats.total || 0,
        totalCost: llmStats.totalCost || 0
      },
      apiUsage: allUsage
    });
  } catch (error) {
    log.error("AdminSystem", "Failed to get admin overview", { error });
    res.status(500).json({ error: "Failed to get admin overview" });
  }
});
router22.get("/rbac/me", requireAdmin, async (req, res) => {
  try {
    const user = await storage.getUser(req.userId);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    const rbacContext = createRBACContext(user);
    res.json({
      userId: user.id,
      username: user.username,
      role: rbacContext.role,
      capabilities: rbacContext.capabilities,
      isAdmin: user.isAdmin
    });
  } catch (error) {
    log.error("AdminSystem", "Failed to get RBAC context", { error });
    res.status(500).json({ error: "Failed to get RBAC context" });
  }
});
router22.get("/rbac/roles", requireAdmin, async (req, res) => {
  try {
    const roles = getAllRoles();
    res.json({ roles });
  } catch (error) {
    log.error("AdminSystem", "Failed to get roles", { error });
    res.status(500).json({ error: "Failed to get roles" });
  }
});
router22.get(
  "/rbac/check/:capability",
  requireAdmin,
  async (req, res) => {
    try {
      const { capability } = req.params;
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const rbacContext = createRBACContext(user);
      const allowed = hasCapability(rbacContext, capability);
      res.json({
        capability,
        allowed,
        role: rbacContext.role
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to check capability", { error });
      res.status(500).json({ error: "Failed to check capability" });
    }
  }
);
router22.get("/settings", requireAdmin, async (req, res) => {
  try {
    const settings = await listSettings();
    res.json({
      settings: settings.map(sanitizeSettingForResponse),
      count: settings.length
    });
  } catch (error) {
    log.error("AdminSystem", "Failed to list settings", { error });
    res.status(500).json({ error: "Failed to list settings" });
  }
});
router22.get(
  "/settings/:namespace/:key",
  requireAdmin,
  async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const setting = await getSettingFull(namespace, key);
      if (!setting) {
        return res.status(404).json({ error: "Setting not found" });
      }
      res.json(sanitizeSettingForResponse(setting));
    } catch (error) {
      log.error("AdminSystem", "Failed to get setting", { error });
      res.status(500).json({ error: "Failed to get setting" });
    }
  }
);
router22.put(
  "/settings/:namespace/:key",
  requireAdmin,
  async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const { value, description, isSecret } = req.body;
      if (value === void 0) {
        return res.status(400).json({ error: "Value is required" });
      }
      const setting = await setSetting(namespace, key, value, {
        description,
        isSecret,
        userId: req.userId
      });
      res.json(sanitizeSettingForResponse(setting));
    } catch (error) {
      log.error("AdminSystem", "Failed to update setting", { error });
      res.status(500).json({ error: "Failed to update setting" });
    }
  }
);
router22.delete(
  "/settings/:namespace/:key",
  async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const deleted = await deleteSetting(namespace, key);
      if (!deleted) {
        return res.status(404).json({ error: "Setting not found" });
      }
      res.json({ success: true, message: "Setting deleted" });
    } catch (error) {
      log.error("AdminSystem", "Failed to delete setting", { error });
      res.status(500).json({ error: "Failed to delete setting" });
    }
  }
);
router22.get(
  "/orchestrator/status",
  requireAdmin,
  async (req, res) => {
    try {
      const state = orchestrator.getState();
      const riskLimits = orchestrator.getRiskLimits();
      res.json({
        ...state,
        riskLimits,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to get orchestrator status", { error });
      res.status(500).json({ error: "Failed to get orchestrator status" });
    }
  }
);
router22.post(
  "/orchestrator/pause",
  requireAdmin,
  async (req, res) => {
    try {
      await orchestrator.stop(true);
      res.json({ success: true, message: "Orchestrator paused" });
    } catch (error) {
      log.error("AdminSystem", "Failed to pause orchestrator", { error });
      res.status(500).json({ error: "Failed to pause orchestrator" });
    }
  }
);
router22.post(
  "/orchestrator/resume",
  requireAdmin,
  async (req, res) => {
    try {
      await orchestrator.start();
      res.json({ success: true, message: "Orchestrator resumed" });
    } catch (error) {
      log.error("AdminSystem", "Failed to resume orchestrator", { error });
      res.status(500).json({ error: "Failed to resume orchestrator" });
    }
  }
);
router22.post(
  "/orchestrator/run-now",
  requireAdmin,
  async (req, res) => {
    try {
      await orchestrator.start();
      res.json({ success: true, message: "Orchestrator run triggered" });
    } catch (error) {
      log.error("AdminSystem", "Failed to trigger orchestrator", { error });
      res.status(500).json({ error: "Failed to trigger orchestrator" });
    }
  }
);
router22.put(
  "/orchestrator/config",
  requireAdmin,
  async (req, res) => {
    try {
      const config2 = req.body;
      if (config2.riskLimits) {
        await orchestrator.updateRiskLimits(config2.riskLimits);
      }
      res.json({ success: true, config: orchestrator.getState() });
    } catch (error) {
      log.error("AdminSystem", "Failed to update orchestrator config", {
        error
      });
      res.status(500).json({ error: "Failed to update orchestrator config" });
    }
  }
);
router22.post(
  "/orchestrator/reset-stats",
  async (req, res) => {
    try {
      res.json({
        success: true,
        message: "Stats tracking is handled automatically",
        state: orchestrator.getState()
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to reset orchestrator stats", { error });
      res.status(500).json({ error: "Failed to reset orchestrator stats" });
    }
  }
);
router22.get(
  "/jobs/status",
  requireAdmin,
  async (req, res) => {
    try {
      const counts = {
        PENDING: await storage.getWorkItemCount("PENDING"),
        RUNNING: await storage.getWorkItemCount("RUNNING"),
        SUCCEEDED: await storage.getWorkItemCount("SUCCEEDED"),
        FAILED: await storage.getWorkItemCount("FAILED"),
        DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
      };
      res.json({
        counts,
        total: Object.values(counts).reduce((a, b) => a + b, 0),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to get jobs status", { error });
      res.status(500).json({ error: "Failed to get jobs status" });
    }
  }
);
router22.post(
  "/jobs/sync-positions",
  requireAdmin,
  async (req, res) => {
    try {
      const userId = req.userId;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      await alpacaTradingEngine.syncPositionsFromAlpaca(userId);
      res.json({ success: true, message: "Position sync completed" });
    } catch (error) {
      log.error("AdminSystem", "Failed to sync positions", { error });
      res.status(500).json({ error: "Failed to sync positions" });
    }
  }
);
router22.get("/search", requireAdmin, async (req, res) => {
  try {
    const { q, limit: limit4 } = req.query;
    if (!q || typeof q !== "string") {
      return res.status(400).json({ error: "Search query required" });
    }
    const searchResults = await globalSearch(
      q,
      limit4 ? parseInt(limit4) : 20
    );
    res.json({ ...searchResults, count: searchResults.totalResults });
  } catch (error) {
    log.error("AdminSystem", "Failed to search", { error });
    res.status(500).json({ error: "Failed to search" });
  }
});
router22.get(
  "/trace/:traceId",
  requireAdmin,
  async (req, res) => {
    try {
      const { traceId } = req.params;
      const related = await getRelatedEntities(traceId);
      res.json({
        traceId,
        ...related,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminSystem", "Failed to get trace", { error });
      res.status(500).json({ error: "Failed to get trace" });
    }
  }
);
var system_default = router22;

// server/routes/admin/trading.ts
init_storage();
init_universe2();
init_logger();
import { Router as Router25 } from "express";
var router23 = Router25();
router23.get(
  "/universe/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await alpacaUniverseService.getStats();
      res.json({
        ...stats,
        source: "alpaca_universe",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get universe stats", { error });
      res.status(500).json({ error: "Failed to get universe stats" });
    }
  }
);
router23.get(
  "/universe/assets",
  requireAdmin,
  async (req, res) => {
    try {
      const { assetClass, tradable, limit: limit4, offset } = req.query;
      const assets = await storage.getBrokerAssets(
        assetClass,
        tradable === "true",
        limit4 ? parseInt(limit4) : 100
      );
      res.json({
        assets,
        count: assets.length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get universe assets", { error });
      res.status(500).json({ error: "Failed to get universe assets" });
    }
  }
);
router23.get(
  "/universe/assets/:symbol",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const asset = await storage.getBrokerAsset(symbol);
      if (!asset) {
        return res.status(404).json({ error: "Asset not found" });
      }
      res.json(asset);
    } catch (error) {
      log.error("AdminTrading", "Failed to get asset", { error });
      res.status(500).json({ error: "Failed to get asset" });
    }
  }
);
router23.post(
  "/universe/refresh",
  requireAdmin,
  async (req, res) => {
    try {
      const { assetClass } = req.body;
      const result = await alpacaUniverseService.refreshAssets({
        assetClass: assetClass || "us_equity"
      });
      res.json({
        ...result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to refresh universe", { error });
      res.status(500).json({ error: "Failed to refresh universe" });
    }
  }
);
router23.post(
  "/universe/exclude/:symbol",
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const { reason } = req.body;
      await alpacaUniverseService.setExcluded(
        symbol,
        true,
        reason || "Admin exclusion"
      );
      res.json({ success: true, symbol, excluded: true });
    } catch (error) {
      log.error("AdminTrading", "Failed to exclude symbol", { error });
      res.status(500).json({ error: "Failed to exclude symbol" });
    }
  }
);
router23.get(
  "/universe/tradable",
  requireAdmin,
  async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const assets = await storage.getBrokerAssets(
        "us_equity",
        true,
        limit4 ? parseInt(limit4) : 500
      );
      res.json({
        symbols: assets.map((a) => a.symbol),
        count: assets.length
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get tradable symbols", { error });
      res.status(500).json({ error: "Failed to get tradable symbols" });
    }
  }
);
router23.get(
  "/liquidity/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await liquidityService.getTierStats();
      res.json({
        ...stats,
        source: "liquidity_metrics",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get liquidity stats", { error });
      res.status(500).json({ error: "Failed to get liquidity stats" });
    }
  }
);
router23.get(
  "/liquidity/metrics/:symbol",
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const metrics = await liquidityService.getMetricsBySymbol(symbol);
      if (!metrics) {
        return res.status(404).json({ error: "Liquidity metrics not found" });
      }
      res.json(metrics);
    } catch (error) {
      log.error("AdminTrading", "Failed to get liquidity metrics", { error });
      res.status(500).json({ error: "Failed to get liquidity metrics" });
    }
  }
);
router23.get(
  "/liquidity/tier/:tier",
  requireAdmin,
  async (req, res) => {
    try {
      const { tier } = req.params;
      const { limit: limit4 } = req.query;
      if (!["A", "B", "C", "D"].includes(tier)) {
        return res.status(400).json({ error: "Invalid tier. Must be A, B, C, or D" });
      }
      const metrics = await liquidityService.getMetricsByTier(
        tier,
        limit4 ? parseInt(limit4) : 100
      );
      res.json({ tier, symbols: metrics, count: metrics.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to get tier symbols", { error });
      res.status(500).json({ error: "Failed to get tier symbols" });
    }
  }
);
router23.get(
  "/liquidity/top",
  requireAdmin,
  async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const symbols = await liquidityService.getTopLiquid(
        limit4 ? parseInt(limit4) : 50
      );
      res.json({ symbols, count: symbols.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to get top liquid symbols", { error });
      res.status(500).json({ error: "Failed to get top liquid symbols" });
    }
  }
);
router23.post(
  "/liquidity/compute",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbols, traceId } = req.body;
      const result = await liquidityService.computeLiquidityMetrics({
        symbols,
        traceId: traceId || `liq-${Date.now()}`
      });
      res.json({
        ...result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to compute liquidity", { error });
      res.status(500).json({ error: "Failed to compute liquidity metrics" });
    }
  }
);
router23.get(
  "/fundamentals/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await fundamentalsService.getStats();
      res.json({
        ...stats,
        source: "universe_fundamentals",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get fundamentals stats", { error });
      res.status(500).json({ error: "Failed to get fundamentals stats" });
    }
  }
);
router23.get(
  "/fundamentals/:symbol",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const fundamentals = await fundamentalsService.getFundamentalsBySymbol(symbol);
      if (!fundamentals) {
        return res.status(404).json({ error: "Fundamentals not found" });
      }
      res.json(fundamentals);
    } catch (error) {
      log.error("AdminTrading", "Failed to get fundamentals", { error });
      res.status(500).json({ error: "Failed to get fundamentals" });
    }
  }
);
router23.get(
  "/fundamentals/top/scores",
  requireAdmin,
  async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const symbols = await fundamentalsService.getTopByScore(
        limit4 ? parseInt(limit4) : 50
      );
      res.json({ symbols, count: symbols.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to get top scores", { error });
      res.status(500).json({ error: "Failed to get top scores" });
    }
  }
);
router23.post(
  "/fundamentals/fetch",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbols, traceId } = req.body;
      const result = await fundamentalsService.fetchAndStoreFundamentals({
        symbols,
        traceId: traceId || `fund-${Date.now()}`
      });
      res.json({
        ...result,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to fetch fundamentals", { error });
      res.status(500).json({ error: "Failed to fetch fundamentals" });
    }
  }
);
router23.get(
  "/candidates/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await candidatesService.getStats();
      res.json({
        ...stats,
        source: "universe_candidates",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get candidates stats", { error });
      res.status(500).json({ error: "Failed to get candidates stats" });
    }
  }
);
router23.get("/candidates", requireAdmin, async (req, res) => {
  try {
    const { status, limit: limit4 } = req.query;
    let candidates;
    if (status && ["NEW", "WATCHLIST", "APPROVED", "REJECTED"].includes(status)) {
      candidates = await candidatesService.getCandidatesByStatus(
        status,
        limit4 ? parseInt(limit4) : 100
      );
    } else {
      candidates = await candidatesService.getTopCandidates(
        limit4 ? parseInt(limit4) : 100
      );
    }
    res.json({ candidates, count: candidates.length });
  } catch (error) {
    log.error("AdminTrading", "Failed to get candidates", { error });
    res.status(500).json({ error: "Failed to get candidates" });
  }
});
router23.get(
  "/candidates/:symbol",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const candidate = await candidatesService.getCandidateBySymbol(symbol);
      if (!candidate) {
        return res.status(404).json({ error: "Candidate not found" });
      }
      res.json(candidate);
    } catch (error) {
      log.error("AdminTrading", "Failed to get candidate", { error });
      res.status(500).json({ error: "Failed to get candidate" });
    }
  }
);
router23.post(
  "/candidates/generate",
  requireAdmin,
  async (req, res) => {
    try {
      const { minLiquidityTier, minScore, limit: limit4, traceId } = req.body;
      const result = await candidatesService.generateCandidates({
        minLiquidityTier,
        minScore: minScore ? parseFloat(minScore) : 0.4,
        limit: limit4 ? parseInt(limit4) : 100,
        traceId: traceId || `cand-${Date.now()}`
      });
      res.json(result);
    } catch (error) {
      log.error("AdminTrading", "Failed to generate candidates", { error });
      res.status(500).json({ error: "Failed to generate candidates" });
    }
  }
);
router23.post(
  "/candidates/:symbol/approve",
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const userId = req.userId;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const result = await candidatesService.approveCandidate(symbol, userId);
      res.json(result);
    } catch (error) {
      log.error("AdminTrading", "Failed to approve candidate", { error });
      res.status(500).json({ error: "Failed to approve candidate" });
    }
  }
);
router23.post(
  "/candidates/:symbol/reject",
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const result = await candidatesService.rejectCandidate(symbol);
      res.json(result);
    } catch (error) {
      log.error("AdminTrading", "Failed to reject candidate", { error });
      res.status(500).json({ error: "Failed to reject candidate" });
    }
  }
);
router23.post(
  "/candidates/:symbol/watchlist",
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const result = await candidatesService.watchlistCandidate(symbol);
      res.json(result);
    } catch (error) {
      log.error("AdminTrading", "Failed to watchlist candidate", { error });
      res.status(500).json({ error: "Failed to watchlist candidate" });
    }
  }
);
router23.get(
  "/candidates/approved/list",
  requireAdmin,
  async (req, res) => {
    try {
      const symbols = await candidatesService.getApprovedSymbols();
      res.json({ symbols, count: symbols.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to get approved symbols", { error });
      res.status(500).json({ error: "Failed to get approved symbols" });
    }
  }
);
router23.get(
  "/enforcement/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await tradingEnforcementService.getStats();
      res.json({
        ...stats,
        source: "trading_enforcement",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get enforcement stats", { error });
      res.status(500).json({ error: "Failed to get enforcement stats" });
    }
  }
);
router23.post(
  "/enforcement/check",
  requireAdmin,
  async (req, res) => {
    try {
      const { symbol, symbols, traceId } = req.body;
      if (symbol) {
        const result = await tradingEnforcementService.canTradeSymbol(
          symbol,
          traceId || `chk-${Date.now()}`
        );
        res.json(result);
      } else if (symbols && Array.isArray(symbols)) {
        const results = await tradingEnforcementService.canTradeMultiple(
          symbols,
          traceId || `chk-${Date.now()}`
        );
        res.json({ results: Object.fromEntries(results) });
      } else {
        res.status(400).json({ error: "Provide symbol or symbols array" });
      }
    } catch (error) {
      log.error("AdminTrading", "Failed to check trading eligibility", {
        error
      });
      res.status(500).json({ error: "Failed to check trading eligibility" });
    }
  }
);
router23.post(
  "/enforcement/reset-stats",
  requireAdmin,
  async (req, res) => {
    try {
      tradingEnforcementService.resetStats();
      res.json({ success: true, message: "Enforcement stats reset" });
    } catch (error) {
      log.error("AdminTrading", "Failed to reset enforcement stats", { error });
      res.status(500).json({ error: "Failed to reset enforcement stats" });
    }
  }
);
router23.get(
  "/allocation/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await allocationService.getStats();
      res.json({
        ...stats,
        source: "allocation_policies",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get allocation stats", { error });
      res.status(500).json({ error: "Failed to get allocation stats" });
    }
  }
);
router23.get(
  "/allocation/policies",
  requireAdmin,
  async (req, res) => {
    try {
      const policies = await allocationService.listPolicies();
      res.json({ policies, count: policies.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to list policies", { error });
      res.status(500).json({ error: "Failed to list policies" });
    }
  }
);
router23.get(
  "/allocation/policies/active",
  async (req, res) => {
    try {
      const policy = await allocationService.getActivePolicy();
      if (!policy) {
        return res.status(404).json({ error: "No active policy found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("AdminTrading", "Failed to get active policy", { error });
      res.status(500).json({ error: "Failed to get active policy" });
    }
  }
);
router23.get(
  "/allocation/policies/:id",
  requireAdmin,
  async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.getPolicyById(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("AdminTrading", "Failed to get policy", { error });
      res.status(500).json({ error: "Failed to get policy" });
    }
  }
);
router23.post(
  "/allocation/policies",
  requireAdmin,
  async (req, res) => {
    try {
      const userId = req.userId;
      const policy = await allocationService.createPolicy({
        ...req.body,
        createdBy: userId
      });
      res.status(201).json(policy);
    } catch (error) {
      log.error("AdminTrading", "Failed to create policy", { error });
      res.status(500).json({ error: "Failed to create policy" });
    }
  }
);
router23.patch(
  "/allocation/policies/:id",
  async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.updatePolicy(id, req.body);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("AdminTrading", "Failed to update policy", { error });
      res.status(500).json({ error: "Failed to update policy" });
    }
  }
);
router23.post(
  "/allocation/policies/:id/activate",
  async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.activatePolicy(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, policy });
    } catch (error) {
      log.error("AdminTrading", "Failed to activate policy", { error });
      res.status(500).json({ error: "Failed to activate policy" });
    }
  }
);
router23.post(
  "/allocation/policies/:id/deactivate",
  async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.deactivatePolicy(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, policy });
    } catch (error) {
      log.error("AdminTrading", "Failed to deactivate policy", { error });
      res.status(500).json({ error: "Failed to deactivate policy" });
    }
  }
);
router23.post(
  "/allocation/analyze",
  requireAdmin,
  async (req, res) => {
    try {
      const { traceId } = req.body;
      const analysis = await allocationService.analyzeRebalance(
        traceId || `analyze-${Date.now()}`
      );
      if (!analysis) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      res.json({
        ...analysis,
        currentPositions: Object.fromEntries(analysis.currentPositions)
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to analyze rebalance", { error });
      res.status(500).json({ error: "Failed to analyze rebalance" });
    }
  }
);
router23.get(
  "/allocation/runs",
  requireAdmin,
  async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const runs = await allocationService.getRebalanceRuns(
        limit4 ? parseInt(limit4) : 20
      );
      res.json({ runs, count: runs.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to get rebalance runs", { error });
      res.status(500).json({ error: "Failed to get rebalance runs" });
    }
  }
);
router23.get(
  "/allocation/runs/:id",
  requireAdmin,
  async (req, res) => {
    try {
      const { id } = req.params;
      const run = await allocationService.getRebalanceRunById(id);
      if (!run) {
        return res.status(404).json({ error: "Rebalance run not found" });
      }
      res.json(run);
    } catch (error) {
      log.error("AdminTrading", "Failed to get rebalance run", { error });
      res.status(500).json({ error: "Failed to get rebalance run" });
    }
  }
);
router23.get(
  "/rebalancer/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const stats = await rebalancerService.getStats();
      res.json({
        ...stats,
        source: "rebalancer",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to get rebalancer stats", { error });
      res.status(500).json({ error: "Failed to get rebalancer stats" });
    }
  }
);
router23.post(
  "/rebalancer/dry-run",
  requireAdmin,
  async (req, res) => {
    try {
      const { traceId } = req.body;
      const analysis = await rebalancerService.executeDryRun(
        traceId || `dry-${Date.now()}`
      );
      if (!analysis) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      res.json({
        ...analysis,
        analysis: analysis.analysis ? {
          ...analysis.analysis,
          currentPositions: Object.fromEntries(
            analysis.analysis.currentPositions
          )
        } : null
      });
    } catch (error) {
      log.error("AdminTrading", "Failed to execute dry run", { error });
      res.status(500).json({ error: "Failed to execute dry run" });
    }
  }
);
router23.post(
  "/rebalancer/execute",
  requireAdmin,
  async (req, res) => {
    try {
      const { traceId, dryRun } = req.body;
      const result = await rebalancerService.executeRebalance(
        traceId || `rebal-${Date.now()}`,
        dryRun === true
      );
      res.json(result);
    } catch (error) {
      log.error("AdminTrading", "Failed to execute rebalance", { error });
      res.status(500).json({ error: "Failed to execute rebalance" });
    }
  }
);
router23.post(
  "/rebalancer/profit-taking/analyze",
  async (req, res) => {
    try {
      const { traceId } = req.body;
      const policy = await allocationService.getActivePolicy();
      if (!policy) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      const analysis = await rebalancerService.analyzeProfitTaking(
        policy,
        traceId || `profit-${Date.now()}`
      );
      res.json({ candidates: analysis, count: analysis.length });
    } catch (error) {
      log.error("AdminTrading", "Failed to analyze profit-taking", { error });
      res.status(500).json({ error: "Failed to analyze profit-taking" });
    }
  }
);
var trading_default = router23;

// server/routes/admin/management.ts
init_storage();
init_logger();
import { Router as Router26 } from "express";
import bcrypt2 from "bcryptjs";
var router24 = Router26();
router24.get("/audit-logs", requireAdmin, async (req, res) => {
  try {
    const { getAuditLogs: getAuditLogs2 } = await Promise.resolve().then(() => (init_audit_logger(), audit_logger_exports));
    const { limit: limit4, offset } = req.query;
    const limitNum = limit4 ? parseInt(limit4) : 100;
    const offsetNum = offset ? parseInt(offset) : 0;
    const logs = await getAuditLogs2(limitNum, offsetNum);
    res.json({ logs, count: logs.length });
  } catch (error) {
    log.error("AdminMgmt", "Failed to get audit logs", { error });
    res.status(500).json({ error: "Failed to get audit logs" });
  }
});
router24.get(
  "/audit-logs/stats",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAuditStats: getAuditStats2 } = await Promise.resolve().then(() => (init_audit_logger(), audit_logger_exports));
      const stats = await getAuditStats2();
      res.json(stats);
    } catch (error) {
      log.error("AdminMgmt", "Failed to get audit stats", { error });
      res.status(500).json({ error: "Failed to get audit stats" });
    }
  }
);
router24.get("/dashboard", requireAdmin, async (req, res) => {
  try {
    const { getAllAvailableProviders: getAllAvailableProviders2 } = await Promise.resolve().then(() => (init_ai(), ai_exports));
    const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
    const aiProviders = getAllAvailableProviders2();
    const providerStatuses = await getAllProviderStatuses2();
    const activeProviders = Object.entries(providerStatuses).filter(
      ([_, status]) => status.isAvailable
    ).length;
    const pendingCount = await storage.getWorkItemCount("PENDING");
    const runningCount = await storage.getWorkItemCount("RUNNING");
    const failedCount = await storage.getWorkItemCount("FAILED");
    const agentStatus2 = await storage.getAgentStatus();
    res.json({
      providers: {
        total: aiProviders.length,
        active: activeProviders
      },
      models: {
        total: aiProviders.length,
        enabled: activeProviders
      },
      jobs: {
        running: runningCount,
        pending: pendingCount,
        failed: failedCount
      },
      killSwitch: !(agentStatus2?.autoExecuteTrades ?? false)
    });
  } catch (error) {
    log.error("AdminMgmt", "Failed to get dashboard stats", { error });
    res.status(500).json({ error: "Failed to get dashboard stats" });
  }
});
router24.get("/users", requireAdmin, async (req, res) => {
  try {
    const allUsers = await storage.getAllUsers();
    const sanitizedUsers = allUsers.map(({ password, ...user }) => ({
      ...user,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    }));
    res.json({ users: sanitizedUsers, count: sanitizedUsers.length });
  } catch (error) {
    log.error("AdminMgmt", "Failed to get users", { error });
    res.status(500).json({ error: "Failed to get users" });
  }
});
router24.get("/users/:id", requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const user = await storage.getUser(id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    const { password, ...sanitizedUser } = user;
    res.json(sanitizedUser);
  } catch (error) {
    log.error("AdminMgmt", "Failed to get user", { error });
    res.status(500).json({ error: "Failed to get user" });
  }
});
router24.post("/users", requireAdmin, async (req, res) => {
  try {
    const { username, password, isAdmin } = req.body;
    if (!username || !password) {
      return res.status(400).json({ error: "Username and password are required" });
    }
    const existing = await storage.getUserByUsername(username);
    if (existing) {
      return res.status(409).json({ error: "Username already exists" });
    }
    const hashedPassword = await bcrypt2.hash(password, 10);
    const user = await storage.createUser({
      username,
      password: hashedPassword,
      isAdmin: isAdmin || false
    });
    const { password: _, ...sanitizedUser } = user;
    res.status(201).json(sanitizedUser);
  } catch (error) {
    log.error("AdminMgmt", "Failed to create user", { error });
    res.status(500).json({ error: "Failed to create user" });
  }
});
router24.patch(
  "/users/:id",
  requireAdmin,
  async (req, res) => {
    try {
      const { id } = req.params;
      const { username, password, isAdmin } = req.body;
      const updates = {};
      if (username !== void 0) updates.username = username;
      if (isAdmin !== void 0) updates.isAdmin = isAdmin;
      if (password) {
        updates.password = await bcrypt2.hash(password, 10);
      }
      const user = await storage.updateUser(id, updates);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password: _, ...sanitizedUser } = user;
      res.json(sanitizedUser);
    } catch (error) {
      log.error("AdminMgmt", "Failed to update user", { error });
      res.status(500).json({ error: "Failed to update user" });
    }
  }
);
router24.delete(
  "/users/:id",
  requireAdmin,
  async (req, res) => {
    try {
      const { id } = req.params;
      if (id === req.userId) {
        return res.status(400).json({ error: "Cannot delete your own account" });
      }
      const deleted = await storage.deleteUser(id);
      if (!deleted) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({ success: true });
    } catch (error) {
      log.error("AdminMgmt", "Failed to delete user", { error });
      res.status(500).json({ error: "Failed to delete user" });
    }
  }
);
router24.get(
  "/observability/metrics",
  requireAdmin,
  async (req, res) => {
    try {
      const memUsage = process.memoryUsage();
      const uptime = process.uptime();
      const pendingJobs = await storage.getWorkItemCount("PENDING");
      const runningJobs = await storage.getWorkItemCount("RUNNING");
      const failedJobs = await storage.getWorkItemCount("FAILED");
      const completedJobs = await storage.getWorkItemCount("SUCCEEDED");
      const recentLogs = await storage.getRecentAuditLogs(100);
      const logsLast24h = recentLogs.filter((auditLog) => {
        const logTime = new Date(auditLog.timestamp).getTime();
        return Date.now() - logTime < 24 * 60 * 60 * 1e3;
      }).length;
      res.json({
        system: {
          memoryUsedMB: Math.round(memUsage.heapUsed / 1024 / 1024),
          memoryTotalMB: Math.round(memUsage.heapTotal / 1024 / 1024),
          uptimeHours: Math.round(uptime / 3600 * 10) / 10,
          nodeVersion: process.version
        },
        workQueue: {
          pending: pendingJobs,
          running: runningJobs,
          failed: failedJobs,
          completed: completedJobs
        },
        activity: {
          logsLast24h,
          totalRecentLogs: recentLogs.length
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminMgmt", "Failed to get observability metrics", { error });
      res.status(500).json({ error: "Failed to get observability metrics" });
    }
  }
);
router24.get(
  "/observability/logs",
  requireAdmin,
  async (req, res) => {
    try {
      const { limit: limit4, offset, action } = req.query;
      const limitNum = parseInt(limit4) || 50;
      const offsetNum = parseInt(offset) || 0;
      const logs = await storage.getRecentAuditLogs(limitNum, offsetNum);
      const filteredLogs = action ? logs.filter((auditLog) => auditLog.action === action) : logs;
      res.json({
        logs: filteredLogs,
        count: filteredLogs.length,
        offset: offsetNum
      });
    } catch (error) {
      log.error("AdminMgmt", "Failed to get logs", { error });
      res.status(500).json({ error: "Failed to get logs" });
    }
  }
);
router24.get(
  "/observability/health",
  requireAdmin,
  async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      let dbHealthy = true;
      try {
        await storage.getAgentStatus();
      } catch {
        dbHealthy = false;
      }
      const providerStatuses = await getAllProviderStatuses2();
      const providersHealthy = Object.values(providerStatuses).some(
        (s) => s.enabled && s.budgetStatus.allowed
      );
      let alpacaHealthy = false;
      try {
        const alpaca2 = await Promise.resolve().then(() => (init_alpaca(), alpaca_exports));
        const account = await alpaca2.alpacaClient.getAccount();
        alpacaHealthy = account?.status === "ACTIVE";
      } catch {
        alpacaHealthy = false;
      }
      res.json({
        services: [
          {
            name: "Database",
            status: dbHealthy ? "healthy" : "unhealthy",
            message: dbHealthy ? "Connected" : "Connection failed"
          },
          { name: "API Endpoints", status: "healthy", message: "Operational" },
          {
            name: "LLM Providers",
            status: providersHealthy ? "healthy" : "degraded",
            message: providersHealthy ? "Available" : "No providers"
          },
          {
            name: "Alpaca Trading",
            status: alpacaHealthy ? "healthy" : "unhealthy",
            message: alpacaHealthy ? "Connected" : "Disconnected"
          },
          { name: "Background Jobs", status: "healthy", message: "Running" }
        ],
        overall: dbHealthy && alpacaHealthy ? "healthy" : "degraded",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("AdminMgmt", "Failed to get health status", { error });
      res.status(500).json({ error: "Failed to get health status" });
    }
  }
);
var management_default = router24;

// server/routes/admin/index.ts
var router25 = Router27();
router25.use("/", api_default);
router25.use("/", ai_default);
router25.use("/", system_default);
router25.use("/", trading_default);
router25.use("/", management_default);
var admin_default = router25;

// server/routes/notifications.ts
init_logger();
init_notification_service();
import { Router as Router28 } from "express";
var router26 = Router28();
var redactChannelConfig = (channel) => {
  const config2 = { ...channel.config };
  if ("botToken" in config2 && typeof config2.botToken === "string") {
    config2.botToken = "***REDACTED***";
  }
  if ("webhookUrl" in config2 && typeof config2.webhookUrl === "string") {
    config2.webhookUrl = config2.webhookUrl.replace(
      /\/[^/]+$/,
      "/***REDACTED***"
    );
  }
  if ("password" in config2 && typeof config2.password === "string") {
    config2.password = "***REDACTED***";
  }
  return {
    id: channel.id,
    type: channel.type,
    name: channel.name,
    enabled: channel.enabled,
    config: config2,
    createdAt: channel.createdAt
  };
};
router26.get("/channels", (req, res) => {
  res.json({ channels: getChannels().map(redactChannelConfig) });
});
router26.get("/channels/:id", (req, res) => {
  const channel = getChannel(req.params.id);
  if (!channel) {
    return res.status(404).json({ error: "Channel not found" });
  }
  res.json(redactChannelConfig(channel));
});
router26.post("/channels", (req, res) => {
  try {
    const { type, name, config: config2, enabled } = req.body;
    if (!type || !name || !config2) {
      return res.status(400).json({ error: "type, name, and config are required" });
    }
    if (!["telegram", "slack", "discord", "email"].includes(type)) {
      return res.status(400).json({ error: "Invalid channel type" });
    }
    const id = `ch_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const channel = {
      id,
      type,
      name,
      config: config2,
      enabled: enabled === true,
      createdAt: /* @__PURE__ */ new Date()
    };
    registerChannel(channel);
    res.status(201).json(redactChannelConfig(channel));
  } catch (error) {
    log.error("NotificationsAPI", "Channel creation error", { error });
    res.status(500).json({ error: "Failed to create channel" });
  }
});
router26.put("/channels/:id", (req, res) => {
  const updated = updateChannel(req.params.id, req.body);
  if (!updated) {
    return res.status(404).json({ error: "Channel not found" });
  }
  res.json(redactChannelConfig(updated));
});
router26.delete("/channels/:id", (req, res) => {
  const result = deleteChannel(req.params.id);
  if (!result) {
    return res.status(404).json({ error: "Channel not found" });
  }
  res.json({ success: true });
});
router26.post(
  "/channels/:id/test",
  requireAuth,
  async (req, res) => {
    try {
      const { message } = req.body;
      const result = await sendDirectNotification(
        req.params.id,
        message || "Test notification from AI Active Trader"
      );
      if (!result) {
        return res.status(404).json({ error: "Channel not found" });
      }
      res.json(result);
    } catch (error) {
      log.error("NotificationsAPI", "Notification test error", {
        error
      });
      res.status(500).json({ error: "Failed to send test notification" });
    }
  }
);
router26.get("/templates", (req, res) => {
  res.json({ templates: getTemplates() });
});
router26.post("/templates", (req, res) => {
  try {
    const { name, eventType, channels: channels2, messageTemplate, enabled } = req.body;
    if (!name || !eventType || !messageTemplate) {
      return res.status(400).json({ error: "name, eventType, and messageTemplate are required" });
    }
    const id = `tpl_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const template = {
      id,
      name,
      eventType,
      channels: channels2 || [],
      messageTemplate,
      enabled: enabled !== false
    };
    registerTemplate(template);
    res.status(201).json(template);
  } catch (error) {
    log.error("NotificationsAPI", "Template creation error", { error });
    res.status(500).json({ error: "Failed to create template" });
  }
});
router26.put("/templates/:id", (req, res) => {
  const updated = updateTemplate(req.params.id, req.body);
  if (!updated) {
    return res.status(404).json({ error: "Template not found" });
  }
  res.json(updated);
});
router26.delete("/templates/:id", (req, res) => {
  const result = deleteTemplate(req.params.id);
  if (!result) {
    return res.status(404).json({ error: "Template not found" });
  }
  res.json({ success: true });
});
router26.post("/send", requireAuth, async (req, res) => {
  try {
    const { eventType, data } = req.body;
    if (!eventType) {
      return res.status(400).json({ error: "eventType is required" });
    }
    const results = await sendNotification(eventType, data || {});
    res.json({ sent: results.length, results });
  } catch (error) {
    log.error("NotificationsAPI", "Notification send error", { error });
    res.status(500).json({ error: "Failed to send notification" });
  }
});
router26.get("/history", (req, res) => {
  const limit4 = parseInt(req.query.limit) || 50;
  res.json({ notifications: getNotificationHistory(limit4) });
});
router26.get("/stats", (req, res) => {
  res.json(getNotificationStats());
});
var notifications_default = router26;

// server/routes/allocation-rebalance.ts
init_db();
init_schema2();
init_logger();
import { Router as Router29 } from "express";
import { desc as desc19, eq as eq27 } from "drizzle-orm";
var router27 = Router29();
router27.get(
  "/allocation-policies",
  requireAuth,
  async (req, res) => {
    try {
      const policies = await db.query.allocationPolicies.findMany({
        orderBy: [desc19(allocationPolicies.createdAt)]
      });
      res.json({ policies, count: policies.length });
    } catch (error) {
      log.error("Routes", "Failed to get allocation policies", {
        error
      });
      res.status(500).json({ error: "Failed to get allocation policies" });
    }
  }
);
router27.post(
  "/allocation-policies",
  requireAuth,
  async (req, res) => {
    try {
      const {
        name,
        description,
        maxPositionWeightPct,
        maxSectorWeightPct,
        rebalanceFrequency,
        isActive
      } = req.body;
      if (!name) {
        return res.status(400).json({ error: "name is required" });
      }
      const [policy] = await db.insert(allocationPolicies).values({
        name,
        description: description || null,
        maxPositionWeightPct: maxPositionWeightPct ? String(maxPositionWeightPct) : "8",
        maxSectorWeightPct: maxSectorWeightPct ? String(maxSectorWeightPct) : "25",
        rebalanceFrequency: rebalanceFrequency || "daily",
        isActive: isActive !== void 0 ? isActive : false,
        createdBy: req.user?.id || null
      }).returning();
      res.json(policy);
    } catch (error) {
      log.error("Routes", "Failed to create allocation policy", {
        error
      });
      res.status(500).json({ error: "Failed to create allocation policy" });
    }
  }
);
router27.patch(
  "/allocation-policies/:id",
  async (req, res) => {
    try {
      const {
        name,
        description,
        maxPositionWeightPct,
        maxSectorWeightPct,
        rebalanceFrequency,
        isActive
      } = req.body;
      const updates = { updatedAt: /* @__PURE__ */ new Date() };
      if (name !== void 0) updates.name = name;
      if (description !== void 0) updates.description = description;
      if (maxPositionWeightPct !== void 0)
        updates.maxPositionWeightPct = String(maxPositionWeightPct);
      if (maxSectorWeightPct !== void 0)
        updates.maxSectorWeightPct = String(maxSectorWeightPct);
      if (rebalanceFrequency !== void 0)
        updates.rebalanceFrequency = rebalanceFrequency;
      if (isActive !== void 0) updates.isActive = isActive;
      const [updated] = await db.update(allocationPolicies).set(updates).where(eq27(allocationPolicies.id, req.params.id)).returning();
      if (!updated) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(updated);
    } catch (error) {
      log.error("Routes", "Failed to update allocation policy", {
        error
      });
      res.status(500).json({ error: "Failed to update allocation policy" });
    }
  }
);
router27.delete(
  "/allocation-policies/:id",
  async (req, res) => {
    try {
      const [deleted] = await db.delete(allocationPolicies).where(eq27(allocationPolicies.id, req.params.id)).returning();
      if (!deleted) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, message: "Policy deleted" });
    } catch (error) {
      log.error("Routes", "Failed to delete allocation policy", {
        error
      });
      res.status(500).json({ error: "Failed to delete allocation policy" });
    }
  }
);
router27.get(
  "/rebalance/runs",
  requireAuth,
  async (req, res) => {
    try {
      const { limit: limit4, status } = req.query;
      let whereClause = void 0;
      if (status) {
        whereClause = eq27(rebalanceRuns.status, status);
      }
      const runs = await db.query.rebalanceRuns.findMany({
        where: whereClause,
        orderBy: [desc19(rebalanceRuns.startedAt)],
        limit: limit4 ? parseInt(limit4) : 50
      });
      res.json({ runs, count: runs.length });
    } catch (error) {
      log.error("Routes", "Failed to get rebalance runs", { error });
      res.status(500).json({ error: "Failed to get rebalance runs" });
    }
  }
);
router27.post(
  "/rebalance/trigger",
  requireAuth,
  async (req, res) => {
    try {
      const { policyId, triggerType = "manual" } = req.body;
      const traceId = `rebalance-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const [run] = await db.insert(rebalanceRuns).values({
        policyId: policyId || null,
        traceId,
        status: "running",
        triggerType,
        inputSnapshot: {}
      }).returning();
      setTimeout(async () => {
        await db.update(rebalanceRuns).set({ status: "completed", completedAt: /* @__PURE__ */ new Date() }).where(eq27(rebalanceRuns.id, run.id));
      }, 2e3);
      res.json({ success: true, run });
    } catch (error) {
      log.error("Routes", "Failed to trigger rebalance", { error });
      res.status(500).json({ error: "Failed to trigger rebalance" });
    }
  }
);
var allocation_rebalance_default = router27;

// server/routes/enforcement-fundamentals.ts
init_db();
init_schema2();
init_logger();
import { Router as Router30 } from "express";
import { desc as desc20, eq as eq28 } from "drizzle-orm";
var router28 = Router30();
async function authMiddleware(req, res, next) {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      log.warn("Auth", "No session cookie found for request:", {
        path: req.path
      });
      return res.status(401).json({
        error: "Not authenticated",
        code: "NO_SESSION",
        message: "Please log in to access this resource"
      });
    }
    const session = await getSession(sessionId);
    if (!session) {
      log.warn("Auth", "Session expired or invalid:", {
        sessionId: sessionId.substring(0, 8) + "..."
      });
      return res.status(401).json({
        error: "Session expired",
        code: "SESSION_EXPIRED",
        message: "Your session has expired. Please log in again."
      });
    }
    req.userId = session.userId;
    next();
  } catch (error) {
    log.error("Auth", "Auth middleware error:", { error });
    res.status(500).json({ error: "Authentication error" });
  }
}
router28.get(
  "/enforcement/rules",
  authMiddleware,
  async (req, res) => {
    try {
      const rules = await db.query.alertRules.findMany({
        orderBy: [desc20(alertRules.createdAt)]
      });
      res.json({ rules, count: rules.length });
    } catch (error) {
      log.error("Routes", "Failed to get enforcement rules", { error });
      res.status(500).json({ error: "Failed to get enforcement rules" });
    }
  }
);
router28.post(
  "/enforcement/rules",
  authMiddleware,
  async (req, res) => {
    try {
      const {
        name,
        description,
        ruleType,
        condition,
        threshold,
        enabled,
        webhookUrl
      } = req.body;
      if (!name || !ruleType || threshold === void 0) {
        return res.status(400).json({ error: "name, ruleType, and threshold are required" });
      }
      const [rule] = await db.insert(alertRules).values({
        name,
        description: description || null,
        ruleType,
        condition: condition || { scope: "portfolio" },
        threshold: String(threshold),
        enabled: enabled !== void 0 ? enabled : true,
        webhookUrl: webhookUrl || null
      }).returning();
      res.json(rule);
    } catch (error) {
      log.error("Routes", "Failed to create enforcement rule", {
        error
      });
      res.status(500).json({ error: "Failed to create enforcement rule" });
    }
  }
);
router28.patch(
  "/enforcement/rules/:id",
  authMiddleware,
  async (req, res) => {
    try {
      const {
        name,
        description,
        ruleType,
        condition,
        threshold,
        enabled,
        webhookUrl
      } = req.body;
      const updates = { updatedAt: /* @__PURE__ */ new Date() };
      if (name !== void 0) updates.name = name;
      if (description !== void 0) updates.description = description;
      if (ruleType !== void 0) updates.ruleType = ruleType;
      if (condition !== void 0) updates.condition = condition;
      if (threshold !== void 0) updates.threshold = String(threshold);
      if (enabled !== void 0) updates.enabled = enabled;
      if (webhookUrl !== void 0) updates.webhookUrl = webhookUrl;
      const [updated] = await db.update(alertRules).set(updates).where(eq28(alertRules.id, req.params.id)).returning();
      if (!updated) {
        return res.status(404).json({ error: "Rule not found" });
      }
      res.json(updated);
    } catch (error) {
      log.error("Routes", "Failed to update enforcement rule", {
        error
      });
      res.status(500).json({ error: "Failed to update enforcement rule" });
    }
  }
);
router28.delete(
  "/enforcement/rules/:id",
  authMiddleware,
  async (req, res) => {
    try {
      const [deleted] = await db.delete(alertRules).where(eq28(alertRules.id, req.params.id)).returning();
      if (!deleted) {
        return res.status(404).json({ error: "Rule not found" });
      }
      res.json({ success: true, message: "Rule deleted" });
    } catch (error) {
      log.error("Routes", "Failed to delete enforcement rule", {
        error
      });
      res.status(500).json({ error: "Failed to delete enforcement rule" });
    }
  }
);
router28.get(
  "/fundamentals/factors",
  authMiddleware,
  async (req, res) => {
    try {
      const { symbol } = req.query;
      let whereClause = void 0;
      if (symbol) {
        whereClause = eq28(universeFundamentals.symbol, symbol);
      }
      const factors = await db.query.universeFundamentals.findMany({
        where: whereClause,
        limit: 100
      });
      const factorList = [
        {
          id: "1",
          name: "P/E Ratio",
          source: "SEC EDGAR",
          cadence: "Quarterly",
          status: "healthy",
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "2",
          name: "Revenue Growth",
          source: "SEC EDGAR",
          cadence: "Quarterly",
          status: "healthy",
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "3",
          name: "Analyst Ratings",
          source: "Market Data",
          cadence: "Real-time",
          status: "healthy",
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "4",
          name: "Earnings Estimates",
          source: "Analyst Consensus",
          cadence: "Weekly",
          status: "healthy",
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
      res.json({
        factors: factorList,
        rawData: factors,
        count: factors.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get fundamentals", { error });
      res.status(500).json({ error: "Failed to get fundamentals" });
    }
  }
);
router28.post(
  "/fundamentals/refresh",
  authMiddleware,
  async (req, res) => {
    try {
      res.json({
        success: true,
        message: "Fundamental data refresh initiated"
      });
    } catch (error) {
      log.error("Routes", "Failed to refresh fundamentals", { error });
      res.status(500).json({ error: "Failed to refresh fundamentals" });
    }
  }
);
var enforcement_fundamentals_default = router28;

// server/routes/portfolio-trading.ts
init_storage();
init_alpaca();
init_logger();
async function authMiddleware2(req, res, next) {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      log.warn("Auth", "No session cookie found for request:", {
        path: req.path
      });
      return res.status(401).json({
        error: "Not authenticated",
        code: "NO_SESSION",
        message: "Please log in to access this resource"
      });
    }
    const session = await getSession(sessionId);
    if (!session) {
      log.warn("Auth", "Session expired or invalid:", {
        sessionId: sessionId.substring(0, 8) + "..."
      });
      return res.status(401).json({
        error: "Session expired",
        code: "SESSION_EXPIRED",
        message: "Your session has expired. Please log in again."
      });
    }
    req.userId = session.userId;
    next();
  } catch (error) {
    log.error("Auth", "Authentication error:", { error });
    res.status(500).json({
      error: "Authentication failed",
      code: "AUTH_ERROR"
    });
  }
}
function registerPortfolioTradingRoutes(app2) {
  app2.post("/api/strategy-config", authMiddleware2, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const config2 = normalizeMovingAverageConfig2(req.body);
      res.json(config2);
    } catch (error) {
      log.error("Routes", "Failed to normalize strategy config", {
        error
      });
      res.status(500).json({
        error: error.message || "Failed to normalize config"
      });
    }
  });
  app2.post("/api/strategy-validate", authMiddleware2, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const { validateMovingAverageConfig: validateMovingAverageConfig2, getValidatorStatus: getValidatorStatus2 } = await Promise.resolve().then(() => (init_ai_strategy_validator(), ai_strategy_validator_exports));
      const status = getValidatorStatus2();
      if (!status.available) {
        return res.status(503).json({ error: "AI validation service is not available" });
      }
      const config2 = normalizeMovingAverageConfig2(req.body.config || req.body);
      const result = await validateMovingAverageConfig2(config2);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to validate strategy", { error });
      res.status(500).json({
        error: error.message || "Failed to validate strategy"
      });
    }
  });
  app2.get("/api/portfolio/snapshot", authMiddleware2, async (req, res) => {
    try {
      const userId = req.userId;
      const account = await alpaca.getAccount();
      const positions2 = await storage.getPositions(userId);
      const totalEquity = parseFloat(account.equity);
      const totalCash = parseFloat(account.cash);
      const todayPnL = parseFloat(account.equity) - parseFloat(account.last_equity);
      const totalPositionValue = positions2.reduce(
        (sum, pos) => sum + parseFloat(pos.currentPrice || "0") * parseFloat(pos.quantity),
        0
      );
      res.json({
        totalEquity,
        totalCash,
        todayPnL,
        totalPositions: positions2.length,
        totalPositionValue,
        buyingPower: parseFloat(account.buying_power),
        portfolioValue: parseFloat(account.portfolio_value),
        lastEquity: parseFloat(account.last_equity),
        accountStatus: account.status,
        daytradeCount: parseInt(String(account.daytrade_count)),
        patternDayTrader: account.pattern_day_trader
      });
    } catch (error) {
      log.error("Routes", "Failed to get portfolio snapshot", { error });
      res.status(500).json({ error: "Failed to get portfolio snapshot" });
    }
  });
  app2.get("/api/trading/candidates", authMiddleware2, async (req, res) => {
    try {
      const userId = req.userId;
      const recentDecisions = await storage.getAiDecisions(userId, 50);
      const candidates = recentDecisions.filter(
        (d) => (d.action === "buy" || d.action === "sell") && d.status === "pending" && parseFloat(d.confidence || "0") >= 0.6
      ).map((d) => ({
        symbol: d.symbol,
        action: d.action,
        confidence: d.confidence,
        reasoning: d.reasoning,
        createdAt: d.createdAt,
        entryPrice: d.entryPrice,
        stopLoss: d.stopLoss,
        takeProfit: d.takeProfit
      })).slice(0, 20);
      res.json(candidates);
    } catch (error) {
      log.error("Routes", "Failed to get trading candidates", { error });
      res.status(500).json({ error: "Failed to get trading candidates" });
    }
  });
  app2.get("/api/portfolio/allocation", authMiddleware2, async (req, res) => {
    try {
      const [positions2, account] = await Promise.all([
        alpaca.getPositions(),
        alpaca.getAccount()
      ]);
      const portfolioValue = parseFloat(account.portfolio_value);
      const cash = parseFloat(account.cash);
      const dbPositions = await storage.getPositions(req.userId);
      const positionStrategyMap = new Map(
        dbPositions.map((p) => [p.symbol, p.strategyId])
      );
      const allocation = positions2.map((p) => {
        const marketValue = parseFloat(p.market_value);
        return {
          symbol: p.symbol,
          value: marketValue,
          percent: marketValue / portfolioValue * 100,
          qty: parseFloat(p.qty),
          currentPrice: parseFloat(p.current_price),
          unrealizedPnl: parseFloat(p.unrealized_pl),
          strategyId: positionStrategyMap.get(p.symbol) || null
        };
      });
      allocation.sort((a, b) => b.percent - a.percent);
      res.json({
        allocation,
        cash: {
          value: cash,
          percent: cash / portfolioValue * 100
        },
        portfolioValue,
        totalPositions: positions2.length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("PortfolioAPI", "Failed to get allocation", { error });
      return serverError(res, "Failed to get portfolio allocation");
    }
  });
  app2.get("/api/portfolio/positions", authMiddleware2, async (req, res) => {
    try {
      const { strategyId } = req.query;
      const [alpacaPositions, dbPositions] = await Promise.all([
        alpaca.getPositions(),
        storage.getPositions(req.userId)
      ]);
      const alpacaMap = new Map(alpacaPositions.map((p) => [p.symbol, p]));
      const dbMap = new Map(dbPositions.map((p) => [p.symbol, p]));
      const mergedPositions = alpacaPositions.map((ap) => {
        const dbPos = dbMap.get(ap.symbol);
        return {
          symbol: ap.symbol,
          qty: parseFloat(ap.qty),
          marketValue: parseFloat(ap.market_value),
          costBasis: parseFloat(ap.cost_basis),
          currentPrice: parseFloat(ap.current_price),
          unrealizedPnl: parseFloat(ap.unrealized_pl),
          unrealizedPnlPercent: parseFloat(ap.unrealized_plpc) * 100,
          avgEntryPrice: parseFloat(ap.avg_entry_price),
          side: parseFloat(ap.qty) > 0 ? "long" : "short",
          strategyId: dbPos?.strategyId || null,
          openedAt: dbPos?.openedAt || null,
          dbPositionId: dbPos?.id || null
        };
      });
      const filtered = strategyId ? mergedPositions.filter((p) => p.strategyId === strategyId) : mergedPositions;
      res.json({
        positions: filtered,
        count: filtered.length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("PortfolioAPI", "Failed to get positions", { error });
      return serverError(res, "Failed to get positions");
    }
  });
  app2.get("/api/portfolio/by-strategy", authMiddleware2, async (req, res) => {
    try {
      const [strategies2, dbPositions, trades3] = await Promise.all([
        storage.getStrategies(),
        storage.getPositions(req.userId),
        storage.getTrades(req.userId, 500)
      ]);
      const alpacaPositions = await alpaca.getPositions();
      const alpacaMap = new Map(alpacaPositions.map((p) => [p.symbol, p]));
      const strategyBreakdown = strategies2.map((strategy) => {
        const strategyPositions = dbPositions.filter(
          (p) => p.strategyId === strategy.id
        );
        const strategyTrades = trades3.filter(
          (t) => t.strategyId === strategy.id
        );
        const closedTrades = strategyTrades.filter((t) => t.pnl !== null);
        let totalMarketValue = 0;
        let totalUnrealizedPnl = 0;
        for (const pos of strategyPositions) {
          const alpacaPos = alpacaMap.get(pos.symbol);
          if (alpacaPos) {
            totalMarketValue += parseFloat(alpacaPos.market_value);
            totalUnrealizedPnl += parseFloat(alpacaPos.unrealized_pl);
          }
        }
        const totalRealizedPnl = closedTrades.reduce(
          (sum, t) => sum + parseFloat(t.pnl || "0"),
          0
        );
        const winningTrades = closedTrades.filter(
          (t) => parseFloat(t.pnl || "0") > 0
        );
        return {
          strategyId: strategy.id,
          strategyName: strategy.name,
          strategyType: strategy.type,
          isActive: strategy.isActive,
          positionCount: strategyPositions.length,
          totalMarketValue,
          unrealizedPnl: totalUnrealizedPnl,
          realizedPnl: totalRealizedPnl,
          totalPnl: totalUnrealizedPnl + totalRealizedPnl,
          totalTrades: strategyTrades.length,
          closedTrades: closedTrades.length,
          winRate: closedTrades.length > 0 ? winningTrades.length / closedTrades.length * 100 : 0,
          symbols: strategyPositions.map((p) => p.symbol)
        };
      });
      res.json({
        strategies: strategyBreakdown,
        totalStrategies: strategies2.length,
        activeStrategies: strategies2.filter((s) => s.isActive).length,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("PortfolioAPI", "Failed to get strategy breakdown", { error });
      return serverError(res, "Failed to get portfolio by strategy");
    }
  });
  app2.post(
    "/api/portfolio/rebalance/preview",
    authMiddleware2,
    async (req, res) => {
      try {
        const { targetAllocations } = req.body;
        if (!targetAllocations || !Array.isArray(targetAllocations)) {
          return badRequest(res, "targetAllocations array is required");
        }
        const totalTarget = targetAllocations.reduce(
          (sum, a) => sum + a.targetPercent,
          0
        );
        if (totalTarget > 100) {
          return badRequest(
            res,
            `Total target allocation (${totalTarget}%) exceeds 100%`
          );
        }
        const [positions2, account] = await Promise.all([
          alpaca.getPositions(),
          alpaca.getAccount()
        ]);
        const portfolioValue = parseFloat(account.portfolio_value);
        const positionMap = new Map(positions2.map((p) => [p.symbol, p]));
        const rebalanceActions = targetAllocations.map((target) => {
          const position = positionMap.get(target.symbol);
          const currentValue = position ? parseFloat(position.market_value) : 0;
          const currentPercent = currentValue / portfolioValue * 100;
          const targetValue = target.targetPercent / 100 * portfolioValue;
          const deltaValue = targetValue - currentValue;
          const currentPrice = position ? parseFloat(position.current_price) : 0;
          let action = "hold";
          if (deltaValue > 50) action = "buy";
          else if (deltaValue < -50) action = "sell";
          return {
            symbol: target.symbol,
            action,
            currentPercent,
            targetPercent: target.targetPercent,
            currentValue,
            targetValue,
            deltaValue,
            estimatedQty: currentPrice > 0 ? Math.abs(Math.floor(deltaValue / currentPrice)) : 0
          };
        });
        const buys = rebalanceActions.filter((a) => a.action === "buy");
        const sells = rebalanceActions.filter((a) => a.action === "sell");
        res.json({
          preview: {
            actions: rebalanceActions,
            totalBuys: buys.length,
            totalSells: sells.length,
            totalBuyValue: buys.reduce((sum, a) => sum + a.deltaValue, 0),
            totalSellValue: Math.abs(
              sells.reduce((sum, a) => sum + a.deltaValue, 0)
            )
          },
          portfolioValue,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      } catch (error) {
        log.error("PortfolioAPI", "Failed to preview rebalance", { error });
        return serverError(res, "Failed to preview rebalance");
      }
    }
  );
  log.info("Routes", "Portfolio trading routes registered");
}

// server/routes/alpaca.ts
init_alpaca();
init_alpaca_trading_engine();
init_logger();
init_sse_emitter();
import { Router as Router31 } from "express";

// server/validation/api-schemas.ts
import { z as z11 } from "zod";
var loginSchema = z11.object({
  username: z11.string().min(3, "Username must be at least 3 characters"),
  password: z11.string().min(6, "Password must be at least 6 characters")
});
var killSwitchSchema = z11.object({
  activate: z11.boolean(),
  reason: z11.string().optional()
});
var riskLimitsSchema = z11.object({
  maxPositionSizePercent: z11.number().min(1).max(100).optional(),
  maxTotalExposurePercent: z11.number().min(1).max(300).optional(),
  // Allow up to 300% for margin accounts
  maxPositionsCount: z11.number().min(1).max(100).optional(),
  dailyLossLimitPercent: z11.number().min(0.1).max(100).optional()
});
var modeSchema = z11.object({
  mode: z11.enum(["autonomous", "semi-auto", "manual"])
});
var closePositionSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required")
});
var executeTradesSchema = z11.object({
  decisionIds: z11.array(z11.string()).min(1, "At least one decision ID required")
});
var executeTradeSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  side: z11.enum(["buy", "sell"]),
  quantity: z11.number().positive().optional(),
  notional: z11.number().positive().optional(),
  orderType: z11.enum(["market", "limit", "stop", "stop_limit", "trailing_stop"]).optional(),
  limitPrice: z11.number().positive().optional(),
  stopPrice: z11.number().positive().optional(),
  timeInForce: z11.enum(["day", "gtc", "opg", "cls", "ioc", "fok"]).optional(),
  extendedHours: z11.boolean().optional(),
  takeProfitPrice: z11.number().positive().optional(),
  stopLossPrice: z11.number().positive().optional(),
  trailPercent: z11.number().positive().optional()
}).refine(
  (data) => data.quantity !== void 0 || data.notional !== void 0,
  { message: "Either quantity or notional amount is required" }
);
var quickTradeSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  side: z11.enum(["buy", "sell"]),
  amount: z11.number().positive("Amount must be positive"),
  orderType: z11.enum(["market", "limit"]).optional(),
  limitPrice: z11.number().positive().optional(),
  extendedHours: z11.boolean().optional()
});
var alpacaOrderSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  side: z11.enum(["buy", "sell"]),
  qty: z11.string().optional(),
  notional: z11.string().optional(),
  type: z11.enum(["market", "limit", "stop", "stop_limit", "trailing_stop"]).optional(),
  time_in_force: z11.enum(["day", "gtc", "opg", "cls", "ioc", "fok"]).optional(),
  limit_price: z11.string().optional(),
  stop_price: z11.string().optional(),
  extended_hours: z11.boolean().optional(),
  order_class: z11.enum(["simple", "bracket", "oco", "oto"]).optional(),
  take_profit: z11.object({ limit_price: z11.string() }).optional(),
  stop_loss: z11.object({
    stop_price: z11.string(),
    limit_price: z11.string().optional()
  }).optional(),
  trail_percent: z11.string().optional(),
  trail_price: z11.string().optional()
});
var bracketOrderSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  qty: z11.string().min(1, "Quantity is required"),
  side: z11.enum(["buy", "sell"]),
  type: z11.enum(["market", "limit"]).optional(),
  time_in_force: z11.enum(["day", "gtc"]).optional(),
  limit_price: z11.string().optional(),
  take_profit_price: z11.string().min(1, "Take profit price is required"),
  stop_loss_price: z11.string().min(1, "Stop loss price is required"),
  stop_loss_limit_price: z11.string().optional()
});
var trailingStopSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  qty: z11.string().min(1, "Quantity is required"),
  side: z11.enum(["buy", "sell"]),
  trail_percent: z11.number().positive().optional(),
  trail_price: z11.number().positive().optional(),
  time_in_force: z11.enum(["day", "gtc"]).optional()
});
var closeAllPositionsSchema = z11.object({
  cancelOrders: z11.boolean().optional()
});
var symbolParamSchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required")
});
var searchAssetsSchema = z11.object({
  query: z11.string().min(1, "Search query is required"),
  assetClass: z11.enum(["us_equity", "crypto"]).optional()
});
var analyzeOpportunitySchema = z11.object({
  symbol: z11.string().min(1, "Symbol is required"),
  marketData: z11.object({
    symbol: z11.string(),
    currentPrice: z11.number().positive(),
    priceChange24h: z11.number().optional(),
    priceChangePercent24h: z11.number().optional(),
    high24h: z11.number().optional(),
    low24h: z11.number().optional(),
    volume: z11.number().optional(),
    marketCap: z11.number().optional()
  }).optional(),
  newsContext: z11.object({
    headlines: z11.array(
      z11.object({
        title: z11.string(),
        source: z11.string().optional(),
        publishedAt: z11.string().optional(),
        sentiment: z11.number().optional()
      })
    ).optional(),
    overallSentiment: z11.number().optional()
  }).optional(),
  strategyContext: z11.object({
    id: z11.string().optional(),
    name: z11.string().optional(),
    type: z11.string().optional(),
    parameters: z11.record(z11.unknown()).optional()
  }).optional()
});
var barsQuerySchema = z11.object({
  timeframe: z11.string().optional(),
  start: z11.string().optional(),
  end: z11.string().optional(),
  limit: z11.string().optional()
});
var paginationSchema = z11.object({
  limit: z11.string().optional().transform((val) => val ? parseInt(val, 10) : void 0),
  offset: z11.string().optional().transform((val) => val ? parseInt(val, 10) : void 0)
});
var tradesFilterSchema = z11.object({
  limit: z11.string().optional().transform((val) => val ? parseInt(val, 10) : 20),
  offset: z11.string().optional().transform((val) => val ? parseInt(val, 10) : 0),
  symbol: z11.string().optional(),
  strategyId: z11.string().optional(),
  pnlDirection: z11.enum(["profit", "loss", "all"]).optional(),
  startDate: z11.string().optional(),
  endDate: z11.string().optional()
});
var portfolioHistorySchema = z11.object({
  period: z11.enum(["1D", "1W", "1M", "3M", "1A", "all"]).optional(),
  timeframe: z11.enum(["1Min", "5Min", "15Min", "1H", "1D"]).optional()
});
function validateRequest(schema, data) {
  const result = schema.safeParse(data);
  if (result.success) {
    return { success: true, data: result.data };
  }
  const errorMessage = result.error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join("; ");
  return { success: false, error: errorMessage };
}

// server/routes/alpaca.ts
var router29 = Router31();
router29.post(
  "/clear-cache",
  requireAdmin,
  asyncHandler(async (req, res) => {
    alpaca.clearCache();
    log.info("AlpacaAPI", "Cache cleared successfully");
    res.json({ success: true, message: "Alpaca cache cleared" });
  })
);
router29.get(
  "/account",
  requireAuth,
  asyncHandler(async (req, res) => {
    const account = await alpaca.getAccount();
    res.json(account);
  })
);
router29.get(
  "/positions",
  requireAuth,
  asyncHandler(async (req, res) => {
    const positions2 = await alpaca.getPositions();
    const DUST_THRESHOLD = 1e-4;
    const filteredPositions = positions2.filter((p) => {
      const qty = Math.abs(parseFloat(p.qty || "0"));
      return qty >= DUST_THRESHOLD;
    });
    res.json(filteredPositions);
  })
);
router29.get(
  "/assets",
  requireAuth,
  asyncHandler(async (req, res) => {
    const assetClass = req.query.asset_class || "us_equity";
    const assets = await alpaca.getAssets("active", assetClass);
    res.json(assets);
  })
);
router29.get(
  "/assets/search",
  requireAuth,
  asyncHandler(async (req, res) => {
    const query = (req.query.query || "").toUpperCase();
    if (!query) {
      return res.json([]);
    }
    const allAssets = await alpaca.getAssets("active", "us_equity");
    const matches = allAssets.filter(
      (a) => a.symbol.includes(query) || a.name && a.name.toUpperCase().includes(query)
    ).slice(0, 20);
    res.json(matches);
  })
);
router29.get(
  "/allocations",
  requireAuth,
  asyncHandler(async (req, res) => {
    const result = await alpacaTradingEngine.getCurrentAllocations();
    res.json(result);
  })
);
router29.post(
  "/rebalance/preview",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { targetAllocations } = req.body;
    if (!targetAllocations || !Array.isArray(targetAllocations)) {
      throw badRequestError("targetAllocations array required");
    }
    for (const alloc of targetAllocations) {
      if (!alloc.symbol || typeof alloc.targetPercent !== "number") {
        throw badRequestError(
          "Each allocation must have symbol and targetPercent"
        );
      }
    }
    const preview = await alpacaTradingEngine.previewRebalance(targetAllocations);
    res.json(preview);
  })
);
router29.post(
  "/rebalance/execute",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { targetAllocations, preview } = req.body;
    if (!targetAllocations || !Array.isArray(targetAllocations)) {
      throw badRequestError("targetAllocations array required");
    }
    const result = await alpacaTradingEngine.executeRebalance(
      targetAllocations,
      preview
    );
    res.json(result);
  })
);
router29.get(
  "/rebalance/suggestions",
  requireAuth,
  asyncHandler(async (req, res) => {
    const suggestions = await alpacaTradingEngine.getRebalanceSuggestions();
    res.json(suggestions);
  })
);
router29.get(
  "/bars",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { symbol, timeframe = "1Day", limit: limit4 = 100 } = req.query;
    if (!symbol) {
      throw badRequestError("symbol parameter required");
    }
    const symbolArr = symbol.split(",").map((s) => s.trim().toUpperCase());
    const bars = await alpaca.getBars(
      symbolArr,
      timeframe,
      void 0,
      void 0,
      parseInt(limit4)
    );
    res.json(bars);
  })
);
router29.get(
  "/snapshots",
  requireAuth,
  asyncHandler(async (req, res) => {
    const symbolsParam = req.query.symbols;
    if (!symbolsParam) {
      throw badRequestError("symbols parameter required");
    }
    const symbols = symbolsParam.split(",").map((s) => s.trim().toUpperCase());
    const snapshots = await alpaca.getSnapshots(symbols);
    const result = symbols.map((symbol) => {
      const snap = snapshots[symbol];
      if (!snap) {
        return { symbol, price: null, change: null, volume: null };
      }
      const price = snap.latestTrade?.p || snap.dailyBar?.c || 0;
      const prevClose = snap.prevDailyBar?.c || price;
      const change = price - prevClose;
      const changePercent = prevClose ? change / prevClose * 100 : 0;
      return {
        symbol,
        price,
        change,
        changePercent,
        volume: snap.dailyBar?.v || 0,
        high: snap.dailyBar?.h || 0,
        low: snap.dailyBar?.l || 0,
        open: snap.dailyBar?.o || 0
      };
    });
    res.json(result);
  })
);
router29.get(
  "/health",
  requireAuth,
  asyncHandler(async (req, res) => {
    const start = Date.now();
    const account = await alpaca.getAccount();
    const latencyMs = Date.now() - start;
    res.json({
      status: "healthy",
      latencyMs,
      accountStatus: account.status,
      tradingBlocked: account.trading_blocked,
      accountBlocked: account.account_blocked,
      buyingPower: account.buying_power,
      equity: account.equity
    });
  })
);
router29.post(
  "/reset-circuit-breaker",
  requireAdmin,
  asyncHandler(async (req, res) => {
    alpaca.resetCircuitBreaker();
    log.info("AlpacaAPI", "Circuit breaker reset successfully via API");
    res.json({
      success: true,
      message: "Circuit breaker reset successfully"
    });
  })
);
router29.get(
  "/orders",
  requireAuth,
  asyncHandler(async (req, res) => {
    const statusParam = req.query.status || "all";
    const status = statusParam === "open" ? "open" : statusParam === "closed" ? "closed" : "all";
    const limit4 = parseInt(req.query.limit) || 100;
    const orders2 = await alpaca.getOrders(status, limit4);
    res.json(orders2);
  })
);
router29.post(
  "/orders",
  requireAuth,
  asyncHandler(async (req, res) => {
    const validation = validateRequest(alpacaOrderSchema, req.body);
    if (!validation.success) {
      throw badRequestError(validation.error);
    }
    const {
      symbol,
      side,
      type,
      qty,
      notional,
      time_in_force,
      limit_price,
      stop_price
    } = validation.data;
    const orderParams = {
      symbol: symbol.toUpperCase(),
      side,
      type: type || "market",
      time_in_force: time_in_force || "day"
    };
    if (qty) orderParams.qty = String(qty);
    if (notional) orderParams.notional = String(notional);
    if (limit_price) orderParams.limit_price = String(limit_price);
    if (stop_price) orderParams.stop_price = String(stop_price);
    const order = await alpaca.createOrder(orderParams);
    const userId = req.user?.id;
    if (userId) {
      emitOrderUpdate(
        order.id,
        {
          status: order.status,
          symbol: order.symbol,
          side: order.side,
          qty: order.qty,
          filled_qty: order.filled_qty,
          type: order.type,
          created_at: order.created_at
        },
        userId
      );
    }
    res.json(order);
  })
);
router29.delete(
  "/orders/:orderId",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { orderId } = req.params;
    await alpaca.cancelOrder(orderId);
    res.json({ success: true, message: "Order cancelled" });
  })
);
router29.delete(
  "/orders",
  requireAuth,
  asyncHandler(async (req, res) => {
    await alpaca.cancelAllOrders();
    res.json({ success: true, message: "All orders cancelled" });
  })
);
router29.delete(
  "/positions/:symbol",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { symbol } = req.params;
    const result = await alpaca.closePosition(symbol);
    res.json(result);
  })
);
router29.delete(
  "/positions",
  requireAuth,
  asyncHandler(async (req, res) => {
    const result = await alpaca.closeAllPositions();
    res.json(result);
  })
);
router29.get(
  "/clock",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { alpacaTradingEngine: alpacaTradingEngine2 } = await Promise.resolve().then(() => (init_alpaca_trading_engine(), alpaca_trading_engine_exports));
    const clock = await alpacaTradingEngine2.getClock();
    res.json(clock);
  })
);
router29.get(
  "/market-status",
  requireAuth,
  asyncHandler(async (req, res) => {
    const { alpacaTradingEngine: alpacaTradingEngine2 } = await Promise.resolve().then(() => (init_alpaca_trading_engine(), alpaca_trading_engine_exports));
    const status = await alpacaTradingEngine2.getMarketStatus();
    res.json(status);
  })
);
router29.get(
  "/can-trade-extended/:symbol",
  asyncHandler(async (req, res) => {
    const { symbol } = req.params;
    const { alpacaTradingEngine: alpacaTradingEngine2 } = await Promise.resolve().then(() => (init_alpaca_trading_engine(), alpaca_trading_engine_exports));
    const result = await alpacaTradingEngine2.canTradeExtendedHours(symbol);
    res.json(result);
  })
);
router29.get(
  "/portfolio-history",
  requireAuth,
  asyncHandler(async (req, res) => {
    const period = req.query.period || "1M";
    const timeframe = req.query.timeframe || "1D";
    const history = await alpaca.getPortfolioHistory(period, timeframe);
    res.json(history);
  })
);
router29.get(
  "/top-stocks",
  requireAuth,
  asyncHandler(async (req, res) => {
    const limit4 = parseInt(req.query.limit) || 25;
    const stocks = await alpaca.getTopStocks(limit4);
    res.json(stocks);
  })
);
router29.get(
  "/top-crypto",
  requireAuth,
  asyncHandler(async (req, res) => {
    const limit4 = parseInt(req.query.limit) || 25;
    const crypto5 = await alpaca.getTopCrypto(limit4);
    res.json(crypto5);
  })
);
router29.get(
  "/top-etfs",
  requireAuth,
  asyncHandler(async (req, res) => {
    const limit4 = parseInt(req.query.limit) || 25;
    const etfs = await alpaca.getTopETFs(limit4);
    res.json(etfs);
  })
);
router29.post(
  "/validate-order",
  requireAuth,
  asyncHandler(async (req, res) => {
    const validation = alpaca.validateOrder(req.body);
    res.json(validation);
  })
);
var alpaca_default = router29;

// server/routes/alpaca-trading.ts
init_alpaca_trading_engine();
init_numeric();
init_logger();
import { Router as Router32 } from "express";
var router30 = Router32();
router30.get("/status", requireAuth, async (req, res) => {
  try {
    const status = alpacaTradingEngine.getStatus();
    const connected = await alpacaTradingEngine.isAlpacaConnected();
    res.json({ ...status, alpacaConnected: connected });
  } catch (error) {
    log.error("AlpacaTradingAPI", "Failed to get Alpaca trading status", {
      error
    });
    res.status(500).json({ error: "Failed to get Alpaca trading status" });
  }
});
router30.post("/execute", requireAuth, async (req, res) => {
  try {
    const { symbol, side, quantity, strategyId, notes, orderType, limitPrice } = req.body;
    if (!symbol || !side || !quantity) {
      return res.status(400).json({ error: "Symbol, side, and quantity are required" });
    }
    if (!["buy", "sell"].includes(side)) {
      return res.status(400).json({ error: "Side must be 'buy' or 'sell'" });
    }
    const result = await alpacaTradingEngine.executeAlpacaTrade({
      symbol,
      side,
      quantity: safeParseFloat(quantity),
      strategyId,
      notes,
      orderType,
      limitPrice: limitPrice ? safeParseFloat(limitPrice) : void 0,
      authorizedByOrchestrator: true
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    res.json(result);
  } catch (error) {
    log.error("AlpacaTradingAPI", "Alpaca trade execution error", { error });
    res.status(500).json({ error: "Failed to execute Alpaca trade" });
  }
});
router30.post(
  "/close/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const { strategyId } = req.body;
      const result = await alpacaTradingEngine.closeAlpacaPosition(
        symbol,
        strategyId,
        {
          authorizedByOrchestrator: true
        }
      );
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json(result);
    } catch (error) {
      log.error("AlpacaTradingAPI", "Close Alpaca position error", { error });
      res.status(500).json({ error: "Failed to close Alpaca position" });
    }
  }
);
router30.post("/analyze", requireAuth, async (req, res) => {
  try {
    const { symbol, strategyId } = req.body;
    if (!symbol) {
      return res.status(400).json({ error: "Symbol is required" });
    }
    const result = await alpacaTradingEngine.analyzeSymbol(symbol, strategyId);
    res.json(result);
  } catch (error) {
    log.error("AlpacaTradingAPI", "Analyze symbol error", { error });
    res.status(500).json({ error: "Failed to analyze symbol" });
  }
});
router30.post(
  "/analyze-execute",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol, strategyId } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const result = await alpacaTradingEngine.analyzeAndExecute(
        symbol,
        strategyId
      );
      res.json(result);
    } catch (error) {
      log.error("AlpacaTradingAPI", "Analyze and execute error", { error });
      res.status(500).json({ error: "Failed to analyze and execute trade" });
    }
  }
);
router30.post("/stop-all", requireAuth, async (req, res) => {
  try {
    await alpacaTradingEngine.stopAllStrategies();
    res.json({ success: true, message: "All strategies stopped" });
  } catch (error) {
    log.error("AlpacaTradingAPI", "Stop all strategies error", { error });
    res.status(500).json({ error: "Failed to stop all strategies" });
  }
});
var alpaca_trading_default = router30;

// server/routes/uae-markets.ts
init_logger();
import { Router as Router33 } from "express";

// server/connectors/uae-markets.ts
init_api_cache();
init_logger();
var DUBAI_PULSE_API_KEY = process.env.UAE_MARKETS_API_KEY || "";
var DUBAI_PULSE_BASE_URL = "https://api.dubaipulse.gov.ae";
var UAE_MARKET_INFO = {
  exchanges: {
    ADX: {
      name: "ADX",
      fullName: "Abu Dhabi Securities Exchange",
      website: "https://www.adx.ae",
      currency: "AED",
      timezone: "GST (UTC+4)",
      tradingHours: "10:00 AM - 2:00 PM (Sun-Thu)",
      established: 2e3
    },
    DFM: {
      name: "DFM",
      fullName: "Dubai Financial Market",
      website: "https://www.dfm.ae",
      currency: "AED",
      timezone: "GST (UTC+4)",
      tradingHours: "10:00 AM - 2:00 PM (Sun-Thu)",
      established: 2e3
    }
  },
  apiProviders: [
    {
      name: "Dubai Pulse Open API",
      type: "free",
      coverage: ["DFM"],
      features: ["DFM Indices", "Market Summary", "OAuth Authentication"],
      url: "https://www.dubaipulse.gov.ae/data/dfm-general/dfm_indices-open-api"
    },
    {
      name: "DFM Native API",
      type: "free",
      coverage: ["DFM"],
      features: ["SOAP/XML Format", "Market Summary", "Real-time Prices"],
      url: "https://api.dfm.ae"
    },
    {
      name: "Twelve Data",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["REST API", "Real-time & Historical", "Analyst Ratings"],
      url: "https://twelvedata.com"
    },
    {
      name: "ICE Data Services",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["Native & Normalized Feed", "Level 1 & 2", "Historical Data"],
      url: "https://developer.ice.com"
    },
    {
      name: "LSEG (Refinitiv)",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["Low Latency Feed", "Market Depth", "Full Tick History"],
      url: "https://www.lseg.com"
    }
  ],
  regulatoryAuthority: "UAE Securities and Commodities Authority (SCA)",
  notes: "UAE markets operate Sunday-Thursday. First exchange globally to operate under Islamic Sharia principles (DFM)."
};
var UAEMarketsConnector = class {
  stocksCache = new ApiCache({
    freshDuration: 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  summaryCache = new ApiCache({
    freshDuration: 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  apiCallCount = 0;
  lastApiCallTime = null;
  usingLiveData = false;
  /**
   * Fetch DFM index data from Dubai Pulse Open API
   */
  async fetchDubaiPulseIndices() {
    try {
      this.apiCallCount++;
      this.lastApiCallTime = /* @__PURE__ */ new Date();
      const url = `${DUBAI_PULSE_BASE_URL}/data/dfm-general/dfm-indices`;
      const response = await fetch(url, {
        headers: {
          Authorization: `Bearer ${DUBAI_PULSE_API_KEY}`,
          Accept: "application/json"
        },
        signal: AbortSignal.timeout(1e4)
        // 10s timeout
      });
      if (!response.ok) {
        log.warn("UAEMarkets", `Dubai Pulse API returned ${response.status}`);
        return null;
      }
      const data = await response.json();
      const records = data?.data?.records;
      if (!records || records.length === 0) {
        log.warn("UAEMarkets", "No records in Dubai Pulse response");
        return null;
      }
      const record = records[0];
      const indexValue = parseFloat(String(record.Index_Value || 0));
      const change = parseFloat(String(record.Change || 0));
      const changePercent = parseFloat(String(record.Change_Percentage || 0));
      const volume = parseFloat(String(record.Volume || 0));
      const value = parseFloat(String(record.Value || 0));
      this.usingLiveData = true;
      return {
        exchange: "DFM",
        indexName: record.Index_Name || "DFM General Index",
        indexValue,
        change,
        changePercent,
        tradingValue: value,
        tradingVolume: volume,
        advancers: 0,
        // Not provided by this API
        decliners: 0,
        unchanged: 0,
        lastUpdated: record.Trade_Date || (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      log.error("UAEMarkets", `Failed to fetch Dubai Pulse data: ${error}`);
      this.usingLiveData = false;
      return null;
    }
  }
  /**
   * Fetch stocks with live API integration
   * Returns empty array when API key not configured
   */
  async getTopStocks(exchange) {
    const cacheKey = `stocks_${exchange || "all"}`;
    const cached = this.stocksCache.get(cacheKey);
    if (cached?.isFresh) {
      return cached.data;
    }
    if (!DUBAI_PULSE_API_KEY) {
      log.info(
        "UAEMarkets",
        "UAE_MARKETS_API_KEY not configured - returning empty stock list"
      );
      return [];
    }
    log.info(
      "UAEMarkets",
      "Live stock data requires DFM Native API or premium provider (Twelve Data, ICE Data Services, LSEG)"
    );
    const stocks = [];
    this.stocksCache.set(cacheKey, stocks);
    return stocks;
  }
  /**
   * Fetch market summary with live API integration
   * Returns only live data from Dubai Pulse API or empty array
   */
  async getMarketSummary(exchange) {
    const cacheKey = `summary_${exchange || "all"}`;
    const cached = this.summaryCache.get(cacheKey);
    if (cached?.isFresh) {
      return cached.data;
    }
    if (!DUBAI_PULSE_API_KEY) {
      log.info(
        "UAEMarkets",
        "UAE_MARKETS_API_KEY not configured - returning empty market summary"
      );
      return [];
    }
    let summaries = [];
    if (!exchange || exchange === "DFM") {
      const liveDfmData = await this.fetchDubaiPulseIndices();
      if (liveDfmData) {
        summaries.push(liveDfmData);
        log.info("UAEMarkets", "Using live DFM data from Dubai Pulse API");
      }
    }
    if (!exchange || exchange === "ADX") {
      log.info(
        "UAEMarkets",
        "ADX market summary requires premium data provider (Twelve Data, ICE Data Services, LSEG)"
      );
    }
    if (exchange) {
      summaries = summaries.filter((s) => s.exchange === exchange);
    }
    this.summaryCache.set(cacheKey, summaries);
    return summaries;
  }
  getMarketInfo() {
    return { ...UAE_MARKET_INFO };
  }
  getConnectionStatus() {
    return {
      connected: !!DUBAI_PULSE_API_KEY,
      dataSource: this.usingLiveData ? "live" : "unavailable",
      cacheSize: this.stocksCache.size() + this.summaryCache.size(),
      apiCallCount: this.apiCallCount,
      lastApiCall: this.lastApiCallTime?.toISOString() || null,
      apiConfigured: !!DUBAI_PULSE_API_KEY
    };
  }
  clearCache() {
    this.stocksCache.clear();
    this.summaryCache.clear();
  }
};
var uaeMarkets = new UAEMarketsConnector();

// server/routes/uae-markets.ts
var router31 = Router33();
router31.get("/stocks", requireAuth, async (req, res) => {
  try {
    const exchange = req.query.exchange;
    const stocks = await uaeMarkets.getTopStocks(exchange);
    res.json(stocks);
  } catch (error) {
    log.error("Routes", "Failed to fetch UAE stocks", { error });
    res.status(500).json({ error: "Failed to fetch UAE stocks" });
  }
});
router31.get("/summary", requireAuth, async (req, res) => {
  try {
    const exchange = req.query.exchange;
    const summary = await uaeMarkets.getMarketSummary(exchange);
    res.json(summary);
  } catch (error) {
    log.error("Routes", "Failed to fetch UAE market summary", { error });
    res.status(500).json({ error: "Failed to fetch UAE market summary" });
  }
});
router31.get("/info", requireAuth, async (req, res) => {
  try {
    const info = uaeMarkets.getMarketInfo();
    res.json(info);
  } catch (error) {
    log.error("Routes", "Failed to fetch UAE market info", { error });
    res.status(500).json({ error: "Failed to fetch UAE market info" });
  }
});
router31.get("/status", requireAuth, async (req, res) => {
  try {
    const status = uaeMarkets.getConnectionStatus();
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: "Failed to get UAE connector status" });
  }
});
var uae_markets_default = router31;

// server/routes/news.ts
init_logger();
import { Router as Router34 } from "express";
init_newsapi();
var router32 = Router34();
router32.get("/headlines", requireAuth, async (req, res) => {
  try {
    const category = req.query.category || "business";
    const country = req.query.country || "us";
    const pageSize = parseInt(req.query.pageSize) || 20;
    const headlines = await newsapi.getTopHeadlines(
      category,
      country,
      pageSize
    );
    res.json(headlines);
  } catch (error) {
    log.error("Routes", "Failed to get news headlines", { error });
    res.status(500).json({ error: "Failed to get news headlines" });
  }
});
router32.get("/search", requireAuth, async (req, res) => {
  try {
    const query = req.query.q;
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const sortBy = req.query.sortBy || "publishedAt";
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.searchNews(query, sortBy, pageSize);
    res.json(articles);
  } catch (error) {
    log.error("Routes", "Failed to search news", { error });
    res.status(500).json({ error: "Failed to search news" });
  }
});
router32.get("/market", requireAuth, async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getMarketNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("Routes", "Failed to get market news", { error });
    res.status(500).json({ error: "Failed to get market news" });
  }
});
router32.get("/crypto", requireAuth, async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getCryptoNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("Routes", "Failed to get crypto news", { error });
    res.status(500).json({ error: "Failed to get crypto news" });
  }
});
router32.get(
  "/stock/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const pageSize = parseInt(req.query.pageSize) || 10;
      const articles = await newsapi.getStockNews(symbol, pageSize);
      res.json(articles);
    } catch (error) {
      log.error("Routes", "Failed to get stock news", { error });
      res.status(500).json({ error: "Failed to get stock news" });
    }
  }
);
var news_default = router32;

// server/routes/user-preferences.ts
init_storage();
init_logger();
import { Router as Router35 } from "express";
init_schema2();
var router33 = Router35();
async function requireAuth7(req, res, next) {
  const sessionId = req.cookies?.session;
  if (!sessionId) {
    return unauthorized(res, "Authentication required");
  }
  const session = await getSession(sessionId);
  if (!session) {
    return unauthorized(res, "Invalid or expired session");
  }
  req.userId = session.userId;
  next();
}
router33.get("/", requireAuth7, async (req, res) => {
  try {
    const userId = req.userId;
    const preferences = await storage.getOrCreateUserPreferences(userId);
    log.debug("UserPreferencesAPI", "Retrieved preferences", { userId });
    res.json(preferences);
  } catch (error) {
    log.error("UserPreferencesAPI", "Failed to get preferences", { error });
    serverError(res, "Failed to retrieve preferences");
  }
});
router33.put("/", requireAuth7, async (req, res) => {
  try {
    const userId = req.userId;
    const parsed = updateUserPreferencesSchema.safeParse(req.body);
    if (!parsed.success) {
      return fromZodError(res, parsed.error);
    }
    await storage.getOrCreateUserPreferences(userId);
    const updated = await storage.updateUserPreferences(userId, parsed.data);
    if (!updated) {
      return serverError(res, "Failed to update preferences");
    }
    log.info("UserPreferencesAPI", "Updated preferences", {
      userId,
      updates: Object.keys(parsed.data)
    });
    res.json(updated);
  } catch (error) {
    log.error("UserPreferencesAPI", "Failed to update preferences", { error });
    serverError(res, "Failed to update preferences");
  }
});
router33.patch("/", requireAuth7, async (req, res) => {
  try {
    const userId = req.userId;
    const parsed = updateUserPreferencesSchema.safeParse(req.body);
    if (!parsed.success) {
      return fromZodError(res, parsed.error);
    }
    await storage.getOrCreateUserPreferences(userId);
    const updated = await storage.updateUserPreferences(userId, parsed.data);
    if (!updated) {
      return serverError(res, "Failed to update preferences");
    }
    log.info("UserPreferencesAPI", "Patched preferences", {
      userId,
      fields: Object.keys(parsed.data)
    });
    res.json(updated);
  } catch (error) {
    log.error("UserPreferencesAPI", "Failed to patch preferences", { error });
    serverError(res, "Failed to update preferences");
  }
});
router33.delete("/", requireAuth7, async (req, res) => {
  try {
    const userId = req.userId;
    await storage.deleteUserPreferences(userId);
    const defaults = await storage.createUserPreferences(userId);
    log.info("UserPreferencesAPI", "Reset preferences to defaults", { userId });
    res.json(defaults);
  } catch (error) {
    log.error("UserPreferencesAPI", "Failed to reset preferences", { error });
    serverError(res, "Failed to reset preferences");
  }
});
var user_preferences_default = router33;

// server/routes/notification-preferences.ts
init_storage();
init_logger();
import { Router as Router36 } from "express";
init_schema2();
var router34 = Router36();
async function requireAuth8(req, res, next) {
  const sessionId = req.cookies?.session;
  if (!sessionId) {
    return unauthorized(res, "Authentication required");
  }
  const session = await getSession(sessionId);
  if (!session) {
    return unauthorized(res, "Invalid or expired session");
  }
  req.userId = session.userId;
  next();
}
router34.get("/", requireAuth8, async (req, res) => {
  try {
    const userId = req.userId;
    const preferences = await storage.getOrCreateNotificationPreferences(userId);
    log.debug(
      "NotificationPreferencesAPI",
      "Retrieved notification preferences",
      { userId }
    );
    res.json(preferences);
  } catch (error) {
    log.error(
      "NotificationPreferencesAPI",
      "Failed to get notification preferences",
      { error }
    );
    serverError(res, "Failed to retrieve notification preferences");
  }
});
router34.put("/", requireAuth8, async (req, res) => {
  try {
    const userId = req.userId;
    const parsed = updateNotificationPreferencesSchema.safeParse(req.body);
    if (!parsed.success) {
      return fromZodError(res, parsed.error);
    }
    await storage.getOrCreateNotificationPreferences(userId);
    const updated = await storage.updateNotificationPreferences(
      userId,
      parsed.data
    );
    if (!updated) {
      return serverError(res, "Failed to update notification preferences");
    }
    log.info("NotificationPreferencesAPI", "Updated notification preferences", {
      userId,
      updates: Object.keys(parsed.data)
    });
    res.json(updated);
  } catch (error) {
    log.error(
      "NotificationPreferencesAPI",
      "Failed to update notification preferences",
      { error }
    );
    serverError(res, "Failed to update notification preferences");
  }
});
router34.patch("/", requireAuth8, async (req, res) => {
  try {
    const userId = req.userId;
    const parsed = updateNotificationPreferencesSchema.safeParse(req.body);
    if (!parsed.success) {
      return fromZodError(res, parsed.error);
    }
    await storage.getOrCreateNotificationPreferences(userId);
    const updated = await storage.updateNotificationPreferences(
      userId,
      parsed.data
    );
    if (!updated) {
      return serverError(res, "Failed to update notification preferences");
    }
    log.info("NotificationPreferencesAPI", "Patched notification preferences", {
      userId,
      fields: Object.keys(parsed.data)
    });
    res.json(updated);
  } catch (error) {
    log.error(
      "NotificationPreferencesAPI",
      "Failed to patch notification preferences",
      { error }
    );
    serverError(res, "Failed to update notification preferences");
  }
});
router34.delete("/", requireAuth8, async (req, res) => {
  try {
    const userId = req.userId;
    await storage.deleteNotificationPreferences(userId);
    const defaults = await storage.createDefaultNotificationPreferences(userId);
    log.info(
      "NotificationPreferencesAPI",
      "Reset notification preferences to defaults",
      { userId }
    );
    res.json(defaults);
  } catch (error) {
    log.error(
      "NotificationPreferencesAPI",
      "Failed to reset notification preferences",
      { error }
    );
    serverError(res, "Failed to reset notification preferences");
  }
});
var notification_preferences_default = router34;

// server/routes/cmc.ts
init_logger();
import { Router as Router37 } from "express";

// server/connectors/coinmarketcap.ts
init_api_cache();
init_connectorClient();
init_logger();
var CMC_BASE_URL = "https://pro-api.coinmarketcap.com";
var PROVIDER = "coinmarketcap";
var CoinMarketCapConnector = class {
  listingsCache = new ApiCache({
    freshDuration: 5 * 60 * 1e3,
    staleDuration: 60 * 60 * 1e3
  });
  quotesCache = new ApiCache({
    freshDuration: 5 * 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  globalCache = new ApiCache({
    freshDuration: 10 * 60 * 1e3,
    staleDuration: 60 * 60 * 1e3
  });
  mapCache = new ApiCache({
    freshDuration: 60 * 60 * 1e3,
    staleDuration: 24 * 60 * 60 * 1e3
  });
  getApiKey() {
    return process.env.COINMARKETCAP_API_KEY;
  }
  getAuthHeaders() {
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    return {
      "X-CMC_PRO_API_KEY": apiKey2,
      Accept: "application/json"
    };
  }
  async getLatestListings(start = 1, limit4 = 100, sort = "market_cap", sortDir = "desc") {
    const l1CacheKey = `listings_${start}_${limit4}_${sort}_${sortDir}`;
    const l1Cached = this.listingsCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      const stale = this.listingsCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/listings/latest?start=${start}&limit=${limit4}&sort=${sort}&sort_dir=${sortDir}&convert=USD`;
    const cacheKey = buildCacheKey(
      PROVIDER,
      "listings",
      start,
      limit4,
      sort,
      sortDir
    );
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "listings/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(
        result.data.status.error_message || "CoinMarketCap API error"
      );
    }
    const data = result.data.data;
    this.listingsCache.set(l1CacheKey, data);
    return data;
  }
  async getQuotes(ids) {
    const idsParam = ids.join(",");
    const l1CacheKey = `quotes_${idsParam}`;
    const l1Cached = this.quotesCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      const stale = this.quotesCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/quotes/latest?id=${idsParam}&convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "quotes", idsParam);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "quotes/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(
        result.data.status.error_message || "CoinMarketCap API error"
      );
    }
    const data = result.data.data;
    this.quotesCache.set(l1CacheKey, data);
    return data;
  }
  async getQuotesBySymbols(symbols) {
    const symbolsParam = symbols.join(",");
    const l1CacheKey = `quotes_symbols_${symbolsParam}`;
    const l1Cached = this.quotesCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      const stale = this.quotesCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/quotes/latest?symbol=${symbolsParam}&convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "quotes_symbols", symbolsParam);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "quotes/latest/symbols",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(
        result.data.status.error_message || "CoinMarketCap API error"
      );
    }
    const data = result.data.data;
    this.quotesCache.set(l1CacheKey, data);
    return data;
  }
  async getGlobalMetrics() {
    const l1CacheKey = "global_metrics";
    const l1Cached = this.globalCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      const stale = this.globalCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/global-metrics/quotes/latest?convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "global_metrics");
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "global-metrics/quotes/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(
        result.data.status.error_message || "CoinMarketCap API error"
      );
    }
    const data = result.data.data;
    this.globalCache.set(l1CacheKey, data);
    return data;
  }
  async getCryptoMap(start = 1, limit4 = 5e3, sort = "cmc_rank") {
    const l1CacheKey = `map_${start}_${limit4}_${sort}`;
    const l1Cached = this.mapCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey2 = this.getApiKey();
    if (!apiKey2) {
      const stale = this.mapCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/map?start=${start}&limit=${limit4}&sort=${sort}`;
    const cacheKey = buildCacheKey(PROVIDER, "map", start, limit4, sort);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "cryptocurrency/map",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(
        result.data.status.error_message || "CoinMarketCap API error"
      );
    }
    const data = result.data.data;
    this.mapCache.set(l1CacheKey, data);
    return data;
  }
  async searchCryptos(query, limit4 = 20) {
    const allCryptos = await this.getCryptoMap(1, 500);
    const lowerQuery = query.toLowerCase();
    return allCryptos.filter(
      (crypto5) => crypto5.symbol.toLowerCase().includes(lowerQuery) || crypto5.name.toLowerCase().includes(lowerQuery)
    ).slice(0, limit4);
  }
  getConnectionStatus() {
    const totalCacheSize = this.listingsCache.size() + this.quotesCache.size() + this.globalCache.size() + this.mapCache.size();
    return {
      connected: !!this.getApiKey(),
      hasApiKey: !!this.getApiKey(),
      cacheSize: totalCacheSize
    };
  }
  clearCache() {
    this.listingsCache.clear();
    this.quotesCache.clear();
    this.globalCache.clear();
    this.mapCache.clear();
  }
};
var coinmarketcap = new CoinMarketCapConnector();

// server/routes/cmc.ts
var router35 = Router37();
router35.get("/listings", requireAuth, async (req, res) => {
  try {
    const start = parseInt(req.query.start) || 1;
    const limit4 = parseInt(req.query.limit) || 100;
    const listings = await coinmarketcap.getLatestListings(start, limit4);
    res.json(listings);
  } catch (error) {
    log.error("Routes", "Failed to get CMC listings", { error });
    res.status(500).json({ error: "Failed to get CoinMarketCap listings" });
  }
});
router35.get("/quotes", requireAuth, async (req, res) => {
  try {
    const symbols = req.query.symbols?.split(",") || ["BTC", "ETH"];
    const quotes = await coinmarketcap.getQuotesBySymbols(symbols);
    res.json(quotes);
  } catch (error) {
    log.error("Routes", "Failed to get CMC quotes", { error });
    res.status(500).json({ error: "Failed to get CoinMarketCap quotes" });
  }
});
router35.get("/global", requireAuth, async (req, res) => {
  try {
    const metrics = await coinmarketcap.getGlobalMetrics();
    res.json(metrics);
  } catch (error) {
    log.error("Routes", "Failed to get CMC global metrics", { error });
    res.status(500).json({ error: "Failed to get CoinMarketCap global metrics" });
  }
});
router35.get("/search", requireAuth, async (req, res) => {
  try {
    const query = req.query.q;
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const results = await coinmarketcap.searchCryptos(query);
    res.json(results);
  } catch (error) {
    log.error("Routes", "Failed to search CMC", { error });
    res.status(500).json({ error: "Failed to search CoinMarketCap" });
  }
});
var cmc_default = router35;

// server/routes/trading-sessions.ts
init_trading_session_manager();
init_logger();
import { Router as Router38 } from "express";
var router36 = Router38();
router36.get("/all", requireAuth, async (req, res) => {
  try {
    const allSessions = tradingSessionManager.getAllSessionInfo();
    res.json({
      sessions: allSessions,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("TradingSessionsRoutes", "Failed to get all trading sessions", {
      error
    });
    res.status(500).json({ error: "Failed to get trading sessions" });
  }
});
router36.get("/:exchange", requireAuth, async (req, res) => {
  try {
    const { exchange } = req.params;
    const session = tradingSessionManager.getCurrentSession(
      exchange.toUpperCase()
    );
    const config2 = tradingSessionManager.getSessionConfig(
      exchange.toUpperCase()
    );
    res.json({
      exchange: exchange.toUpperCase(),
      session,
      config: config2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("TradingSessionsRoutes", "Failed to get trading session", {
      error
    });
    res.status(500).json({ error: "Failed to get trading session" });
  }
});
router36.get(
  "/:exchange/is-open",
  requireAuth,
  async (req, res) => {
    try {
      const { exchange } = req.params;
      const isOpen = tradingSessionManager.isMarketOpen(exchange.toUpperCase());
      res.json({
        exchange: exchange.toUpperCase(),
        isOpen,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("TradingSessionsRoutes", "Failed to check if market is open", {
        error
      });
      res.status(500).json({ error: "Failed to check market status" });
    }
  }
);
router36.get(
  "/:exchange/next-open",
  requireAuth,
  async (req, res) => {
    try {
      const { exchange } = req.params;
      const nextOpen = tradingSessionManager.getNextMarketOpen(
        exchange.toUpperCase()
      );
      res.json({
        exchange: exchange.toUpperCase(),
        nextOpen: nextOpen?.toISOString() || null,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("TradingSessionsRoutes", "Failed to get next market open", {
        error
      });
      res.status(500).json({ error: "Failed to get next market open" });
    }
  }
);
router36.get(
  "/:exchange/volatility",
  requireAuth,
  async (req, res) => {
    try {
      const { exchange } = req.params;
      const session = tradingSessionManager.getCurrentSession(
        exchange.toUpperCase()
      );
      const volatilityMultiplier = tradingSessionManager.getSessionVolatilityMultiplier(
        exchange.toUpperCase(),
        session.session
      );
      res.json({
        exchange: exchange.toUpperCase(),
        session: session.session,
        volatilityMultiplier,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error(
        "TradingSessionsRoutes",
        "Failed to get volatility multiplier",
        {
          error
        }
      );
      res.status(500).json({ error: "Failed to get volatility multiplier" });
    }
  }
);
var trading_sessions_default = router36;

// server/routes/feeds.ts
init_logger();
import { Router as Router39 } from "express";

// server/services/connector-metrics-service.ts
init_db();
init_schema2();
init_logger();
import { eq as eq29, and as and19, gte as gte9, desc as desc21 } from "drizzle-orm";
var ConnectorMetricsService = class {
  memoryBuffer;
  flushIntervalMs = 6e4;
  flushTimer = null;
  constructor() {
    this.memoryBuffer = /* @__PURE__ */ new Map();
    this.startFlushTimer();
  }
  getBufferKey(connector, endpoint) {
    return `${connector}:${endpoint}`;
  }
  startFlushTimer() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
    }
    this.flushTimer = setInterval(() => {
      this.flushToDatabase().catch((err) => {
        log.error("ConnectorMetricsService", "Failed to flush metrics", {
          error: err
        });
      });
    }, this.flushIntervalMs);
  }
  recordEvent(event) {
    const key = this.getBufferKey(event.connector, event.endpoint);
    let buffer = this.memoryBuffer.get(key);
    if (!buffer) {
      buffer = {
        totalRequests: 0,
        successCount: 0,
        failureCount: 0,
        cacheHits: 0,
        cacheMisses: 0,
        rateLimitHits: 0,
        fallbackUsed: 0,
        latencies: { latencies: [], maxSize: 1e3 }
      };
      this.memoryBuffer.set(key, buffer);
    }
    buffer.totalRequests++;
    if (event.success) {
      buffer.successCount++;
    } else {
      buffer.failureCount++;
      buffer.lastError = event.error;
      buffer.lastErrorAt = /* @__PURE__ */ new Date();
    }
    if (event.cacheHit) {
      buffer.cacheHits++;
    } else {
      buffer.cacheMisses++;
    }
    if (event.rateLimited) {
      buffer.rateLimitHits++;
    }
    if (event.usedFallback) {
      buffer.fallbackUsed++;
    }
    if (buffer.latencies.latencies.length < buffer.latencies.maxSize) {
      buffer.latencies.latencies.push(event.latencyMs);
    }
  }
  calculatePercentile(sorted, percentile) {
    if (sorted.length === 0) return 0;
    const index18 = Math.ceil(percentile / 100 * sorted.length) - 1;
    return sorted[Math.max(0, index18)];
  }
  calculateStats(latencies) {
    if (latencies.length === 0) {
      return { avg: 0, p50: 0, p95: 0, p99: 0 };
    }
    const sorted = [...latencies].sort((a, b) => a - b);
    const sum = sorted.reduce((a, b) => a + b, 0);
    return {
      avg: sum / sorted.length,
      p50: this.calculatePercentile(sorted, 50),
      p95: this.calculatePercentile(sorted, 95),
      p99: this.calculatePercentile(sorted, 99)
    };
  }
  async flushToDatabase() {
    const now = /* @__PURE__ */ new Date();
    const dateKey = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    for (const [key, buffer] of this.memoryBuffer.entries()) {
      const [connector, endpoint] = key.split(":");
      const stats = this.calculateStats(buffer.latencies.latencies);
      try {
        const existing = await db.select().from(connectorMetrics).where(
          and19(
            eq29(connectorMetrics.connector, connector),
            eq29(connectorMetrics.endpoint, endpoint),
            gte9(connectorMetrics.date, dateKey)
          )
        ).limit(1);
        if (existing.length > 0) {
          const oldTotal = existing[0].totalRequests;
          const newTotal = oldTotal + buffer.totalRequests;
          const oldAvg = parseFloat(existing[0].avgLatencyMs || "0");
          const newAvg = oldTotal > 0 ? (oldAvg * oldTotal + stats.avg * buffer.totalRequests) / newTotal : stats.avg;
          await db.update(connectorMetrics).set({
            totalRequests: newTotal,
            successCount: existing[0].successCount + buffer.successCount,
            failureCount: existing[0].failureCount + buffer.failureCount,
            cacheHits: existing[0].cacheHits + buffer.cacheHits,
            cacheMisses: existing[0].cacheMisses + buffer.cacheMisses,
            rateLimitHits: existing[0].rateLimitHits + buffer.rateLimitHits,
            fallbackUsed: existing[0].fallbackUsed + buffer.fallbackUsed,
            avgLatencyMs: newAvg.toFixed(2),
            p50LatencyMs: stats.p50.toFixed(2),
            p95LatencyMs: stats.p95.toFixed(2),
            p99LatencyMs: stats.p99.toFixed(2),
            lastError: buffer.lastError || existing[0].lastError,
            lastErrorAt: buffer.lastErrorAt || existing[0].lastErrorAt,
            updatedAt: now
          }).where(eq29(connectorMetrics.id, existing[0].id));
        } else {
          await db.insert(connectorMetrics).values({
            connector,
            endpoint,
            date: dateKey,
            totalRequests: buffer.totalRequests,
            successCount: buffer.successCount,
            failureCount: buffer.failureCount,
            cacheHits: buffer.cacheHits,
            cacheMisses: buffer.cacheMisses,
            rateLimitHits: buffer.rateLimitHits,
            fallbackUsed: buffer.fallbackUsed,
            avgLatencyMs: stats.avg.toFixed(2),
            p50LatencyMs: stats.p50.toFixed(2),
            p95LatencyMs: stats.p95.toFixed(2),
            p99LatencyMs: stats.p99.toFixed(2),
            lastError: buffer.lastError,
            lastErrorAt: buffer.lastErrorAt,
            createdAt: now,
            updatedAt: now
          });
        }
        buffer.totalRequests = 0;
        buffer.successCount = 0;
        buffer.failureCount = 0;
        buffer.cacheHits = 0;
        buffer.cacheMisses = 0;
        buffer.rateLimitHits = 0;
        buffer.fallbackUsed = 0;
        buffer.latencies.latencies = [];
        buffer.lastError = void 0;
        buffer.lastErrorAt = void 0;
      } catch (error) {
        log.error(
          "ConnectorMetricsService",
          `Failed to flush metrics for ${key}`,
          { error }
        );
      }
    }
  }
  async getMetricsByConnector(connector, days = 7) {
    const since = /* @__PURE__ */ new Date();
    since.setDate(since.getDate() - days);
    return db.select().from(connectorMetrics).where(
      and19(
        eq29(connectorMetrics.connector, connector),
        gte9(connectorMetrics.date, since)
      )
    ).orderBy(desc21(connectorMetrics.date));
  }
  async getLatestMetrics() {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    return db.select().from(connectorMetrics).where(gte9(connectorMetrics.date, today)).orderBy(desc21(connectorMetrics.totalRequests));
  }
  async getConnectorSummary() {
    const weekAgo = /* @__PURE__ */ new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    const metrics = await db.select().from(connectorMetrics).where(gte9(connectorMetrics.date, weekAgo));
    const byConnector = /* @__PURE__ */ new Map();
    for (const m of metrics) {
      const existing = byConnector.get(m.connector) || {
        totalRequests: 0,
        successCount: 0,
        cacheHits: 0,
        cacheMisses: 0,
        latencySum: 0
      };
      existing.totalRequests += m.totalRequests;
      existing.successCount += m.successCount;
      existing.cacheHits += m.cacheHits;
      existing.cacheMisses += m.cacheMisses;
      existing.latencySum += parseFloat(m.avgLatencyMs || "0") * m.totalRequests;
      byConnector.set(m.connector, existing);
    }
    return Array.from(byConnector.entries()).map(([connector, data]) => ({
      connector,
      successRate: data.totalRequests > 0 ? data.successCount / data.totalRequests * 100 : 100,
      avgLatencyMs: data.totalRequests > 0 ? data.latencySum / data.totalRequests : 0,
      totalRequests: data.totalRequests,
      cacheHitRate: data.cacheHits + data.cacheMisses > 0 ? data.cacheHits / (data.cacheHits + data.cacheMisses) * 100 : 0
    }));
  }
  shutdown() {
    if (this.flushTimer) {
      clearInterval(this.flushTimer);
      this.flushTimer = null;
    }
    this.flushToDatabase().catch(() => {
    });
  }
};
var connectorMetricsService = new ConnectorMetricsService();

// server/routes/feeds.ts
var router37 = Router39();
var FEED_CONFIGS = [
  {
    id: "alpaca",
    name: "Alpaca Markets",
    category: "market",
    connectorId: "Alpaca",
    description: "US equities, real-time quotes and trades"
  },
  {
    id: "coingecko",
    name: "CoinGecko",
    category: "crypto",
    connectorId: "CoinGecko",
    description: "Cryptocurrency prices and market data"
  },
  {
    id: "finnhub",
    name: "Finnhub",
    category: "market",
    connectorId: "Finnhub",
    description: "Stock data, fundamentals, and earnings"
  },
  {
    id: "coinmarketcap",
    name: "CoinMarketCap",
    category: "crypto",
    connectorId: "CoinMarketCap",
    description: "Cryptocurrency rankings and metrics"
  },
  {
    id: "newsapi",
    name: "NewsAPI",
    category: "news",
    connectorId: "NewsAPI",
    description: "Global news articles and headlines"
  },
  {
    id: "gdelt",
    name: "GDELT Project",
    category: "news",
    connectorId: "GDELT",
    description: "Global event monitoring and sentiment"
  },
  {
    id: "huggingface",
    name: "HuggingFace",
    category: "fundamental",
    connectorId: "HuggingFace",
    description: "AI-powered sentiment analysis (FinBERT)"
  },
  {
    id: "fred",
    name: "FRED",
    category: "fundamental",
    connectorId: "FRED",
    description: "Federal Reserve economic data"
  }
];
function determineStatus(metrics) {
  if (!metrics || metrics.totalRequests === 0) {
    return "unknown";
  }
  if (metrics.successRate >= 95) {
    return "active";
  }
  if (metrics.successRate >= 70) {
    return "degraded";
  }
  return "inactive";
}
router37.get("/", requireAuth, async (req, res) => {
  try {
    const connectorSummaries = await connectorMetricsService.getConnectorSummary();
    const summaryByConnector = new Map(
      connectorSummaries.map((s) => [s.connector.toLowerCase(), s])
    );
    const latestMetrics = await connectorMetricsService.getLatestMetrics();
    const latestByConnector = new Map(
      latestMetrics.map((m) => [m.connector.toLowerCase(), m])
    );
    const feeds = FEED_CONFIGS.map((config2) => {
      const connectorKey = config2.connectorId.toLowerCase();
      const summary = summaryByConnector.get(connectorKey);
      const latest = latestByConnector.get(connectorKey);
      return {
        id: config2.id,
        name: config2.name,
        category: config2.category,
        description: config2.description,
        status: determineStatus(summary),
        metrics: summary ? {
          successRate: Math.round(summary.successRate * 10) / 10,
          avgLatencyMs: Math.round(summary.avgLatencyMs),
          totalRequests: summary.totalRequests,
          cacheHitRate: Math.round(summary.cacheHitRate * 10) / 10
        } : null,
        lastError: latest?.lastError || null,
        lastErrorAt: latest?.lastErrorAt?.toISOString() || null,
        lastUpdate: latest?.updatedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      };
    });
    res.json(feeds);
  } catch (error) {
    log.error("FeedsRoutes", "Failed to get feed sources", { error });
    const fallback = FEED_CONFIGS.map((config2) => ({
      id: config2.id,
      name: config2.name,
      category: config2.category,
      description: config2.description,
      status: "unknown",
      metrics: null,
      lastError: null,
      lastErrorAt: null,
      lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
    }));
    res.json(fallback);
  }
});
router37.get("/:id", requireAuth, async (req, res) => {
  try {
    const { id } = req.params;
    const config2 = FEED_CONFIGS.find((f) => f.id === id);
    if (!config2) {
      res.status(404).json({ error: "Feed not found" });
      return;
    }
    const metrics = await connectorMetricsService.getMetricsByConnector(
      config2.connectorId,
      7
    );
    const dailyStats = metrics.map((m) => ({
      date: m.date.toISOString().split("T")[0],
      totalRequests: m.totalRequests,
      successCount: m.successCount,
      failureCount: m.failureCount,
      successRate: m.totalRequests > 0 ? Math.round(m.successCount / m.totalRequests * 1e3) / 10 : 100,
      avgLatencyMs: Math.round(parseFloat(m.avgLatencyMs || "0")),
      p95LatencyMs: Math.round(parseFloat(m.p95LatencyMs || "0")),
      cacheHitRate: m.cacheHits + m.cacheMisses > 0 ? Math.round(m.cacheHits / (m.cacheHits + m.cacheMisses) * 1e3) / 10 : 0,
      rateLimitHits: m.rateLimitHits,
      fallbackUsed: m.fallbackUsed
    }));
    const totalRequests = metrics.reduce((sum, m) => sum + m.totalRequests, 0);
    const totalSuccess = metrics.reduce((sum, m) => sum + m.successCount, 0);
    const totalCacheHits = metrics.reduce((sum, m) => sum + m.cacheHits, 0);
    const totalCacheMisses = metrics.reduce((sum, m) => sum + m.cacheMisses, 0);
    res.json({
      id: config2.id,
      name: config2.name,
      category: config2.category,
      description: config2.description,
      status: determineStatus({
        successRate: totalRequests > 0 ? totalSuccess / totalRequests * 100 : 100,
        totalRequests
      }),
      aggregate: {
        totalRequests,
        successRate: totalRequests > 0 ? Math.round(totalSuccess / totalRequests * 1e3) / 10 : 100,
        cacheHitRate: totalCacheHits + totalCacheMisses > 0 ? Math.round(
          totalCacheHits / (totalCacheHits + totalCacheMisses) * 1e3
        ) / 10 : 0
      },
      dailyStats,
      lastError: metrics[0]?.lastError || null,
      lastErrorAt: metrics[0]?.lastErrorAt?.toISOString() || null
    });
  } catch (error) {
    log.error("FeedsRoutes", "Failed to get feed details", { error });
    res.status(500).json({ error: "Failed to get feed details" });
  }
});
var feeds_default = router37;

// server/routes/watchlists.ts
init_db();
init_schema2();
import { Router as Router40 } from "express";
import { eq as eq30, and as and20, desc as desc22, asc } from "drizzle-orm";
init_logger();
var router38 = Router40();
async function requireAuth9(req, res, next) {
  const sessionId = req.cookies?.session;
  if (!sessionId) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }
  const session = await getSession(sessionId);
  if (!session) {
    res.status(401).json({ error: "Unauthorized" });
    return;
  }
  req.userId = session.userId;
  next();
}
router38.use(requireAuth9);
router38.get("/", async (req, res) => {
  try {
    const userId = req.userId;
    const userWatchlists = await db.select().from(watchlists).where(eq30(watchlists.userId, userId)).orderBy(asc(watchlists.sortOrder), asc(watchlists.createdAt));
    const watchlistsWithSymbols = await Promise.all(
      userWatchlists.map(async (watchlist) => {
        const symbols = await db.select().from(watchlistSymbols).where(eq30(watchlistSymbols.watchlistId, watchlist.id)).orderBy(
          asc(watchlistSymbols.sortOrder),
          desc22(watchlistSymbols.addedAt)
        );
        return {
          ...watchlist,
          symbols
        };
      })
    );
    res.json(watchlistsWithSymbols);
  } catch (error) {
    log.error("Watchlists", "Failed to get watchlists", { error });
    res.status(500).json({ error: "Failed to get watchlists" });
  }
});
router38.post("/", async (req, res) => {
  try {
    const userId = req.userId;
    const validationResult = createWatchlistSchema.safeParse(req.body);
    if (!validationResult.success) {
      res.status(400).json({
        error: "Invalid input",
        details: validationResult.error.errors
      });
      return;
    }
    const { name, description, isDefault } = validationResult.data;
    if (isDefault) {
      await db.update(watchlists).set({ isDefault: false }).where(
        and20(eq30(watchlists.userId, userId), eq30(watchlists.isDefault, true))
      );
    }
    const [newWatchlist] = await db.insert(watchlists).values({
      userId,
      name,
      description,
      isDefault: isDefault || false
    }).returning();
    log.info("Watchlists", "Created watchlist", {
      userId,
      watchlistId: newWatchlist.id,
      name
    });
    res.status(201).json({
      ...newWatchlist,
      symbols: []
    });
  } catch (error) {
    log.error("Watchlists", "Failed to create watchlist", { error });
    res.status(500).json({ error: "Failed to create watchlist" });
  }
});
router38.get("/:id", async (req, res) => {
  try {
    const userId = req.userId;
    const { id } = req.params;
    const [watchlist] = await db.select().from(watchlists).where(and20(eq30(watchlists.id, id), eq30(watchlists.userId, userId)));
    if (!watchlist) {
      res.status(404).json({ error: "Watchlist not found" });
      return;
    }
    const symbols = await db.select().from(watchlistSymbols).where(eq30(watchlistSymbols.watchlistId, id)).orderBy(asc(watchlistSymbols.sortOrder), desc22(watchlistSymbols.addedAt));
    res.json({
      ...watchlist,
      symbols
    });
  } catch (error) {
    log.error("Watchlists", "Failed to get watchlist", { error });
    res.status(500).json({ error: "Failed to get watchlist" });
  }
});
router38.put("/:id", async (req, res) => {
  try {
    const userId = req.userId;
    const { id } = req.params;
    const validationResult = updateWatchlistSchema.safeParse(req.body);
    if (!validationResult.success) {
      res.status(400).json({
        error: "Invalid input",
        details: validationResult.error.errors
      });
      return;
    }
    const updates = validationResult.data;
    const [existing] = await db.select().from(watchlists).where(and20(eq30(watchlists.id, id), eq30(watchlists.userId, userId)));
    if (!existing) {
      res.status(404).json({ error: "Watchlist not found" });
      return;
    }
    if (updates.isDefault) {
      await db.update(watchlists).set({ isDefault: false }).where(
        and20(eq30(watchlists.userId, userId), eq30(watchlists.isDefault, true))
      );
    }
    const [updated] = await db.update(watchlists).set({
      ...updates,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(and20(eq30(watchlists.id, id), eq30(watchlists.userId, userId))).returning();
    log.info("Watchlists", "Updated watchlist", { userId, watchlistId: id });
    res.json(updated);
  } catch (error) {
    log.error("Watchlists", "Failed to update watchlist", { error });
    res.status(500).json({ error: "Failed to update watchlist" });
  }
});
router38.delete("/:id", async (req, res) => {
  try {
    const userId = req.userId;
    const { id } = req.params;
    const [existing] = await db.select().from(watchlists).where(and20(eq30(watchlists.id, id), eq30(watchlists.userId, userId)));
    if (!existing) {
      res.status(404).json({ error: "Watchlist not found" });
      return;
    }
    await db.delete(watchlists).where(and20(eq30(watchlists.id, id), eq30(watchlists.userId, userId)));
    log.info("Watchlists", "Deleted watchlist", { userId, watchlistId: id });
    res.json({ success: true });
  } catch (error) {
    log.error("Watchlists", "Failed to delete watchlist", { error });
    res.status(500).json({ error: "Failed to delete watchlist" });
  }
});
router38.post(
  "/:id/symbols",
  async (req, res) => {
    try {
      const userId = req.userId;
      const { id: watchlistId } = req.params;
      const validationResult = addWatchlistSymbolSchema.safeParse(req.body);
      if (!validationResult.success) {
        res.status(400).json({
          error: "Invalid input",
          details: validationResult.error.errors
        });
        return;
      }
      const { symbol, notes, tags } = validationResult.data;
      const [watchlist] = await db.select().from(watchlists).where(
        and20(eq30(watchlists.id, watchlistId), eq30(watchlists.userId, userId))
      );
      if (!watchlist) {
        res.status(404).json({ error: "Watchlist not found" });
        return;
      }
      const [existingSymbol] = await db.select().from(watchlistSymbols).where(
        and20(
          eq30(watchlistSymbols.watchlistId, watchlistId),
          eq30(watchlistSymbols.symbol, symbol.toUpperCase())
        )
      );
      if (existingSymbol) {
        res.status(409).json({ error: "Symbol already in watchlist" });
        return;
      }
      const [newSymbol] = await db.insert(watchlistSymbols).values({
        watchlistId,
        symbol: symbol.toUpperCase(),
        notes,
        tags
      }).returning();
      log.info("Watchlists", "Added symbol to watchlist", {
        userId,
        watchlistId,
        symbol: symbol.toUpperCase()
      });
      res.status(201).json({
        success: true,
        item: newSymbol
      });
    } catch (error) {
      log.error("Watchlists", "Failed to add symbol", { error });
      res.status(500).json({ error: "Failed to add symbol" });
    }
  }
);
router38.put(
  "/:id/symbols/:symbol",
  async (req, res) => {
    try {
      const userId = req.userId;
      const { id: watchlistId, symbol } = req.params;
      const validationResult = updateWatchlistSymbolSchema.safeParse(req.body);
      if (!validationResult.success) {
        res.status(400).json({
          error: "Invalid input",
          details: validationResult.error.errors
        });
        return;
      }
      const updates = validationResult.data;
      const [watchlist] = await db.select().from(watchlists).where(
        and20(eq30(watchlists.id, watchlistId), eq30(watchlists.userId, userId))
      );
      if (!watchlist) {
        res.status(404).json({ error: "Watchlist not found" });
        return;
      }
      const [updated] = await db.update(watchlistSymbols).set(updates).where(
        and20(
          eq30(watchlistSymbols.watchlistId, watchlistId),
          eq30(watchlistSymbols.symbol, symbol.toUpperCase())
        )
      ).returning();
      if (!updated) {
        res.status(404).json({ error: "Symbol not found in watchlist" });
        return;
      }
      log.info("Watchlists", "Updated symbol in watchlist", {
        userId,
        watchlistId,
        symbol: symbol.toUpperCase()
      });
      res.json(updated);
    } catch (error) {
      log.error("Watchlists", "Failed to update symbol", { error });
      res.status(500).json({ error: "Failed to update symbol" });
    }
  }
);
router38.delete(
  "/:id/symbols/:symbol",
  async (req, res) => {
    try {
      const userId = req.userId;
      const { id: watchlistId, symbol } = req.params;
      const [watchlist] = await db.select().from(watchlists).where(
        and20(eq30(watchlists.id, watchlistId), eq30(watchlists.userId, userId))
      );
      if (!watchlist) {
        res.status(404).json({ error: "Watchlist not found" });
        return;
      }
      const result = await db.delete(watchlistSymbols).where(
        and20(
          eq30(watchlistSymbols.watchlistId, watchlistId),
          eq30(watchlistSymbols.symbol, symbol.toUpperCase())
        )
      ).returning();
      if (result.length === 0) {
        res.status(404).json({ error: "Symbol not found in watchlist" });
        return;
      }
      log.info("Watchlists", "Removed symbol from watchlist", {
        userId,
        watchlistId,
        symbol: symbol.toUpperCase()
      });
      res.json({ success: true });
    } catch (error) {
      log.error("Watchlists", "Failed to remove symbol", { error });
      res.status(500).json({ error: "Failed to remove symbol" });
    }
  }
);
var watchlists_default = router38;

// server/routes/connectors.ts
init_coingecko();
init_finnhub();
init_alpaca();
import { Router as Router41 } from "express";
init_newsapi();
init_valyu();
init_huggingface();
init_gdelt();
init_decision_engine();
init_data_fusion_engine2();
init_logger();
var router39 = Router41();
router39.get("/status", requireAuth, async (req, res) => {
  try {
    const cryptoStatus = coingecko.getConnectionStatus();
    const stockStatus = finnhub.getConnectionStatus();
    const aiStatus = aiDecisionEngine.getStatus();
    const fusionStatus = dataFusionEngine.getStatus();
    const alpacaStatus = alpaca.getConnectionStatus();
    const newsStatus = await newsapi.getConnectionStatus();
    const coinmarketcapStatus = coinmarketcap.getConnectionStatus();
    const valyuStatus = valyu.getConnectionStatus();
    const huggingfaceStatus = huggingface.getConnectionStatus();
    const uaeStatus = uaeMarkets.getConnectionStatus();
    const gdeltStatus = gdelt.getConnectionStatus();
    res.json({
      crypto: {
        provider: "CoinGecko",
        ...cryptoStatus,
        lastChecked: (/* @__PURE__ */ new Date()).toISOString()
      },
      stock: {
        provider: "Finnhub",
        ...stockStatus,
        lastChecked: (/* @__PURE__ */ new Date()).toISOString()
      },
      ai: {
        ...aiStatus,
        lastChecked: (/* @__PURE__ */ new Date()).toISOString()
      },
      fusion: {
        provider: "Data Fusion Engine",
        ...fusionStatus,
        lastChecked: (/* @__PURE__ */ new Date()).toISOString()
      },
      allConnectors: [
        {
          id: "alpaca",
          name: "Alpaca",
          category: "broker",
          description: "Paper trading execution & account management",
          connected: alpacaStatus.connected,
          hasApiKey: alpacaStatus.hasCredentials,
          cacheSize: alpacaStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "finnhub",
          name: "Finnhub",
          category: "market_data",
          description: "Real-time stock quotes & fundamentals",
          connected: stockStatus.connected,
          hasApiKey: stockStatus.hasApiKey,
          cacheSize: stockStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "coingecko",
          name: "CoinGecko",
          category: "market_data",
          description: "Cryptocurrency prices & market data",
          connected: cryptoStatus.connected,
          hasApiKey: cryptoStatus.hasApiKey,
          cacheSize: cryptoStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "coinmarketcap",
          name: "CoinMarketCap",
          category: "market_data",
          description: "Comprehensive crypto market data",
          connected: coinmarketcapStatus.connected,
          hasApiKey: coinmarketcapStatus.hasApiKey,
          cacheSize: coinmarketcapStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "newsapi",
          name: "NewsAPI",
          category: "news",
          description: "Real-time news headlines for sentiment",
          connected: newsStatus.connected,
          hasApiKey: newsStatus.hasApiKey,
          cacheSize: newsStatus.cacheSize,
          budgetAllowed: newsStatus.budgetStatus.allowed,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "valyu",
          name: "Valyu.ai",
          category: "enrichment",
          description: "9 financial datasets: earnings, ratios, balance sheets, income, cash flow, dividends, insider trades, SEC filings, market movers",
          connected: valyuStatus.connected,
          hasApiKey: valyuStatus.hasApiKey,
          cacheSize: valyuStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "huggingface",
          name: "Hugging Face",
          category: "enrichment",
          description: "FinBERT sentiment analysis & ML models",
          connected: huggingfaceStatus.connected,
          hasApiKey: huggingfaceStatus.hasApiKey,
          cacheSize: huggingfaceStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "openai",
          name: "OpenAI",
          category: "ai",
          description: "GPT-4o-mini for trading decisions",
          connected: aiStatus.available,
          hasApiKey: aiStatus.available,
          model: aiStatus.model,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "uae-markets",
          name: "UAE Markets",
          category: "market_data",
          description: "Dubai DFM & Abu Dhabi ADX stocks",
          connected: uaeStatus.connected,
          hasApiKey: uaeStatus.apiConfigured,
          cacheSize: uaeStatus.cacheSize,
          dataSource: uaeStatus.dataSource,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "gdelt",
          name: "GDELT",
          category: "news",
          description: "Real-time global news (100+ languages), sentiment tracking, breaking news detection (FREE, updates every 15min)",
          connected: gdeltStatus.connected,
          hasApiKey: true,
          cacheSize: gdeltStatus.cacheSize,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        }
      ]
    });
  } catch (error) {
    log.error("ConnectorsRoutes", "Failed to get connector status", {
      error
    });
    res.status(500).json({ error: "Failed to get connector status" });
  }
});
var connectors_default = router39;

// server/routes/fusion.ts
init_data_fusion_engine2();
init_logger();
import { Router as Router42 } from "express";
var router40 = Router42();
router40.get(
  "/intelligence",
  requireAuth,
  async (req, res) => {
    try {
      const intelligence = await dataFusionEngine.getMarketIntelligence();
      res.json(intelligence);
    } catch (error) {
      log.error("FusionRoutes", "Failed to get market intelligence", {
        error
      });
      res.status(500).json({ error: "Failed to get market intelligence" });
    }
  }
);
router40.get("/market-data", requireAuth, async (req, res) => {
  try {
    const fusedData = await dataFusionEngine.getFusedMarketData();
    res.json(fusedData);
  } catch (error) {
    log.error("FusionRoutes", "Failed to get fused market data", {
      error
    });
    res.status(500).json({ error: "Failed to get fused market data" });
  }
});
router40.get("/status", requireAuth, async (req, res) => {
  try {
    const status = dataFusionEngine.getStatus();
    res.json(status);
  } catch (error) {
    log.error("FusionRoutes", "Failed to get fusion status", { error });
    res.status(500).json({ error: "Failed to get fusion status" });
  }
});
var fusion_default = router40;

// server/routes/market-quotes.ts
init_alpaca();
init_logger();
import { Router as Router43 } from "express";
var router41 = Router43();
router41.get("/quotes", requireAuth, async (req, res) => {
  try {
    const symbolsParam = req.query.symbols;
    if (!symbolsParam) {
      return res.status(400).json({ error: "symbols parameter required" });
    }
    const symbols = symbolsParam.split(",").map((s) => s.trim().toUpperCase());
    const snapshots = await alpaca.getSnapshots(symbols);
    const quotes = symbols.map((symbol) => {
      const snap = snapshots[symbol];
      if (!snap) {
        return { symbol, price: null, change: null, changePercent: null };
      }
      const price = snap.latestTrade?.p || snap.dailyBar?.c || 0;
      const prevClose = snap.prevDailyBar?.c || price;
      const change = price - prevClose;
      const changePercent = prevClose ? change / prevClose * 100 : 0;
      return {
        symbol,
        price,
        change,
        changePercent,
        volume: snap.dailyBar?.v || 0,
        high: snap.dailyBar?.h || 0,
        low: snap.dailyBar?.l || 0,
        open: snap.dailyBar?.o || 0
      };
    });
    res.json(quotes);
  } catch (error) {
    log.error("MarketQuotesRoutes", "Failed to get market quotes", {
      error
    });
    res.status(500).json({ error: "Failed to get market quotes" });
  }
});
var market_quotes_default = router41;

// server/routes/health.ts
init_db();
init_logger();
import { Router as Router44 } from "express";
import { sql as sql32 } from "drizzle-orm";
var router42 = Router44();
router42.get("/db", async (req, res) => {
  try {
    const stats = getPoolStats();
    await db.execute(sql32`SELECT 1 as test`);
    res.json({
      status: "healthy",
      pool: stats,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("HealthRoutes", "Database health check failed", { error });
    res.status(503).json({
      status: "unhealthy",
      error: error instanceof Error ? error.message : "Unknown error",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
});
var health_default = router42;

// server/routes/ai-analysis.ts
init_storage();
init_logger();
init_llmGateway();
init_decision_engine();
import { Router as Router45 } from "express";
var router43 = Router45();
router43.post("/analyze", requireAuth, async (req, res) => {
  try {
    const { symbol, marketData, newsContext, strategyId } = req.body;
    if (!symbol || !marketData) {
      return res.status(400).json({ error: "Symbol and market data are required" });
    }
    let strategy;
    if (strategyId) {
      const dbStrategy = await storage.getStrategy(strategyId);
      if (dbStrategy) {
        strategy = {
          id: dbStrategy.id,
          name: dbStrategy.name,
          type: dbStrategy.type,
          parameters: dbStrategy.parameters ? JSON.parse(dbStrategy.parameters) : void 0
        };
      }
    }
    const traceId = generateTraceId();
    const decision = await aiDecisionEngine.analyzeOpportunity(
      symbol,
      marketData,
      newsContext,
      strategy,
      { traceId }
    );
    const aiDecisionRecord = await storage.createAiDecision({
      strategyId: strategyId || null,
      symbol,
      action: decision.action,
      confidence: decision.confidence.toString(),
      reasoning: decision.reasoning,
      traceId,
      marketContext: JSON.stringify({
        marketData,
        newsContext,
        riskLevel: decision.riskLevel,
        suggestedQuantity: decision.suggestedQuantity,
        targetPrice: decision.targetPrice,
        stopLoss: decision.stopLoss
      })
    });
    res.json({
      id: aiDecisionRecord.id,
      ...decision,
      createdAt: aiDecisionRecord.createdAt
    });
  } catch (error) {
    log.error("Routes", "AI analysis error", { error });
    res.status(500).json({ error: "Failed to analyze trading opportunity" });
  }
});
router43.get("/status", requireAuth, async (req, res) => {
  try {
    const status = aiDecisionEngine.getStatus();
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: "Failed to get AI status" });
  }
});
router43.get("/events", requireAuth, async (req, res) => {
  try {
    const limit4 = Math.min(parseInt(req.query.limit) || 20, 100);
    const type = req.query.type;
    const decisions = await storage.getAiDecisions(void 0, limit4 * 2);
    const events = decisions.filter((d) => !type || d.action === type).slice(0, limit4).map((d) => ({
      id: d.id,
      type: d.action || "signal",
      title: `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol || "Market"}`,
      headline: `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol}`,
      description: d.reasoning,
      explanation: d.reasoning,
      symbol: d.symbol,
      confidence: typeof d.confidence === "string" ? parseFloat(d.confidence) : d.confidence,
      action: d.action,
      time: d.createdAt,
      createdAt: d.createdAt,
      metadata: {
        strategyId: d.strategyId,
        signals: []
      }
    }));
    res.json(events);
  } catch (error) {
    log.error("Routes", "Failed to get AI events", { error });
    res.json([]);
  }
});
router43.get("/cache/stats", requireAuth, async (req, res) => {
  try {
    const stats = getLLMCacheStats();
    res.json(stats);
  } catch (error) {
    log.error("Routes", "Error getting LLM cache stats", { error });
    res.status(500).json({ error: "Failed to get cache stats" });
  }
});
router43.post(
  "/cache/clear",
  requireAuth,
  async (req, res) => {
    try {
      clearLLMCache();
      res.json({ success: true, message: "LLM cache cleared" });
    } catch (error) {
      log.error("Routes", "Error clearing LLM cache", { error });
      res.status(500).json({ error: "Failed to clear cache" });
    }
  }
);
router43.post(
  "/cache/clear/:role",
  requireAuth,
  async (req, res) => {
    try {
      const { role } = req.params;
      clearLLMCacheForRole(role);
      res.json({ success: true, message: `Cache cleared for role: ${role}` });
    } catch (error) {
      log.error("Routes", "Error clearing LLM cache for role", {
        error
      });
      res.status(500).json({ error: "Failed to clear cache for role" });
    }
  }
);
router43.post(
  "/cache/reset-stats",
  requireAuth,
  async (req, res) => {
    try {
      resetLLMCacheStats();
      res.json({ success: true, message: "Cache statistics reset" });
    } catch (error) {
      log.error("Routes", "Error resetting LLM cache stats", { error });
      res.status(500).json({ error: "Failed to reset cache stats" });
    }
  }
);
router43.get("/sentiment", requireAuth, async (req, res) => {
  try {
    const symbols = req.query.symbols?.split(",") || [
      "SPY",
      "QQQ",
      "AAPL",
      "TSLA",
      "NVDA"
    ];
    const sentimentResults = await sentimentAggregator.batchGetSentiment(symbols);
    const sentiments = Array.from(sentimentResults.entries()).map(
      ([symbol, result]) => ({
        id: `sent-${symbol}-${Date.now()}`,
        sourceId: "sentiment-aggregator",
        sourceName: "Sentiment Aggregator",
        symbol,
        // Convert from -1 to 1 range to -100 to 100 range for frontend
        score: Math.round(result.overallScore * 100),
        trend: result.recommendation === "bullish" ? "up" : result.recommendation === "bearish" ? "down" : "neutral",
        explanation: `${result.recommendation.charAt(0).toUpperCase() + result.recommendation.slice(1)} sentiment based on ${result.sources.length} sources. Confidence: ${Math.round(result.overallConfidence * 100)}%${result.conflictDetected ? " (conflicting signals)" : ""}`,
        timestamp: result.timestamp.toISOString()
      })
    );
    res.json(sentiments);
  } catch (error) {
    log.error("Routes", "Failed to get sentiment signals", { error });
    res.status(500).json({ error: "Failed to get sentiment signals" });
  }
});
var ai_analysis_default = router43;

// server/routes/agent-control.ts
init_storage();
init_logger();
init_alpaca_trading_engine();
import { Router as Router46 } from "express";
var router44 = Router46();
router44.get("/status", requireAuth, async (req, res) => {
  try {
    const status = await storage.getAgentStatus();
    if (!status) {
      const defaultStatus = await storage.updateAgentStatus({
        isRunning: false,
        totalTrades: 0,
        totalPnl: "0"
      });
      return res.json(defaultStatus);
    }
    res.json(status);
  } catch (error) {
    res.status(500).json({ error: "Failed to get agent status" });
  }
});
router44.post("/toggle", requireAuth, async (req, res) => {
  try {
    const currentStatus = await storage.getAgentStatus();
    const newIsRunning = !(currentStatus?.isRunning ?? false);
    if (newIsRunning) {
      await alpacaTradingEngine.resumeAgent();
    } else {
      await alpacaTradingEngine.stopAllStrategies();
    }
    const status = await storage.getAgentStatus();
    res.json(status);
  } catch (error) {
    log.error("Routes", "Failed to toggle agent", { error });
    res.status(500).json({ error: "Failed to toggle agent" });
  }
});
var agent_control_default = router44;

// server/routes/activity.ts
init_storage();
init_logger();
init_alpaca();
import { Router as Router47 } from "express";
var router45 = Router47();
router45.get("/timeline", requireAuth, async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const cursor = req.query.cursor;
    const categoryFilter = req.query.category;
    const [decisions, brokerOrders, trades3] = await Promise.all([
      storage.getAiDecisions(void 0, limit4 * 2),
      alpaca.getOrders("all", limit4).catch(() => []),
      storage.getTrades(void 0, limit4)
    ]);
    const alpacaConnected = brokerOrders.length > 0 || decisions.some((d) => d.executedTradeId);
    const alpacaStatus = alpacaConnected ? "live" : "unavailable";
    const events = [];
    for (const d of decisions) {
      const status = d.status === "filled" || d.status === "executed" ? "success" : d.status === "skipped" || d.status === "rejected" ? "warning" : d.status === "pending" || d.status === "pending_execution" ? "pending" : d.status === "failed" ? "error" : "info";
      const subtitle = d.action === "hold" ? "No action taken" : d.skipReason ? `Skipped: ${d.skipReason}` : `${d.action.toUpperCase()} ${d.symbol}`;
      events.push({
        id: `decision-${d.id}`,
        ts: new Date(d.createdAt).toISOString(),
        category: "decision",
        title: `AI Decision: ${d.action.toUpperCase()} ${d.symbol}`,
        subtitle: d.confidence ? `Confidence: ${(parseFloat(d.confidence) * 100).toFixed(0)}%` : null,
        status,
        entityLinks: {
          decisionId: d.id,
          symbol: d.symbol,
          strategyId: d.strategyId ?? void 0,
          tradeId: d.executedTradeId ?? void 0
        },
        provenance: {
          provider: "ai-decision-engine",
          cacheStatus: "unknown"
        },
        details: {
          action: d.action,
          confidence: d.confidence,
          reasoning: d.reasoning?.substring(0, 200),
          entryPrice: d.entryPrice,
          stopLoss: d.stopLoss,
          takeProfit: d.takeProfit
        }
      });
    }
    for (const o of brokerOrders) {
      const status = o.status === "filled" ? "success" : o.status === "canceled" || o.status === "expired" ? "warning" : o.status === "rejected" ? "error" : "pending";
      const filledInfo = o.filled_qty && parseFloat(o.filled_qty) > 0 ? `${o.filled_qty} @ $${parseFloat(o.filled_avg_price || "0").toFixed(2)}` : `${o.qty} shares`;
      events.push({
        id: `order-${o.id}`,
        ts: o.submitted_at,
        category: o.status === "filled" ? "fill" : "order",
        title: `${o.side.toUpperCase()} ${o.symbol}`,
        subtitle: filledInfo,
        status,
        entityLinks: {
          brokerOrderId: o.id,
          symbol: o.symbol
        },
        provenance: {
          provider: "alpaca",
          cacheStatus: "fresh"
        },
        details: {
          orderId: o.id,
          orderType: o.order_type,
          timeInForce: o.time_in_force,
          limitPrice: o.limit_price,
          stopPrice: o.stop_price,
          filledQty: o.filled_qty,
          filledAvgPrice: o.filled_avg_price,
          brokerStatus: o.status
        }
      });
    }
    for (const t of trades3) {
      const matchingOrder = brokerOrders.find(
        (o) => o.symbol === t.symbol && o.status === "filled" && Math.abs(
          new Date(o.filled_at || 0).getTime() - new Date(t.executedAt).getTime()
        ) < 6e4
      );
      if (matchingOrder) continue;
      const pnl = t.pnl ? parseFloat(t.pnl) : null;
      const status = pnl !== null ? pnl >= 0 ? "success" : "warning" : "info";
      events.push({
        id: `trade-${t.id}`,
        ts: new Date(t.executedAt).toISOString(),
        category: "fill",
        title: `${t.side.toUpperCase()} ${t.symbol}`,
        subtitle: `${t.quantity} @ $${parseFloat(t.price).toFixed(2)}`,
        status,
        entityLinks: {
          tradeId: t.id,
          symbol: t.symbol,
          strategyId: t.strategyId ?? void 0
        },
        provenance: {
          provider: "database",
          cacheStatus: "unknown"
        },
        details: {
          quantity: t.quantity,
          price: t.price,
          pnl: t.pnl
        }
      });
    }
    let filteredEvents = events;
    if (categoryFilter && categoryFilter !== "all") {
      filteredEvents = events.filter((e) => e.category === categoryFilter);
    }
    filteredEvents.sort(
      (a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime()
    );
    let startIdx = 0;
    if (cursor) {
      const cursorIdx = filteredEvents.findIndex((e) => e.id === cursor);
      if (cursorIdx >= 0) startIdx = cursorIdx + 1;
    }
    const paginatedEvents = filteredEvents.slice(startIdx, startIdx + limit4);
    const hasMore = startIdx + limit4 < filteredEvents.length;
    const nextCursor = hasMore ? paginatedEvents[paginatedEvents.length - 1]?.id : null;
    res.json({
      events: paginatedEvents,
      hasMore,
      cursor: nextCursor,
      meta: {
        alpacaConnected,
        alpacaStatus,
        totalEvents: filteredEvents.length,
        fetchedAt: fetchedAt.toISOString()
      }
    });
  } catch (error) {
    log.error("Routes", "Timeline fetch error", { error });
    res.status(500).json({
      error: "Failed to fetch activity timeline",
      meta: {
        alpacaConnected: false,
        alpacaStatus: "unavailable",
        totalEvents: 0,
        fetchedAt: fetchedAt.toISOString()
      }
    });
  }
});
var activity_default = router45;

// server/routes/performance.ts
init_logger();
import { Router as Router48 } from "express";
var router46 = Router48();
router46.get("/metrics", requireAuth, async (req, res) => {
  try {
    const { performanceTracker: performanceTracker2 } = await Promise.resolve().then(() => (init_performance_metrics(), performance_metrics_exports));
    const { getOrderCacheStats: getOrderCacheStats2 } = await Promise.resolve().then(() => (init_order_execution_cache(), order_execution_cache_exports));
    const { getPoolStats: getPoolStats2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const metrics = performanceTracker2.getMetrics();
    const sloStatus = performanceTracker2.getSLOStatus();
    const cacheStats = getOrderCacheStats2();
    const poolStats = getPoolStats2();
    res.json({
      orderExecution: performanceTracker2.getMetricSummary("orderExecution"),
      quoteRetrieval: performanceTracker2.getMetricSummary("quoteRetrieval"),
      aiDecision: performanceTracker2.getMetricSummary("aiDecision"),
      databaseQuery: performanceTracker2.getMetricSummary("databaseQuery"),
      apiCall: performanceTracker2.getMetricSummary("apiCall"),
      sloCompliance: sloStatus,
      cache: cacheStats,
      dbPool: poolStats,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("Routes", "Performance metrics error", { error });
    res.status(500).json({ error: "Failed to get performance metrics" });
  }
});
var performance_default = router46;

// server/routes/analytics.ts
init_storage();
init_alpaca();
import { Router as Router49 } from "express";
init_numeric();
init_logger();
var router47 = Router49();
router47.get("/summary", requireAuth, async (req, res) => {
  try {
    const orchestratorState = orchestrator.getState();
    const riskLimits = orchestrator.getRiskLimits();
    let alpacaPositions = [];
    let unrealizedPnl = 0;
    let dailyPnlFromAccount = 0;
    let accountData = {
      equity: "0",
      cash: "0",
      buyingPower: "0",
      lastEquity: "0",
      portfolioValue: "0"
    };
    const [trades3, alpacaData] = await Promise.all([
      storage.getTrades(void 0, 100),
      Promise.all([alpaca.getPositions(), alpaca.getAccount()]).catch((e) => {
        log.error("AnalyticsAPI", "Failed to fetch Alpaca data", { error: e });
        return [[], null];
      })
    ]);
    const [positions2, account] = alpacaData;
    if (positions2 && positions2.length > 0) {
      alpacaPositions = positions2;
      unrealizedPnl = alpacaPositions.reduce(
        (sum, p) => sum + safeParseFloat(p.unrealized_pl, 0),
        0
      );
    }
    if (account && !Array.isArray(account)) {
      const portfolioValue = safeParseFloat(account.portfolio_value, 0);
      const lastEquity = safeParseFloat(account.last_equity, 0);
      dailyPnlFromAccount = portfolioValue - lastEquity;
      accountData = {
        equity: account.equity || "0",
        cash: account.cash || "0",
        buyingPower: account.buying_power || "0",
        lastEquity: account.last_equity || "0",
        portfolioValue: account.portfolio_value || "0"
      };
    }
    const filledTrades = trades3.filter((t) => {
      const status = (t.status || "").toLowerCase();
      return status === "filled" || status === "completed" || status === "executed";
    });
    const sellTrades = filledTrades.filter((t) => t.side === "sell");
    const closedTrades = sellTrades.filter((t) => {
      if (t.pnl === null || t.pnl === void 0) return false;
      const pnlStr = String(t.pnl).trim();
      if (pnlStr === "") return false;
      const pnlValue = parseFloat(pnlStr);
      return Number.isFinite(pnlValue);
    });
    const realizedPnl = closedTrades.reduce(
      (sum, t) => sum + safeParseFloat(t.pnl, 0),
      0
    );
    const totalPnl = unrealizedPnl + realizedPnl;
    const winningTrades = closedTrades.filter(
      (t) => safeParseFloat(t.pnl, 0) > 0
    );
    const losingTrades = closedTrades.filter(
      (t) => safeParseFloat(t.pnl, 0) < 0
    );
    const winRate = closedTrades.length > 0 ? winningTrades.length / closedTrades.length * 100 : 0;
    const todayStart = /* @__PURE__ */ new Date();
    todayStart.setHours(0, 0, 0, 0);
    const todaysTrades = closedTrades.filter((t) => {
      const executedAt = new Date(t.executedAt);
      return executedAt >= todayStart;
    });
    const dailyTradeCount = todaysTrades.length;
    const dailyWinningTrades = todaysTrades.filter(
      (t) => safeParseFloat(t.pnl, 0) > 0
    );
    const dailyLosingTrades = todaysTrades.filter(
      (t) => safeParseFloat(t.pnl, 0) < 0
    );
    const dailyRealizedPnl = todaysTrades.reduce(
      (sum, t) => sum + safeParseFloat(t.pnl, 0),
      0
    );
    res.json({
      totalTrades: filledTrades.length,
      closedTradesCount: closedTrades.length,
      totalPnl: totalPnl.toFixed(2),
      realizedPnl: realizedPnl.toFixed(2),
      winRate: winRate.toFixed(1),
      winningTrades: winningTrades.length,
      losingTrades: losingTrades.length,
      openPositions: alpacaPositions.length,
      unrealizedPnl: unrealizedPnl.toFixed(2),
      isAgentRunning: orchestratorState.isRunning,
      dailyPnl: dailyPnlFromAccount.toFixed(2),
      dailyTradeCount,
      dailyWinningTrades: dailyWinningTrades.length,
      dailyLosingTrades: dailyLosingTrades.length,
      dailyRealizedPnl: dailyRealizedPnl.toFixed(2),
      account: accountData,
      riskControls: {
        maxPositionSizePercent: riskLimits.maxPositionSizePercent,
        maxTotalExposurePercent: riskLimits.maxTotalExposurePercent,
        maxPositionsCount: riskLimits.maxPositionsCount,
        dailyLossLimitPercent: riskLimits.dailyLossLimitPercent,
        killSwitchActive: riskLimits.killSwitchActive
      }
    });
  } catch (error) {
    log.error("AnalyticsAPI", "Failed to get analytics summary", { error });
    res.status(500).json({ error: "Failed to get analytics summary" });
  }
});
var analytics_default = router47;

// server/routes/crypto.ts
init_coingecko();
init_logger();
import { Router as Router50 } from "express";
var router48 = Router50();
router48.get("/markets", requireAuth, async (req, res) => {
  try {
    const perPage = parseInt(req.query.per_page) || 20;
    const page = parseInt(req.query.page) || 1;
    const order = req.query.order || "market_cap_desc";
    const markets = await coingecko.getMarkets("usd", perPage, page, order);
    res.json(markets);
  } catch (error) {
    log.error("CryptoAPI", "Failed to get crypto markets", { error });
    res.status(500).json({ error: "Failed to fetch crypto market data" });
  }
});
router48.get("/prices", requireAuth, async (req, res) => {
  try {
    const ids = req.query.ids || "bitcoin,ethereum,solana";
    const coinIds = ids.split(",").map((id) => id.trim());
    const prices = await coingecko.getSimplePrice(coinIds);
    res.json(prices);
  } catch (error) {
    log.error("CryptoAPI", "Failed to get crypto prices", { error });
    res.status(500).json({ error: "Failed to fetch crypto prices" });
  }
});
router48.get(
  "/chart/:coinId",
  requireAuth,
  async (req, res) => {
    try {
      const { coinId } = req.params;
      const days = req.query.days || "7";
      const chart = await coingecko.getMarketChart(coinId, "usd", days);
      res.json(chart);
    } catch (error) {
      log.error("CryptoAPI", "Failed to get crypto chart", { error });
      res.status(500).json({ error: "Failed to fetch crypto chart data" });
    }
  }
);
router48.get("/trending", requireAuth, async (req, res) => {
  try {
    const trending = await coingecko.getTrending();
    res.json(trending);
  } catch (error) {
    log.error("CryptoAPI", "Failed to get trending crypto", { error });
    res.status(500).json({ error: "Failed to fetch trending coins" });
  }
});
router48.get("/global", requireAuth, async (req, res) => {
  try {
    const global2 = await coingecko.getGlobalData();
    res.json(global2);
  } catch (error) {
    log.error("CryptoAPI", "Failed to get global crypto stats", { error });
    res.status(500).json({ error: "Failed to fetch global market data" });
  }
});
router48.get("/search", requireAuth, async (req, res) => {
  try {
    const query = req.query.q || "";
    if (!query) {
      return res.status(400).json({ error: "Search query required" });
    }
    const results = await coingecko.searchCoins(query);
    res.json(results);
  } catch (error) {
    log.error("CryptoAPI", "Failed to search crypto", { error });
    res.status(500).json({ error: "Failed to search coins" });
  }
});
var crypto_default = router48;

// server/routes/stock.ts
init_finnhub();
init_logger();
import { Router as Router51 } from "express";
var router49 = Router51();
router49.get(
  "/quote/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const quote = await finnhub.getQuote(symbol);
      res.json(quote);
    } catch (error) {
      log.error("StockAPI", "Failed to get stock quote", { error });
      res.status(500).json({ error: "Failed to fetch stock quote" });
    }
  }
);
router49.get("/quotes", requireAuth, async (req, res) => {
  try {
    const symbols = req.query.symbols || "AAPL,GOOGL,MSFT,AMZN,TSLA";
    const symbolList = symbols.split(",").map((s) => s.trim().toUpperCase());
    const quotes = await finnhub.getMultipleQuotes(symbolList);
    const result = {};
    quotes.forEach((quote, symbol) => {
      result[symbol] = quote;
    });
    res.json(result);
  } catch (error) {
    log.error("StockAPI", "Failed to get stock quotes", { error });
    res.status(500).json({ error: "Failed to fetch stock quotes" });
  }
});
router49.get(
  "/candles/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const resolution = req.query.resolution || "D";
      const from = req.query.from ? parseInt(req.query.from) : void 0;
      const to = req.query.to ? parseInt(req.query.to) : void 0;
      const candles = await finnhub.getCandles(symbol, resolution, from, to);
      res.json(candles);
    } catch (error) {
      log.error("StockAPI", "Failed to get stock candles", { error });
      res.status(500).json({ error: "Failed to fetch stock candles" });
    }
  }
);
router49.get(
  "/profile/:symbol",
  requireAuth,
  async (req, res) => {
    try {
      const { symbol } = req.params;
      const profile = await finnhub.getCompanyProfile(symbol);
      res.json(profile);
    } catch (error) {
      log.error("StockAPI", "Failed to get company profile", { error });
      res.status(500).json({ error: "Failed to fetch company profile" });
    }
  }
);
router49.get("/search", requireAuth, async (req, res) => {
  try {
    const query = req.query.q || "";
    if (!query) {
      return res.status(400).json({ error: "Search query required" });
    }
    const results = await finnhub.searchSymbols(query);
    res.json(results);
  } catch (error) {
    log.error("StockAPI", "Failed to search stocks", { error });
    res.status(500).json({ error: "Failed to search stocks" });
  }
});
router49.get("/news", requireAuth, async (req, res) => {
  try {
    const category = req.query.category || "general";
    const news = await finnhub.getMarketNews(category);
    res.json(news);
  } catch (error) {
    log.error("StockAPI", "Failed to get stock news", { error });
    res.status(500).json({ error: "Failed to fetch market news" });
  }
});
var stock_default = router49;

// server/routes.ts
init_audit_logger();
init_logger();
var isProduction2 = process.env.NODE_ENV === "production";
async function authMiddleware3(req, res, next) {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      log.warn("Auth", "No session cookie found for request:", {
        path: req.path
      });
      return res.status(401).json({
        error: "Not authenticated",
        code: "NO_SESSION",
        message: "Please log in to access this resource"
      });
    }
    const session = await getSession(sessionId);
    if (!session) {
      log.warn("Auth", "Session expired or invalid:", {
        sessionId: sessionId.substring(0, 8) + "..."
      });
      return res.status(401).json({
        error: "Session expired",
        code: "SESSION_EXPIRED",
        message: "Your session has expired. Please log in again."
      });
    }
    req.userId = session.userId;
    next();
  } catch (error) {
    log.error("Auth", "Middleware error", { error });
    return res.status(500).json({
      error: "Authentication error",
      code: "AUTH_ERROR",
      message: "An error occurred while verifying your session"
    });
  }
}
async function registerRoutes(app2) {
  log.info("Routes", "Starting route registration...");
  initializeDefaultModules();
  log.info("Routes", "Admin module registry initialized");
  app2.get("/health", (_req, res) => {
    res.status(200).json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
  });
  app2.get("/__replit_ready", (_req, res) => {
    res.status(200).send("ready");
  });
  log.info("Routes", "Health check endpoints registered");
  setTimeout(() => {
    log.info("Routes", "Starting delayed initializations...");
    coordinator.start().catch(
      (err) => log.error("Routes", "Failed to start trading coordinator", {
        error: err
      })
    );
    alpacaTradingEngine.initialize().catch(
      (err) => log.error("Routes", "Failed to initialize Alpaca trading engine", {
        error: err
      })
    );
    orchestrator.autoStart().catch(
      (err) => log.error("Routes", "Failed to auto-start orchestrator", { error: err })
    );
    workQueue.startWorker(5e3);
    log.info("Routes", "Work queue worker started with 5s poll interval");
    alpacaStream.connect().catch((err) => {
      log.error("Routes", "Failed to connect to Alpaca stream", { error: err });
    });
    log.info("Routes", "Alpaca trade updates stream connecting...");
    setInterval(async () => {
      try {
        const traceId = `reconcile-${Date.now()}`;
        await workQueue.enqueue({
          type: "ORDER_SYNC",
          payload: JSON.stringify({ traceId }),
          idempotencyKey: `ORDER_SYNC:periodic:${Math.floor(Date.now() / 45e3)}`
        });
        log.info("Routes", "Periodic order reconciliation triggered");
      } catch (err) {
        log.error("Routes", "Failed to trigger order reconciliation", {
          error: err
        });
      }
    }, 45e3);
    log.info("Routes", "Order reconciliation job scheduled (45s interval)");
  }, 2e3);
  setTimeout(async () => {
    try {
      log.info("Bootstrap", "Checking for admin user...");
      const adminUser = await storage.getUserByUsername("admintest");
      log.info("Bootstrap", "Admin user check complete:", {
        status: adminUser ? "exists" : "not found"
      });
      if (!adminUser) {
        const hashedPassword = await bcrypt3.hash("admin1234", 10);
        await storage.createUser({
          username: "admintest",
          password: hashedPassword,
          isAdmin: true
        });
        log.info("Bootstrap", "Created admin user: admintest");
      } else {
        if (!adminUser.isAdmin) {
          await storage.updateUser(adminUser.id, { isAdmin: true });
          log.info("Bootstrap", "Promoted admintest to admin");
        } else {
          log.info("Bootstrap", "Admin user admintest already exists");
        }
      }
    } catch (err) {
      log.error("Bootstrap", "Failed to create admin user", { error: err });
    }
  }, 3e3);
  log.info("Routes", "Continuing registration (admin bootstrap deferred)...");
  app2.use("/api", auditLogger);
  log.info("Routes", "Audit logging middleware enabled for all API routes");
  app2.use("/api/backtests", authMiddleware3, backtests_default);
  app2.use("/api/traces", authMiddleware3, tracesRouter);
  app2.use("/api/admin/observability", authMiddleware3, observabilityRouter);
  app2.use("/api/admin/providers", authMiddleware3, providers_default);
  app2.use("/api/debate", authMiddleware3, debate_default);
  app2.use("/api/tools", authMiddleware3, tools_default);
  app2.use("/api/competition", authMiddleware3, competition_default);
  app2.use("/api/strategies", authMiddleware3, strategies_default);
  app2.use("/api/arena", authMiddleware3, arena_default);
  app2.use("/api/jina", authMiddleware3, jina_default);
  app2.use("/api/macro", authMiddleware3, macro_default);
  app2.use("/api/enrichment", authMiddleware3, enrichment_default);
  app2.use("/api/auth", auth_default);
  app2.use("/api/user/preferences", user_preferences_default);
  app2.use("/api/notifications/preferences", notification_preferences_default);
  app2.use("/api/positions", authMiddleware3, positions_default);
  app2.use("/api/orders", authMiddleware3, orders_default);
  app2.use("/api/trades", authMiddleware3, trades_default);
  app2.use("/api", authMiddleware3, market_data_default);
  app2.use("/api/webhooks", authMiddleware3, webhooks_default);
  app2.use("/api", authMiddleware3, ai_decisions_default);
  registerAutonomousRoutes(app2, authMiddleware3);
  app2.use("/api", authMiddleware3, cache_default);
  app2.use("/api/llm", authMiddleware3, llm_default);
  app2.use("/api/admin", authMiddleware3, admin_default);
  app2.use("/api/notifications", authMiddleware3, notifications_default);
  app2.use("/api", authMiddleware3, allocation_rebalance_default);
  app2.use("/api", enforcement_fundamentals_default);
  registerPortfolioTradingRoutes(app2);
  app2.use("/api/alpaca", authMiddleware3, alpaca_default);
  app2.use("/api/alpaca-trading", authMiddleware3, alpaca_trading_default);
  app2.use("/api/crypto", crypto_default);
  app2.use("/api/stock", stock_default);
  app2.use("/api/analytics", authMiddleware3, analytics_default);
  app2.use("/api/uae", uae_markets_default);
  app2.use("/api/news", news_default);
  app2.use("/api/cmc", cmc_default);
  app2.use("/api/trading-sessions", authMiddleware3, trading_sessions_default);
  app2.use("/api/feeds", authMiddleware3, feeds_default);
  app2.use("/api/watchlists", authMiddleware3, watchlists_default);
  app2.use("/api/connectors", authMiddleware3, connectors_default);
  app2.use("/api/fusion", authMiddleware3, fusion_default);
  app2.use("/api/market", authMiddleware3, market_quotes_default);
  app2.use("/api/health", authMiddleware3, health_default);
  app2.use("/api/ai", authMiddleware3, ai_analysis_default);
  app2.use("/api/agent", authMiddleware3, agent_control_default);
  app2.use("/api/activity", authMiddleware3, activity_default);
  app2.use("/api/performance", authMiddleware3, performance_default);
  alertService.startEvaluationJob(6e4);
  enrichmentScheduler.start();
  app2.get("/api/events", async (req, res) => {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const session = await getSession(sessionId);
    if (!session) {
      return res.status(401).json({ error: "Session expired" });
    }
    const userId = session.userId;
    const clientId = `${userId}-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    const { sseEmitter: sseEmitter2 } = (init_sse_emitter(), __toCommonJS(sse_emitter_exports));
    sseEmitter2.addClient(clientId, res, userId);
    req.on("close", () => {
      sseEmitter2.removeClient(clientId, userId);
    });
  });
  app2.delete(
    "/api/alpaca/orders/:orderId",
    authMiddleware3,
    async (req, res) => {
      try {
        await alpaca.cancelOrder(req.params.orderId);
        res.status(204).send();
      } catch (error) {
        log.error("Routes", "Failed to cancel Alpaca order", { error });
        res.status(500).json({ error: "Failed to cancel Alpaca order" });
      }
    }
  );
  const redactWebhook2 = (webhook) => ({
    ...webhook,
    secret: webhook.secret ? "***REDACTED***" : void 0,
    headers: webhook.headers ? Object.fromEntries(
      Object.entries(webhook.headers).map(
        ([k, v]) => k.toLowerCase().includes("auth") || k.toLowerCase().includes("token") || k.toLowerCase().includes("key") ? [k, "***REDACTED***"] : [k, v]
      )
    ) : void 0
  });
  const {
    registerChannel: registerChannel2,
    getChannel: getChannel2,
    getChannels: getChannels2,
    updateChannel: updateChannel2,
    deleteChannel: deleteChannel2,
    registerTemplate: registerTemplate2,
    getTemplates: getTemplates2,
    updateTemplate: updateTemplate2,
    deleteTemplate: deleteTemplate2,
    sendNotification: sendNotification2,
    sendDirectNotification: sendDirectNotification2,
    getNotificationHistory: getNotificationHistory2,
    getNotificationStats: getNotificationStats2
  } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
  const redactChannelConfig2 = (channel) => {
    const redacted = { ...channel };
    if (redacted.config) {
      const config2 = { ...redacted.config };
      if ("botToken" in config2) config2.botToken = "***REDACTED***";
      if ("webhookUrl" in config2)
        config2.webhookUrl = config2.webhookUrl.replace(
          /\/[^/]+$/,
          "/***REDACTED***"
        );
      if ("password" in config2) config2.password = "***REDACTED***";
      redacted.config = config2;
    }
    return redacted;
  };
  const httpServer = createServer(app2);
  return httpServer;
}

// server/index.ts
init_logger();
import * as fs from "fs";
import * as path from "path";

// server/config/env-validator.ts
init_logger();
var REQUIRED_ENV_VARS = [
  "DATABASE_URL",
  "ALPACA_API_KEY",
  "ALPACA_SECRET_KEY"
];
var OPTIONAL_ENV_VARS = [
  { key: "FINNHUB_API_KEY", feature: "Finnhub market data" },
  { key: "OPENAI_API_KEY", feature: "OpenAI AI decisions" },
  { key: "NEWS_API_KEY", feature: "News sentiment" },
  { key: "COINMARKETCAP_API_KEY", feature: "CoinMarketCap data" },
  { key: "VALYU_API_KEY", feature: "Fundamental data" },
  { key: "FRED_API_KEY", feature: "Macro indicators" },
  { key: "HUGGINGFACE_API_KEY", feature: "HuggingFace sentiment" }
];
function validateDatabaseUrl(url) {
  if (!url.startsWith("postgres://") && !url.startsWith("postgresql://")) {
    return "DATABASE_URL must start with postgres:// or postgresql://";
  }
  const pattern = /^postgres(ql)?:\/\/[^:]+:[^@]+@[^\/]+\/.+$/;
  if (!pattern.test(url)) {
    return "DATABASE_URL appears to be malformed. Expected format: postgres://user:password@host/database";
  }
  return null;
}
function validateApiKeyLength(key, name, minLength = 16) {
  if (key.length < minLength) {
    return `${name} appears too short (minimum ${minLength} characters expected)`;
  }
  return null;
}
function validateTradingMode(mode) {
  if (mode !== "paper" && mode !== "live") {
    return "ALPACA_TRADING_MODE must be either 'paper' or 'live'";
  }
  return null;
}
function validateEnvironment() {
  const errors = [];
  const warnings = [];
  const features = [];
  for (const varName of REQUIRED_ENV_VARS) {
    const value = process.env[varName];
    if (!value) {
      errors.push(`Required environment variable ${varName} is not set`);
      continue;
    }
    if (varName === "DATABASE_URL") {
      const error = validateDatabaseUrl(value);
      if (error) {
        errors.push(error);
      }
    }
    if (varName === "ALPACA_API_KEY" || varName === "ALPACA_SECRET_KEY") {
      const error = validateApiKeyLength(value, varName);
      if (error) {
        warnings.push(error);
      }
    }
  }
  for (const { key, feature } of OPTIONAL_ENV_VARS) {
    const value = process.env[key];
    if (!value) {
      features.push({ name: feature, enabled: false });
      warnings.push(
        `Optional environment variable ${key} is not set - ${feature} will be disabled`
      );
    } else {
      features.push({ name: feature, enabled: true });
      const error = validateApiKeyLength(value, key, 10);
      if (error) {
        warnings.push(error);
      }
    }
  }
  const tradingMode = process.env.ALPACA_TRADING_MODE;
  if (tradingMode) {
    const error = validateTradingMode(tradingMode);
    if (error) {
      errors.push(error);
    }
  } else {
    warnings.push("ALPACA_TRADING_MODE not set - will default to 'paper' mode");
  }
  const port = process.env.PORT;
  if (port) {
    const portNum = parseInt(port, 10);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      errors.push(
        `PORT must be a valid number between 1 and 65535 (got: ${port})`
      );
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    features
  };
}
function validateAndReportEnvironment() {
  log.info("EnvValidator", "Validating environment variables...");
  const result = validateEnvironment();
  const enabledFeatures = result.features.filter((f) => f.enabled);
  const disabledFeatures = result.features.filter((f) => !f.enabled);
  log.info("EnvValidator", "Feature status", {
    enabledCount: enabledFeatures.length,
    disabledCount: disabledFeatures.length,
    enabled: enabledFeatures.map((f) => f.name),
    disabled: disabledFeatures.map((f) => f.name)
  });
  if (result.warnings.length > 0) {
    result.warnings.forEach((warning) => {
      log.warn("EnvValidator", warning);
    });
  }
  if (result.errors.length > 0) {
    log.error(
      "EnvValidator",
      "Validation failed - missing or invalid required environment variables",
      {
        errors: result.errors
      }
    );
    result.errors.forEach((error) => {
      log.error("EnvValidator", error);
    });
    log.error(
      "EnvValidator",
      "Please set all required environment variables and restart the server. Server startup aborted."
    );
    throw new Error(
      "Environment validation failed - missing or invalid required variables"
    );
  }
  log.info(
    "EnvValidator",
    "Environment validation passed - all required variables are set and valid"
  );
}

// server/jobs/position-reconciliation.ts
init_alpaca_trading_engine();
init_orchestration2();
init_logger();
import * as cron from "node-cron";
var PositionReconciliationJob = class {
  cronTask = null;
  isRunning = false;
  stats = {
    isRunning: false,
    lastRunTime: null,
    lastRunDuration: null,
    nextRunTime: null,
    totalRuns: 0,
    successfulRuns: 0,
    failedRuns: 0,
    lastError: null,
    lastResult: null
  };
  /**
   * Start the position reconciliation cron job
   * Runs every 5 minutes to sync positions from Alpaca
   */
  start() {
    if (this.cronTask) {
      log.warn(
        "PositionReconciliation",
        "Job already running, ignoring start request"
      );
      return;
    }
    this.cronTask = cron.schedule(
      "*/5 * * * *",
      async () => {
        await this.executeSync();
      },
      {
        timezone: "America/New_York"
        // Use market timezone (NYSE)
      }
    );
    log.info(
      "PositionReconciliation",
      "Cron job started - syncing every 5 minutes"
    );
    this.updateNextRunTime();
    setTimeout(() => {
      this.executeSync();
    }, 1e4);
  }
  /**
   * Stop the position reconciliation cron job
   */
  stop() {
    if (this.cronTask) {
      this.cronTask.stop();
      this.cronTask = null;
      log.info("PositionReconciliation", "Cron job stopped");
    }
  }
  /**
   * Execute the position sync (can be called manually or by cron)
   */
  async executeSync() {
    if (this.isRunning) {
      log.warn(
        "PositionReconciliation",
        "Sync already in progress, skipping this run"
      );
      return { created: [], updated: [], removed: [], errors: [] };
    }
    this.isRunning = true;
    this.stats.isRunning = true;
    this.stats.totalRuns++;
    const startTime = Date.now();
    const runTime = /* @__PURE__ */ new Date();
    log.info("PositionReconciliation", "Starting position sync...");
    try {
      const result = await alpacaTradingEngine.syncPositionsFromAlpaca();
      const duration = Date.now() - startTime;
      this.stats.successfulRuns++;
      this.stats.lastRunTime = runTime;
      this.stats.lastRunDuration = duration;
      this.stats.lastError = null;
      this.stats.lastResult = result;
      this.updateNextRunTime();
      log.info("PositionReconciliation", "Position sync completed", {
        created: result.created.length,
        updated: result.updated.length,
        removed: result.removed.length,
        errors: result.errors.length,
        duration: `${duration}ms`
      });
      if (result.created.length > 0) {
        log.info(
          "PositionReconciliation",
          `Created ${result.created.length} new positions: ${result.created.join(", ")}`
        );
      }
      if (result.updated.length > 0) {
        log.info(
          "PositionReconciliation",
          `Updated ${result.updated.length} existing positions: ${result.updated.join(", ")}`
        );
      }
      if (result.removed.length > 0) {
        log.warn(
          "PositionReconciliation",
          `Removed ${result.removed.length} stale positions: ${result.removed.join(", ")}`
        );
      }
      if (result.errors.length > 0) {
        log.error(
          "PositionReconciliation",
          `Encountered ${result.errors.length} errors during sync`,
          {
            errors: result.errors
          }
        );
      }
      if (result.created.length > 0 || result.updated.length > 0 || result.removed.length > 0) {
        eventBus.emit(
          "position:updated",
          {
            type: "reconciliation",
            created: result.created,
            updated: result.updated,
            removed: result.removed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          "position-reconciliation-job"
        );
      }
      return result;
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error.message;
      this.stats.failedRuns++;
      this.stats.lastRunTime = runTime;
      this.stats.lastRunDuration = duration;
      this.stats.lastError = errorMessage;
      this.updateNextRunTime();
      log.error("PositionReconciliation", "Position sync failed", {
        error: errorMessage,
        duration: `${duration}ms`
      });
      eventBus.emit(
        "system:error",
        {
          message: "Position reconciliation failed",
          error: errorMessage,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        },
        "position-reconciliation-job"
      );
      throw error;
    } finally {
      this.isRunning = false;
      this.stats.isRunning = false;
    }
  }
  /**
   * Get current job statistics
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset job statistics (useful for testing)
   */
  resetStats() {
    this.stats = {
      isRunning: this.isRunning,
      lastRunTime: null,
      lastRunDuration: null,
      nextRunTime: this.stats.nextRunTime,
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      lastError: null,
      lastResult: null
    };
    log.info("PositionReconciliation", "Job statistics reset");
  }
  /**
   * Update the next run time based on cron schedule
   */
  updateNextRunTime() {
    if (!this.cronTask) {
      this.stats.nextRunTime = null;
      return;
    }
    const now = /* @__PURE__ */ new Date();
    const nextRun = new Date(now.getTime() + 5 * 60 * 1e3);
    nextRun.setSeconds(0, 0);
    const minutes = nextRun.getMinutes();
    const remainder = minutes % 5;
    if (remainder !== 0) {
      nextRun.setMinutes(minutes + (5 - remainder));
    }
    this.stats.nextRunTime = nextRun;
  }
  /**
   * Check if job is currently running
   */
  isJobRunning() {
    return this.isRunning;
  }
};
var positionReconciliationJob = new PositionReconciliationJob();

// server/autonomous/exit-rule-enforcer.ts
init_logger();
init_storage();
init_alpaca();
var ExitRuleEnforcer = class {
  isRunning = false;
  checkInterval = null;
  statistics = {
    totalChecks: 0,
    exitTriggered: 0,
    profitTargetExits: 0,
    stopLossExits: 0,
    timeExits: 0,
    trailingStopExits: 0,
    failedExits: 0
  };
  // Track trailing stop high water marks
  trailingStopHighs = /* @__PURE__ */ new Map();
  // DEPRECATED: Position entry times now come from database (TE-001 fix)
  // Kept for backward compatibility with recordPositionEntry() calls
  positionEntryTimes = /* @__PURE__ */ new Map();
  DEFAULT_CHECK_INTERVAL_MS = 3e4;
  // 30 seconds
  /**
   * Start the exit rule enforcer
   */
  start(intervalMs = this.DEFAULT_CHECK_INTERVAL_MS) {
    if (this.isRunning) {
      log.warn("ExitRuleEnforcer", "Already running");
      return;
    }
    this.isRunning = true;
    log.info("ExitRuleEnforcer", "Starting exit rule enforcer", {
      intervalMs
    });
    this.checkAllPositions();
    this.checkInterval = setInterval(() => {
      this.checkAllPositions();
    }, intervalMs);
  }
  /**
   * Stop the exit rule enforcer
   */
  stop() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
    this.isRunning = false;
    log.info("ExitRuleEnforcer", "Stopped exit rule enforcer");
  }
  /**
   * Check all positions against their strategy exit rules
   */
  async checkAllPositions() {
    this.statistics.totalChecks++;
    const results = [];
    try {
      const positions2 = await this.getPositionsWithStrategy();
      log.debug("ExitRuleEnforcer", "Checking positions", {
        positionCount: positions2.length
      });
      for (const position of positions2) {
        const result = await this.checkPosition(position);
        if (result) {
          results.push(result);
        }
      }
      return results;
    } catch (error) {
      log.error("ExitRuleEnforcer", "Error checking positions", {
        error: error instanceof Error ? error.message : String(error)
      });
      return results;
    }
  }
  /**
   * Check a single position against its strategy exit rules
   */
  async checkPosition(position) {
    try {
      const strategy = await storage.getStrategy(position.strategyId);
      if (!strategy) {
        log.warn("ExitRuleEnforcer", "Strategy not found for position", {
          strategyId: position.strategyId,
          symbol: position.symbol
        });
        return null;
      }
      const context = parseStrategyContext(strategy);
      const exitRules = context.params.exitRules;
      const bracketOrders = context.params.bracketOrders;
      const decision = this.evaluateExitRules(
        position,
        exitRules,
        bracketOrders
      );
      if (!decision.shouldExit) {
        return null;
      }
      log.info("ExitRuleEnforcer", "Exit triggered", {
        symbol: position.symbol,
        strategyId: position.strategyId,
        exitType: decision.exitType,
        reason: decision.reason,
        pnlPercent: position.unrealizedPnlPercent.toFixed(2)
      });
      const exitResult = await this.executeExit(position, decision);
      this.statistics.exitTriggered++;
      switch (decision.exitType) {
        case "profit_target":
          this.statistics.profitTargetExits++;
          break;
        case "stop_loss":
          this.statistics.stopLossExits++;
          break;
        case "time_exit":
          this.statistics.timeExits++;
          break;
        case "trailing_stop":
          this.statistics.trailingStopExits++;
          break;
      }
      if (!exitResult.success) {
        this.statistics.failedExits++;
      }
      return exitResult;
    } catch (error) {
      log.error("ExitRuleEnforcer", "Error checking position", {
        symbol: position.symbol,
        error: error instanceof Error ? error.message : String(error)
      });
      return null;
    }
  }
  /**
   * Evaluate exit rules for a position
   */
  evaluateExitRules(position, exitRules, bracketOrders) {
    const decisions = [];
    const profitTarget = exitRules.profitTargetPercent ?? bracketOrders.takeProfitPercent;
    if (profitTarget && position.unrealizedPnlPercent >= profitTarget) {
      decisions.push({
        shouldExit: true,
        reason: `Profit target ${profitTarget}% reached (current: ${position.unrealizedPnlPercent.toFixed(2)}%)`,
        exitType: "profit_target",
        priority: 3
        // Medium priority - can wait a bit for better execution
      });
    }
    const stopLoss = exitRules.lossLimitPercent ?? bracketOrders.stopLossPercent;
    if (stopLoss && position.unrealizedPnlPercent <= -stopLoss) {
      decisions.push({
        shouldExit: true,
        reason: `Stop loss ${stopLoss}% triggered (current: ${position.unrealizedPnlPercent.toFixed(2)}%)`,
        exitType: "stop_loss",
        priority: 5
        // High priority - exit immediately
      });
    }
    if (bracketOrders.useTrailingStop && bracketOrders.trailingStopPercent) {
      const trailingDecision = this.evaluateTrailingStop(
        position,
        bracketOrders.trailingStopPercent
      );
      if (trailingDecision.shouldExit) {
        decisions.push(trailingDecision);
      }
    }
    if (exitRules.maxHoldingPeriodHours && position.holdingPeriodHours >= exitRules.maxHoldingPeriodHours) {
      decisions.push({
        shouldExit: true,
        reason: `Max holding period ${exitRules.maxHoldingPeriodHours}h exceeded (current: ${position.holdingPeriodHours.toFixed(1)}h)`,
        exitType: "time_exit",
        priority: 2
        // Lower priority - time-based exits can be more flexible
      });
    }
    if (decisions.length === 0) {
      return { shouldExit: false, priority: 0 };
    }
    decisions.sort((a, b) => b.priority - a.priority);
    return decisions[0];
  }
  /**
   * Evaluate trailing stop
   */
  evaluateTrailingStop(position, trailingStopPercent) {
    const key = `${position.strategyId}:${position.symbol}`;
    const currentHigh = this.trailingStopHighs.get(key) || position.entryPrice;
    const newHigh = Math.max(currentHigh, position.currentPrice);
    this.trailingStopHighs.set(key, newHigh);
    const trailingStopPrice2 = newHigh * (1 - trailingStopPercent / 100);
    const dropFromHigh = (newHigh - position.currentPrice) / newHigh * 100;
    if (position.currentPrice <= trailingStopPrice2) {
      return {
        shouldExit: true,
        reason: `Trailing stop triggered: dropped ${dropFromHigh.toFixed(2)}% from high of $${newHigh.toFixed(2)}`,
        exitType: "trailing_stop",
        priority: 4
        // High priority
      };
    }
    return { shouldExit: false, priority: 0 };
  }
  /**
   * Execute an exit order
   */
  async executeExit(position, decision) {
    try {
      const result = await strategyOrderService.closePosition(
        position.strategyId,
        position.symbol,
        Math.abs(position.quantity),
        `exit-${decision.exitType}-${Date.now()}`
      );
      if (result.success) {
        const key = `${position.strategyId}:${position.symbol}`;
        this.trailingStopHighs.delete(key);
        this.positionEntryTimes.delete(key);
      }
      return {
        symbol: position.symbol,
        strategyId: position.strategyId,
        success: result.success,
        exitType: decision.exitType || "unknown",
        orderId: result.orderId,
        error: result.error
      };
    } catch (error) {
      return {
        symbol: position.symbol,
        strategyId: position.strategyId,
        success: false,
        exitType: decision.exitType || "unknown",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Get positions with their associated strategies
   */
  async getPositionsWithStrategy() {
    const positions2 = await alpaca.getPositions();
    const result = [];
    const dbPositions = await storage.getPositions();
    const dbPositionMap = new Map(
      dbPositions.map((p) => [`${p.strategyId}:${p.symbol}`, p])
    );
    for (const position of positions2) {
      const strategyId = await this.findStrategyForPosition(position.symbol);
      if (!strategyId) {
        continue;
      }
      const entryPrice = parseFloat(position.avg_entry_price);
      const currentPrice = parseFloat(position.current_price);
      const quantity = parseFloat(position.qty);
      const marketValue = parseFloat(position.market_value);
      const unrealizedPnl = parseFloat(position.unrealized_pl);
      const unrealizedPnlPercent = parseFloat(position.unrealized_plpc) * 100;
      const key = `${strategyId}:${position.symbol}`;
      const dbPosition = dbPositionMap.get(key);
      let entryTime;
      if (dbPosition && dbPosition.entryTime) {
        entryTime = new Date(dbPosition.entryTime);
      } else {
        entryTime = this.positionEntryTimes.get(key) || /* @__PURE__ */ new Date();
        if (!this.positionEntryTimes.has(key)) {
          this.positionEntryTimes.set(key, entryTime);
        }
      }
      const holdingPeriodHours = (Date.now() - entryTime.getTime()) / (1e3 * 60 * 60);
      result.push({
        symbol: position.symbol,
        strategyId,
        entryPrice,
        currentPrice,
        quantity,
        marketValue,
        unrealizedPnl,
        unrealizedPnlPercent,
        entryTime,
        holdingPeriodHours
      });
    }
    return result;
  }
  /**
   * Find the strategy associated with a position
   * In a full implementation, this would query orders/positions with strategyId
   */
  async findStrategyForPosition(symbol) {
    try {
      const strategies2 = await storage.getStrategies();
      for (const strategy of strategies2) {
        if (strategy.status !== "paper" && strategy.status !== "live") {
          continue;
        }
        const strategyOrders = await storage.getOrdersByStrategy(
          strategy.id,
          50
        );
        const hasSymbolOrder = strategyOrders.some(
          (order) => order.symbol === symbol && order.status === "filled"
        );
        if (hasSymbolOrder) {
          return strategy.id;
        }
        const config2 = strategy.config;
        const includeSymbols = config2?.includeSymbols;
        if (includeSymbols?.includes(symbol)) {
          return strategy.id;
        }
      }
      return null;
    } catch (error) {
      log.warn("ExitRuleEnforcer", "Error finding strategy for position", {
        symbol,
        error: error instanceof Error ? error.message : String(error)
      });
      return null;
    }
  }
  /**
   * Manually trigger exit check for a specific strategy
   */
  async checkStrategy(strategyId) {
    const positions2 = await this.getPositionsWithStrategy();
    const strategyPositions = positions2.filter(
      (p) => p.strategyId === strategyId
    );
    const results = [];
    for (const position of strategyPositions) {
      const result = await this.checkPosition(position);
      if (result) {
        results.push(result);
      }
    }
    return results;
  }
  /**
   * Set entry time for a position (called when order fills)
   */
  recordPositionEntry(strategyId, symbol, entryTime = /* @__PURE__ */ new Date()) {
    const key = `${strategyId}:${symbol}`;
    this.positionEntryTimes.set(key, entryTime);
  }
  /**
   * Get enforcer statistics
   */
  getStatistics() {
    return { ...this.statistics };
  }
  /**
   * Reset statistics
   */
  resetStatistics() {
    this.statistics = {
      totalChecks: 0,
      exitTriggered: 0,
      profitTargetExits: 0,
      stopLossExits: 0,
      timeExits: 0,
      trailingStopExits: 0,
      failedExits: 0
    };
  }
  /**
   * Check if enforcer is running
   */
  isActive() {
    return this.isRunning;
  }
};
var exitRuleEnforcer = new ExitRuleEnforcer();

// server/index.ts
init_alpaca();
init_position_manager();

// server/middleware/error-handler.ts
init_logger();
function errorHandler(err, req, res, next) {
  const correlationId = req.correlationId || "unknown";
  log.error("ErrorHandler", `Unhandled error in ${req.method} ${req.path}`, {
    correlationId,
    error: err.message,
    stack: err.stack,
    code: err.code,
    statusCode: err.statusCode,
    method: req.method,
    path: req.path,
    userId: req.userId
  });
  const isDevelopment = process.env.NODE_ENV === "development";
  const statusCode = err.statusCode || 500;
  const errorResponse = {
    error: isDevelopment ? err.message : "Internal server error",
    code: err.code || "INTERNAL_ERROR",
    correlationId
  };
  if (isDevelopment && err.stack) {
    errorResponse.stack = err.stack.split("\n").slice(0, 5);
  }
  res.status(statusCode).json(errorResponse);
}
function notFoundHandler(req, res) {
  const correlationId = req.correlationId || "unknown";
  log.warn("ErrorHandler", `Route not found: ${req.method} ${req.path}`, {
    correlationId,
    method: req.method,
    path: req.path
  });
  res.status(404).json({
    error: "Not found",
    code: "NOT_FOUND",
    message: `Route ${req.method} ${req.path} not found`,
    correlationId
  });
}

// server/middleware/request-logger.ts
init_logger();
import { randomBytes as randomBytes2 } from "crypto";
function generateCorrelationId() {
  return `req_${Date.now()}_${randomBytes2(8).toString("hex")}`;
}
function requestLogger(req, res, next) {
  const startTime = Date.now();
  const extendedReq = req;
  const correlationId = req.headers["x-correlation-id"] || generateCorrelationId();
  extendedReq.correlationId = correlationId;
  res.setHeader("X-Correlation-ID", correlationId);
  log.info("Request", `${req.method} ${req.path}`, {
    correlationId,
    method: req.method,
    path: req.path,
    query: Object.keys(req.query).length > 0 ? req.query : void 0,
    userId: extendedReq.userId,
    ip: req.ip || req.socket.remoteAddress,
    userAgent: req.headers["user-agent"]
  });
  const originalSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - startTime;
    log.info("Response", `${req.method} ${req.path} - ${res.statusCode}`, {
      correlationId,
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      durationMs: duration,
      userId: extendedReq.userId
    });
    return originalSend.call(this, data);
  };
  next();
}
function performanceLogger(thresholdMs = 1e3) {
  return (req, res, next) => {
    const startTime = Date.now();
    const extendedReq = req;
    const correlationId = extendedReq.correlationId || "unknown";
    res.on("finish", () => {
      const duration = Date.now() - startTime;
      if (duration > thresholdMs) {
        log.warn(
          "Performance",
          `Slow request detected: ${req.method} ${req.path}`,
          {
            correlationId,
            method: req.method,
            path: req.path,
            durationMs: duration,
            threshold: thresholdMs,
            statusCode: res.statusCode
          }
        );
      }
    });
    next();
  };
}

// server/index.ts
init_redis_cache();
dotenv.config({ override: true });
process.on("uncaughtException", (err) => {
  log.error("FATAL", "Uncaught exception", { error: err });
});
process.on("unhandledRejection", (reason, promise) => {
  log.error("FATAL", "Unhandled rejection", { promise, reason });
});
var isShuttingDown = false;
async function gracefulShutdown(signal) {
  if (isShuttingDown) return;
  isShuttingDown = true;
  log.info("SHUTDOWN", `${signal} received, starting graceful shutdown...`);
  try {
    if (global.httpServer) {
      log.info("SHUTDOWN", "Closing HTTP server...");
      await new Promise((resolve2) => {
        global.httpServer.close(() => {
          log.info("SHUTDOWN", "HTTP server closed");
          resolve2();
        });
      });
    }
    log.info("SHUTDOWN", "Shutting down WebSocket server...");
    wsServer.shutdown();
    log.info("SHUTDOWN", "WebSocket server shutdown complete");
    log.info("SHUTDOWN", "Stopping background jobs...");
    positionReconciliationJob.stop();
    exitRuleEnforcer.stop();
    log.info("SHUTDOWN", "Background jobs stopped");
    const { workQueue: workQueue2 } = await Promise.resolve().then(() => (init_work_queue(), work_queue_exports));
    log.info("SHUTDOWN", "Draining work queue...");
    await workQueue2.drain();
    log.info("SHUTDOWN", "Work queue drained");
    log.info("SHUTDOWN", "Disconnecting Redis...");
    await closeRedis();
    log.info("SHUTDOWN", "Redis disconnected");
    const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    log.info("SHUTDOWN", "Closing database pool...");
    await db2.$client.end();
    log.info("SHUTDOWN", "Database pool closed");
    log.info("SHUTDOWN", "Graceful shutdown complete");
    process.exit(0);
  } catch (error) {
    log.error("SHUTDOWN", "Error during graceful shutdown", { error });
    process.exit(1);
  }
}
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));
process.on("beforeExit", (code) => log.info("PROCESS", "beforeExit", { code }));
process.on("exit", (code) => log.info("PROCESS", "exit", { code }));
var app = express();
function setupCors(app2) {
  app2.use((req, res, next) => {
    const origins = /* @__PURE__ */ new Set();
    if (process.env.REPLIT_DEV_DOMAIN) {
      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);
    }
    if (process.env.REPLIT_DOMAINS) {
      process.env.REPLIT_DOMAINS.split(",").forEach((d) => {
        origins.add(`https://${d.trim()}`);
      });
    }
    const origin = req.header("origin");
    if (!origin || origins.has(origin)) {
      res.header("Access-Control-Allow-Origin", origin || "*");
      res.header(
        "Access-Control-Allow-Methods",
        "GET, POST, PUT, DELETE, OPTIONS"
      );
      res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
      res.header("Access-Control-Allow-Credentials", "true");
    }
    if (req.method === "OPTIONS") {
      return res.sendStatus(200);
    }
    next();
  });
}
function setupBodyParsing(app2) {
  app2.use(
    express.json({
      verify: (req, _res, buf) => {
        req.rawBody = buf;
      }
    })
  );
  app2.use(express.urlencoded({ extended: false }));
}
function setupRequestLogging(app2) {
  app2.use(requestLogger);
  app2.use(performanceLogger(1e3));
}
function getAppName() {
  try {
    const appJsonPath = path.resolve(process.cwd(), "app.json");
    const appJsonContent = fs.readFileSync(appJsonPath, "utf-8");
    const appJson = JSON.parse(appJsonContent);
    return appJson.expo?.name || "App Landing Page";
  } catch {
    return "App Landing Page";
  }
}
function serveExpoManifest(platform, res) {
  const manifestPath = path.resolve(
    process.cwd(),
    "static-build",
    platform,
    "manifest.json"
  );
  if (!fs.existsSync(manifestPath)) {
    return res.status(404).json({ error: `Manifest not found for platform: ${platform}` });
  }
  res.setHeader("expo-protocol-version", "1");
  res.setHeader("expo-sfv-version", "0");
  res.setHeader("content-type", "application/json");
  const manifest = fs.readFileSync(manifestPath, "utf-8");
  res.send(manifest);
}
function serveLandingPage({
  req,
  res,
  landingPageTemplate,
  appName
}) {
  const forwardedProto = req.header("x-forwarded-proto");
  const protocol = forwardedProto || req.protocol || "https";
  const forwardedHost = req.header("x-forwarded-host");
  const host = forwardedHost || req.get("host");
  const baseUrl = `${protocol}://${host}`;
  const expsUrl = `${host}`;
  log.debug("Server", "Landing page URL generation", { baseUrl, expsUrl });
  const html = landingPageTemplate.replace(/BASE_URL_PLACEHOLDER/g, baseUrl).replace(/EXPS_URL_PLACEHOLDER/g, expsUrl).replace(/APP_NAME_PLACEHOLDER/g, appName);
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.status(200).send(html);
}
function configureExpoAndLanding(app2) {
  const templatePath = path.resolve(
    process.cwd(),
    "server",
    "templates",
    "landing-page.html"
  );
  const landingPageTemplate = fs.readFileSync(templatePath, "utf-8");
  const appName = getAppName();
  log.info("Server", "Serving static Expo files with dynamic manifest routing");
  app2.use((req, res, next) => {
    if (req.path.startsWith("/api")) {
      return next();
    }
    if (req.path !== "/" && req.path !== "/manifest") {
      return next();
    }
    const platform = req.header("expo-platform");
    if (platform && (platform === "ios" || platform === "android")) {
      return serveExpoManifest(platform, res);
    }
    if (req.path === "/") {
      return serveLandingPage({
        req,
        res,
        landingPageTemplate,
        appName
      });
    }
    next();
  });
  app2.use("/assets", express.static(path.resolve(process.cwd(), "assets")));
  app2.use(express.static(path.resolve(process.cwd(), "static-build")));
  log.info(
    "Server",
    "Expo routing: Checking expo-platform header on / and /manifest"
  );
}
function setupErrorHandler(app2) {
  app2.use(notFoundHandler);
  app2.use(errorHandler);
}
async function verifyAlpacaAccount() {
  const apiKey2 = process.env.ALPACA_API_KEY;
  const maskedKey = apiKey2 ? `${apiKey2.substring(0, 6)}...${apiKey2.substring(apiKey2.length - 4)}` : "NOT SET";
  log.info("ALPACA_VERIFY", `Using API Key: ${maskedKey}`);
  try {
    const account = await alpaca.getAccount();
    log.info("ALPACA_VERIFY", `Connected to Alpaca account: ${account.id}`);
    log.info("ALPACA_VERIFY", `Account Status: ${account.status}`);
    log.info(
      "ALPACA_VERIFY",
      `Buying Power: $${parseFloat(account.buying_power).toFixed(2)}`
    );
    log.info(
      "ALPACA_VERIFY",
      `Portfolio Value: $${parseFloat(account.portfolio_value).toFixed(2)}`
    );
    return true;
  } catch (error) {
    log.error("ALPACA_VERIFY", "Failed to connect to Alpaca", { error });
    log.warn(
      "ALPACA_VERIFY",
      "Server will continue but trading features may not work"
    );
    return false;
  }
}
(async () => {
  try {
    validateAndReportEnvironment();
    log.info("STARTUP", "Verifying Alpaca account...");
    await verifyAlpacaAccount();
    log.info("STARTUP", "Syncing orders from Alpaca...");
    try {
      const syncResult = await positionManager.syncOrdersFromAlpaca();
      log.info("STARTUP", "Order sync completed", {
        created: syncResult.created.length,
        skipped: syncResult.skipped.length,
        errors: syncResult.errors.length
      });
    } catch (error) {
      log.warn("STARTUP", "Order sync failed - will continue without sync", {
        error: error instanceof Error ? error.message : String(error)
      });
    }
    if (process.env.REDIS_HOST) {
      log.info("STARTUP", "Initializing Redis connection...");
      await initRedis();
      if (isRedisAvailable()) {
        log.info("STARTUP", "Redis connection established successfully");
      } else {
        log.warn(
          "STARTUP",
          "Redis unavailable - will continue without caching"
        );
      }
    } else {
      log.info(
        "STARTUP",
        "Redis not configured - skipping cache initialization"
      );
    }
    log.info("STARTUP", "Beginning server initialization...");
    setupCors(app);
    app.use(
      helmet({
        contentSecurityPolicy: {
          directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'", "'unsafe-eval'"],
            styleSrc: [
              "'self'",
              "'unsafe-inline'",
              "https://fonts.googleapis.com"
            ],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            imgSrc: ["'self'", "data:", "https:", "blob:"],
            connectSrc: ["'self'", "https:", "wss:"]
          }
        },
        crossOriginEmbedderPolicy: false,
        // Required for some external resources
        crossOriginResourcePolicy: { policy: "cross-origin" }
      })
    );
    log.info("STARTUP", "Security headers configured (helmet)");
    setupBodyParsing(app);
    app.use(cookieParser());
    setupRequestLogging(app);
    configureExpoAndLanding(app);
    log.info("STARTUP", "Registering routes...");
    const server = await registerRoutes(app);
    log.info("STARTUP", "Routes registered successfully");
    log.info("STARTUP", "Starting position reconciliation job...");
    positionReconciliationJob.start();
    log.info("STARTUP", "Position reconciliation job started");
    log.info("STARTUP", "Starting exit rule enforcer...");
    exitRuleEnforcer.start(3e4);
    log.info("STARTUP", "Exit rule enforcer started (30s interval)");
    log.info("STARTUP", "Starting session cleanup job...");
    setInterval(
      async () => {
        try {
          await cleanupExpiredSessions();
        } catch (error) {
          log.error("SessionCleanup", "Error cleaning up expired sessions", {
            error
          });
        }
      },
      60 * 60 * 1e3
    );
    log.info("STARTUP", "Session cleanup job started (runs every hour)");
    setupErrorHandler(app);
    const port = parseInt(process.env.PORT || "5000", 10);
    log.info("STARTUP", `Starting server on port ${port}...`);
    global.httpServer = server;
    log.info("STARTUP", "Initializing WebSocket server...");
    wsServer.initialize(server);
    log.info("STARTUP", "WebSocket server initialized on /ws path");
    server.listen(
      {
        port,
        host: "0.0.0.0",
        reusePort: true
      },
      () => {
        log.info("Server", `Express server listening on port ${port}`);
      }
    );
  } catch (error) {
    log.error("STARTUP", "Fatal error during server initialization", { error });
  }
})();
