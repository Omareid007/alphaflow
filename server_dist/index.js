var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc20) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc20 = __getOwnPropDesc(from, key)) || desc20.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// shared/models/chat.ts
import { pgTable, serial, integer, text, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { sql } from "drizzle-orm";
var conversations, messages, insertConversationSchema, insertMessageSchema;
var init_chat = __esm({
  "shared/models/chat.ts"() {
    "use strict";
    conversations = pgTable("conversations", {
      id: serial("id").primaryKey(),
      title: text("title").notNull(),
      createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    messages = pgTable("messages", {
      id: serial("id").primaryKey(),
      conversationId: integer("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
      role: text("role").notNull(),
      content: text("content").notNull(),
      createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull()
    });
    insertConversationSchema = createInsertSchema(conversations).omit({
      id: true,
      createdAt: true
    });
    insertMessageSchema = createInsertSchema(messages).omit({
      id: true,
      createdAt: true
    });
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  adminSettings: () => adminSettings,
  agentStatus: () => agentStatus,
  aiAgentProfiles: () => aiAgentProfiles,
  aiArenaAgentDecisions: () => aiArenaAgentDecisions,
  aiArenaRuns: () => aiArenaRuns,
  aiCalibrationLog: () => aiCalibrationLog,
  aiDecisionFeatures: () => aiDecisionFeatures,
  aiDecisions: () => aiDecisions,
  aiOutcomeLinks: () => aiOutcomeLinks,
  aiTradeOutcomes: () => aiTradeOutcomes,
  alertEvents: () => alertEvents,
  alertRules: () => alertRules,
  allocationPolicies: () => allocationPolicies,
  analysisFeedback: () => analysisFeedback,
  assetClasses: () => assetClasses,
  assetClassifications: () => assetClassifications,
  auditLogs: () => auditLogs,
  backtestEquityCurve: () => backtestEquityCurve,
  backtestRuns: () => backtestRuns,
  backtestStatuses: () => backtestStatuses,
  backtestTradeEvents: () => backtestTradeEvents,
  brokerAssets: () => brokerAssets,
  competitionRuns: () => competitionRuns,
  competitionScores: () => competitionScores,
  connectorMetrics: () => connectorMetrics,
  conversations: () => conversations,
  dataSourceAnalysis: () => dataSourceAnalysis,
  debateConsensus: () => debateConsensus,
  debateMessages: () => debateMessages,
  debateSessions: () => debateSessions,
  executionPriceRules: () => executionPriceRules,
  externalApiCacheEntries: () => externalApiCacheEntries,
  externalApiUsageCounters: () => externalApiUsageCounters,
  fills: () => fills,
  insertAdminSettingSchema: () => insertAdminSettingSchema,
  insertAiAgentProfileSchema: () => insertAiAgentProfileSchema,
  insertAiArenaAgentDecisionSchema: () => insertAiArenaAgentDecisionSchema,
  insertAiArenaRunSchema: () => insertAiArenaRunSchema,
  insertAiCalibrationLogSchema: () => insertAiCalibrationLogSchema,
  insertAiDecisionFeaturesSchema: () => insertAiDecisionFeaturesSchema,
  insertAiDecisionSchema: () => insertAiDecisionSchema,
  insertAiOutcomeLinkSchema: () => insertAiOutcomeLinkSchema,
  insertAiTradeOutcomesSchema: () => insertAiTradeOutcomesSchema,
  insertAlertEventSchema: () => insertAlertEventSchema,
  insertAlertRuleSchema: () => insertAlertRuleSchema,
  insertAllocationPolicySchema: () => insertAllocationPolicySchema,
  insertAnalysisFeedbackSchema: () => insertAnalysisFeedbackSchema,
  insertAssetClassificationSchema: () => insertAssetClassificationSchema,
  insertAuditLogSchema: () => insertAuditLogSchema,
  insertBacktestEquityCurveSchema: () => insertBacktestEquityCurveSchema,
  insertBacktestRunSchema: () => insertBacktestRunSchema,
  insertBacktestTradeEventSchema: () => insertBacktestTradeEventSchema,
  insertBrokerAssetSchema: () => insertBrokerAssetSchema,
  insertCompetitionRunSchema: () => insertCompetitionRunSchema,
  insertCompetitionScoreSchema: () => insertCompetitionScoreSchema,
  insertConversationSchema: () => insertConversationSchema,
  insertDataSourceAnalysisSchema: () => insertDataSourceAnalysisSchema,
  insertDebateConsensusSchema: () => insertDebateConsensusSchema,
  insertDebateMessageSchema: () => insertDebateMessageSchema,
  insertDebateSessionSchema: () => insertDebateSessionSchema,
  insertExternalApiCacheEntrySchema: () => insertExternalApiCacheEntrySchema,
  insertExternalApiUsageCounterSchema: () => insertExternalApiUsageCounterSchema,
  insertFillSchema: () => insertFillSchema,
  insertInsiderActivityAnalysisSchema: () => insertInsiderActivityAnalysisSchema,
  insertLlmCallSchema: () => insertLlmCallSchema,
  insertLlmRoleConfigSchema: () => insertLlmRoleConfigSchema,
  insertMacroAnalysisSchema: () => insertMacroAnalysisSchema,
  insertMacroIndicatorsSchema: () => insertMacroIndicatorsSchema,
  insertMessageSchema: () => insertMessageSchema,
  insertOrderSchema: () => insertOrderSchema,
  insertPositionSchema: () => insertPositionSchema,
  insertRebalanceRunSchema: () => insertRebalanceRunSchema,
  insertSessionSchema: () => insertSessionSchema,
  insertShortInterestAnalysisSchema: () => insertShortInterestAnalysisSchema,
  insertStrategySchema: () => insertStrategySchema,
  insertStrategyVersionSchema: () => insertStrategyVersionSchema,
  insertToolInvocationSchema: () => insertToolInvocationSchema,
  insertTradeSchema: () => insertTradeSchema,
  insertTraderProfileSchema: () => insertTraderProfileSchema,
  insertUniverseAssetSchema: () => insertUniverseAssetSchema,
  insertUniverseCandidateSchema: () => insertUniverseCandidateSchema,
  insertUniverseFundamentalsSchema: () => insertUniverseFundamentalsSchema,
  insertUniverseLiquiditySchema: () => insertUniverseLiquiditySchema,
  insertUniverseTechnicalsSchema: () => insertUniverseTechnicalsSchema,
  insertUserSchema: () => insertUserSchema,
  insertWorkItemRunSchema: () => insertWorkItemRunSchema,
  insertWorkItemSchema: () => insertWorkItemSchema,
  insiderActivityAnalysis: () => insiderActivityAnalysis,
  llmCalls: () => llmCalls,
  llmRoleConfigs: () => llmRoleConfigs,
  llmRoles: () => llmRoles,
  macroAnalysis: () => macroAnalysis,
  macroIndicators: () => macroIndicators,
  messages: () => messages,
  orderStatuses: () => orderStatuses,
  orderTypes: () => orderTypes,
  orders: () => orders,
  positions: () => positions,
  rebalanceRuns: () => rebalanceRuns,
  sessions: () => sessions,
  shortInterestAnalysis: () => shortInterestAnalysis,
  strategies: () => strategies,
  strategyVersions: () => strategyVersions,
  timeInForceValues: () => timeInForceValues,
  toolInvocations: () => toolInvocations,
  traderProfiles: () => traderProfiles,
  trades: () => trades,
  universeAssets: () => universeAssets,
  universeCandidates: () => universeCandidates,
  universeFundamentals: () => universeFundamentals,
  universeLiquidityMetrics: () => universeLiquidityMetrics,
  universeTechnicals: () => universeTechnicals,
  users: () => users,
  valyuRetrievalCounters: () => valyuRetrievalCounters,
  workItemRuns: () => workItemRuns,
  workItemStatuses: () => workItemStatuses,
  workItemTypes: () => workItemTypes,
  workItems: () => workItems
});
import { sql as sql2 } from "drizzle-orm";
import { pgTable as pgTable2, text as text2, varchar, timestamp as timestamp2, numeric, boolean, integer as integer2, jsonb, index, unique } from "drizzle-orm/pg-core";
import { createInsertSchema as createInsertSchema2 } from "drizzle-zod";
import { z } from "zod";
var users, sessions, strategies, trades, positions, aiDecisions, agentStatus, aiDecisionFeatures, aiTradeOutcomes, aiCalibrationLog, externalApiCacheEntries, externalApiUsageCounters, valyuRetrievalCounters, dataSourceAnalysis, shortInterestAnalysis, insiderActivityAnalysis, macroAnalysis, analysisFeedback, insertAiDecisionFeaturesSchema, insertAiTradeOutcomesSchema, insertAiCalibrationLogSchema, insertDataSourceAnalysisSchema, insertShortInterestAnalysisSchema, insertInsiderActivityAnalysisSchema, insertMacroAnalysisSchema, insertAnalysisFeedbackSchema, insertUserSchema, insertSessionSchema, insertStrategySchema, insertTradeSchema, insertPositionSchema, insertAiDecisionSchema, insertExternalApiCacheEntrySchema, insertExternalApiUsageCounterSchema, llmRoles, llmRoleConfigs, llmCalls, insertLlmRoleConfigSchema, insertLlmCallSchema, workItemTypes, workItemStatuses, workItems, workItemRuns, insertWorkItemSchema, insertWorkItemRunSchema, assetClasses, brokerAssets, insertBrokerAssetSchema, orderStatuses, orderTypes, timeInForceValues, orders, fills, insertOrderSchema, insertFillSchema, backtestStatuses, executionPriceRules, backtestRuns, backtestTradeEvents, backtestEquityCurve, insertBacktestRunSchema, insertBacktestTradeEventSchema, insertBacktestEquityCurveSchema, adminSettings, insertAdminSettingSchema, universeAssets, universeLiquidityMetrics, universeFundamentals, universeTechnicals, macroIndicators, assetClassifications, connectorMetrics, universeCandidates, allocationPolicies, rebalanceRuns, insertUniverseAssetSchema, insertUniverseLiquiditySchema, insertUniverseFundamentalsSchema, insertUniverseTechnicalsSchema, insertMacroIndicatorsSchema, insertAssetClassificationSchema, insertUniverseCandidateSchema, insertAllocationPolicySchema, insertRebalanceRunSchema, alertRules, alertEvents, insertAlertRuleSchema, insertAlertEventSchema, auditLogs, insertAuditLogSchema, debateSessions, debateMessages, debateConsensus, traderProfiles, competitionRuns, competitionScores, strategyVersions, toolInvocations, aiAgentProfiles, aiOutcomeLinks, aiArenaRuns, aiArenaAgentDecisions, insertDebateSessionSchema, insertDebateMessageSchema, insertDebateConsensusSchema, insertTraderProfileSchema, insertCompetitionRunSchema, insertCompetitionScoreSchema, insertStrategyVersionSchema, insertToolInvocationSchema, insertAiAgentProfileSchema, insertAiOutcomeLinkSchema, insertAiArenaRunSchema, insertAiArenaAgentDecisionSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    init_chat();
    users = pgTable2("users", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      username: text2("username").notNull().unique(),
      password: text2("password").notNull(),
      isAdmin: boolean("is_admin").default(false).notNull()
    });
    sessions = pgTable2("sessions", {
      id: text2("id").primaryKey(),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      expiresAt: timestamp2("expires_at").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("sessions_user_id_idx").on(table.userId),
      index("sessions_expires_at_idx").on(table.expiresAt)
    ]);
    strategies = pgTable2("strategies", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull(),
      type: text2("type").notNull(),
      description: text2("description"),
      isActive: boolean("is_active").default(false).notNull(),
      assets: text2("assets").array(),
      parameters: text2("parameters"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    trades = pgTable2("trades", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
      orderId: varchar("order_id").references(() => orders.id, { onDelete: "set null" }),
      symbol: text2("symbol").notNull(),
      side: text2("side").notNull(),
      quantity: numeric("quantity").notNull(),
      price: numeric("price").notNull(),
      executedAt: timestamp2("executed_at").defaultNow().notNull(),
      pnl: numeric("pnl"),
      status: text2("status").default("completed").notNull(),
      notes: text2("notes"),
      traceId: text2("trace_id")
    }, (table) => ({
      userIdIdx: index("trades_user_id_idx").on(table.userId)
    }));
    positions = pgTable2("positions", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      symbol: text2("symbol").notNull(),
      quantity: numeric("quantity").notNull(),
      entryPrice: numeric("entry_price").notNull(),
      currentPrice: numeric("current_price"),
      unrealizedPnl: numeric("unrealized_pnl"),
      side: text2("side").notNull(),
      openedAt: timestamp2("opened_at").defaultNow().notNull(),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" })
    }, (table) => ({
      userIdIdx: index("positions_user_id_idx").on(table.userId)
    }));
    aiDecisions = pgTable2("ai_decisions", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
      symbol: text2("symbol").notNull(),
      action: text2("action").notNull(),
      confidence: numeric("confidence"),
      reasoning: text2("reasoning"),
      marketContext: text2("market_context"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      executedTradeId: varchar("executed_trade_id").references(() => trades.id, { onDelete: "set null" }),
      status: text2("status").default("pending").notNull(),
      stopLoss: numeric("stop_loss"),
      takeProfit: numeric("take_profit"),
      entryPrice: numeric("entry_price"),
      filledPrice: numeric("filled_price"),
      filledAt: timestamp2("filled_at"),
      skipReason: text2("skip_reason"),
      traceId: text2("trace_id"),
      metadata: text2("metadata")
    }, (table) => ({
      userIdIdx: index("ai_decisions_user_id_idx").on(table.userId)
    }));
    agentStatus = pgTable2("agent_status", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      isRunning: boolean("is_running").default(false).notNull(),
      lastHeartbeat: timestamp2("last_heartbeat"),
      totalTrades: integer2("total_trades").default(0),
      totalPnl: numeric("total_pnl").default("0"),
      winRate: numeric("win_rate"),
      cashBalance: numeric("cash_balance").default("100000"),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      killSwitchActive: boolean("kill_switch_active").default(false).notNull(),
      maxPositionSizePercent: numeric("max_position_size_percent").default("10"),
      maxTotalExposurePercent: numeric("max_total_exposure_percent").default("50"),
      maxPositionsCount: integer2("max_positions_count").default(10),
      dailyLossLimitPercent: numeric("daily_loss_limit_percent").default("5"),
      dynamicOrderLimit: integer2("dynamic_order_limit").default(10),
      minOrderLimit: integer2("min_order_limit").default(10),
      maxOrderLimit: integer2("max_order_limit").default(50),
      marketCondition: text2("market_condition").default("neutral"),
      aiConfidenceScore: numeric("ai_confidence_score").default("0.5"),
      autoStartEnabled: boolean("auto_start_enabled").default(true).notNull(),
      lastMarketAnalysis: timestamp2("last_market_analysis"),
      autoExecuteTrades: boolean("auto_execute_trades").default(false).notNull(),
      conservativeMode: boolean("conservative_mode").default(false).notNull()
    });
    aiDecisionFeatures = pgTable2("ai_decision_features", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
      symbol: text2("symbol").notNull(),
      volatility: numeric("volatility"),
      trendStrength: numeric("trend_strength"),
      signalAgreement: numeric("signal_agreement"),
      sentimentScore: numeric("sentiment_score"),
      peRatio: numeric("pe_ratio"),
      pbRatio: numeric("pb_ratio"),
      rsi: numeric("rsi"),
      macdSignal: text2("macd_signal"),
      volumeRatio: numeric("volume_ratio"),
      priceChangePercent: numeric("price_change_percent"),
      marketCondition: text2("market_condition"),
      dataQuality: numeric("data_quality"),
      activeSources: integer2("active_sources"),
      featureVector: text2("feature_vector"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    aiTradeOutcomes = pgTable2("ai_trade_outcomes", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
      tradeId: varchar("trade_id").references(() => trades.id, { onDelete: "set null" }),
      symbol: text2("symbol").notNull(),
      action: text2("action").notNull(),
      predictionConfidence: numeric("prediction_confidence"),
      entryPrice: numeric("entry_price"),
      exitPrice: numeric("exit_price"),
      quantity: numeric("quantity"),
      realizedPnl: numeric("realized_pnl"),
      realizedPnlPercent: numeric("realized_pnl_percent"),
      holdingTimeMs: integer2("holding_time_ms"),
      isWin: boolean("is_win"),
      slippagePercent: numeric("slippage_percent"),
      targetPriceHit: boolean("target_price_hit"),
      stopLossHit: boolean("stop_loss_hit"),
      maxDrawdown: numeric("max_drawdown"),
      maxGain: numeric("max_gain"),
      marketSessionAtEntry: text2("market_session_at_entry"),
      marketSessionAtExit: text2("market_session_at_exit"),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
      exitReason: text2("exit_reason"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      closedAt: timestamp2("closed_at")
    });
    aiCalibrationLog = pgTable2("ai_calibration_log", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      calibrationType: text2("calibration_type").notNull(),
      dataWindowDays: integer2("data_window_days").default(30),
      totalDecisions: integer2("total_decisions"),
      winCount: integer2("win_count"),
      lossCount: integer2("loss_count"),
      avgConfidenceOnWins: numeric("avg_confidence_on_wins"),
      avgConfidenceOnLosses: numeric("avg_confidence_on_losses"),
      avgHoldingTimeWins: integer2("avg_holding_time_wins"),
      avgHoldingTimeLosses: integer2("avg_holding_time_losses"),
      topWinningSymbols: text2("top_winning_symbols"),
      topLosingSymbols: text2("top_losing_symbols"),
      recommendedAdjustments: text2("recommended_adjustments"),
      modelVersion: text2("model_version"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    externalApiCacheEntries = pgTable2("external_api_cache_entries", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      provider: text2("provider").notNull(),
      cacheKey: text2("cache_key").notNull(),
      responseJson: text2("response_json").notNull(),
      expiresAt: timestamp2("expires_at").notNull(),
      staleUntilAt: timestamp2("stale_until_at").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      hitCount: integer2("hit_count").default(0).notNull(),
      lastAccessedAt: timestamp2("last_accessed_at").defaultNow().notNull()
    });
    externalApiUsageCounters = pgTable2("external_api_usage_counters", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      provider: text2("provider").notNull(),
      windowType: text2("window_type").notNull(),
      windowStart: timestamp2("window_start").notNull(),
      windowEnd: timestamp2("window_end").notNull(),
      requestCount: integer2("request_count").default(0).notNull(),
      tokenCount: integer2("token_count").default(0),
      errorCount: integer2("error_count").default(0).notNull(),
      rateLimitHits: integer2("rate_limit_hits").default(0).notNull(),
      cacheHits: integer2("cache_hits").default(0).notNull(),
      cacheMisses: integer2("cache_misses").default(0).notNull(),
      avgLatencyMs: numeric("avg_latency_ms"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    valyuRetrievalCounters = pgTable2("valyu_retrieval_counters", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      sourceTier: text2("source_tier").notNull(),
      monthKey: text2("month_key").notNull(),
      retrievalCount: integer2("retrieval_count").default(0).notNull(),
      lastUpdated: timestamp2("last_updated").defaultNow().notNull()
    });
    dataSourceAnalysis = pgTable2("data_source_analysis", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }),
      symbol: text2("symbol").notNull(),
      source: text2("source").notNull(),
      // finra, sec-edgar, finnhub, fred, frankfurter, etc.
      analysisType: text2("analysis_type").notNull(),
      // short_interest, insider_activity, fundamentals, macro, forex
      dataJson: jsonb("data_json").notNull(),
      // Raw analysis data
      score: numeric("score"),
      // Normalized score (-1 to 1 or 0 to 100)
      signal: text2("signal"),
      // bullish, bearish, neutral
      confidence: numeric("confidence"),
      // 0 to 1
      reliability: numeric("reliability"),
      // Source reliability weight
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("data_source_analysis_decision_id_idx").on(table.decisionId),
      index("data_source_analysis_symbol_idx").on(table.symbol),
      index("data_source_analysis_source_idx").on(table.source),
      index("data_source_analysis_created_at_idx").on(table.createdAt)
    ]);
    shortInterestAnalysis = pgTable2("short_interest_analysis", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull(),
      shortRatio: numeric("short_ratio").notNull(),
      // Short volume / Total volume
      shortVolume: numeric("short_volume"),
      totalVolume: numeric("total_volume"),
      daysToCover: numeric("days_to_cover"),
      shortRatioTrend: text2("short_ratio_trend"),
      // increasing, decreasing, stable
      squeezePotential: text2("squeeze_potential"),
      // high, medium, low
      averageShortRatio: numeric("average_short_ratio"),
      // 20-day average
      analysisDate: timestamp2("analysis_date").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("short_interest_symbol_idx").on(table.symbol),
      index("short_interest_date_idx").on(table.analysisDate),
      unique("short_interest_symbol_date_unique").on(table.symbol, table.analysisDate)
    ]);
    insiderActivityAnalysis = pgTable2("insider_activity_analysis", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull(),
      totalBuys: numeric("total_buys").default("0"),
      totalSells: numeric("total_sells").default("0"),
      netActivity: numeric("net_activity").default("0"),
      // Buys - Sells (shares)
      netValue: numeric("net_value").default("0"),
      // Dollar value
      buyToSellRatio: numeric("buy_to_sell_ratio"),
      sentiment: text2("sentiment"),
      // bullish, bearish, neutral
      recentTransactionsJson: jsonb("recent_transactions_json"),
      // Last 10 transactions
      analysisWindowDays: integer2("analysis_window_days").default(90),
      analysisDate: timestamp2("analysis_date").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("insider_activity_symbol_idx").on(table.symbol),
      index("insider_activity_date_idx").on(table.analysisDate),
      unique("insider_activity_symbol_date_unique").on(table.symbol, table.analysisDate)
    ]);
    macroAnalysis = pgTable2("macro_analysis", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      vix: numeric("vix"),
      fedFundsRate: numeric("fed_funds_rate"),
      yieldCurve: numeric("yield_curve"),
      // 10Y-2Y spread
      inflation: numeric("inflation"),
      // CPI
      unemployment: numeric("unemployment"),
      marketRegime: text2("market_regime"),
      // risk_on, risk_off, neutral
      indicatorsJson: jsonb("indicators_json"),
      // All FRED indicators
      analysisDate: timestamp2("analysis_date").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("macro_analysis_date_idx").on(table.analysisDate),
      unique("macro_analysis_date_unique").on(table.analysisDate)
    ]);
    analysisFeedback = pgTable2("analysis_feedback", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      dataSourceAnalysisId: varchar("data_source_analysis_id").references(() => dataSourceAnalysis.id, { onDelete: "cascade" }),
      tradeOutcomeId: varchar("trade_outcome_id").references(() => aiTradeOutcomes.id, { onDelete: "cascade" }),
      symbol: text2("symbol").notNull(),
      source: text2("source").notNull(),
      signalAtEntry: text2("signal_at_entry"),
      // The signal when trade was entered
      confidenceAtEntry: numeric("confidence_at_entry"),
      tradeResult: text2("trade_result"),
      // win, loss
      pnlPercent: numeric("pnl_percent"),
      signalAccuracy: boolean("signal_accuracy"),
      // Did signal predict correctly?
      holdingTimeMs: integer2("holding_time_ms"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("analysis_feedback_source_idx").on(table.source),
      index("analysis_feedback_symbol_idx").on(table.symbol),
      index("analysis_feedback_created_at_idx").on(table.createdAt)
    ]);
    insertAiDecisionFeaturesSchema = createInsertSchema2(aiDecisionFeatures).omit({
      id: true,
      createdAt: true
    });
    insertAiTradeOutcomesSchema = createInsertSchema2(aiTradeOutcomes).omit({
      id: true,
      createdAt: true
    });
    insertAiCalibrationLogSchema = createInsertSchema2(aiCalibrationLog).omit({
      id: true,
      createdAt: true
    });
    insertDataSourceAnalysisSchema = createInsertSchema2(dataSourceAnalysis).omit({
      id: true,
      createdAt: true
    });
    insertShortInterestAnalysisSchema = createInsertSchema2(shortInterestAnalysis).omit({
      id: true,
      createdAt: true
    });
    insertInsiderActivityAnalysisSchema = createInsertSchema2(insiderActivityAnalysis).omit({
      id: true,
      createdAt: true
    });
    insertMacroAnalysisSchema = createInsertSchema2(macroAnalysis).omit({
      id: true,
      createdAt: true
    });
    insertAnalysisFeedbackSchema = createInsertSchema2(analysisFeedback).omit({
      id: true,
      createdAt: true
    });
    insertUserSchema = createInsertSchema2(users).pick({
      username: true,
      password: true,
      isAdmin: true
    }).extend({
      isAdmin: z.boolean().optional()
    });
    insertSessionSchema = createInsertSchema2(sessions).omit({
      createdAt: true
    });
    insertStrategySchema = createInsertSchema2(strategies).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      // Make assets optional and allow empty arrays
      assets: z.array(z.string()).optional().default([])
    });
    insertTradeSchema = createInsertSchema2(trades).omit({
      id: true,
      executedAt: true
    });
    insertPositionSchema = createInsertSchema2(positions).omit({
      id: true,
      openedAt: true
    });
    insertAiDecisionSchema = createInsertSchema2(aiDecisions).omit({
      id: true,
      createdAt: true
    });
    insertExternalApiCacheEntrySchema = createInsertSchema2(externalApiCacheEntries).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      hitCount: true,
      lastAccessedAt: true
    });
    insertExternalApiUsageCounterSchema = createInsertSchema2(externalApiUsageCounters).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    llmRoles = [
      "market_news_summarizer",
      "technical_analyst",
      "risk_manager",
      "execution_planner",
      "post_trade_reporter",
      // New roles added for enhanced trading capabilities
      "position_sizer",
      // Optimal position sizing based on risk and market conditions
      "sentiment_analyst",
      // Dedicated sentiment analysis from news and social sources
      "post_trade_analyzer",
      // Detailed trade performance analysis and learning
      "futures_analyst"
      // Specialized futures market analysis
    ];
    llmRoleConfigs = pgTable2("llm_role_configs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      role: text2("role").notNull().unique(),
      description: text2("description"),
      fallbackChain: text2("fallback_chain").notNull(),
      maxTokens: integer2("max_tokens").default(1e3),
      temperature: numeric("temperature").default("0.3"),
      enableCitations: boolean("enable_citations").default(false).notNull(),
      isActive: boolean("is_active").default(true).notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    llmCalls = pgTable2("llm_calls", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      role: text2("role").notNull(),
      provider: text2("provider").notNull(),
      model: text2("model").notNull(),
      promptTokens: integer2("prompt_tokens"),
      completionTokens: integer2("completion_tokens"),
      totalTokens: integer2("total_tokens"),
      estimatedCost: numeric("estimated_cost"),
      latencyMs: integer2("latency_ms"),
      status: text2("status").default("success").notNull(),
      errorMessage: text2("error_message"),
      systemPrompt: text2("system_prompt"),
      userPrompt: text2("user_prompt"),
      response: text2("response"),
      cacheHit: boolean("cache_hit").default(false).notNull(),
      fallbackUsed: boolean("fallback_used").default(false).notNull(),
      fallbackReason: text2("fallback_reason"),
      traceId: text2("trace_id"),
      criticality: text2("criticality"),
      purpose: text2("purpose"),
      metadata: text2("metadata"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    insertLlmRoleConfigSchema = createInsertSchema2(llmRoleConfigs).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertLlmCallSchema = createInsertSchema2(llmCalls).omit({
      id: true,
      createdAt: true
    });
    workItemTypes = [
      "ORDER_SUBMIT",
      "ORDER_CANCEL",
      "ORDER_SYNC",
      "POSITION_CLOSE",
      "KILL_SWITCH",
      "DECISION_EVALUATION",
      "ASSET_UNIVERSE_SYNC"
    ];
    workItemStatuses = [
      "PENDING",
      "RUNNING",
      "SUCCEEDED",
      "FAILED",
      "DEAD_LETTER"
    ];
    workItems = pgTable2("work_items", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      type: text2("type").notNull(),
      status: text2("status").default("PENDING").notNull(),
      attempts: integer2("attempts").default(0).notNull(),
      maxAttempts: integer2("max_attempts").default(3).notNull(),
      nextRunAt: timestamp2("next_run_at").defaultNow().notNull(),
      lastError: text2("last_error"),
      payload: text2("payload"),
      idempotencyKey: text2("idempotency_key").unique(),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "set null" }),
      brokerOrderId: text2("broker_order_id"),
      symbol: text2("symbol"),
      result: text2("result"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    workItemRuns = pgTable2("work_item_runs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      workItemId: varchar("work_item_id").references(() => workItems.id, { onDelete: "cascade" }).notNull(),
      attemptNumber: integer2("attempt_number").notNull(),
      startedAt: timestamp2("started_at").defaultNow().notNull(),
      completedAt: timestamp2("completed_at"),
      status: text2("status").default("RUNNING").notNull(),
      error: text2("error"),
      durationMs: integer2("duration_ms"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    });
    insertWorkItemSchema = createInsertSchema2(workItems).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      attempts: true
    });
    insertWorkItemRunSchema = createInsertSchema2(workItemRuns).omit({
      id: true,
      createdAt: true
    });
    assetClasses = ["us_equity", "crypto"];
    brokerAssets = pgTable2("broker_assets", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      alpacaId: text2("alpaca_id").notNull().unique(),
      symbol: text2("symbol").notNull().unique(),
      name: text2("name").notNull(),
      assetClass: text2("asset_class").notNull(),
      exchange: text2("exchange").notNull(),
      status: text2("status").notNull(),
      tradable: boolean("tradable").default(false).notNull(),
      marginable: boolean("marginable").default(false).notNull(),
      shortable: boolean("shortable").default(false).notNull(),
      easyToBorrow: boolean("easy_to_borrow").default(false).notNull(),
      fractionable: boolean("fractionable").default(false).notNull(),
      minOrderSize: numeric("min_order_size"),
      minTradeIncrement: numeric("min_trade_increment"),
      priceIncrement: numeric("price_increment"),
      lastSyncedAt: timestamp2("last_synced_at").defaultNow().notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    });
    insertBrokerAssetSchema = createInsertSchema2(brokerAssets).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    orderStatuses = [
      "new",
      "accepted",
      "pending_new",
      "partially_filled",
      "filled",
      "canceled",
      "rejected",
      "expired",
      "replaced",
      "pending_cancel",
      "pending_replace",
      "stopped",
      "suspended",
      "calculated",
      "done_for_day"
    ];
    orderTypes = ["market", "limit", "stop", "stop_limit"];
    timeInForceValues = ["day", "gtc", "opg", "cls", "ioc", "fok"];
    orders = pgTable2("orders", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
      broker: text2("broker").notNull(),
      brokerOrderId: text2("broker_order_id").notNull().unique(),
      clientOrderId: text2("client_order_id").unique(),
      symbol: text2("symbol").notNull(),
      side: text2("side").notNull(),
      type: text2("type").notNull(),
      timeInForce: text2("time_in_force"),
      qty: numeric("qty"),
      notional: numeric("notional"),
      limitPrice: numeric("limit_price"),
      stopPrice: numeric("stop_price"),
      status: text2("status").notNull(),
      // ADDED: Missing Alpaca order fields for complete tracking
      extendedHours: boolean("extended_hours").default(false),
      orderClass: text2("order_class"),
      // simple, bracket, oco, oto
      submittedAt: timestamp2("submitted_at").notNull(),
      updatedAt: timestamp2("updated_at").notNull(),
      filledAt: timestamp2("filled_at"),
      expiredAt: timestamp2("expired_at"),
      canceledAt: timestamp2("canceled_at"),
      failedAt: timestamp2("failed_at"),
      filledQty: numeric("filled_qty"),
      filledAvgPrice: numeric("filled_avg_price"),
      traceId: text2("trace_id"),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "set null" }),
      tradeIntentId: varchar("trade_intent_id").references(() => trades.id, { onDelete: "set null" }),
      workItemId: varchar("work_item_id").references(() => workItems.id, { onDelete: "set null" }),
      rawJson: jsonb("raw_json"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("orders_user_id_idx").on(table.userId),
      index("orders_broker_order_id_idx").on(table.brokerOrderId),
      index("orders_client_order_id_idx").on(table.clientOrderId),
      index("orders_symbol_idx").on(table.symbol),
      index("orders_status_idx").on(table.status),
      index("orders_trace_id_idx").on(table.traceId),
      index("orders_decision_id_idx").on(table.decisionId)
    ]);
    fills = pgTable2("fills", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      broker: text2("broker").notNull(),
      brokerOrderId: text2("broker_order_id").notNull(),
      brokerFillId: text2("broker_fill_id").unique(),
      orderId: varchar("order_id").references(() => orders.id, { onDelete: "cascade" }),
      symbol: text2("symbol").notNull(),
      side: text2("side").notNull(),
      qty: numeric("qty").notNull(),
      price: numeric("price").notNull(),
      occurredAt: timestamp2("occurred_at").notNull(),
      traceId: text2("trace_id"),
      rawJson: jsonb("raw_json"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("fills_broker_order_id_idx").on(table.brokerOrderId),
      index("fills_order_id_idx").on(table.orderId),
      index("fills_symbol_idx").on(table.symbol),
      index("fills_trace_id_idx").on(table.traceId)
    ]);
    insertOrderSchema = createInsertSchema2(orders).omit({
      id: true,
      createdAt: true
    });
    insertFillSchema = createInsertSchema2(fills).omit({
      id: true,
      createdAt: true
    });
    backtestStatuses = ["QUEUED", "RUNNING", "DONE", "FAILED"];
    executionPriceRules = ["NEXT_OPEN", "NEXT_CLOSE"];
    backtestRuns = pgTable2("backtest_runs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull(),
      status: text2("status").default("QUEUED").notNull(),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
      strategyConfigHash: text2("strategy_config_hash").notNull(),
      strategyConfig: jsonb("strategy_config").notNull(),
      universe: text2("universe").array().notNull(),
      broker: text2("broker").notNull(),
      timeframe: text2("timeframe").notNull(),
      startDate: text2("start_date").notNull(),
      endDate: text2("end_date").notNull(),
      initialCash: numeric("initial_cash").notNull(),
      feesModel: jsonb("fees_model").notNull(),
      slippageModel: jsonb("slippage_model").notNull(),
      executionPriceRule: text2("execution_price_rule").notNull(),
      dataSource: text2("data_source").notNull(),
      provenance: jsonb("provenance"),
      resultsSummary: jsonb("results_summary"),
      errorMessage: text2("error_message"),
      runtimeMs: integer2("runtime_ms")
    }, (table) => [
      index("backtest_runs_status_idx").on(table.status),
      index("backtest_runs_strategy_id_idx").on(table.strategyId),
      index("backtest_runs_created_at_idx").on(table.createdAt)
    ]);
    backtestTradeEvents = pgTable2("backtest_trade_events", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      runId: varchar("run_id").references(() => backtestRuns.id, { onDelete: "cascade" }).notNull(),
      ts: timestamp2("ts").notNull(),
      symbol: text2("symbol").notNull(),
      side: text2("side").notNull(),
      qty: numeric("qty").notNull(),
      price: numeric("price").notNull(),
      reason: text2("reason").notNull(),
      orderType: text2("order_type").notNull(),
      fees: numeric("fees").notNull(),
      slippage: numeric("slippage").notNull(),
      positionAfter: numeric("position_after").notNull(),
      cashAfter: numeric("cash_after").notNull()
    }, (table) => [
      index("backtest_trade_events_run_id_idx").on(table.runId),
      index("backtest_trade_events_ts_idx").on(table.ts),
      index("backtest_trade_events_symbol_idx").on(table.symbol)
    ]);
    backtestEquityCurve = pgTable2("backtest_equity_curve", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      runId: varchar("run_id").references(() => backtestRuns.id, { onDelete: "cascade" }).notNull(),
      ts: timestamp2("ts").notNull(),
      equity: numeric("equity").notNull(),
      cash: numeric("cash").notNull(),
      exposure: numeric("exposure").notNull()
    }, (table) => [
      index("backtest_equity_curve_run_id_idx").on(table.runId),
      index("backtest_equity_curve_ts_idx").on(table.ts)
    ]);
    insertBacktestRunSchema = createInsertSchema2(backtestRuns).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertBacktestTradeEventSchema = createInsertSchema2(backtestTradeEvents).omit({
      id: true
    });
    insertBacktestEquityCurveSchema = createInsertSchema2(backtestEquityCurve).omit({
      id: true
    });
    adminSettings = pgTable2("admin_settings", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      namespace: text2("namespace").notNull(),
      key: text2("key").notNull(),
      value: jsonb("value").notNull(),
      description: text2("description"),
      isSecret: boolean("is_secret").default(false).notNull(),
      isReadOnly: boolean("is_read_only").default(false).notNull(),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("admin_settings_namespace_idx").on(table.namespace),
      index("admin_settings_key_idx").on(table.key),
      unique("admin_settings_namespace_key_unique").on(table.namespace, table.key)
    ]);
    insertAdminSettingSchema = createInsertSchema2(adminSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    universeAssets = pgTable2("universe_assets", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull().unique(),
      name: text2("name").notNull(),
      exchange: text2("exchange").notNull(),
      assetClass: text2("asset_class").notNull(),
      status: text2("status").notNull(),
      tradable: boolean("tradable").default(false).notNull(),
      marginable: boolean("marginable").default(false).notNull(),
      shortable: boolean("shortable").default(false).notNull(),
      fractionable: boolean("fractionable").default(false).notNull(),
      easyToBorrow: boolean("easy_to_borrow").default(false).notNull(),
      isOtc: boolean("is_otc").default(false).notNull(),
      isSpac: boolean("is_spac").default(false).notNull(),
      isPennyStock: boolean("is_penny_stock").default(false).notNull(),
      excluded: boolean("excluded").default(false).notNull(),
      excludeReason: text2("exclude_reason"),
      lastRefreshedAt: timestamp2("last_refreshed_at").defaultNow().notNull(),
      rawJson: jsonb("raw_json")
    }, (table) => [
      index("universe_assets_symbol_idx").on(table.symbol),
      index("universe_assets_tradable_idx").on(table.tradable),
      index("universe_assets_exchange_idx").on(table.exchange)
    ]);
    universeLiquidityMetrics = pgTable2("universe_liquidity_metrics", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull().unique(),
      avgDailyVolumeShares: numeric("avg_daily_volume_shares"),
      avgDailyTradedValueUsd: numeric("avg_daily_traded_value_usd"),
      avgBidAskSpreadPct: numeric("avg_bid_ask_spread_pct"),
      latestPrice: numeric("latest_price"),
      priceDataDays: integer2("price_data_days").default(30),
      liquidityTier: text2("liquidity_tier"),
      source: text2("source").notNull(),
      lastUpdatedAt: timestamp2("last_updated_at").defaultNow().notNull(),
      rawJson: jsonb("raw_json")
    }, (table) => [
      index("universe_liquidity_symbol_idx").on(table.symbol),
      index("universe_liquidity_tier_idx").on(table.liquidityTier)
    ]);
    universeFundamentals = pgTable2("universe_fundamentals", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull().unique(),
      marketCap: numeric("market_cap"),
      revenueTtm: numeric("revenue_ttm"),
      revenueCagr3y: numeric("revenue_cagr_3y"),
      grossMargin: numeric("gross_margin"),
      operatingMargin: numeric("operating_margin"),
      netMargin: numeric("net_margin"),
      freeCashFlowMargin: numeric("free_cash_flow_margin"),
      debtToEquity: numeric("debt_to_equity"),
      sharesDilution1y: numeric("shares_dilution_1y"),
      peRatio: numeric("pe_ratio"),
      priceToBook: numeric("price_to_book"),
      beta: numeric("beta"),
      week52High: numeric("week_52_high"),
      week52Low: numeric("week_52_low"),
      dividendYield: numeric("dividend_yield"),
      sector: text2("sector"),
      industry: text2("industry"),
      source: text2("source").notNull(),
      lastUpdatedAt: timestamp2("last_updated_at").defaultNow().notNull(),
      rawJson: jsonb("raw_json")
    }, (table) => [
      index("universe_fundamentals_symbol_idx").on(table.symbol),
      index("universe_fundamentals_sector_idx").on(table.sector)
    ]);
    universeTechnicals = pgTable2("universe_technicals", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull(),
      date: timestamp2("date").notNull(),
      open: numeric("open"),
      high: numeric("high"),
      low: numeric("low"),
      close: numeric("close"),
      volume: numeric("volume"),
      vwap: numeric("vwap"),
      sma20: numeric("sma_20"),
      sma50: numeric("sma_50"),
      sma200: numeric("sma_200"),
      ema12: numeric("ema_12"),
      ema26: numeric("ema_26"),
      rsi14: numeric("rsi_14"),
      macd: numeric("macd"),
      macdSignal: numeric("macd_signal"),
      macdHistogram: numeric("macd_histogram"),
      atr14: numeric("atr_14"),
      bollingerUpper: numeric("bollinger_upper"),
      bollingerLower: numeric("bollinger_lower"),
      adx14: numeric("adx_14"),
      plusDi: numeric("plus_di"),
      minusDi: numeric("minus_di"),
      pivotPoint: numeric("pivot_point"),
      resistance1: numeric("resistance_1"),
      support1: numeric("support_1"),
      source: text2("source").notNull(),
      lastUpdatedAt: timestamp2("last_updated_at").defaultNow().notNull()
    }, (table) => [
      index("universe_technicals_symbol_idx").on(table.symbol),
      index("universe_technicals_date_idx").on(table.date),
      unique("universe_technicals_symbol_date_unique").on(table.symbol, table.date)
    ]);
    macroIndicators = pgTable2("macro_indicators", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      indicatorId: text2("indicator_id").notNull().unique(),
      name: text2("name").notNull(),
      category: text2("category").notNull(),
      latestValue: numeric("latest_value"),
      previousValue: numeric("previous_value"),
      changePercent: numeric("change_percent"),
      frequency: text2("frequency"),
      lastUpdatedAt: timestamp2("last_updated_at").defaultNow().notNull(),
      source: text2("source").notNull().default("FRED"),
      rawJson: jsonb("raw_json")
    }, (table) => [
      index("macro_indicators_category_idx").on(table.category),
      index("macro_indicators_indicator_id_idx").on(table.indicatorId)
    ]);
    assetClassifications = pgTable2("asset_classifications", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull().unique(),
      assetClass: text2("asset_class"),
      marketCapTier: text2("market_cap_tier"),
      liquidityTier: text2("liquidity_tier"),
      volatilityTier: text2("volatility_tier"),
      trendStrength: text2("trend_strength"),
      momentumScore: numeric("momentum_score"),
      valueScore: numeric("value_score"),
      qualityScore: numeric("quality_score"),
      lastUpdatedAt: timestamp2("last_updated_at").defaultNow().notNull(),
      source: text2("source").notNull(),
      rawJson: jsonb("raw_json")
    }, (table) => [
      index("asset_classifications_symbol_idx").on(table.symbol),
      index("asset_classifications_asset_class_idx").on(table.assetClass),
      index("asset_classifications_market_cap_tier_idx").on(table.marketCapTier)
    ]);
    connectorMetrics = pgTable2("connector_metrics", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      connector: text2("connector").notNull(),
      endpoint: text2("endpoint").notNull(),
      date: timestamp2("date").notNull().defaultNow(),
      totalRequests: integer2("total_requests").default(0).notNull(),
      successCount: integer2("success_count").default(0).notNull(),
      failureCount: integer2("failure_count").default(0).notNull(),
      cacheHits: integer2("cache_hits").default(0).notNull(),
      cacheMisses: integer2("cache_misses").default(0).notNull(),
      rateLimitHits: integer2("rate_limit_hits").default(0).notNull(),
      fallbackUsed: integer2("fallback_used").default(0).notNull(),
      avgLatencyMs: numeric("avg_latency_ms"),
      p50LatencyMs: numeric("p50_latency_ms"),
      p95LatencyMs: numeric("p95_latency_ms"),
      p99LatencyMs: numeric("p99_latency_ms"),
      lastError: text2("last_error"),
      lastErrorAt: timestamp2("last_error_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("connector_metrics_connector_idx").on(table.connector),
      index("connector_metrics_date_idx").on(table.date),
      unique("connector_metrics_connector_endpoint_date_unique").on(table.connector, table.endpoint, table.date)
    ]);
    universeCandidates = pgTable2("universe_candidates", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      symbol: text2("symbol").notNull().unique(),
      tier: text2("tier").notNull(),
      liquidityScore: numeric("liquidity_score"),
      growthScore: numeric("growth_score"),
      qualityScore: numeric("quality_score"),
      finalScore: numeric("final_score"),
      themeTags: jsonb("theme_tags"),
      rationale: text2("rationale"),
      status: text2("status").notNull().default("NEW"),
      approvedBy: varchar("approved_by").references(() => users.id, { onDelete: "set null" }),
      approvedAt: timestamp2("approved_at"),
      traceId: text2("trace_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("universe_candidates_symbol_idx").on(table.symbol),
      index("universe_candidates_status_idx").on(table.status),
      index("universe_candidates_tier_idx").on(table.tier),
      index("universe_candidates_final_score_idx").on(table.finalScore)
    ]);
    allocationPolicies = pgTable2("allocation_policies", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      isActive: boolean("is_active").default(false).notNull(),
      maxPositionWeightPct: numeric("max_position_weight_pct").default("8"),
      maxSectorWeightPct: numeric("max_sector_weight_pct").default("25"),
      minLiquidityTier: text2("min_liquidity_tier").default("B"),
      profitTakingThresholdPct: numeric("profit_taking_threshold_pct").default("20"),
      overweightThresholdPct: numeric("overweight_threshold_pct").default("50"),
      rotationTopN: integer2("rotation_top_n").default(10),
      rebalanceFrequency: text2("rebalance_frequency").default("daily"),
      createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("allocation_policies_active_idx").on(table.isActive)
    ]);
    rebalanceRuns = pgTable2("rebalance_runs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      policyId: varchar("policy_id").references(() => allocationPolicies.id, { onDelete: "set null" }),
      traceId: text2("trace_id").notNull(),
      status: text2("status").notNull().default("pending"),
      triggerType: text2("trigger_type").notNull(),
      inputSnapshot: jsonb("input_snapshot"),
      orderIntents: jsonb("order_intents"),
      executedOrders: jsonb("executed_orders"),
      rationale: text2("rationale"),
      startedAt: timestamp2("started_at").defaultNow().notNull(),
      completedAt: timestamp2("completed_at")
    }, (table) => [
      index("rebalance_runs_trace_id_idx").on(table.traceId),
      index("rebalance_runs_status_idx").on(table.status)
    ]);
    insertUniverseAssetSchema = createInsertSchema2(universeAssets).omit({
      id: true,
      lastRefreshedAt: true
    });
    insertUniverseLiquiditySchema = createInsertSchema2(universeLiquidityMetrics).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseFundamentalsSchema = createInsertSchema2(universeFundamentals).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseTechnicalsSchema = createInsertSchema2(universeTechnicals).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertMacroIndicatorsSchema = createInsertSchema2(macroIndicators).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertAssetClassificationSchema = createInsertSchema2(assetClassifications).omit({
      id: true,
      lastUpdatedAt: true
    });
    insertUniverseCandidateSchema = createInsertSchema2(universeCandidates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAllocationPolicySchema = createInsertSchema2(allocationPolicies).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRebalanceRunSchema = createInsertSchema2(rebalanceRuns).omit({
      id: true,
      startedAt: true
    });
    alertRules = pgTable2("alert_rules", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      ruleType: text2("rule_type").notNull(),
      condition: jsonb("condition").notNull(),
      threshold: numeric("threshold").notNull(),
      enabled: boolean("enabled").default(true).notNull(),
      webhookUrl: text2("webhook_url"),
      lastTriggeredAt: timestamp2("last_triggered_at"),
      lastCheckedAt: timestamp2("last_checked_at"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("alert_rules_enabled_idx").on(table.enabled),
      index("alert_rules_type_idx").on(table.ruleType)
    ]);
    alertEvents = pgTable2("alert_events", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      ruleId: varchar("rule_id").references(() => alertRules.id, { onDelete: "cascade" }).notNull(),
      ruleName: text2("rule_name").notNull(),
      ruleType: text2("rule_type").notNull(),
      triggeredValue: numeric("triggered_value").notNull(),
      threshold: numeric("threshold").notNull(),
      status: text2("status").default("triggered").notNull(),
      webhookSent: boolean("webhook_sent").default(false),
      webhookResponse: text2("webhook_response"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("alert_events_rule_id_idx").on(table.ruleId),
      index("alert_events_created_at_idx").on(table.createdAt)
    ]);
    insertAlertRuleSchema = createInsertSchema2(alertRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertAlertEventSchema = createInsertSchema2(alertEvents).omit({
      id: true,
      createdAt: true
    });
    auditLogs = pgTable2("audit_logs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      username: text2("username"),
      action: text2("action").notNull(),
      resource: text2("resource").notNull(),
      resourceId: text2("resource_id"),
      method: text2("method").notNull(),
      path: text2("path").notNull(),
      ipAddress: text2("ip_address"),
      userAgent: text2("user_agent"),
      requestBody: jsonb("request_body"),
      responseStatus: integer2("response_status"),
      errorMessage: text2("error_message"),
      timestamp: timestamp2("timestamp").defaultNow().notNull()
    }, (table) => [
      index("audit_logs_user_id_idx").on(table.userId),
      index("audit_logs_action_idx").on(table.action),
      index("audit_logs_resource_idx").on(table.resource),
      index("audit_logs_timestamp_idx").on(table.timestamp)
    ]);
    insertAuditLogSchema = createInsertSchema2(auditLogs).omit({
      id: true,
      timestamp: true
    });
    debateSessions = pgTable2("debate_sessions", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      traceId: text2("trace_id").notNull(),
      strategyVersionId: varchar("strategy_version_id"),
      symbols: text2("symbols").array().notNull(),
      status: text2("status").$type().default("pending").notNull(),
      triggeredBy: text2("triggered_by"),
      marketContext: jsonb("market_context"),
      config: jsonb("config"),
      startedAt: timestamp2("started_at"),
      completedAt: timestamp2("completed_at"),
      durationMs: integer2("duration_ms"),
      totalCost: numeric("total_cost"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("debate_sessions_trace_id_idx").on(table.traceId),
      index("debate_sessions_status_idx").on(table.status),
      index("debate_sessions_created_at_idx").on(table.createdAt)
    ]);
    debateMessages = pgTable2("debate_messages", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      sessionId: varchar("session_id").references(() => debateSessions.id, { onDelete: "cascade" }).notNull(),
      role: text2("role").$type().notNull(),
      stance: text2("stance"),
      confidence: numeric("confidence"),
      keySignals: jsonb("key_signals"),
      risks: jsonb("risks"),
      invalidationPoints: jsonb("invalidation_points"),
      proposedAction: text2("proposed_action"),
      proposedOrder: jsonb("proposed_order"),
      evidenceRefs: jsonb("evidence_refs"),
      rawOutput: text2("raw_output"),
      provider: text2("provider"),
      model: text2("model"),
      tokensUsed: integer2("tokens_used"),
      estimatedCost: numeric("estimated_cost"),
      latencyMs: integer2("latency_ms"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("debate_messages_session_id_idx").on(table.sessionId),
      index("debate_messages_role_idx").on(table.role)
    ]);
    debateConsensus = pgTable2("debate_consensus", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      sessionId: varchar("session_id").references(() => debateSessions.id, { onDelete: "cascade" }).notNull().unique(),
      decision: text2("decision").notNull(),
      orderIntent: jsonb("order_intent"),
      reasonsSummary: text2("reasons_summary"),
      riskChecks: jsonb("risk_checks"),
      confidence: numeric("confidence"),
      dissent: jsonb("dissent"),
      workItemId: varchar("work_item_id").references(() => workItems.id, { onDelete: "set null" }),
      brokerOrderId: text2("broker_order_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("debate_consensus_session_id_idx").on(table.sessionId),
      index("debate_consensus_work_item_id_idx").on(table.workItemId)
    ]);
    traderProfiles = pgTable2("trader_profiles", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      strategyVersionId: varchar("strategy_version_id"),
      modelProfile: jsonb("model_profile"),
      riskPreset: jsonb("risk_preset"),
      universeFilter: jsonb("universe_filter"),
      isPromoted: boolean("is_promoted").default(false).notNull(),
      status: text2("status").$type().default("active").notNull(),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("trader_profiles_status_idx").on(table.status),
      index("trader_profiles_promoted_idx").on(table.isPromoted)
    ]);
    competitionRuns = pgTable2("competition_runs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull(),
      traceId: text2("trace_id").notNull(),
      mode: text2("mode").$type().notNull(),
      traderIds: text2("trader_ids").array().notNull(),
      universeSymbols: text2("universe_symbols").array(),
      startedAt: timestamp2("started_at").defaultNow().notNull(),
      endedAt: timestamp2("ended_at"),
      durationMinutes: integer2("duration_minutes"),
      status: text2("status").$type().default("pending").notNull(),
      config: jsonb("config"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("competition_runs_trace_id_idx").on(table.traceId),
      index("competition_runs_status_idx").on(table.status)
    ]);
    competitionScores = pgTable2("competition_scores", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      runId: varchar("run_id").references(() => competitionRuns.id, { onDelete: "cascade" }).notNull(),
      traderProfileId: varchar("trader_profile_id").references(() => traderProfiles.id, { onDelete: "cascade" }).notNull(),
      totalPnl: numeric("total_pnl").default("0").notNull(),
      roi: numeric("roi").default("0").notNull(),
      maxDrawdown: numeric("max_drawdown").default("0").notNull(),
      winRate: numeric("win_rate").default("0").notNull(),
      avgHoldTime: integer2("avg_hold_time"),
      tradeCount: integer2("trade_count").default(0).notNull(),
      errorCount: integer2("error_count").default(0).notNull(),
      costPerDecision: numeric("cost_per_decision"),
      slippageProxy: numeric("slippage_proxy"),
      rank: integer2("rank"),
      snapshotAt: timestamp2("snapshot_at").defaultNow().notNull(),
      details: jsonb("details")
    }, (table) => [
      index("competition_scores_run_id_idx").on(table.runId),
      index("competition_scores_trader_id_idx").on(table.traderProfileId),
      index("competition_scores_rank_idx").on(table.rank)
    ]);
    strategyVersions = pgTable2("strategy_versions", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "cascade" }).notNull(),
      version: integer2("version").notNull(),
      name: text2("name").notNull(),
      spec: jsonb("spec").notNull(),
      universeConfig: jsonb("universe_config"),
      signalsConfig: jsonb("signals_config"),
      riskConfig: jsonb("risk_config"),
      llmPolicy: jsonb("llm_policy"),
      promptTemplate: text2("prompt_template"),
      status: text2("status").$type().default("draft").notNull(),
      dryRunResult: jsonb("dry_run_result"),
      changeNotes: text2("change_notes"),
      createdBy: varchar("created_by"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      activatedAt: timestamp2("activated_at")
    }, (table) => [
      index("strategy_versions_strategy_id_idx").on(table.strategyId),
      index("strategy_versions_status_idx").on(table.status),
      unique("strategy_versions_unique").on(table.strategyId, table.version)
    ]);
    toolInvocations = pgTable2("tool_invocations", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      traceId: text2("trace_id").notNull(),
      toolName: text2("tool_name").notNull(),
      category: text2("category").$type().notNull(),
      inputParams: jsonb("input_params"),
      outputResult: jsonb("output_result"),
      status: text2("status").$type().default("pending").notNull(),
      errorMessage: text2("error_message"),
      cacheHit: boolean("cache_hit").default(false).notNull(),
      latencyMs: integer2("latency_ms"),
      callerRole: text2("caller_role"),
      debateSessionId: varchar("debate_session_id").references(() => debateSessions.id, { onDelete: "set null" }),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("tool_invocations_trace_id_idx").on(table.traceId),
      index("tool_invocations_tool_name_idx").on(table.toolName),
      index("tool_invocations_created_at_idx").on(table.createdAt),
      index("tool_invocations_session_id_idx").on(table.debateSessionId)
    ]);
    aiAgentProfiles = pgTable2("ai_agent_profiles", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      name: text2("name").notNull().unique(),
      description: text2("description"),
      provider: text2("provider").$type().notNull(),
      model: text2("model").notNull(),
      role: text2("role").$type().notNull(),
      mode: text2("mode").$type().default("cheap_first").notNull(),
      temperature: numeric("temperature").default("0.7"),
      maxTokens: integer2("max_tokens").default(2e3),
      promptTemplateId: varchar("prompt_template_id"),
      toolPolicy: jsonb("tool_policy"),
      budgetLimitPerDay: numeric("budget_limit_per_day"),
      budgetLimitPerRun: numeric("budget_limit_per_run"),
      priority: integer2("priority").default(0),
      status: text2("status").$type().default("active").notNull(),
      totalCalls: integer2("total_calls").default(0).notNull(),
      totalTokens: integer2("total_tokens").default(0).notNull(),
      totalCostUsd: numeric("total_cost_usd").default("0").notNull(),
      avgLatencyMs: numeric("avg_latency_ms"),
      successRate: numeric("success_rate"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      updatedAt: timestamp2("updated_at").defaultNow().notNull()
    }, (table) => [
      index("ai_agent_profiles_status_idx").on(table.status),
      index("ai_agent_profiles_role_idx").on(table.role),
      index("ai_agent_profiles_mode_idx").on(table.mode)
    ]);
    aiOutcomeLinks = pgTable2("ai_outcome_links", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      consensusId: varchar("consensus_id").references(() => debateConsensus.id, { onDelete: "set null" }),
      debateSessionId: varchar("debate_session_id").references(() => debateSessions.id, { onDelete: "set null" }),
      decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "set null" }),
      workItemId: varchar("work_item_id").references(() => workItems.id, { onDelete: "set null" }),
      brokerOrderId: varchar("broker_order_id"),
      symbol: text2("symbol").notNull(),
      side: text2("side").notNull(),
      intendedQty: numeric("intended_qty"),
      intendedNotional: numeric("intended_notional"),
      filledQty: numeric("filled_qty"),
      filledAvgPrice: numeric("filled_avg_price"),
      fillCount: integer2("fill_count").default(0),
      status: text2("status").$type().default("pending").notNull(),
      pnlRealized: numeric("pnl_realized"),
      pnlUnrealized: numeric("pnl_unrealized"),
      entryPrice: numeric("entry_price"),
      exitPrice: numeric("exit_price"),
      holdDurationMs: integer2("hold_duration_ms"),
      outcome: text2("outcome").$type().default("unknown"),
      llmCostUsd: numeric("llm_cost_usd"),
      traceId: text2("trace_id"),
      createdAt: timestamp2("created_at").defaultNow().notNull(),
      closedAt: timestamp2("closed_at")
    }, (table) => [
      index("ai_outcome_links_consensus_id_idx").on(table.consensusId),
      index("ai_outcome_links_debate_session_id_idx").on(table.debateSessionId),
      index("ai_outcome_links_work_item_id_idx").on(table.workItemId),
      index("ai_outcome_links_symbol_idx").on(table.symbol),
      index("ai_outcome_links_status_idx").on(table.status),
      index("ai_outcome_links_outcome_idx").on(table.outcome),
      index("ai_outcome_links_created_at_idx").on(table.createdAt)
    ]);
    aiArenaRuns = pgTable2("ai_arena_runs", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      traceId: text2("trace_id").notNull(),
      mode: text2("mode").$type().default("debate").notNull(),
      symbols: text2("symbols").array().notNull(),
      agentProfileIds: text2("agent_profile_ids").array().notNull(),
      marketSnapshotHash: text2("market_snapshot_hash"),
      portfolioSnapshotHash: text2("portfolio_snapshot_hash"),
      strategyVersionId: varchar("strategy_version_id").references(() => strategyVersions.id, { onDelete: "set null" }),
      status: text2("status").$type().default("pending").notNull(),
      startedAt: timestamp2("started_at"),
      completedAt: timestamp2("completed_at"),
      durationMs: integer2("duration_ms"),
      totalTokensUsed: integer2("total_tokens_used").default(0),
      totalCostUsd: numeric("total_cost_usd").default("0"),
      escalationTriggered: boolean("escalation_triggered").default(false),
      escalationReason: text2("escalation_reason"),
      consensusReached: boolean("consensus_reached"),
      finalDecision: text2("final_decision"),
      disagreementRate: numeric("disagreement_rate"),
      avgConfidence: numeric("avg_confidence"),
      triggeredBy: text2("triggered_by"),
      outcomeLinked: boolean("outcome_linked").default(false),
      notes: text2("notes"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("ai_arena_runs_trace_id_idx").on(table.traceId),
      index("ai_arena_runs_status_idx").on(table.status),
      index("ai_arena_runs_mode_idx").on(table.mode),
      index("ai_arena_runs_created_at_idx").on(table.createdAt)
    ]);
    aiArenaAgentDecisions = pgTable2("ai_arena_agent_decisions", {
      id: varchar("id").primaryKey().default(sql2`gen_random_uuid()`),
      arenaRunId: varchar("arena_run_id").references(() => aiArenaRuns.id, { onDelete: "cascade" }).notNull(),
      agentProfileId: varchar("agent_profile_id").references(() => aiAgentProfiles.id, { onDelete: "cascade" }).notNull(),
      role: text2("role").$type().notNull(),
      action: text2("action").notNull(),
      symbols: text2("symbols").array(),
      confidence: numeric("confidence"),
      stance: text2("stance"),
      rationale: text2("rationale"),
      keySignals: jsonb("key_signals"),
      risks: jsonb("risks"),
      proposedOrder: jsonb("proposed_order"),
      tokensUsed: integer2("tokens_used"),
      costUsd: numeric("cost_usd"),
      latencyMs: integer2("latency_ms"),
      modelUsed: text2("model_used"),
      wasEscalation: boolean("was_escalation").default(false),
      rawOutput: text2("raw_output"),
      toolCallsCount: integer2("tool_calls_count").default(0),
      errorMessage: text2("error_message"),
      createdAt: timestamp2("created_at").defaultNow().notNull()
    }, (table) => [
      index("ai_arena_agent_decisions_run_id_idx").on(table.arenaRunId),
      index("ai_arena_agent_decisions_agent_profile_id_idx").on(table.agentProfileId),
      index("ai_arena_agent_decisions_role_idx").on(table.role)
    ]);
    insertDebateSessionSchema = createInsertSchema2(debateSessions).omit({
      id: true,
      createdAt: true
    });
    insertDebateMessageSchema = createInsertSchema2(debateMessages).omit({
      id: true,
      createdAt: true
    });
    insertDebateConsensusSchema = createInsertSchema2(debateConsensus).omit({
      id: true,
      createdAt: true
    });
    insertTraderProfileSchema = createInsertSchema2(traderProfiles).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCompetitionRunSchema = createInsertSchema2(competitionRuns).omit({
      id: true,
      createdAt: true
    });
    insertCompetitionScoreSchema = createInsertSchema2(competitionScores).omit({
      id: true,
      snapshotAt: true
    });
    insertStrategyVersionSchema = createInsertSchema2(strategyVersions).omit({
      id: true,
      createdAt: true
    });
    insertToolInvocationSchema = createInsertSchema2(toolInvocations).omit({
      id: true,
      createdAt: true
    });
    insertAiAgentProfileSchema = createInsertSchema2(aiAgentProfiles).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      totalCalls: true,
      totalTokens: true,
      totalCostUsd: true
    });
    insertAiOutcomeLinkSchema = createInsertSchema2(aiOutcomeLinks).omit({
      id: true,
      createdAt: true
    });
    insertAiArenaRunSchema = createInsertSchema2(aiArenaRuns).omit({
      id: true,
      createdAt: true
    });
    insertAiArenaAgentDecisionSchema = createInsertSchema2(aiArenaAgentDecisions).omit({
      id: true,
      createdAt: true
    });
  }
});

// server/utils/logger.ts
function redactSecrets(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(redactSecrets);
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (SECRET_PATTERNS.some((pattern) => pattern.test(key))) {
      result[key] = "[REDACTED]";
    } else if (typeof value === "object" && value !== null) {
      result[key] = redactSecrets(value);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function formatTimestamp() {
  return (/* @__PURE__ */ new Date()).toISOString().slice(11, 23);
}
function generateId() {
  return Math.random().toString(36).substring(2, 10);
}
var LEVEL_PRIORITY, SECRET_PATTERNS, Logger, log;
var init_logger = __esm({
  "server/utils/logger.ts"() {
    "use strict";
    LEVEL_PRIORITY = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    };
    SECRET_PATTERNS = [
      /api[_-]?key/i,
      /secret/i,
      /password/i,
      /token/i,
      /credential/i,
      /authorization/i
    ];
    Logger = class {
      minLevel = "info";
      currentRequestId;
      currentCycleId;
      setLevel(level) {
        this.minLevel = level;
      }
      setRequestId(requestId) {
        this.currentRequestId = requestId;
      }
      setCycleId(cycleId) {
        this.currentCycleId = cycleId;
      }
      generateRequestId() {
        return `req-${generateId()}`;
      }
      generateCycleId() {
        return `cyc-${generateId()}`;
      }
      shouldLog(level) {
        return LEVEL_PRIORITY[level] >= LEVEL_PRIORITY[this.minLevel];
      }
      formatMessage(level, context, message, meta) {
        const time = formatTimestamp();
        const levelStr = level.toUpperCase().padEnd(5);
        const ids = [];
        const requestId = meta?.requestId || this.currentRequestId;
        const cycleId = meta?.cycleId || this.currentCycleId;
        if (requestId) ids.push(requestId);
        if (cycleId) ids.push(cycleId);
        const idStr = ids.length > 0 ? ` [${ids.join("|")}]` : "";
        return `[${time}] [${levelStr}] [${context}]${idStr} ${message}`;
      }
      log(level, context, message, meta) {
        if (!this.shouldLog(level)) return;
        const formatted = this.formatMessage(level, context, message, meta);
        const safeMeta = meta ? redactSecrets(meta) : void 0;
        switch (level) {
          case "debug":
            console.debug(formatted, safeMeta || "");
            break;
          case "info":
            console.log(formatted, safeMeta ? JSON.stringify(safeMeta) : "");
            break;
          case "warn":
            console.warn(formatted, safeMeta || "");
            break;
          case "error":
            console.error(formatted, safeMeta || "");
            break;
        }
      }
      debug(context, message, meta) {
        this.log("debug", context, message, meta);
      }
      info(context, message, meta) {
        this.log("info", context, message, meta);
      }
      warn(context, message, meta) {
        this.log("warn", context, message, meta);
      }
      error(context, message, meta) {
        this.log("error", context, message, meta);
      }
      api(message, meta) {
        this.info("API", message, meta);
      }
      orchestrator(message, meta) {
        this.info("Orchestrator", message, meta);
      }
      alpaca(message, meta) {
        this.info("Alpaca", message, meta);
      }
      ai(message, meta) {
        this.info("AI", message, meta);
      }
      connector(name, message, meta) {
        this.info(name, message, meta);
      }
      trade(action, meta) {
        this.info("Trade", action, meta);
      }
    };
    log = new Logger();
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  getPoolStats: () => getPoolStats,
  pool: () => pool
});
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
function getPoolStats() {
  return {
    totalCount: pool.totalCount,
    idleCount: pool.idleCount,
    waitingCount: pool.waitingCount
  };
}
var Pool, poolConfig, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    init_logger();
    ({ Pool } = pg);
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    poolConfig = {
      connectionString: process.env.DATABASE_URL,
      max: 20,
      min: 5,
      idleTimeoutMillis: 3e4,
      connectionTimeoutMillis: 5e3,
      allowExitOnIdle: false
    };
    pool = new Pool(poolConfig);
    pool.on("error", (err) => {
      log.error("DB Pool", "Unexpected error on idle client", { error: err.message });
    });
    pool.on("connect", () => {
      log.debug("DB Pool", "New client connected");
    });
    db = drizzle(pool, { schema: schema_exports });
  }
});

// server/lib/sanitization.ts
import DOMPurify from "isomorphic-dompurify";
function sanitizeInput(input) {
  if (typeof input !== "string") {
    return input;
  }
  return DOMPurify.sanitize(input, {
    ALLOWED_TAGS: [],
    // Strip ALL HTML tags
    ALLOWED_ATTR: [],
    // Strip ALL attributes
    KEEP_CONTENT: true
    // Keep text content, just remove tags
  });
}
function sanitizeArray(arr) {
  if (!Array.isArray(arr)) {
    return arr;
  }
  return arr.map((item) => typeof item === "string" ? sanitizeInput(item) : item);
}
function sanitizeUserInput(user) {
  const sanitized = { ...user };
  if (sanitized.username) {
    sanitized.username = sanitizeInput(sanitized.username);
  }
  if (sanitized.email) {
    sanitized.email = sanitizeInput(sanitized.email);
  }
  if (sanitized.displayName) {
    sanitized.displayName = sanitizeInput(sanitized.displayName);
  }
  if (sanitized.bio) {
    sanitized.bio = sanitizeInput(sanitized.bio);
  }
  return sanitized;
}
function sanitizeStrategyInput(strategy) {
  const sanitized = { ...strategy };
  if (sanitized.name) {
    sanitized.name = sanitizeInput(sanitized.name);
  }
  if (sanitized.description) {
    sanitized.description = sanitizeInput(sanitized.description);
  }
  if (sanitized.notes) {
    sanitized.notes = sanitizeInput(sanitized.notes);
  }
  return sanitized;
}
var init_sanitization = __esm({
  "server/lib/sanitization.ts"() {
    "use strict";
  }
});

// server/storage.ts
import { eq as eq2, desc, and, gte, lte, sql as sql3, like, or } from "drizzle-orm";
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_db();
    init_sanitization();
    init_logger();
    init_schema();
    DatabaseStorage = class {
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq2(users.id, id));
        return user;
      }
      async getUserByUsername(username) {
        const [user] = await db.select().from(users).where(eq2(users.username, username));
        return user;
      }
      async getAdminUser() {
        const [adminUser] = await db.select().from(users).where(eq2(users.isAdmin, true)).limit(1);
        return adminUser;
      }
      async getAllUsers() {
        return db.select().from(users).orderBy(desc(users.id));
      }
      async createUser(insertUser) {
        const sanitizedUser = sanitizeUserInput(insertUser);
        const [user] = await db.insert(users).values(sanitizedUser).returning();
        return user;
      }
      async updateUser(id, updates) {
        const sanitizedUpdates = sanitizeUserInput(updates);
        const [user] = await db.update(users).set(sanitizedUpdates).where(eq2(users.id, id)).returning();
        return user;
      }
      async deleteUser(id) {
        const result = await db.delete(users).where(eq2(users.id, id)).returning();
        return result.length > 0;
      }
      async getStrategies() {
        return db.select().from(strategies).orderBy(desc(strategies.createdAt));
      }
      async getStrategy(id) {
        const [strategy] = await db.select().from(strategies).where(eq2(strategies.id, id));
        return strategy;
      }
      async createStrategy(insertStrategy) {
        const sanitizedStrategy = sanitizeStrategyInput(insertStrategy);
        const [strategy] = await db.insert(strategies).values(sanitizedStrategy).returning();
        return strategy;
      }
      async updateStrategy(id, updates) {
        const sanitizedUpdates = sanitizeStrategyInput(updates);
        const [strategy] = await db.update(strategies).set({ ...sanitizedUpdates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(strategies.id, id)).returning();
        return strategy;
      }
      async toggleStrategy(id, isActive) {
        return this.updateStrategy(id, { isActive });
      }
      async getTrades(userId, limit4 = 50) {
        return db.select().from(trades).where(eq2(trades.userId, userId)).orderBy(desc(trades.executedAt)).limit(limit4);
      }
      async getTradesFiltered(userId, filters) {
        const conditions = [eq2(trades.userId, userId)];
        if (filters.symbol) {
          conditions.push(eq2(trades.symbol, filters.symbol));
        }
        if (filters.strategyId) {
          conditions.push(eq2(trades.strategyId, filters.strategyId));
        }
        if (filters.startDate) {
          conditions.push(gte(trades.executedAt, filters.startDate));
        }
        if (filters.endDate) {
          conditions.push(lte(trades.executedAt, filters.endDate));
        }
        if (filters.pnlDirection === "profit") {
          conditions.push(sql3`CAST(${trades.pnl} AS numeric) >= 0`);
        } else if (filters.pnlDirection === "loss") {
          conditions.push(sql3`CAST(${trades.pnl} AS numeric) < 0`);
        }
        const whereClause = conditions.length > 0 ? and(...conditions) : void 0;
        const countResult = await db.select({ count: sql3`count(*)` }).from(trades).where(whereClause);
        const total = Number(countResult[0]?.count ?? 0);
        const limit4 = filters.limit ?? 50;
        const offset = filters.offset ?? 0;
        const result = await db.select({
          trade: trades,
          strategy: strategies,
          aiDecision: aiDecisions
        }).from(trades).leftJoin(strategies, eq2(trades.strategyId, strategies.id)).leftJoin(aiDecisions, eq2(aiDecisions.executedTradeId, trades.id)).where(whereClause).orderBy(desc(trades.executedAt)).limit(limit4).offset(offset);
        const enrichedTrades = result.map((row) => ({
          ...row.trade,
          aiDecision: row.aiDecision ?? null,
          strategyName: row.strategy?.name ?? null
        }));
        return { trades: enrichedTrades, total };
      }
      async getTrade(id) {
        const [trade] = await db.select().from(trades).where(eq2(trades.id, id));
        return trade;
      }
      async getEnrichedTrade(id) {
        const [trade] = await db.select().from(trades).where(eq2(trades.id, id));
        if (!trade) return void 0;
        const [aiDecision] = await db.select().from(aiDecisions).where(eq2(aiDecisions.executedTradeId, trade.id)).limit(1);
        let strategyName = null;
        if (trade.strategyId) {
          const [strategy] = await db.select().from(strategies).where(eq2(strategies.id, trade.strategyId));
          strategyName = strategy?.name ?? null;
        }
        return {
          ...trade,
          aiDecision: aiDecision ?? null,
          strategyName
        };
      }
      async createTrade(insertTrade) {
        const [trade] = await db.insert(trades).values(insertTrade).returning();
        return trade;
      }
      async updateTrade(id, updates) {
        const [trade] = await db.update(trades).set(updates).where(eq2(trades.id, id)).returning();
        return trade;
      }
      async getDistinctSymbols() {
        const result = await db.selectDistinct({ symbol: trades.symbol }).from(trades).orderBy(trades.symbol);
        return result.map((r) => r.symbol);
      }
      async getPositions(userId) {
        return db.select().from(positions).where(eq2(positions.userId, userId)).orderBy(desc(positions.openedAt));
      }
      async getPosition(id) {
        const [position] = await db.select().from(positions).where(eq2(positions.id, id));
        return position;
      }
      async createPosition(insertPosition) {
        const [position] = await db.insert(positions).values(insertPosition).returning();
        return position;
      }
      async updatePosition(id, updates) {
        const [position] = await db.update(positions).set(updates).where(eq2(positions.id, id)).returning();
        return position;
      }
      async deletePosition(id) {
        const result = await db.delete(positions).where(eq2(positions.id, id)).returning();
        return result.length > 0;
      }
      async deleteAllPositions() {
        const result = await db.delete(positions).returning();
        return result.length;
      }
      async syncPositionsFromAlpaca(userId, alpacaPositions) {
        return await db.transaction(async (tx) => {
          await tx.delete(positions).where(eq2(positions.userId, userId));
          if (alpacaPositions.length === 0) {
            return [];
          }
          const positionsToInsert = alpacaPositions.map((pos) => ({
            userId,
            symbol: pos.symbol,
            quantity: pos.qty,
            entryPrice: pos.avg_entry_price,
            currentPrice: pos.current_price,
            unrealizedPnl: pos.unrealized_pl,
            side: pos.side === "long" ? "long" : "short"
          }));
          const insertedPositions = await tx.insert(positions).values(positionsToInsert).returning();
          return insertedPositions;
        });
      }
      async getAiDecisions(userId, limit4 = 20) {
        return db.select().from(aiDecisions).where(eq2(aiDecisions.userId, userId)).orderBy(desc(aiDecisions.createdAt)).limit(limit4);
      }
      async createAiDecision(insertDecision) {
        const [decision] = await db.insert(aiDecisions).values(insertDecision).returning();
        return decision;
      }
      async updateAiDecision(id, updates) {
        const [decision] = await db.update(aiDecisions).set(updates).where(eq2(aiDecisions.id, id)).returning();
        return decision;
      }
      async getLatestAiDecisionForSymbol(symbol, strategyId) {
        const conditions = [eq2(aiDecisions.symbol, symbol.toUpperCase())];
        if (strategyId) {
          conditions.push(eq2(aiDecisions.strategyId, strategyId));
        }
        const [decision] = await db.select().from(aiDecisions).where(and(...conditions)).orderBy(desc(aiDecisions.createdAt)).limit(1);
        return decision;
      }
      async getOrdersByDecisionId(decisionId) {
        return db.select().from(orders).where(eq2(orders.decisionId, decisionId)).orderBy(desc(orders.submittedAt));
      }
      async getAiDecisionsByStatus(userId, status, limit4 = 100) {
        return db.select().from(aiDecisions).where(and(eq2(aiDecisions.userId, userId), eq2(aiDecisions.status, status))).orderBy(desc(aiDecisions.createdAt)).limit(limit4);
      }
      async getPendingAiDecisions(userId, limit4 = 50) {
        return this.getAiDecisionsByStatus(userId, "pending", limit4);
      }
      async getAgentStatus() {
        const [status] = await db.select().from(agentStatus).limit(1);
        return status;
      }
      async updateAgentStatus(updates) {
        const existing = await this.getAgentStatus();
        if (existing) {
          const [status] = await db.update(agentStatus).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(agentStatus.id, existing.id)).returning();
          return status;
        } else {
          const [status] = await db.insert(agentStatus).values({
            isRunning: updates.isRunning ?? false,
            ...updates
          }).returning();
          return status;
        }
      }
      async createWorkItem(item) {
        const [workItem] = await db.insert(workItems).values(item).returning();
        return workItem;
      }
      async getWorkItem(id) {
        const [item] = await db.select().from(workItems).where(eq2(workItems.id, id));
        return item;
      }
      async getWorkItemByIdempotencyKey(key) {
        const [item] = await db.select().from(workItems).where(eq2(workItems.idempotencyKey, key));
        return item || null;
      }
      async updateWorkItem(id, updates) {
        const [item] = await db.update(workItems).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(workItems.id, id)).returning();
        return item;
      }
      async claimNextWorkItem(types) {
        const now = /* @__PURE__ */ new Date();
        const conditions = [
          eq2(workItems.status, "PENDING"),
          lte(workItems.nextRunAt, now)
        ];
        const query = db.select().from(workItems).where(and(...conditions)).orderBy(workItems.nextRunAt).limit(1);
        const [item] = await query;
        if (!item) return null;
        if (types && types.length > 0 && !types.includes(item.type)) {
          return null;
        }
        const [claimed] = await db.update(workItems).set({ status: "RUNNING", updatedAt: /* @__PURE__ */ new Date() }).where(and(eq2(workItems.id, item.id), eq2(workItems.status, "PENDING"))).returning();
        return claimed || null;
      }
      async getWorkItemCount(status, type) {
        const conditions = [];
        if (status) conditions.push(eq2(workItems.status, status));
        if (type) conditions.push(eq2(workItems.type, type));
        const result = await db.select({ count: sql3`count(*)` }).from(workItems).where(conditions.length > 0 ? and(...conditions) : void 0);
        return Number(result[0]?.count || 0);
      }
      async getWorkItems(limit4 = 50, status) {
        const conditions = status ? [eq2(workItems.status, status)] : [];
        return db.select().from(workItems).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(desc(workItems.createdAt)).limit(limit4);
      }
      async createWorkItemRun(run) {
        const [itemRun] = await db.insert(workItemRuns).values(run).returning();
        return itemRun;
      }
      async getWorkItemRuns(workItemId) {
        return db.select().from(workItemRuns).where(eq2(workItemRuns.workItemId, workItemId)).orderBy(desc(workItemRuns.createdAt));
      }
      async getBrokerAsset(symbol) {
        const [asset] = await db.select().from(brokerAssets).where(eq2(brokerAssets.symbol, symbol.toUpperCase()));
        return asset;
      }
      async getBrokerAssets(assetClass, tradableOnly = false, limit4 = 1e3) {
        const conditions = [];
        if (assetClass) conditions.push(eq2(brokerAssets.assetClass, assetClass));
        if (tradableOnly) conditions.push(eq2(brokerAssets.tradable, true));
        return db.select().from(brokerAssets).where(conditions.length > 0 ? and(...conditions) : void 0).orderBy(brokerAssets.symbol).limit(limit4);
      }
      async upsertBrokerAsset(asset) {
        const [existing] = await db.select().from(brokerAssets).where(eq2(brokerAssets.symbol, asset.symbol.toUpperCase()));
        if (existing) {
          const [updated] = await db.update(brokerAssets).set({ ...asset, updatedAt: /* @__PURE__ */ new Date(), lastSyncedAt: /* @__PURE__ */ new Date() }).where(eq2(brokerAssets.id, existing.id)).returning();
          return updated;
        }
        const [created] = await db.insert(brokerAssets).values({ ...asset, symbol: asset.symbol.toUpperCase() }).returning();
        return created;
      }
      async bulkUpsertBrokerAssets(assets) {
        let count3 = 0;
        const batchSize = 100;
        for (let i = 0; i < assets.length; i += batchSize) {
          const batch = assets.slice(i, i + batchSize);
          for (const asset of batch) {
            await this.upsertBrokerAsset(asset);
            count3++;
          }
        }
        return count3;
      }
      async getBrokerAssetCount(assetClass) {
        const conditions = assetClass ? [eq2(brokerAssets.assetClass, assetClass)] : [];
        const result = await db.select({ count: sql3`count(*)` }).from(brokerAssets).where(conditions.length > 0 ? and(...conditions) : void 0);
        return Number(result[0]?.count || 0);
      }
      async getLastAssetSyncTime() {
        const [result] = await db.select({ lastSynced: sql3`MAX(last_synced_at)` }).from(brokerAssets);
        return result?.lastSynced || null;
      }
      async searchBrokerAssets(query, limit4 = 20) {
        const searchPattern = `%${query.toUpperCase()}%`;
        return db.select().from(brokerAssets).where(
          and(
            eq2(brokerAssets.tradable, true),
            or(
              like(brokerAssets.symbol, searchPattern),
              like(sql3`UPPER(${brokerAssets.name})`, searchPattern)
            )
          )
        ).orderBy(brokerAssets.symbol).limit(limit4);
      }
      async createOrder(order) {
        const [result] = await db.insert(orders).values(order).returning();
        return result;
      }
      async upsertOrderByBrokerOrderId(brokerOrderId, data) {
        const existing = await this.getOrderByBrokerOrderId(brokerOrderId);
        if (existing) {
          const [updated] = await db.update(orders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(orders.brokerOrderId, brokerOrderId)).returning();
          return updated;
        }
        try {
          const [created] = await db.insert(orders).values({ ...data, brokerOrderId }).returning();
          return created;
        } catch (error) {
          if (error.code === "23505" || error.message?.includes("duplicate")) {
            const [updated] = await db.update(orders).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(orders.brokerOrderId, brokerOrderId)).returning();
            return updated;
          }
          throw error;
        }
      }
      async getOrderByBrokerOrderId(brokerOrderId) {
        const [result] = await db.select().from(orders).where(eq2(orders.brokerOrderId, brokerOrderId)).limit(1);
        return result;
      }
      async getOrderByClientOrderId(clientOrderId) {
        const [result] = await db.select().from(orders).where(eq2(orders.clientOrderId, clientOrderId)).limit(1);
        return result;
      }
      async getOrdersByStatus(userId, status, limit4 = 100) {
        return db.select().from(orders).where(and(eq2(orders.userId, userId), eq2(orders.status, status))).limit(limit4).orderBy(desc(orders.createdAt));
      }
      async getRecentOrders(userId, limit4 = 50) {
        return db.select().from(orders).where(eq2(orders.userId, userId)).orderBy(desc(orders.createdAt)).limit(limit4);
      }
      async createFill(fill) {
        const [result] = await db.insert(fills).values(fill).returning();
        return result;
      }
      async getFillsByOrderId(orderId) {
        return db.select().from(fills).where(eq2(fills.orderId, orderId)).orderBy(desc(fills.occurredAt));
      }
      async getFillsByBrokerOrderId(brokerOrderId) {
        return db.select().from(fills).where(eq2(fills.brokerOrderId, brokerOrderId)).orderBy(desc(fills.occurredAt));
      }
      // ============================================================================
      // DEBATE ARENA
      // ============================================================================
      async createDebateSession(session) {
        const [result] = await db.insert(debateSessions).values(session).returning();
        return result;
      }
      async getDebateSession(id) {
        const [result] = await db.select().from(debateSessions).where(eq2(debateSessions.id, id));
        return result;
      }
      async getDebateSessions(limit4 = 50) {
        return db.select().from(debateSessions).orderBy(desc(debateSessions.createdAt)).limit(limit4);
      }
      async updateDebateSession(id, updates) {
        const [result] = await db.update(debateSessions).set(updates).where(eq2(debateSessions.id, id)).returning();
        return result;
      }
      async createDebateMessage(message) {
        const [result] = await db.insert(debateMessages).values(message).returning();
        return result;
      }
      async getDebateMessagesBySession(sessionId) {
        return db.select().from(debateMessages).where(eq2(debateMessages.sessionId, sessionId)).orderBy(debateMessages.createdAt);
      }
      async createDebateConsensus(consensus) {
        const [result] = await db.insert(debateConsensus).values(consensus).returning();
        return result;
      }
      async getDebateConsensusBySession(sessionId) {
        const [result] = await db.select().from(debateConsensus).where(eq2(debateConsensus.sessionId, sessionId));
        return result;
      }
      async updateDebateConsensus(id, updates) {
        const [result] = await db.update(debateConsensus).set(updates).where(eq2(debateConsensus.id, id)).returning();
        return result;
      }
      // ============================================================================
      // TRADER PROFILES & COMPETITION
      // ============================================================================
      async createTraderProfile(profile) {
        const [result] = await db.insert(traderProfiles).values(profile).returning();
        return result;
      }
      async getTraderProfile(id) {
        const [result] = await db.select().from(traderProfiles).where(eq2(traderProfiles.id, id));
        return result;
      }
      async getTraderProfiles() {
        return db.select().from(traderProfiles).orderBy(desc(traderProfiles.createdAt));
      }
      async updateTraderProfile(id, updates) {
        const [result] = await db.update(traderProfiles).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq2(traderProfiles.id, id)).returning();
        return result;
      }
      async createCompetitionRun(run) {
        const [result] = await db.insert(competitionRuns).values(run).returning();
        return result;
      }
      async getCompetitionRun(id) {
        const [result] = await db.select().from(competitionRuns).where(eq2(competitionRuns.id, id));
        return result;
      }
      async getCompetitionRuns(limit4 = 20) {
        return db.select().from(competitionRuns).orderBy(desc(competitionRuns.createdAt)).limit(limit4);
      }
      async updateCompetitionRun(id, updates) {
        const [result] = await db.update(competitionRuns).set(updates).where(eq2(competitionRuns.id, id)).returning();
        return result;
      }
      async createCompetitionScore(score) {
        const [result] = await db.insert(competitionScores).values(score).returning();
        return result;
      }
      async getCompetitionScoresByRun(runId) {
        return db.select().from(competitionScores).where(eq2(competitionScores.runId, runId)).orderBy(competitionScores.rank);
      }
      async updateCompetitionScore(id, updates) {
        const [result] = await db.update(competitionScores).set(updates).where(eq2(competitionScores.id, id)).returning();
        return result;
      }
      // ============================================================================
      // STRATEGY VERSIONS
      // ============================================================================
      async createStrategyVersion(version) {
        const [result] = await db.insert(strategyVersions).values(version).returning();
        return result;
      }
      async getStrategyVersion(id) {
        const [result] = await db.select().from(strategyVersions).where(eq2(strategyVersions.id, id));
        return result;
      }
      async getStrategyVersionsByStrategy(strategyId) {
        return db.select().from(strategyVersions).where(eq2(strategyVersions.strategyId, strategyId)).orderBy(desc(strategyVersions.version));
      }
      async getLatestStrategyVersion(strategyId) {
        const [result] = await db.select().from(strategyVersions).where(eq2(strategyVersions.strategyId, strategyId)).orderBy(desc(strategyVersions.version)).limit(1);
        return result;
      }
      async getNextVersionNumber(strategyId) {
        const latest = await this.getLatestStrategyVersion(strategyId);
        return (latest?.version || 0) + 1;
      }
      async updateStrategyVersion(id, updates) {
        const [result] = await db.update(strategyVersions).set(updates).where(eq2(strategyVersions.id, id)).returning();
        return result;
      }
      async getActiveStrategyVersions() {
        return db.select().from(strategyVersions).where(eq2(strategyVersions.status, "active")).orderBy(strategyVersions.createdAt);
      }
      // ============================================================================
      // TOOL INVOCATIONS
      // ============================================================================
      async createToolInvocation(invocation) {
        const [result] = await db.insert(toolInvocations).values(invocation).returning();
        return result;
      }
      async updateToolInvocation(id, updates) {
        const [result] = await db.update(toolInvocations).set(updates).where(eq2(toolInvocations.id, id)).returning();
        return result;
      }
      async getToolInvocationsByTrace(traceId) {
        return db.select().from(toolInvocations).where(eq2(toolInvocations.traceId, traceId)).orderBy(toolInvocations.createdAt);
      }
      async getToolInvocationsBySession(sessionId) {
        return db.select().from(toolInvocations).where(eq2(toolInvocations.debateSessionId, sessionId)).orderBy(toolInvocations.createdAt);
      }
      async getRecentToolInvocations(limit4 = 100) {
        return db.select().from(toolInvocations).orderBy(desc(toolInvocations.createdAt)).limit(limit4);
      }
      // ============================================================================
      // AUDIT LOGGING
      // ============================================================================
      async createAuditLog(logEntry) {
        try {
          const { auditLogs: auditLogs3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          const [result] = await db.insert(auditLogs3).values(logEntry).returning();
          return result;
        } catch (error) {
          log.error("Storage", "Failed to create audit log", { error });
          throw error;
        }
      }
      async getUserAuditLogs(userId, limit4 = 100, offset = 0) {
        try {
          const { auditLogs: auditLogs3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          return db.select().from(auditLogs3).where(eq2(auditLogs3.userId, userId)).orderBy(desc(auditLogs3.timestamp)).limit(limit4).offset(offset);
        } catch (error) {
          log.error("Storage", "Failed to get user audit logs", { error, userId });
          return [];
        }
      }
      async getResourceAuditLogs(resource, resourceId, limit4 = 50) {
        try {
          const { auditLogs: auditLogs3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          return db.select().from(auditLogs3).where(and(
            eq2(auditLogs3.resource, resource),
            eq2(auditLogs3.resourceId, resourceId)
          )).orderBy(desc(auditLogs3.timestamp)).limit(limit4);
        } catch (error) {
          log.error("Storage", "Failed to get resource audit logs", { error, resource, resourceId });
          return [];
        }
      }
      async getRecentAuditLogs(limit4 = 100, offset = 0) {
        try {
          const { auditLogs: auditLogs3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
          return db.select().from(auditLogs3).orderBy(desc(auditLogs3.timestamp)).limit(limit4).offset(offset);
        } catch (error) {
          log.error("Storage", "Failed to get recent audit logs", { error });
          return [];
        }
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/lib/api-cache.ts
var DEFAULT_FRESH_DURATION, DEFAULT_STALE_DURATION, DEFAULT_MAX_ENTRIES, ApiCache, marketDataCache, stockQuoteCache, cryptoPriceCache, newsCache, assetListCache, portfolioCache;
var init_api_cache = __esm({
  "server/lib/api-cache.ts"() {
    "use strict";
    DEFAULT_FRESH_DURATION = 60 * 1e3;
    DEFAULT_STALE_DURATION = 30 * 60 * 1e3;
    DEFAULT_MAX_ENTRIES = 1e3;
    ApiCache = class {
      cache = /* @__PURE__ */ new Map();
      config;
      constructor(config = {}) {
        this.config = {
          freshDuration: config.freshDuration ?? DEFAULT_FRESH_DURATION,
          staleDuration: config.staleDuration ?? DEFAULT_STALE_DURATION,
          maxEntries: config.maxEntries ?? DEFAULT_MAX_ENTRIES
        };
      }
      get(key) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        const now = Date.now();
        if (now - entry.timestamp < this.config.freshDuration) {
          return { data: entry.data, isFresh: true };
        }
        if (now - entry.timestamp < this.config.staleDuration) {
          return { data: entry.data, isFresh: false };
        }
        this.cache.delete(key);
        return null;
      }
      getFresh(key) {
        const result = this.get(key);
        return result?.isFresh ? result.data : null;
      }
      getStale(key) {
        const result = this.get(key);
        return result?.data ?? null;
      }
      set(key, data) {
        if (this.cache.size >= this.config.maxEntries) {
          this.evictOldest();
        }
        const now = Date.now();
        this.cache.set(key, {
          data,
          timestamp: now,
          staleTimestamp: now + this.config.staleDuration
        });
      }
      evictOldest() {
        let oldestKey = null;
        let oldestTime = Infinity;
        for (const [key, entry] of this.cache.entries()) {
          if (entry.timestamp < oldestTime) {
            oldestTime = entry.timestamp;
            oldestKey = key;
          }
        }
        if (oldestKey) {
          this.cache.delete(oldestKey);
        }
      }
      has(key) {
        return this.get(key) !== null;
      }
      clear() {
        this.cache.clear();
      }
      size() {
        return this.cache.size;
      }
      getStats() {
        const now = Date.now();
        let freshCount = 0;
        let staleCount = 0;
        for (const entry of this.cache.values()) {
          if (now - entry.timestamp < this.config.freshDuration) {
            freshCount++;
          } else if (now - entry.timestamp < this.config.staleDuration) {
            staleCount++;
          }
        }
        return { size: this.cache.size, freshCount, staleCount };
      }
    };
    marketDataCache = new ApiCache({
      freshDuration: 30 * 1e3,
      staleDuration: 60 * 60 * 1e3
    });
    stockQuoteCache = new ApiCache({
      freshDuration: 60 * 1e3,
      staleDuration: 30 * 60 * 1e3
    });
    cryptoPriceCache = new ApiCache({
      freshDuration: 60 * 1e3,
      staleDuration: 30 * 60 * 1e3
    });
    newsCache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 60 * 60 * 1e3
    });
    assetListCache = new ApiCache({
      freshDuration: 15 * 60 * 1e3,
      staleDuration: 24 * 60 * 60 * 1e3
    });
    portfolioCache = new ApiCache({
      freshDuration: 30 * 1e3,
      staleDuration: 10 * 60 * 1e3
    });
  }
});

// server/lib/apiPolicy.ts
function envInt(key, defaultVal) {
  const val = process.env[key];
  if (val !== void 0) {
    const parsed = parseInt(val, 10);
    if (!isNaN(parsed)) return parsed;
  }
  return defaultVal;
}
function envBool(key, defaultVal) {
  const val = process.env[key];
  if (val === "true" || val === "1") return true;
  if (val === "false" || val === "0") return false;
  return defaultVal;
}
function getProviderPolicy(provider) {
  const policy = providerPolicies[provider.toLowerCase()];
  if (policy) return policy;
  log.debug("ApiPolicy", `No policy found for provider ${provider}, using defaults`);
  return { ...defaultPolicy, provider };
}
function getAllProviderPolicies() {
  return Object.values(providerPolicies);
}
function updateProviderPolicy(provider, updates) {
  const existing = providerPolicies[provider.toLowerCase()];
  if (existing) {
    providerPolicies[provider.toLowerCase()] = { ...existing, ...updates };
    log.info("ApiPolicy", `Updated policy for ${provider}`, updates);
  } else {
    providerPolicies[provider.toLowerCase()] = { ...defaultPolicy, provider, ...updates };
    log.info("ApiPolicy", `Created new policy for ${provider}`, updates);
  }
}
function disableProvider(provider) {
  updateProviderPolicy(provider, { enabled: false });
}
function enableProvider(provider) {
  updateProviderPolicy(provider, { enabled: true });
}
function getWindowDurationMs(windowType) {
  switch (windowType) {
    case "minute":
      return 60 * 1e3;
    case "hour":
      return 60 * 60 * 1e3;
    case "day":
      return 24 * 60 * 60 * 1e3;
    case "week":
      return 7 * 24 * 60 * 60 * 1e3;
  }
}
function getWindowBoundaries(windowType) {
  const now = /* @__PURE__ */ new Date();
  const durationMs = getWindowDurationMs(windowType);
  let start;
  switch (windowType) {
    case "minute":
      start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), now.getMinutes(), 0, 0);
      break;
    case "hour":
      start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0, 0);
      break;
    case "day":
      start = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
      break;
    case "week":
      const dayOfWeek = now.getDay();
      start = new Date(now.getFullYear(), now.getMonth(), now.getDate() - dayOfWeek, 0, 0, 0, 0);
      break;
  }
  return { start, end: new Date(start.getTime() + durationMs) };
}
function getLimitForWindow(policy, windowType) {
  switch (windowType) {
    case "minute":
      return policy.maxRequestsPerMinute;
    case "hour":
      return policy.maxRequestsPerHour;
    case "day":
      return policy.maxRequestsPerDay;
    case "week":
      return policy.maxRequestsPerWeek;
  }
}
var defaultPolicy, providerPolicies;
var init_apiPolicy = __esm({
  "server/lib/apiPolicy.ts"() {
    "use strict";
    init_logger();
    defaultPolicy = {
      minRequestIntervalMs: 1e3,
      cacheFreshDurationMs: 60 * 1e3,
      cacheStaleDurationMs: 30 * 60 * 1e3,
      priority: 5,
      enabled: true
    };
    providerPolicies = {
      alpaca: {
        provider: "alpaca",
        maxRequestsPerMinute: envInt("ALPACA_RATE_LIMIT_PER_MIN", 180),
        minRequestIntervalMs: envInt("ALPACA_MIN_INTERVAL_MS", 333),
        cacheFreshDurationMs: envInt("ALPACA_CACHE_FRESH_MS", 30 * 1e3),
        cacheStaleDurationMs: envInt("ALPACA_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 10,
        enabled: envBool("ALPACA_ENABLED", true)
      },
      finnhub: {
        provider: "finnhub",
        maxRequestsPerMinute: envInt("FINNHUB_RATE_LIMIT_PER_MIN", 50),
        minRequestIntervalMs: envInt("FINNHUB_MIN_INTERVAL_MS", 1200),
        cacheFreshDurationMs: envInt("FINNHUB_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("FINNHUB_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 8,
        enabled: envBool("FINNHUB_ENABLED", true)
      },
      coingecko: {
        provider: "coingecko",
        maxRequestsPerMinute: envInt("COINGECKO_RATE_LIMIT_PER_MIN", 10),
        maxRequestsPerDay: envInt("COINGECKO_RATE_LIMIT_PER_DAY", 500),
        minRequestIntervalMs: envInt("COINGECKO_MIN_INTERVAL_MS", 2100),
        cacheFreshDurationMs: envInt("COINGECKO_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("COINGECKO_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 6,
        enabled: envBool("COINGECKO_ENABLED", true)
      },
      coinmarketcap: {
        provider: "coinmarketcap",
        maxRequestsPerMinute: envInt("COINMARKETCAP_RATE_LIMIT_PER_MIN", 30),
        maxRequestsPerDay: envInt("COINMARKETCAP_RATE_LIMIT_PER_DAY", 300),
        minRequestIntervalMs: envInt("COINMARKETCAP_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("COINMARKETCAP_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("COINMARKETCAP_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 6,
        enabled: envBool("COINMARKETCAP_ENABLED", true)
      },
      newsapi: {
        provider: "newsapi",
        maxRequestsPerDay: envInt("NEWSAPI_RATE_LIMIT_PER_DAY", 100),
        minRequestIntervalMs: envInt("NEWSAPI_MIN_INTERVAL_MS", 3e3),
        cacheFreshDurationMs: envInt("NEWSAPI_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("NEWSAPI_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 4,
        enabled: envBool("NEWSAPI_ENABLED", true)
      },
      polygon: {
        provider: "polygon",
        maxRequestsPerMinute: envInt("POLYGON_RATE_LIMIT_PER_MIN", 5),
        minRequestIntervalMs: envInt("POLYGON_MIN_INTERVAL_MS", 12e3),
        cacheFreshDurationMs: envInt("POLYGON_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("POLYGON_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 5,
        enabled: envBool("POLYGON_ENABLED", true)
      },
      twelvedata: {
        provider: "twelvedata",
        maxRequestsPerMinute: envInt("TWELVEDATA_RATE_LIMIT_PER_MIN", 6),
        maxRequestsPerDay: envInt("TWELVEDATA_RATE_LIMIT_PER_DAY", 700),
        minRequestIntervalMs: envInt("TWELVEDATA_MIN_INTERVAL_MS", 1e4),
        cacheFreshDurationMs: envInt("TWELVEDATA_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("TWELVEDATA_CACHE_STALE_MS", 5 * 60 * 1e3),
        priority: 5,
        enabled: envBool("TWELVEDATA_ENABLED", true)
      },
      valyu: {
        provider: "valyu",
        maxRequestsPerWeek: envInt("VALYU_RATE_LIMIT_PER_WEEK", 100),
        minRequestIntervalMs: envInt("VALYU_MIN_INTERVAL_MS", 5e3),
        cacheFreshDurationMs: envInt("VALYU_CACHE_FRESH_MS", 7 * 24 * 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("VALYU_CACHE_STALE_MS", 90 * 24 * 60 * 60 * 1e3),
        priority: 2,
        enabled: envBool("VALYU_ENABLED", true)
      },
      huggingface: {
        provider: "huggingface",
        maxRequestsPerMinute: envInt("HUGGINGFACE_RATE_LIMIT_PER_MIN", 30),
        maxRequestsPerDay: envInt("HUGGINGFACE_RATE_LIMIT_PER_DAY", 1e3),
        minRequestIntervalMs: envInt("HUGGINGFACE_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: envInt("HUGGINGFACE_CACHE_FRESH_MS", 30 * 60 * 1e3),
        cacheStaleDurationMs: envInt("HUGGINGFACE_CACHE_STALE_MS", 2 * 60 * 60 * 1e3),
        priority: 7,
        enabled: envBool("HUGGINGFACE_ENABLED", true)
      },
      gdelt: {
        provider: "gdelt",
        maxRequestsPerMinute: envInt("GDELT_RATE_LIMIT_PER_MIN", 60),
        minRequestIntervalMs: envInt("GDELT_MIN_INTERVAL_MS", 500),
        cacheFreshDurationMs: envInt("GDELT_CACHE_FRESH_MS", 10 * 60 * 1e3),
        cacheStaleDurationMs: envInt("GDELT_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 5,
        enabled: envBool("GDELT_ENABLED", true)
      },
      openai: {
        provider: "openai",
        maxRequestsPerMinute: envInt("OPENAI_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("OPENAI_TOKENS_PER_MIN", 9e4),
        maxTokensPerDay: envInt("OPENAI_TOKENS_PER_DAY", 1e6),
        minRequestIntervalMs: envInt("OPENAI_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: envInt("OPENAI_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("OPENAI_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 9,
        enabled: envBool("OPENAI_ENABLED", true)
      },
      groq: {
        provider: "groq",
        maxRequestsPerMinute: envInt("GROQ_RATE_LIMIT_PER_MIN", 30),
        maxTokensPerMinute: envInt("GROQ_TOKENS_PER_MIN", 3e4),
        maxTokensPerDay: envInt("GROQ_TOKENS_PER_DAY", 5e5),
        minRequestIntervalMs: envInt("GROQ_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: envInt("GROQ_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("GROQ_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 8,
        enabled: envBool("GROQ_ENABLED", true)
      },
      together: {
        provider: "together",
        maxRequestsPerMinute: envInt("TOGETHER_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("TOGETHER_TOKENS_PER_MIN", 6e4),
        maxTokensPerDay: envInt("TOGETHER_TOKENS_PER_DAY", 8e5),
        minRequestIntervalMs: envInt("TOGETHER_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: envInt("TOGETHER_CACHE_FRESH_MS", 60 * 60 * 1e3),
        cacheStaleDurationMs: envInt("TOGETHER_CACHE_STALE_MS", 24 * 60 * 60 * 1e3),
        priority: 8,
        enabled: envBool("TOGETHER_ENABLED", true)
      },
      stocktwits: {
        provider: "stocktwits",
        maxRequestsPerHour: envInt("STOCKTWITS_RATE_LIMIT_PER_HOUR", 200),
        minRequestIntervalMs: envInt("STOCKTWITS_MIN_INTERVAL_MS", 3e3),
        cacheFreshDurationMs: envInt("STOCKTWITS_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("STOCKTWITS_CACHE_STALE_MS", 15 * 60 * 1e3),
        priority: 4,
        enabled: envBool("STOCKTWITS_ENABLED", true)
      },
      reddit: {
        provider: "reddit",
        maxRequestsPerMinute: envInt("REDDIT_RATE_LIMIT_PER_MIN", 60),
        minRequestIntervalMs: envInt("REDDIT_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("REDDIT_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("REDDIT_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 3,
        enabled: envBool("REDDIT_ENABLED", true)
      },
      aitrados_ohlc: {
        provider: "aitrados_ohlc",
        maxRequestsPerHour: envInt("AITRADOS_OHLC_RATE_LIMIT_PER_HOUR", 100),
        maxRequestsPerDay: envInt("AITRADOS_OHLC_RATE_LIMIT_PER_DAY", 1e3),
        minRequestIntervalMs: envInt("AITRADOS_OHLC_MIN_INTERVAL_MS", 500),
        cacheFreshDurationMs: envInt("AITRADOS_OHLC_CACHE_FRESH_MS", 60 * 1e3),
        cacheStaleDurationMs: envInt("AITRADOS_OHLC_CACHE_STALE_MS", 15 * 60 * 1e3),
        priority: 6,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      aitrados_news: {
        provider: "aitrados_news",
        maxRequestsPerHour: envInt("AITRADOS_NEWS_RATE_LIMIT_PER_HOUR", 50),
        maxRequestsPerDay: envInt("AITRADOS_NEWS_RATE_LIMIT_PER_DAY", 500),
        minRequestIntervalMs: envInt("AITRADOS_NEWS_MIN_INTERVAL_MS", 1e3),
        cacheFreshDurationMs: envInt("AITRADOS_NEWS_CACHE_FRESH_MS", 5 * 60 * 1e3),
        cacheStaleDurationMs: envInt("AITRADOS_NEWS_CACHE_STALE_MS", 30 * 60 * 1e3),
        priority: 5,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      aitrados_econ: {
        provider: "aitrados_econ",
        maxRequestsPerHour: envInt("AITRADOS_ECON_RATE_LIMIT_PER_HOUR", 30),
        maxRequestsPerDay: envInt("AITRADOS_ECON_RATE_LIMIT_PER_DAY", 200),
        minRequestIntervalMs: envInt("AITRADOS_ECON_MIN_INTERVAL_MS", 2e3),
        cacheFreshDurationMs: envInt("AITRADOS_ECON_CACHE_FRESH_MS", 10 * 60 * 1e3),
        cacheStaleDurationMs: envInt("AITRADOS_ECON_CACHE_STALE_MS", 60 * 60 * 1e3),
        priority: 5,
        enabled: envBool("AITRADOS_ENABLED", true)
      },
      claude: {
        provider: "claude",
        maxRequestsPerMinute: envInt("CLAUDE_RATE_LIMIT_PER_MIN", 40),
        maxTokensPerMinute: envInt("CLAUDE_TOKEN_LIMIT_PER_MIN", 4e4),
        maxRequestsPerDay: envInt("CLAUDE_RATE_LIMIT_PER_DAY", 5e3),
        minRequestIntervalMs: envInt("CLAUDE_MIN_INTERVAL_MS", 200),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 9,
        enabled: envBool("CLAUDE_ENABLED", true)
      },
      openrouter: {
        provider: "openrouter",
        maxRequestsPerMinute: envInt("OPENROUTER_RATE_LIMIT_PER_MIN", 50),
        maxTokensPerMinute: envInt("OPENROUTER_TOKEN_LIMIT_PER_MIN", 1e5),
        maxRequestsPerDay: envInt("OPENROUTER_RATE_LIMIT_PER_DAY", 5e3),
        minRequestIntervalMs: envInt("OPENROUTER_MIN_INTERVAL_MS", 150),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 8,
        enabled: envBool("OPENROUTER_ENABLED", true)
      },
      deepseek: {
        provider: "deepseek",
        maxRequestsPerMinute: envInt("DEEPSEEK_RATE_LIMIT_PER_MIN", 60),
        maxTokensPerMinute: envInt("DEEPSEEK_TOKEN_LIMIT_PER_MIN", 6e4),
        maxRequestsPerDay: envInt("DEEPSEEK_RATE_LIMIT_PER_DAY", 1e4),
        minRequestIntervalMs: envInt("DEEPSEEK_MIN_INTERVAL_MS", 100),
        cacheFreshDurationMs: 0,
        cacheStaleDurationMs: 0,
        priority: 8,
        enabled: envBool("DEEPSEEK_ENABLED", true)
      }
    };
  }
});

// server/lib/apiBudget.ts
import { eq as eq3, and as and2, gte as gte2, lte as lte2 } from "drizzle-orm";
function getCounterKey(provider, windowType) {
  const { start } = getWindowBoundaries(windowType);
  return `${provider}:${windowType}:${start.getTime()}`;
}
async function checkBudget(provider) {
  const policy = getProviderPolicy(provider);
  if (!policy.enabled) {
    return {
      allowed: false,
      reason: `Provider ${provider} is disabled`,
      currentCount: 0,
      limit: 0,
      windowType: "minute"
    };
  }
  const windowTypes = ["minute", "hour", "day", "week"];
  for (const windowType of windowTypes) {
    const limit4 = getLimitForWindow(policy, windowType);
    if (limit4 === void 0) continue;
    const { start, end } = getWindowBoundaries(windowType);
    const counterKey = getCounterKey(provider, windowType);
    let currentCount = 0;
    const cached = inMemoryCounters.get(counterKey);
    if (cached && cached.windowStart === start.getTime()) {
      currentCount = cached.count;
    } else {
      try {
        const result = await db.select().from(externalApiUsageCounters).where(
          and2(
            eq3(externalApiUsageCounters.provider, provider),
            eq3(externalApiUsageCounters.windowType, windowType),
            gte2(externalApiUsageCounters.windowStart, start),
            lte2(externalApiUsageCounters.windowEnd, end)
          )
        ).limit(1);
        if (result.length > 0) {
          currentCount = result[0].requestCount;
          inMemoryCounters.set(counterKey, { count: currentCount, windowStart: start.getTime() });
        }
      } catch (error) {
        log.warn("ApiBudget", `Failed to check DB budget for ${provider}, using in-memory only`);
      }
    }
    if (currentCount >= limit4) {
      const retryAfterMs = end.getTime() - Date.now();
      return {
        allowed: false,
        reason: `${provider} budget exhausted: ${currentCount}/${limit4} requests per ${windowType}`,
        currentCount,
        limit: limit4,
        windowType,
        retryAfterMs: Math.max(0, retryAfterMs)
      };
    }
  }
  return {
    allowed: true,
    currentCount: 0,
    limit: Infinity,
    windowType: "minute"
  };
}
async function recordUsage(provider, options = {}) {
  const windowTypes = ["minute", "hour", "day", "week"];
  const policy = getProviderPolicy(provider);
  const isCacheHit = options.isCacheHit === true;
  for (const windowType of windowTypes) {
    const limit4 = getLimitForWindow(policy, windowType);
    if (limit4 === void 0) continue;
    const { start, end } = getWindowBoundaries(windowType);
    const counterKey = getCounterKey(provider, windowType);
    if (!isCacheHit) {
      const cached = inMemoryCounters.get(counterKey);
      if (cached && cached.windowStart === start.getTime()) {
        cached.count++;
      } else {
        inMemoryCounters.set(counterKey, { count: 1, windowStart: start.getTime() });
      }
    }
    try {
      const existing = await db.select().from(externalApiUsageCounters).where(
        and2(
          eq3(externalApiUsageCounters.provider, provider),
          eq3(externalApiUsageCounters.windowType, windowType),
          gte2(externalApiUsageCounters.windowStart, start),
          lte2(externalApiUsageCounters.windowEnd, end)
        )
      ).limit(1);
      if (existing.length > 0) {
        const record = existing[0];
        const newRequestCount = isCacheHit ? record.requestCount : record.requestCount + 1;
        const newTokenCount = (record.tokenCount || 0) + (options.tokens || 0);
        const newErrorCount = record.errorCount + (options.isError ? 1 : 0);
        const newRateLimitHits = record.rateLimitHits + (options.isRateLimited ? 1 : 0);
        const newCacheHits = record.cacheHits + (isCacheHit ? 1 : 0);
        const newCacheMisses = record.cacheMisses + (options.isCacheHit === false ? 1 : 0);
        let newAvgLatency = record.avgLatencyMs;
        if (options.latencyMs !== void 0 && !isCacheHit) {
          const prevAvg = parseFloat(record.avgLatencyMs || "0");
          const prevCount = record.requestCount - record.cacheHits;
          const newCount = prevCount + 1;
          newAvgLatency = String((prevAvg * prevCount + options.latencyMs) / newCount);
        }
        await db.update(externalApiUsageCounters).set({
          requestCount: newRequestCount,
          tokenCount: newTokenCount,
          errorCount: newErrorCount,
          rateLimitHits: newRateLimitHits,
          cacheHits: newCacheHits,
          cacheMisses: newCacheMisses,
          avgLatencyMs: newAvgLatency,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq3(externalApiUsageCounters.id, record.id));
      } else {
        await db.insert(externalApiUsageCounters).values({
          provider,
          windowType,
          windowStart: start,
          windowEnd: end,
          requestCount: isCacheHit ? 0 : 1,
          tokenCount: options.tokens || 0,
          errorCount: options.isError ? 1 : 0,
          rateLimitHits: options.isRateLimited ? 1 : 0,
          cacheHits: isCacheHit ? 1 : 0,
          cacheMisses: options.isCacheHit === false ? 1 : 0,
          avgLatencyMs: options.latencyMs !== void 0 && !isCacheHit ? String(options.latencyMs) : null
        });
      }
    } catch (error) {
      log.warn("ApiBudget", `Failed to record usage to DB for ${provider}: ${error}`);
    }
  }
}
async function getUsageStats(provider) {
  const windowTypes = ["minute", "hour", "day", "week"];
  const stats = [];
  for (const windowType of windowTypes) {
    const { start, end } = getWindowBoundaries(windowType);
    try {
      const result = await db.select().from(externalApiUsageCounters).where(
        and2(
          eq3(externalApiUsageCounters.provider, provider),
          eq3(externalApiUsageCounters.windowType, windowType),
          gte2(externalApiUsageCounters.windowStart, start),
          lte2(externalApiUsageCounters.windowEnd, end)
        )
      ).limit(1);
      if (result.length > 0) {
        const r = result[0];
        stats.push({
          provider: r.provider,
          windowType: r.windowType,
          windowStart: r.windowStart,
          windowEnd: r.windowEnd,
          requestCount: r.requestCount,
          tokenCount: r.tokenCount || 0,
          errorCount: r.errorCount,
          rateLimitHits: r.rateLimitHits,
          cacheHits: r.cacheHits,
          cacheMisses: r.cacheMisses,
          avgLatencyMs: r.avgLatencyMs ? parseFloat(r.avgLatencyMs) : null
        });
      } else {
        stats.push({
          provider,
          windowType,
          windowStart: start,
          windowEnd: end,
          requestCount: 0,
          tokenCount: 0,
          errorCount: 0,
          rateLimitHits: 0,
          cacheHits: 0,
          cacheMisses: 0,
          avgLatencyMs: null
        });
      }
    } catch (error) {
      log.warn("ApiBudget", `Failed to get usage stats for ${provider}: ${error}`);
    }
  }
  return stats;
}
async function getAllUsageStats() {
  const providers2 = [
    "alpaca",
    "finnhub",
    "coingecko",
    "coinmarketcap",
    "newsapi",
    "polygon",
    "twelvedata",
    "valyu",
    "huggingface",
    "gdelt",
    "openai",
    "groq",
    "together"
  ];
  const allStats = {};
  for (const provider of providers2) {
    allStats[provider] = await getUsageStats(provider);
  }
  return allStats;
}
var inMemoryCounters;
var init_apiBudget = __esm({
  "server/lib/apiBudget.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    init_apiPolicy();
    inMemoryCounters = /* @__PURE__ */ new Map();
  }
});

// server/lib/persistentApiCache.ts
import { eq as eq4, and as and3, lt as lt2 } from "drizzle-orm";
function getCacheKey(provider, key) {
  return `${provider}:${key}`;
}
async function getFromCache(provider, key) {
  const cacheKey = getCacheKey(provider, key);
  const now = Date.now();
  const memCached = inMemoryCache.get(cacheKey);
  if (memCached) {
    if (now < memCached.expiresAt) {
      return { data: memCached.data, isFresh: true, isStale: false, hitCount: 0 };
    }
    if (now < memCached.staleUntilAt) {
      return { data: memCached.data, isFresh: false, isStale: true, hitCount: 0 };
    }
    inMemoryCache.delete(cacheKey);
  }
  try {
    const result = await db.select().from(externalApiCacheEntries).where(
      and3(
        eq4(externalApiCacheEntries.provider, provider),
        eq4(externalApiCacheEntries.cacheKey, key)
      )
    ).limit(1);
    if (result.length === 0) return null;
    const entry = result[0];
    const expiresAt = entry.expiresAt.getTime();
    const staleUntilAt = entry.staleUntilAt.getTime();
    const data = JSON.parse(entry.responseJson);
    inMemoryCache.set(cacheKey, { data, expiresAt, staleUntilAt });
    await db.update(externalApiCacheEntries).set({
      hitCount: entry.hitCount + 1,
      lastAccessedAt: /* @__PURE__ */ new Date()
    }).where(eq4(externalApiCacheEntries.id, entry.id));
    if (now < expiresAt) {
      return { data, isFresh: true, isStale: false, hitCount: entry.hitCount + 1 };
    }
    if (now < staleUntilAt) {
      return { data, isFresh: false, isStale: true, hitCount: entry.hitCount + 1 };
    }
    await db.delete(externalApiCacheEntries).where(eq4(externalApiCacheEntries.id, entry.id));
    inMemoryCache.delete(cacheKey);
    return null;
  } catch (error) {
    log.warn("PersistentCache", `Failed to get from DB cache for ${provider}:${key}: ${error}`);
    return null;
  }
}
async function setInCache(provider, key, data) {
  const policy = getProviderPolicy(provider);
  const now = Date.now();
  const expiresAt = new Date(now + policy.cacheFreshDurationMs);
  const staleUntilAt = new Date(now + policy.cacheStaleDurationMs);
  const cacheKey = getCacheKey(provider, key);
  inMemoryCache.set(cacheKey, {
    data,
    expiresAt: expiresAt.getTime(),
    staleUntilAt: staleUntilAt.getTime()
  });
  try {
    const existing = await db.select().from(externalApiCacheEntries).where(
      and3(
        eq4(externalApiCacheEntries.provider, provider),
        eq4(externalApiCacheEntries.cacheKey, key)
      )
    ).limit(1);
    if (existing.length > 0) {
      await db.update(externalApiCacheEntries).set({
        responseJson: JSON.stringify(data),
        expiresAt,
        staleUntilAt,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq4(externalApiCacheEntries.id, existing[0].id));
    } else {
      await db.insert(externalApiCacheEntries).values({
        provider,
        cacheKey: key,
        responseJson: JSON.stringify(data),
        expiresAt,
        staleUntilAt
      });
    }
  } catch (error) {
    log.warn("PersistentCache", `Failed to set DB cache for ${provider}:${key}: ${error}`);
  }
}
async function invalidateCache(provider, key) {
  let deletedCount = 0;
  if (key) {
    const cacheKey = getCacheKey(provider, key);
    inMemoryCache.delete(cacheKey);
    try {
      const result = await db.delete(externalApiCacheEntries).where(
        and3(
          eq4(externalApiCacheEntries.provider, provider),
          eq4(externalApiCacheEntries.cacheKey, key)
        )
      );
      deletedCount = 1;
    } catch (error) {
      log.warn("PersistentCache", `Failed to invalidate cache for ${provider}:${key}: ${error}`);
    }
  } else {
    for (const k of inMemoryCache.keys()) {
      if (k.startsWith(`${provider}:`)) {
        inMemoryCache.delete(k);
      }
    }
    try {
      await db.delete(externalApiCacheEntries).where(eq4(externalApiCacheEntries.provider, provider));
    } catch (error) {
      log.warn("PersistentCache", `Failed to invalidate all cache for ${provider}: ${error}`);
    }
  }
  return deletedCount;
}
async function purgeExpiredCache() {
  const now = /* @__PURE__ */ new Date();
  let purgedCount = 0;
  for (const [key, entry] of inMemoryCache.entries()) {
    if (Date.now() > entry.staleUntilAt) {
      inMemoryCache.delete(key);
      purgedCount++;
    }
  }
  try {
    await db.delete(externalApiCacheEntries).where(lt2(externalApiCacheEntries.staleUntilAt, now));
  } catch (error) {
    log.warn("PersistentCache", `Failed to purge expired cache from DB: ${error}`);
  }
  log.info("PersistentCache", `Purged ${purgedCount} expired entries from memory cache`);
  return purgedCount;
}
async function getCacheStats(provider) {
  const now = /* @__PURE__ */ new Date();
  try {
    let query = db.select().from(externalApiCacheEntries);
    if (provider) {
      query = query.where(eq4(externalApiCacheEntries.provider, provider));
    }
    const entries = await query;
    let freshEntries = 0;
    let staleEntries = 0;
    let expiredEntries = 0;
    let totalHits = 0;
    for (const entry of entries) {
      totalHits += entry.hitCount;
      if (now < entry.expiresAt) {
        freshEntries++;
      } else if (now < entry.staleUntilAt) {
        staleEntries++;
      } else {
        expiredEntries++;
      }
    }
    return {
      totalEntries: entries.length,
      freshEntries,
      staleEntries,
      expiredEntries,
      totalHits
    };
  } catch (error) {
    log.warn("PersistentCache", `Failed to get cache stats: ${error}`);
    return {
      totalEntries: 0,
      freshEntries: 0,
      staleEntries: 0,
      expiredEntries: 0,
      totalHits: 0
    };
  }
}
async function getAllCacheEntries(provider) {
  try {
    let query = db.select().from(externalApiCacheEntries);
    if (provider) {
      query = query.where(eq4(externalApiCacheEntries.provider, provider));
    }
    const entries = await query;
    return entries.map((entry) => ({
      provider: entry.provider,
      cacheKey: entry.cacheKey,
      expiresAt: entry.expiresAt,
      staleUntilAt: entry.staleUntilAt,
      hitCount: entry.hitCount,
      lastAccessedAt: entry.lastAccessedAt,
      sizeBytes: entry.responseJson.length
    }));
  } catch (error) {
    log.warn("PersistentCache", `Failed to get cache entries: ${error}`);
    return [];
  }
}
var inMemoryCache;
var init_persistentApiCache = __esm({
  "server/lib/persistentApiCache.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    init_apiPolicy();
    inMemoryCache = /* @__PURE__ */ new Map();
  }
});

// server/lib/callExternal.ts
var callExternal_exports = {};
__export(callExternal_exports, {
  callExternal: () => callExternal,
  getAllProviderStatuses: () => getAllProviderStatuses,
  getProviderStatus: () => getProviderStatus
});
async function enforceMinInterval(provider) {
  const policy = getProviderPolicy(provider);
  const lastCall = lastCallTimes.get(provider) || 0;
  const elapsed = Date.now() - lastCall;
  const minInterval = policy.minRequestIntervalMs;
  if (elapsed < minInterval) {
    const waitTime = minInterval - elapsed;
    await new Promise((resolve2) => setTimeout(resolve2, waitTime));
  }
  lastCallTimes.set(provider, Date.now());
}
async function callExternal(fetcher, options) {
  const {
    provider,
    endpoint,
    cacheKey,
    budgetPolicy = {},
    cachePolicy = {},
    fallbackProvider,
    fallbackFetcher
  } = options;
  const effectiveCacheKey = cacheKey || `${provider}:${endpoint}`;
  const startTime = Date.now();
  let cacheStatus = "miss";
  let usedFallback = false;
  if (!cachePolicy.skipCache && !cachePolicy.forceRefresh) {
    const cached = await getFromCache(provider, effectiveCacheKey);
    if (cached) {
      if (cached.isFresh) {
        cacheStatus = "fresh";
        await recordUsage(provider, { isCacheHit: true });
        log.debug("CallExternal", `Cache HIT (fresh) for ${provider}:${effectiveCacheKey}`);
        return {
          data: cached.data,
          provenance: {
            provider,
            cacheStatus: "fresh",
            budgetRemaining: Infinity,
            latencyMs: Date.now() - startTime,
            usedFallback: false
          }
        };
      }
      cacheStatus = "stale";
    }
  }
  if (!budgetPolicy.skipBudgetCheck) {
    const budgetCheck = await checkBudget(provider);
    if (!budgetCheck.allowed) {
      log.warn("CallExternal", `Budget exhausted for ${provider}: ${budgetCheck.reason}`);
      if (cacheStatus === "stale") {
        const staleData = await getFromCache(provider, effectiveCacheKey);
        if (staleData) {
          log.info("CallExternal", `Serving stale data for ${provider} due to budget limit`);
          await recordUsage(provider, { isCacheHit: true });
          return {
            data: staleData.data,
            provenance: {
              provider,
              cacheStatus: "stale",
              budgetRemaining: 0,
              latencyMs: Date.now() - startTime,
              usedFallback: false
            }
          };
        }
      }
      if (fallbackProvider && fallbackFetcher) {
        log.info("CallExternal", `Trying fallback provider ${fallbackProvider} for ${provider}`);
        try {
          const fallbackResult = await callExternal(fallbackFetcher, {
            provider: fallbackProvider,
            endpoint,
            cacheKey: effectiveCacheKey,
            budgetPolicy,
            cachePolicy
          });
          return {
            ...fallbackResult,
            provenance: {
              ...fallbackResult.provenance,
              usedFallback: true
            }
          };
        } catch (fallbackError) {
          log.warn("CallExternal", `Fallback provider ${fallbackProvider} also failed`);
        }
      }
      throw new Error(`Budget exhausted for ${provider}: ${budgetCheck.reason}`);
    }
  }
  await enforceMinInterval(provider);
  try {
    const data = await fetcher();
    const latencyMs = Date.now() - startTime;
    await setInCache(provider, effectiveCacheKey, data);
    const requestCount = budgetPolicy.countAsMultiple || 1;
    for (let i = 0; i < requestCount; i++) {
      await recordUsage(provider, {
        isCacheHit: false,
        latencyMs: i === 0 ? latencyMs : void 0
      });
    }
    log.debug("CallExternal", `Fetched ${provider}:${effectiveCacheKey} in ${latencyMs}ms`);
    const postBudget = await checkBudget(provider);
    return {
      data,
      provenance: {
        provider,
        cacheStatus: "miss",
        budgetRemaining: postBudget.allowed ? postBudget.limit - postBudget.currentCount : 0,
        latencyMs,
        usedFallback
      }
    };
  } catch (error) {
    const latencyMs = Date.now() - startTime;
    await recordUsage(provider, {
      isCacheHit: false,
      isError: true,
      latencyMs
    });
    if (cacheStatus === "stale") {
      const staleData = await getFromCache(provider, effectiveCacheKey);
      if (staleData) {
        log.warn("CallExternal", `Serving stale data for ${provider} after fetch error: ${error}`);
        return {
          data: staleData.data,
          provenance: {
            provider,
            cacheStatus: "stale",
            budgetRemaining: 0,
            latencyMs,
            usedFallback: false
          }
        };
      }
    }
    if (fallbackProvider && fallbackFetcher) {
      log.info("CallExternal", `Trying fallback provider ${fallbackProvider} after error`);
      try {
        const fallbackResult = await callExternal(fallbackFetcher, {
          provider: fallbackProvider,
          endpoint,
          cacheKey: effectiveCacheKey,
          budgetPolicy,
          cachePolicy
        });
        return {
          ...fallbackResult,
          provenance: {
            ...fallbackResult.provenance,
            usedFallback: true
          }
        };
      } catch (fallbackError) {
        log.warn("CallExternal", `Fallback provider ${fallbackProvider} also failed`);
      }
    }
    throw error;
  }
}
async function getProviderStatus(provider) {
  const policy = getProviderPolicy(provider);
  const budgetCheck = await checkBudget(provider);
  const lastCall = lastCallTimes.get(provider) || null;
  return {
    enabled: policy.enabled,
    budgetStatus: {
      allowed: budgetCheck.allowed,
      currentCount: budgetCheck.currentCount,
      limit: budgetCheck.limit,
      windowType: budgetCheck.windowType
    },
    lastCallTime: lastCall,
    policy: {
      maxRequestsPerMinute: policy.maxRequestsPerMinute,
      maxRequestsPerDay: policy.maxRequestsPerDay,
      maxRequestsPerWeek: policy.maxRequestsPerWeek,
      cacheFreshDurationMs: policy.cacheFreshDurationMs
    }
  };
}
async function getAllProviderStatuses() {
  const providers2 = [
    "alpaca",
    "finnhub",
    "coingecko",
    "coinmarketcap",
    "newsapi",
    "polygon",
    "twelvedata",
    "valyu",
    "huggingface",
    "gdelt",
    "openai",
    "groq",
    "together",
    "aitrados_ohlc",
    "aitrados_news",
    "aitrados_econ"
  ];
  const statuses = {};
  for (const provider of providers2) {
    statuses[provider] = await getProviderStatus(provider);
  }
  return statuses;
}
var lastCallTimes;
var init_callExternal = __esm({
  "server/lib/callExternal.ts"() {
    "use strict";
    init_logger();
    init_apiBudget();
    init_persistentApiCache();
    init_apiPolicy();
    lastCallTimes = /* @__PURE__ */ new Map();
  }
});

// server/lib/connectorClient.ts
async function connectorFetch(url, options) {
  const {
    provider,
    endpoint,
    cacheKey,
    headers = {},
    method = "GET",
    body,
    skipCache = false,
    forceRefresh = false,
    customTTLMs,
    countAsMultiple
  } = options;
  const startTime = Date.now();
  const fetcher = async () => {
    const fetchOptions = {
      method,
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        ...headers
      }
    };
    if (body && method !== "GET") {
      fetchOptions.body = JSON.stringify(body);
    }
    const response = await fetch(url, fetchOptions);
    if (!response.ok) {
      const errorText = await response.text().catch(() => "");
      throw new Error(`${provider} API error ${response.status}: ${errorText.substring(0, 200)}`);
    }
    return response.json();
  };
  const callExternalOptions = {
    provider,
    endpoint,
    cacheKey,
    cachePolicy: {
      skipCache,
      forceRefresh,
      customTTLMs
    },
    budgetPolicy: {
      countAsMultiple
    }
  };
  const result = await callExternal(fetcher, callExternalOptions);
  log.debug("ConnectorClient", `${provider}:${endpoint}`, {
    cacheStatus: result.provenance.cacheStatus,
    budgetRemaining: result.provenance.budgetRemaining,
    latencyMs: result.provenance.latencyMs
  });
  return {
    data: result.data,
    provenance: {
      provider,
      cacheStatus: result.provenance.cacheStatus,
      budgetRemaining: result.provenance.budgetRemaining,
      latencyMs: result.provenance.latencyMs,
      usedFallback: result.provenance.usedFallback,
      timestamp: Date.now()
    }
  };
}
function buildCacheKey(provider, ...parts) {
  const filteredParts = parts.filter((p) => p !== void 0 && p !== null);
  return `${provider}:${filteredParts.join(":")}`;
}
var init_connectorClient = __esm({
  "server/lib/connectorClient.ts"() {
    "use strict";
    init_callExternal();
    init_logger();
  }
});

// server/connectors/coingecko.ts
var COINGECKO_BASE_URL, CoinGeckoConnector, coingecko;
var init_coingecko = __esm({
  "server/connectors/coingecko.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    COINGECKO_BASE_URL = "https://api.coingecko.com/api/v3";
    CoinGeckoConnector = class {
      marketsCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      priceCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      chartCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      trendingCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      globalCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      coinListCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      ohlcCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      pendingRefreshes = /* @__PURE__ */ new Set();
      getApiKey() {
        return process.env.COINGECKO_API_KEY;
      }
      async fetchWithL1Cache(url, endpoint, cacheKey, cache2) {
        const cached = cache2.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("CoinGecko", `L1 cache HIT (fresh) for ${cacheKey}`);
          return cached.data;
        }
        if (cached && !cached.isFresh) {
          if (!this.pendingRefreshes.has(cacheKey)) {
            this.pendingRefreshes.add(cacheKey);
            this.backgroundRefresh(url, endpoint, cacheKey, cache2);
          }
          log.debug("CoinGecko", `Serving stale L1 data for ${cacheKey}, refreshing in background`);
          return cached.data;
        }
        return this.doFetch(url, endpoint, cacheKey, cache2);
      }
      async backgroundRefresh(url, endpoint, cacheKey, cache2) {
        try {
          await this.doFetch(url, endpoint, cacheKey, cache2);
        } catch (error) {
          log.warn("CoinGecko", `Background refresh failed for ${cacheKey}`);
        } finally {
          this.pendingRefreshes.delete(cacheKey);
        }
      }
      async doFetch(url, endpoint, cacheKey, cache2) {
        const apiKey = this.getApiKey();
        const separator = url.includes("?") ? "&" : "?";
        const fullUrl = apiKey ? `${url}${separator}x_cg_demo_api_key=${apiKey}` : url;
        const externalCacheKey = buildCacheKey("coingecko", endpoint, cacheKey);
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "coingecko",
            endpoint,
            cacheKey: externalCacheKey,
            headers: { Accept: "application/json" }
          });
          cache2.set(cacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = cache2.getStale(cacheKey);
          if (stale) {
            log.debug("CoinGecko", `Error fetching, serving stale L1 data for ${cacheKey}`);
            return stale;
          }
          throw error;
        }
      }
      async getMarkets(vsCurrency = "usd", perPage = 20, page = 1, order = "market_cap_desc") {
        const cacheKey = buildCacheKey("coingecko", "markets", vsCurrency, perPage, page, order);
        const url = `${COINGECKO_BASE_URL}/coins/markets?vs_currency=${vsCurrency}&order=${order}&per_page=${perPage}&page=${page}&sparkline=false`;
        return this.fetchWithL1Cache(url, "/coins/markets", cacheKey, this.marketsCache);
      }
      async getSimplePrice(coinIds, vsCurrencies = "usd", includeMarketCap = true, include24hVol = true, include24hChange = true) {
        const ids = coinIds.join(",");
        const cacheKey = buildCacheKey("coingecko", "simple", ids, vsCurrencies);
        const url = `${COINGECKO_BASE_URL}/simple/price?ids=${ids}&vs_currencies=${vsCurrencies}&include_market_cap=${includeMarketCap}&include_24hr_vol=${include24hVol}&include_24hr_change=${include24hChange}&include_last_updated_at=true`;
        return this.fetchWithL1Cache(url, "/simple/price", cacheKey, this.priceCache);
      }
      async getMarketChart(coinId, vsCurrency = "usd", days = 7) {
        const cacheKey = buildCacheKey("coingecko", "chart", coinId, vsCurrency, days);
        const url = `${COINGECKO_BASE_URL}/coins/${coinId}/market_chart?vs_currency=${vsCurrency}&days=${days}`;
        return this.fetchWithL1Cache(url, `/coins/${coinId}/market_chart`, cacheKey, this.chartCache);
      }
      async getTrending() {
        const cacheKey = buildCacheKey("coingecko", "trending");
        const url = `${COINGECKO_BASE_URL}/search/trending`;
        return this.fetchWithL1Cache(url, "/search/trending", cacheKey, this.trendingCache);
      }
      async getGlobalData() {
        const cacheKey = buildCacheKey("coingecko", "global");
        const url = `${COINGECKO_BASE_URL}/global`;
        return this.fetchWithL1Cache(url, "/global", cacheKey, this.globalCache);
      }
      async getCoinList() {
        const cacheKey = buildCacheKey("coingecko", "coinlist");
        const url = `${COINGECKO_BASE_URL}/coins/list`;
        return this.fetchWithL1Cache(url, "/coins/list", cacheKey, this.coinListCache);
      }
      async searchCoins(query) {
        const cacheKey = buildCacheKey("coingecko", "search", query);
        const url = `${COINGECKO_BASE_URL}/search?query=${encodeURIComponent(query)}`;
        return this.fetchWithL1Cache(url, "/search", cacheKey, this.searchCache);
      }
      async getOHLC(coinId, vsCurrency = "usd", days = 7) {
        const cacheKey = buildCacheKey("coingecko", "ohlc", coinId, vsCurrency, days);
        const url = `${COINGECKO_BASE_URL}/coins/${coinId}/ohlc?vs_currency=${vsCurrency}&days=${days}`;
        const rawData = await this.fetchWithL1Cache(url, `/coins/${coinId}/ohlc`, cacheKey, this.ohlcCache);
        return rawData.map(([timestamp3, open, high, low, close]) => ({
          timestamp: timestamp3,
          open,
          high,
          low,
          close
        }));
      }
      async getOHLCWithIndicators(coinId, days = 30) {
        const ohlc = await this.getOHLC(coinId, "usd", days);
        if (ohlc.length === 0) {
          return {
            candles: [],
            latestPrice: 0,
            priceChange24h: 0,
            volatility: 0,
            trend: "neutral",
            support: 0,
            resistance: 0
          };
        }
        const latestCandle = ohlc[ohlc.length - 1];
        const latestPrice = latestCandle.close;
        const firstCandle = ohlc[0];
        const priceChange24h = (latestPrice - firstCandle.close) / firstCandle.close * 100;
        const highs = ohlc.map((c) => c.high);
        const lows = ohlc.map((c) => c.low);
        const closes = ohlc.map((c) => c.close);
        const avgClose = closes.reduce((a, b) => a + b, 0) / closes.length;
        const variance = closes.reduce((sum, c) => sum + Math.pow(c - avgClose, 2), 0) / closes.length;
        const volatility = Math.sqrt(variance) / avgClose * 100;
        const resistance = Math.max(...highs);
        const support = Math.min(...lows);
        const recentCandles = ohlc.slice(-5);
        const bullishCount = recentCandles.filter((c) => c.close > c.open).length;
        const trend = bullishCount >= 4 ? "bullish" : bullishCount <= 1 ? "bearish" : "neutral";
        return {
          candles: ohlc,
          latestPrice,
          priceChange24h,
          volatility,
          trend,
          support,
          resistance
        };
      }
      getConnectionStatus() {
        const totalCacheSize = this.marketsCache.size() + this.priceCache.size() + this.chartCache.size() + this.trendingCache.size() + this.globalCache.size() + this.coinListCache.size() + this.searchCache.size() + this.ohlcCache.size();
        return {
          connected: true,
          hasApiKey: !!this.getApiKey(),
          cacheSize: totalCacheSize
        };
      }
      clearCache() {
        this.marketsCache.clear();
        this.priceCache.clear();
        this.chartCache.clear();
        this.trendingCache.clear();
        this.globalCache.clear();
        this.coinListCache.clear();
        this.searchCache.clear();
        this.ohlcCache.clear();
      }
    };
    coingecko = new CoinGeckoConnector();
  }
});

// server/connectors/finnhub.ts
var FINNHUB_BASE_URL, FinnhubConnector, finnhub;
var init_finnhub = __esm({
  "server/connectors/finnhub.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    FINNHUB_BASE_URL = "https://finnhub.io/api/v1";
    FinnhubConnector = class {
      quoteCache = new ApiCache({
        freshDuration: 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      candleCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      profileCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      newsCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      financialsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      technicalCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      pendingRefreshes = /* @__PURE__ */ new Set();
      getApiKey() {
        return process.env.FINNHUB_API_KEY;
      }
      async fetchWithL1Cache(endpoint, l1CacheKey, l1Cache) {
        const apiKey = this.getApiKey();
        if (!apiKey) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug("Finnhub", `No API key, serving stale L1 data for ${l1CacheKey}`);
            return stale;
          }
          throw new Error("FINNHUB_API_KEY is not configured");
        }
        const l1Cached = l1Cache.get(l1CacheKey);
        if (l1Cached?.isFresh) {
          log.debug("Finnhub", `L1 cache HIT (fresh) for ${l1CacheKey}`);
          return l1Cached.data;
        }
        if (l1Cached && !l1Cached.isFresh) {
          if (!this.pendingRefreshes.has(l1CacheKey)) {
            this.pendingRefreshes.add(l1CacheKey);
            this.backgroundRefresh(endpoint, l1CacheKey, l1Cache);
          }
          log.debug("Finnhub", `Serving stale L1 data for ${l1CacheKey}, refreshing in background`);
          return l1Cached.data;
        }
        return this.doFetch(endpoint, l1CacheKey, l1Cache);
      }
      async backgroundRefresh(endpoint, l1CacheKey, l1Cache) {
        try {
          await this.doFetch(endpoint, l1CacheKey, l1Cache);
        } catch (error) {
          log.warn("Finnhub", `Background refresh failed for ${l1CacheKey}`);
        } finally {
          this.pendingRefreshes.delete(l1CacheKey);
        }
      }
      async doFetch(endpoint, l1CacheKey, l1Cache) {
        const apiKey = this.getApiKey();
        const separator = endpoint.includes("?") ? "&" : "?";
        const fullUrl = `${FINNHUB_BASE_URL}${endpoint}${separator}token=${apiKey}`;
        const cacheKey = buildCacheKey("finnhub", l1CacheKey);
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "finnhub",
            endpoint,
            cacheKey,
            headers: { Accept: "application/json" }
          });
          l1Cache.set(l1CacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug("Finnhub", `Error fetching, serving stale L1 data for ${l1CacheKey}`);
            return stale;
          }
          throw error;
        }
      }
      async getQuote(symbol) {
        const l1CacheKey = `quote_${symbol}`;
        const endpoint = `/quote?symbol=${symbol.toUpperCase()}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.quoteCache);
      }
      async getCandles(symbol, resolution = "D", from, to) {
        const now = Math.floor(Date.now() / 1e3);
        const fromTime = from || now - 30 * 24 * 60 * 60;
        const toTime = to || now;
        const l1CacheKey = `candles_${symbol}_${resolution}_${fromTime}_${toTime}`;
        const endpoint = `/stock/candle?symbol=${symbol.toUpperCase()}&resolution=${resolution}&from=${fromTime}&to=${toTime}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.candleCache);
      }
      async getCompanyProfile(symbol) {
        const l1CacheKey = `profile_${symbol}`;
        const endpoint = `/stock/profile2?symbol=${symbol.toUpperCase()}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.profileCache);
      }
      async searchSymbols(query) {
        const l1CacheKey = `search_${query}`;
        const endpoint = `/search?q=${encodeURIComponent(query)}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.searchCache);
      }
      async getMarketNews(category = "general") {
        const l1CacheKey = `news_${category}`;
        const endpoint = `/news?category=${category}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.newsCache);
      }
      async getMultipleQuotes(symbols) {
        const quotes = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          try {
            const quote = await this.getQuote(symbol);
            if (quote && quote.c !== 0) {
              quotes.set(symbol, quote);
            }
          } catch (error) {
            log.error("Finnhub", `Failed to fetch quote for ${symbol}`, { error: String(error) });
          }
        }
        return quotes;
      }
      async getBasicFinancials(symbol) {
        const l1CacheKey = `financials_${symbol}`;
        const endpoint = `/stock/metric?symbol=${symbol.toUpperCase()}&metric=all`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.financialsCache);
      }
      async getTechnicalIndicator(symbol, resolution = "D") {
        const l1CacheKey = `technical_${symbol}_${resolution}`;
        const endpoint = `/scan/technical-indicator?symbol=${symbol.toUpperCase()}&resolution=${resolution}`;
        return this.fetchWithL1Cache(endpoint, l1CacheKey, this.technicalCache);
      }
      async getKeyMetrics(symbol) {
        try {
          const financials = await this.getBasicFinancials(symbol);
          const m = financials.metric;
          return {
            peRatio: m.peBasicExclExtraTTM ?? m.peExclExtraTTM ?? null,
            pbRatio: m.pbQuarterly ?? null,
            roe: m.roeTTM ?? m.roeRfy ?? null,
            roa: m.roaTTM ?? m.roaRfy ?? null,
            currentRatio: m.currentRatioQuarterly ?? null,
            debtToEquity: m.totalDebtToEquityQuarterly ?? null,
            grossMargin: m.grossMarginTTM ?? m.grossMargin5Y ?? null,
            netProfitMargin: m.netProfitMarginTTM ?? m.netProfitMargin5Y ?? null,
            beta: m.beta ?? null,
            dividendYield: m.dividendYieldIndicatedAnnual ?? null,
            epsGrowth: m.epsGrowthTTMYoy ?? m.epsGrowth3Y ?? null,
            revenueGrowth: m.revenueGrowthTTMYoy ?? m.revenueGrowth3Y ?? null,
            weekHigh52: m["52WeekHigh"] ?? null,
            weekLow52: m["52WeekLow"] ?? null
          };
        } catch (error) {
          log.warn("Finnhub", `Failed to get key metrics for ${symbol}`, { error: String(error) });
          return {
            peRatio: null,
            pbRatio: null,
            roe: null,
            roa: null,
            currentRatio: null,
            debtToEquity: null,
            grossMargin: null,
            netProfitMargin: null,
            beta: null,
            dividendYield: null,
            epsGrowth: null,
            revenueGrowth: null,
            weekHigh52: null,
            weekLow52: null
          };
        }
      }
      async getTechnicalSignals(symbol) {
        try {
          const indicator = await this.getTechnicalIndicator(symbol);
          return {
            signal: indicator.technicalAnalysis.signal,
            buyCount: indicator.technicalAnalysis.count.buy,
            sellCount: indicator.technicalAnalysis.count.sell,
            neutralCount: indicator.technicalAnalysis.count.neutral,
            adx: indicator.trend.adx,
            isTrending: indicator.trend.trending
          };
        } catch (error) {
          log.warn("Finnhub", `Failed to get technical signals for ${symbol}`, { error: String(error) });
          return {
            signal: "neutral",
            buyCount: 0,
            sellCount: 0,
            neutralCount: 0,
            adx: null,
            isTrending: false
          };
        }
      }
      getConnectionStatus() {
        const totalCacheSize = this.quoteCache.size() + this.candleCache.size() + this.profileCache.size() + this.searchCache.size() + this.newsCache.size() + this.financialsCache.size() + this.technicalCache.size();
        return {
          connected: !!this.getApiKey(),
          hasApiKey: !!this.getApiKey(),
          cacheSize: totalCacheSize
        };
      }
      clearCache() {
        this.quoteCache.clear();
        this.candleCache.clear();
        this.profileCache.clear();
        this.searchCache.clear();
        this.newsCache.clear();
        this.financialsCache.clear();
        this.technicalCache.clear();
      }
    };
    finnhub = new FinnhubConnector();
  }
});

// server/config/trading-config.ts
function getAlpacaBaseUrl() {
  return tradingConfig.alpaca.tradingMode === "live" ? tradingConfig.alpaca.liveUrl : tradingConfig.alpaca.paperUrl;
}
var getEnvNumber, getEnvString, alpacaConfig, orderRetryConfig, orderExecutionConfig, riskManagementConfig, universeConfig, queueConfig, tradingConfig;
var init_trading_config = __esm({
  "server/config/trading-config.ts"() {
    "use strict";
    getEnvNumber = (key, defaultVal) => {
      const val = process.env[key];
      if (!val) return defaultVal;
      const parsed = parseFloat(val);
      return isNaN(parsed) ? defaultVal : parsed;
    };
    getEnvString = (key, defaultVal) => {
      return process.env[key] || defaultVal;
    };
    alpacaConfig = Object.freeze({
      // Trading mode: 'paper' or 'live'
      tradingMode: getEnvString("ALPACA_TRADING_MODE", "paper"),
      // Paper trading URL (default for testing)
      paperUrl: getEnvString("ALPACA_PAPER_URL", "https://paper-api.alpaca.markets"),
      // Live trading URL (use with caution!)
      liveUrl: getEnvString("ALPACA_LIVE_URL", "https://api.alpaca.markets"),
      // Market data URL (same for both paper and live)
      dataUrl: getEnvString("ALPACA_DATA_URL", "https://data.alpaca.markets"),
      // WebSocket streaming URL (same for both paper and live)
      streamUrl: getEnvString("ALPACA_STREAM_URL", "wss://stream.data.alpaca.markets")
    });
    orderRetryConfig = Object.freeze({
      // Maximum number of retry attempts per order before giving up
      maxRetriesPerOrder: getEnvNumber("MAX_RETRIES_PER_ORDER", 3),
      // Base delay in milliseconds for exponential backoff (doubles each retry)
      // Formula: delay = retryBackoffBaseMs * 2^(attemptNumber - 1)
      // Example: 2000ms, 4000ms, 8000ms for 3 attempts
      retryBackoffBaseMs: getEnvNumber("RETRY_BACKOFF_BASE_MS", 2e3),
      // Circuit breaker: number of failures before opening circuit
      circuitBreakerThreshold: getEnvNumber("CIRCUIT_BREAKER_THRESHOLD", 10),
      // Circuit breaker: time window in ms to count failures (1 minute default)
      circuitBreakerWindowMs: getEnvNumber("CIRCUIT_BREAKER_WINDOW_MS", 6e4),
      // Circuit breaker: cooldown period before auto-reset (5 minutes default)
      circuitBreakerResetMs: getEnvNumber("CIRCUIT_BREAKER_RESET_MS", 3e5)
    });
    orderExecutionConfig = Object.freeze({
      // Polling interval in ms to check if order is filled (500ms default)
      orderFillPollIntervalMs: getEnvNumber("ORDER_FILL_POLL_INTERVAL_MS", 500),
      // Maximum time in ms to wait for order fill before timing out (30 seconds default)
      orderFillTimeoutMs: getEnvNumber("ORDER_FILL_TIMEOUT_MS", 3e4),
      // Maximum age in ms for unfilled orders before auto-cancellation (5 minutes default)
      staleOrderTimeoutMs: getEnvNumber("STALE_ORDER_TIMEOUT_MS", 3e5)
    });
    riskManagementConfig = Object.freeze({
      // Default hard stop loss percentage (exit when position loses this much)
      defaultHardStopLossPercent: getEnvNumber("DEFAULT_HARD_STOP_LOSS_PERCENT", 3),
      // Default take profit percentage (exit when position gains this much)
      defaultTakeProfitPercent: getEnvNumber("DEFAULT_TAKE_PROFIT_PERCENT", 6),
      // Maximum position size as percentage of portfolio (10% = conservative, 15% = aggressive)
      defaultMaxPositionSizePercent: getEnvNumber("DEFAULT_MAX_POSITION_SIZE_PERCENT", 15),
      // Maximum total exposure as percentage of portfolio
      // 100% = fully invested, 200% = 2x leverage (margin account)
      defaultMaxExposurePercent: getEnvNumber("DEFAULT_MAX_EXPOSURE_PERCENT", 200)
    });
    universeConfig = Object.freeze({
      // Maximum number of stock symbols to analyze per cycle
      // Conservative: 120, Moderate: 300, Aggressive: 500
      maxStockSymbolsPerCycle: getEnvNumber("MAX_STOCK_SYMBOLS_PER_CYCLE", 500),
      // Maximum number of crypto symbols to analyze per cycle
      // Conservative: 20, Moderate: 50, Aggressive: 100
      maxCryptoSymbolsPerCycle: getEnvNumber("MAX_CRYPTO_SYMBOLS_PER_CYCLE", 100),
      // Minimum AI confidence score (0-1) to include symbol in universe
      // Conservative: 0.70, Moderate: 0.60, Aggressive: 0.50
      minConfidenceForUniverse: getEnvNumber("MIN_CONFIDENCE_FOR_UNIVERSE", 0.5),
      // Number of symbols to fetch per Alpaca snapshot API request
      // Max supported: 100, Recommended: 50 for reliability
      alpacaSnapshotChunkSize: getEnvNumber("ALPACA_SNAPSHOT_CHUNK_SIZE", 50)
    });
    queueConfig = Object.freeze({
      // Interval in ms to poll work queue for pending tasks (2 seconds default)
      queuePollIntervalMs: getEnvNumber("QUEUE_POLL_INTERVAL_MS", 2e3),
      // Maximum time in ms for a work item to complete before timing out (1 minute default)
      queuePollTimeoutMs: getEnvNumber("QUEUE_POLL_TIMEOUT_MS", 6e4),
      // Interval in ms to send heartbeat signals (30 seconds default)
      heartbeatIntervalMs: getEnvNumber("HEARTBEAT_INTERVAL_MS", 3e4)
    });
    tradingConfig = Object.freeze({
      alpaca: alpacaConfig,
      orderRetry: orderRetryConfig,
      orderExecution: orderExecutionConfig,
      riskManagement: riskManagementConfig,
      universe: universeConfig,
      queue: queueConfig
    });
  }
});

// server/connectors/alpaca.ts
var alpaca_exports = {};
__export(alpaca_exports, {
  alpaca: () => alpaca
});
var ALPACA_BASE_URL, ALPACA_DATA_URL, ALPACA_STREAM_URL, AlpacaConnector, alpaca;
var init_alpaca = __esm({
  "server/connectors/alpaca.ts"() {
    "use strict";
    init_logger();
    init_trading_config();
    ALPACA_BASE_URL = getAlpacaBaseUrl();
    ALPACA_DATA_URL = tradingConfig.alpaca.dataUrl;
    ALPACA_STREAM_URL = tradingConfig.alpaca.streamUrl;
    AlpacaConnector = class {
      cache = /* @__PURE__ */ new Map();
      cacheDuration = 30 * 1e3;
      lastRequestTime = 0;
      minRequestInterval = 350;
      requestQueue = Promise.resolve();
      activeRequests = 0;
      maxConcurrentRequests = 3;
      getCredentials() {
        const apiKey = process.env.ALPACA_API_KEY;
        const secretKey = process.env.ALPACA_SECRET_KEY;
        if (!apiKey || !secretKey) return null;
        return { apiKey, secretKey };
      }
      async throttle() {
        while (this.activeRequests >= this.maxConcurrentRequests) {
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
        this.activeRequests++;
        const executeThrottle = async () => {
          const now = Date.now();
          const timeSinceLastRequest = now - this.lastRequestTime;
          if (timeSinceLastRequest < this.minRequestInterval) {
            await new Promise(
              (resolve2) => setTimeout(resolve2, this.minRequestInterval - timeSinceLastRequest)
            );
          }
          this.lastRequestTime = Date.now();
        };
        this.requestQueue = this.requestQueue.then(executeThrottle);
        await this.requestQueue;
      }
      releaseThrottle() {
        this.activeRequests = Math.max(0, this.activeRequests - 1);
      }
      getCached(key) {
        const entry = this.cache.get(key);
        if (entry && Date.now() - entry.timestamp < this.cacheDuration) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async fetchWithRetry(url, options = {}, retries = 5) {
        const credentials2 = this.getCredentials();
        if (!credentials2) {
          throw new Error("Alpaca API credentials not configured");
        }
        await this.throttle();
        const headers = {
          "APCA-API-KEY-ID": credentials2.apiKey,
          "APCA-API-SECRET-KEY": credentials2.secretKey,
          "Content-Type": "application/json",
          Accept: "application/json",
          ...options.headers
        };
        try {
          for (let i = 0; i < retries; i++) {
            try {
              const response = await fetch(url, {
                ...options,
                headers
              });
              if (response.status === 429) {
                const waitTime = Math.min(Math.pow(2, i + 1) * 1e3, 16e3);
                log.warn("Alpaca", `Rate limited, waiting ${waitTime}ms (attempt ${i + 1}/${retries})`);
                await new Promise((resolve2) => setTimeout(resolve2, waitTime));
                continue;
              }
              if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Alpaca API error: ${response.status} - ${errorBody}`);
              }
              const text3 = await response.text();
              if (!text3) return {};
              return JSON.parse(text3);
            } catch (error) {
              if (i === retries - 1) throw error;
              const waitTime = Math.min(1e3 * Math.pow(2, i), 8e3);
              await new Promise((resolve2) => setTimeout(resolve2, waitTime));
            }
          }
          throw new Error("Failed to fetch from Alpaca after retries");
        } finally {
          this.releaseThrottle();
        }
      }
      async getAccount() {
        const cacheKey = "account";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/account`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getPositions() {
        const cacheKey = "positions";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/positions`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getPosition(symbol) {
        try {
          const url = `${ALPACA_BASE_URL}/v2/positions/${symbol.toUpperCase()}`;
          return await this.fetchWithRetry(url);
        } catch {
          return null;
        }
      }
      async closePosition(symbol) {
        const url = `${ALPACA_BASE_URL}/v2/positions/${symbol.toUpperCase()}`;
        return await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async closeAllPositions() {
        const url = `${ALPACA_BASE_URL}/v2/positions`;
        return await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async createOrder(params) {
        const url = `${ALPACA_BASE_URL}/v2/orders`;
        return await this.fetchWithRetry(url, {
          method: "POST",
          body: JSON.stringify(params)
        });
      }
      async createBracketOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: params.type || "market",
          time_in_force: "day",
          // MUST be "day" for bracket orders per Alpaca API requirements
          order_class: "bracket",
          take_profit: {
            limit_price: params.take_profit_price
          },
          stop_loss: {
            stop_price: params.stop_loss_price,
            limit_price: params.stop_loss_limit_price
          }
        };
        if (params.limit_price) {
          orderParams.limit_price = params.limit_price;
        }
        log.info("Alpaca", `Creating bracket order for ${params.symbol}: TP=${params.take_profit_price}, SL=${params.stop_loss_price}, TIF=day`);
        try {
          const order = await this.createOrder(orderParams);
          log.info("Alpaca", `Bracket order created successfully for ${params.symbol}`, { orderId: order.id, status: order.status });
          return order;
        } catch (error) {
          log.error("Alpaca", `Bracket order FAILED for ${params.symbol}: ${error.message}`);
          throw error;
        }
      }
      async createTrailingStopOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: "trailing_stop",
          time_in_force: params.time_in_force || "gtc"
        };
        if (params.trail_percent !== void 0) {
          orderParams.trail_percent = params.trail_percent.toString();
        } else if (params.trail_price !== void 0) {
          orderParams.trail_price = params.trail_price.toString();
        } else {
          orderParams.trail_percent = "2";
        }
        log.debug("Alpaca", `Creating trailing stop order for ${params.symbol}: trail=${params.trail_percent || params.trail_price}`);
        return this.createOrder(orderParams);
      }
      async createStopLossOrder(symbol, qty, stopPrice, limitPrice) {
        const orderParams = {
          symbol,
          qty,
          side: "sell",
          type: limitPrice ? "stop_limit" : "stop",
          time_in_force: "gtc",
          stop_price: stopPrice
        };
        if (limitPrice) {
          orderParams.limit_price = limitPrice;
        }
        log.debug("Alpaca", `Creating stop loss order for ${symbol} at $${stopPrice}`);
        return this.createOrder(orderParams);
      }
      async createTakeProfitOrder(symbol, qty, limitPrice) {
        const orderParams = {
          symbol,
          qty,
          side: "sell",
          type: "limit",
          time_in_force: "gtc",
          limit_price: limitPrice
        };
        log.debug("Alpaca", `Creating take profit order for ${symbol} at $${limitPrice}`);
        return this.createOrder(orderParams);
      }
      /**
       * Create an OCO (One-Cancels-Other) order
       * Two orders where filling one automatically cancels the other
       * Use case: Set both take-profit and stop-loss on an existing position
       *
       * @param symbol The trading symbol
       * @param qty Quantity to trade
       * @param takeProfitPrice Limit price for take-profit leg
       * @param stopLossPrice Stop price for stop-loss leg
       * @param stopLossLimitPrice Optional limit price for stop-loss (creates stop-limit)
       */
      async createOCOOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.side,
          type: "limit",
          time_in_force: params.timeInForce || "day",
          // OCO orders should typically be day orders
          limit_price: params.takeProfitPrice,
          order_class: "oco",
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        log.info("Alpaca", `Creating OCO order for ${params.symbol}: TP=$${params.takeProfitPrice}, SL=$${params.stopLossPrice}`);
        try {
          const order = await this.createOrder(orderParams);
          log.info("Alpaca", `OCO order created successfully for ${params.symbol}`, { orderId: order.id, status: order.status });
          return order;
        } catch (error) {
          log.error("Alpaca", `OCO order FAILED for ${params.symbol}: ${error.message}`);
          throw error;
        }
      }
      /**
       * Create an OTO (One-Triggers-Other) order
       * First order triggers the second order upon fill
       * Use case: Buy then immediately set a protective stop-loss
       *
       * @param primaryOrder The primary order that triggers the secondary
       * @param secondaryOrder The order triggered when primary fills
       */
      async createOTOOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.primarySide,
          type: params.primaryType,
          time_in_force: params.timeInForce || "day",
          order_class: "oto",
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        if (params.primaryLimitPrice && params.primaryType === "limit") {
          orderParams.limit_price = params.primaryLimitPrice;
        }
        log.info("Alpaca", `Creating OTO order for ${params.symbol}: Primary=${params.primaryType}, SL=$${params.stopLossPrice}`);
        try {
          const order = await this.createOrder(orderParams);
          log.info("Alpaca", `OTO order created successfully for ${params.symbol}`, { orderId: order.id, status: order.status });
          return order;
        } catch (error) {
          log.error("Alpaca", `OTO order FAILED for ${params.symbol}: ${error.message}`);
          throw error;
        }
      }
      /**
       * Create an OTO order with take-profit
       * Primary order triggers both stop-loss and take-profit upon fill
       *
       * @param params Order parameters including both TP and SL legs
       */
      async createOTOWithTPOrder(params) {
        const orderParams = {
          symbol: params.symbol,
          qty: params.qty,
          side: params.primarySide,
          type: params.primaryType,
          time_in_force: params.timeInForce || "day",
          order_class: "oto",
          take_profit: {
            limit_price: params.takeProfitPrice
          },
          stop_loss: {
            stop_price: params.stopLossPrice,
            limit_price: params.stopLossLimitPrice
          }
        };
        if (params.primaryLimitPrice && params.primaryType === "limit") {
          orderParams.limit_price = params.primaryLimitPrice;
        }
        log.info("Alpaca", `Creating OTO+TP order for ${params.symbol}: Primary=${params.primaryType}, TP=$${params.takeProfitPrice}, SL=$${params.stopLossPrice}`);
        try {
          const order = await this.createOrder(orderParams);
          log.info("Alpaca", `OTO+TP order created successfully for ${params.symbol}`, { orderId: order.id, status: order.status });
          return order;
        } catch (error) {
          log.error("Alpaca", `OTO+TP order FAILED for ${params.symbol}: ${error.message}`);
          throw error;
        }
      }
      async getOrders(status = "all", limit4 = 50) {
        const cacheKey = `orders_${status}_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/orders?status=${status}&limit=${limit4}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getOrder(orderId) {
        const url = `${ALPACA_BASE_URL}/v2/orders/${orderId}`;
        return await this.fetchWithRetry(url);
      }
      async cancelOrder(orderId) {
        const url = `${ALPACA_BASE_URL}/v2/orders/${orderId}`;
        await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async cancelAllOrders() {
        const url = `${ALPACA_BASE_URL}/v2/orders`;
        await this.fetchWithRetry(url, { method: "DELETE" });
      }
      async getAssets(status = "active", assetClass = "us_equity") {
        const cacheKey = `assets_${status}_${assetClass}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/assets?status=${status}&asset_class=${assetClass}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getAsset(symbol) {
        const cacheKey = `asset_${symbol}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/assets/${symbol.toUpperCase()}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getBars(symbols, timeframe = "1Day", start, end, limit4 = 100, pageToken) {
        const symbolsParam = symbols.join(",");
        if (!pageToken) {
          const cacheKey = `bars_${symbolsParam}_${timeframe}_${start}_${end}`;
          const cached = this.getCached(cacheKey);
          if (cached) return cached;
        }
        let url = `${ALPACA_DATA_URL}/v2/stocks/bars?symbols=${symbolsParam}&timeframe=${timeframe}&limit=${limit4}&feed=iex`;
        if (start) url += `&start=${start}`;
        if (end) url += `&end=${end}`;
        if (pageToken) url += `&page_token=${pageToken}`;
        const data = await this.fetchWithRetry(url);
        if (!pageToken) {
          const cacheKey = `bars_${symbolsParam}_${timeframe}_${start}_${end}`;
          this.setCache(cacheKey, data);
        }
        return data;
      }
      async getSnapshots(symbols) {
        const symbolsParam = symbols.join(",");
        const cacheKey = `snapshots_${symbolsParam}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_DATA_URL}/v2/stocks/snapshots?symbols=${symbolsParam}&feed=iex`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getCryptoSnapshots(symbols) {
        const symbolsParam = symbols.join(",");
        const cacheKey = `crypto_snapshots_${symbolsParam}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_DATA_URL}/v1beta3/crypto/us/snapshots?symbols=${symbolsParam}`;
        const response = await this.fetchWithRetry(url);
        const result = {};
        for (const [symbol, snapshot] of Object.entries(response.snapshots || {})) {
          result[symbol] = {
            latestTrade: {
              t: snapshot.latestTrade?.t || "",
              x: "CBSE",
              p: snapshot.latestTrade?.p || 0,
              s: snapshot.latestTrade?.s || 0,
              c: [],
              i: 0,
              z: ""
            },
            latestQuote: snapshot.latestQuote || { ap: 0, as: 0, bp: 0, bs: 0, t: "" },
            minuteBar: snapshot.minuteBar || { t: "", o: 0, h: 0, l: 0, c: 0, v: 0, n: 0, vw: 0 },
            dailyBar: snapshot.dailyBar || { t: "", o: 0, h: 0, l: 0, c: 0, v: 0, n: 0, vw: 0 },
            prevDailyBar: snapshot.prevDailyBar || { t: "", o: 0, h: 0, l: 0, c: 0, v: 0, n: 0, vw: 0 }
          };
        }
        this.setCache(cacheKey, result);
        return result;
      }
      async searchAssets(query) {
        const assets = await this.getAssets("active", "us_equity");
        const lowerQuery = query.toLowerCase();
        return assets.filter(
          (asset) => asset.symbol.toLowerCase().includes(lowerQuery) || asset.name.toLowerCase().includes(lowerQuery)
        );
      }
      getConnectionStatus() {
        const credentials2 = this.getCredentials();
        return {
          connected: !!credentials2,
          hasCredentials: !!credentials2,
          cacheSize: this.cache.size
        };
      }
      clearCache() {
        this.cache.clear();
      }
      async getClock() {
        const cacheKey = "clock";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/clock`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getMarketStatus() {
        const clock = await this.getClock();
        const now = new Date(clock.timestamp);
        const nextOpen = new Date(clock.next_open);
        const nextClose = new Date(clock.next_close);
        const etHour = parseInt(
          now.toLocaleString("en-US", { timeZone: "America/New_York", hour: "2-digit", hour12: false })
        );
        const etMinute = parseInt(
          now.toLocaleString("en-US", { timeZone: "America/New_York", minute: "2-digit" })
        );
        const etTime = etHour * 60 + etMinute;
        const preMarketStart = 4 * 60;
        const marketOpen = 9 * 60 + 30;
        const marketClose = 16 * 60;
        const afterHoursEnd = 20 * 60;
        const isWeekday = now.getDay() >= 1 && now.getDay() <= 5;
        const isPreMarket = isWeekday && etTime >= preMarketStart && etTime < marketOpen;
        const isRegularHours = clock.is_open;
        const isAfterHours = isWeekday && etTime >= marketClose && etTime < afterHoursEnd;
        const isExtendedHours = isPreMarket || isAfterHours;
        let session;
        if (isRegularHours) {
          session = "regular";
        } else if (isPreMarket) {
          session = "pre-market";
        } else if (isAfterHours) {
          session = "after-hours";
        } else {
          session = "closed";
        }
        return {
          isOpen: clock.is_open,
          isPreMarket,
          isAfterHours,
          isExtendedHours,
          currentTime: clock.timestamp,
          nextOpen: clock.next_open,
          nextClose: clock.next_close,
          session
        };
      }
      async healthCheck() {
        const result = {
          overall: "unhealthy",
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          endpoints: {
            account: { status: "unknown", latencyMs: 0 },
            positions: { status: "unknown", latencyMs: 0 },
            orders: { status: "unknown", latencyMs: 0 },
            marketData: { status: "unknown", latencyMs: 0 }
          },
          account: null
        };
        const credentials2 = this.getCredentials();
        if (!credentials2) {
          result.endpoints.account.status = "error";
          result.endpoints.account.error = "API credentials not configured";
          return result;
        }
        const checkEndpoint = async (name, fn) => {
          const start = Date.now();
          try {
            await fn();
            result.endpoints[name].status = "healthy";
            result.endpoints[name].latencyMs = Date.now() - start;
          } catch (error) {
            result.endpoints[name].status = "error";
            result.endpoints[name].latencyMs = Date.now() - start;
            result.endpoints[name].error = error instanceof Error ? error.message : "Unknown error";
          }
        };
        await checkEndpoint("account", async () => {
          const account = await this.getAccount();
          result.account = {
            id: account.id,
            status: account.status,
            currency: account.currency,
            buyingPower: account.buying_power,
            portfolioValue: account.portfolio_value,
            cash: account.cash,
            equity: account.equity,
            tradingBlocked: account.trading_blocked
          };
        });
        await Promise.all([
          checkEndpoint("positions", () => this.getPositions()),
          checkEndpoint("orders", () => this.getOrders("open", 1)),
          checkEndpoint("marketData", () => this.getSnapshots(["AAPL"]))
        ]);
        const healthyCount = Object.values(result.endpoints).filter(
          (e) => e.status === "healthy"
        ).length;
        const total = Object.keys(result.endpoints).length;
        if (healthyCount === total) {
          result.overall = "healthy";
        } else if (healthyCount > 0) {
          result.overall = "degraded";
        } else {
          result.overall = "unhealthy";
        }
        return result;
      }
      async getPortfolioHistory(period = "1M", timeframe = "1D") {
        const cacheKey = `portfolio_history_${period}_${timeframe}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const url = `${ALPACA_BASE_URL}/v2/account/portfolio/history?period=${period}&timeframe=${timeframe}`;
        const data = await this.fetchWithRetry(url);
        this.setCache(cacheKey, data);
        return data;
      }
      async getTopStocks(limit4 = 25) {
        const cacheKey = `top_stocks_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const assets = await this.getAssets("active", "us_equity");
        const tradableAssets = assets.filter((a) => a.tradable && a.fractionable).slice(0, 100);
        const symbols = tradableAssets.slice(0, 50).map((a) => a.symbol);
        let snapshots = {};
        try {
          snapshots = await this.getSnapshots(symbols);
        } catch {
          snapshots = {};
        }
        const result = tradableAssets.map((asset) => {
          const snapshot = snapshots[asset.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: asset.symbol,
            name: asset.name,
            price,
            change,
            volume,
            tradable: asset.tradable,
            fractionable: asset.fractionable,
            assetClass: "us_equity"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume).slice(0, limit4);
        this.setCache(cacheKey, result);
        return result;
      }
      async getTopCrypto(limit4 = 25) {
        const cacheKey = `top_crypto_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const assets = await this.getAssets("active", "crypto");
        const tradableAssets = assets.filter((a) => a.tradable).slice(0, limit4 * 2);
        const symbols = tradableAssets.map((a) => a.symbol);
        let cryptoSnapshots = { snapshots: {} };
        try {
          const url = `${ALPACA_DATA_URL}/v1beta3/crypto/us/snapshots?symbols=${symbols.join(",")}`;
          cryptoSnapshots = await this.fetchWithRetry(url);
        } catch {
          cryptoSnapshots = { snapshots: {} };
        }
        const result = tradableAssets.map((asset) => {
          const snapshot = cryptoSnapshots.snapshots?.[asset.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: asset.symbol,
            name: asset.name,
            price,
            change,
            volume,
            tradable: asset.tradable,
            fractionable: asset.fractionable,
            assetClass: "crypto"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume).slice(0, limit4);
        this.setCache(cacheKey, result);
        return result;
      }
      async getTopETFs(limit4 = 25) {
        const cacheKey = `top_etfs_${limit4}`;
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const popularETFs = [
          { symbol: "SPY", name: "S&P 500 ETF" },
          { symbol: "QQQ", name: "Nasdaq 100 ETF" },
          { symbol: "IWM", name: "Russell 2000 ETF" },
          { symbol: "DIA", name: "Dow Jones ETF" },
          { symbol: "VTI", name: "Total Stock Market" },
          { symbol: "VOO", name: "Vanguard S&P 500" },
          { symbol: "VEA", name: "Developed Markets" },
          { symbol: "VWO", name: "Emerging Markets" },
          { symbol: "EFA", name: "EAFE Index ETF" },
          { symbol: "EEM", name: "Emerging Mkts ETF" },
          { symbol: "GLD", name: "Gold Trust" },
          { symbol: "SLV", name: "Silver Trust" },
          { symbol: "USO", name: "US Oil Fund" },
          { symbol: "TLT", name: "20+ Year Treasury" },
          { symbol: "IEF", name: "7-10 Year Treasury" },
          { symbol: "LQD", name: "Investment Grade Corp" },
          { symbol: "HYG", name: "High Yield Corporate" },
          { symbol: "XLF", name: "Financial Sector" },
          { symbol: "XLK", name: "Technology Sector" },
          { symbol: "XLE", name: "Energy Sector" },
          { symbol: "XLV", name: "Healthcare Sector" },
          { symbol: "XLI", name: "Industrial Sector" },
          { symbol: "XLY", name: "Consumer Discretionary" },
          { symbol: "XLP", name: "Consumer Staples" },
          { symbol: "XLU", name: "Utilities Sector" }
        ];
        const etfList = popularETFs.slice(0, limit4);
        const symbols = etfList.map((e) => e.symbol);
        let snapshots = {};
        try {
          snapshots = await this.getSnapshots(symbols);
        } catch {
          snapshots = {};
        }
        const result = etfList.map((etf) => {
          const snapshot = snapshots[etf.symbol];
          const price = snapshot?.dailyBar?.c ?? snapshot?.latestTrade?.p ?? 0;
          const prevClose = snapshot?.prevDailyBar?.c ?? price;
          const change = price && prevClose ? (price - prevClose) / prevClose * 100 : 0;
          const volume = snapshot?.dailyBar?.v ?? 0;
          return {
            symbol: etf.symbol,
            name: etf.name,
            price,
            change,
            volume,
            tradable: true,
            fractionable: true,
            assetClass: "us_equity"
          };
        }).filter((a) => a.price > 0).sort((a, b) => b.volume - a.volume);
        this.setCache(cacheKey, result);
        return result;
      }
      validateOrder(params) {
        const errors = [];
        const warnings = [];
        const adjustments = [];
        if (!params.symbol || params.symbol.trim() === "") {
          errors.push("Symbol is required");
        }
        if (!params.qty && !params.notional) {
          errors.push("Either qty or notional is required");
        }
        if (params.qty && params.notional) {
          warnings.push("Both qty and notional provided - qty takes precedence");
        }
        if (params.qty) {
          const qty = parseFloat(params.qty);
          if (isNaN(qty) || qty <= 0) {
            errors.push("Quantity must be a positive number");
          }
        }
        if (params.notional) {
          const notional = parseFloat(params.notional);
          if (isNaN(notional) || notional <= 0) {
            errors.push("Notional value must be positive");
          }
          if (notional < 1) {
            errors.push("Minimum order value is $1");
          }
        }
        if (params.type === "limit" && !params.limit_price) {
          errors.push("Limit price required for limit orders");
        }
        if (params.type === "stop" && !params.stop_price) {
          errors.push("Stop price required for stop orders");
        }
        if (params.type === "stop_limit" && (!params.limit_price || !params.stop_price)) {
          errors.push("Both limit and stop prices required for stop-limit orders");
        }
        const normalizedParams = { ...params };
        normalizedParams.symbol = params.symbol?.toUpperCase().trim();
        if (params.type === "market" && params.time_in_force === "gtc") {
          adjustments.push({
            field: "time_in_force",
            from: "gtc",
            to: "day",
            reason: "Market orders cannot be GTC"
          });
          normalizedParams.time_in_force = "day";
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings,
          adjustments,
          normalizedParams
        };
      }
    };
    alpaca = new AlpacaConnector();
  }
});

// server/connectors/newsapi.ts
var NEWSAPI_BASE_URL, NewsAPIConnector, newsapi;
var init_newsapi = __esm({
  "server/connectors/newsapi.ts"() {
    "use strict";
    init_logger();
    init_connectorClient();
    init_callExternal();
    NEWSAPI_BASE_URL = "https://newsapi.org/v2";
    NewsAPIConnector = class {
      cache = /* @__PURE__ */ new Map();
      cacheDuration = 60 * 60 * 1e3;
      // 60 minutes fresh cache (L1 hot cache)
      staleCacheDuration = 24 * 60 * 60 * 1e3;
      // 24 hours stale data
      getApiKey() {
        return process.env.NEWS_API_KEY;
      }
      getCached(key, allowStale = false) {
        const entry = this.cache.get(key);
        if (!entry) return null;
        const age = Date.now() - entry.timestamp;
        const maxAge = allowStale ? this.staleCacheDuration : this.cacheDuration;
        if (age < maxAge) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async fetchWithRetry(url, endpoint, cacheKey) {
        const apiKey = this.getApiKey();
        if (!apiKey) {
          throw new Error("NEWS_API_KEY is not configured");
        }
        const staleData = this.getCached(cacheKey, true);
        const separator = url.includes("?") ? "&" : "?";
        const fullUrl = `${url}${separator}apiKey=${apiKey}`;
        try {
          const result = await connectorFetch(fullUrl, {
            provider: "newsapi",
            endpoint,
            cacheKey: buildCacheKey("newsapi", cacheKey),
            headers: { Accept: "application/json" }
          });
          log.debug("NewsAPI", `Fetched ${endpoint}`, {
            cacheStatus: result.provenance.cacheStatus,
            budgetRemaining: result.provenance.budgetRemaining
          });
          return result.data;
        } catch (error) {
          if (staleData) {
            log.debug("NewsAPI", `Returning L1 stale data for ${cacheKey} after error`);
            return staleData;
          }
          throw error;
        }
      }
      async getTopHeadlines(category = "business", country = "us", pageSize = 20) {
        const cacheKey = `headlines_${category}_${country}_${pageSize}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/top-headlines?category=${category}&country=${country}&pageSize=${pageSize}`;
          const response = await this.fetchWithRetry(url, "/top-headlines", cacheKey);
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.articles);
          return response.articles;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug("NewsAPI", "getTopHeadlines returning stale data due to error");
            return stale;
          }
          throw error;
        }
      }
      async searchNews(query, sortBy = "publishedAt", pageSize = 20, language = "en") {
        const cacheKey = `search_${query}_${sortBy}_${pageSize}_${language}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/everything?q=${encodeURIComponent(query)}&sortBy=${sortBy}&pageSize=${pageSize}&language=${language}`;
          const response = await this.fetchWithRetry(url, "/everything", cacheKey);
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.articles);
          return response.articles;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug("NewsAPI", "searchNews returning stale data due to error");
            return stale;
          }
          throw error;
        }
      }
      async getMarketNews(pageSize = 20) {
        return this.searchNews(
          "stock market OR cryptocurrency OR trading OR investing OR finance",
          "publishedAt",
          pageSize
        );
      }
      async getCryptoNews(pageSize = 20) {
        return this.searchNews(
          "bitcoin OR ethereum OR cryptocurrency OR crypto trading",
          "publishedAt",
          pageSize
        );
      }
      async getStockNews(symbol, pageSize = 10) {
        return this.searchNews(symbol, "relevancy", pageSize);
      }
      async getSources(category = "business", language = "en") {
        const cacheKey = `sources_${category}_${language}`;
        const cached = this.getCached(cacheKey);
        if (cached) {
          log.debug("NewsAPI", `L1 cache hit for ${cacheKey}`);
          return cached;
        }
        try {
          const url = `${NEWSAPI_BASE_URL}/top-headlines/sources?category=${category}&language=${language}`;
          const response = await this.fetchWithRetry(url, "/sources", cacheKey);
          if (response.status !== "ok") {
            throw new Error("NewsAPI returned error status");
          }
          this.setCache(cacheKey, response.sources);
          return response.sources;
        } catch (error) {
          const stale = this.getCached(cacheKey, true);
          if (stale) {
            log.debug("NewsAPI", "getSources returning stale data due to error");
            return stale;
          }
          throw error;
        }
      }
      async getConnectionStatus() {
        const hasApiKey = !!this.getApiKey();
        const providerStatus = await getProviderStatus("newsapi");
        return {
          connected: hasApiKey && providerStatus.enabled && providerStatus.budgetStatus.allowed,
          hasApiKey,
          cacheSize: this.cache.size,
          budgetStatus: providerStatus.budgetStatus
        };
      }
      clearCache() {
        this.cache.clear();
      }
    };
    newsapi = new NewsAPIConnector();
  }
});

// server/connectors/valyu.ts
var VALYU_BASE_URL, DEFAULT_MAX_RESULTS, DEFAULT_RELEVANCE_THRESHOLD, ValyuConnector, valyu;
var init_valyu = __esm({
  "server/connectors/valyu.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    init_callExternal();
    init_connectorClient();
    init_apiBudget();
    VALYU_BASE_URL = "https://api.valyu.ai/v1";
    DEFAULT_MAX_RESULTS = 5;
    DEFAULT_RELEVANCE_THRESHOLD = 0.7;
    ValyuConnector = class {
      searchCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      earningsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      ratiosCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      filingsCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      balanceSheetCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      incomeStatementCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      cashFlowCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      dividendCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        staleDuration: 24 * 60 * 60 * 1e3
      });
      insiderCache = new ApiCache({
        freshDuration: 30 * 60 * 1e3,
        staleDuration: 4 * 60 * 60 * 1e3
      });
      marketMoversCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      getApiKey() {
        return process.env.VALYU_API_KEY;
      }
      isAvailable() {
        return !!this.getApiKey();
      }
      async search(query, options = {}) {
        const apiKey = this.getApiKey();
        if (!apiKey) {
          throw new Error("VALYU_API_KEY is not configured");
        }
        const maxResults = options.maxResults ?? DEFAULT_MAX_RESULTS;
        const maxPrice = options.maxPrice ?? 0.1;
        const relevanceThreshold = options.relevanceThreshold ?? DEFAULT_RELEVANCE_THRESHOLD;
        const cacheKey = buildCacheKey(
          "valyu",
          "search",
          query,
          maxResults.toString(),
          maxPrice.toString(),
          options.sources?.join(",") || "all"
        );
        const l1Cached = this.searchCache.get(cacheKey);
        if (l1Cached?.isFresh) {
          log.debug("Valyu", "L1 cache hit", { query: query.substring(0, 30) });
          return l1Cached.data;
        }
        const body = {
          query,
          max_num_results: maxResults,
          max_price: maxPrice,
          relevance_threshold: relevanceThreshold
        };
        if (options.sources && options.sources.length > 0) {
          body.included_sources = options.sources;
        }
        const fetcher = async () => {
          const response = await fetch(`${VALYU_BASE_URL}/deepsearch`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": apiKey
            },
            body: JSON.stringify(body)
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            throw new Error(`Valyu API error: ${response.status} - ${errorText}`);
          }
          return response.json();
        };
        const result = await callExternal(fetcher, {
          provider: "valyu",
          endpoint: "deepsearch",
          cacheKey,
          budgetPolicy: {
            countAsMultiple: 1
          }
        });
        const retrievalCount = result.data.results?.length || 0;
        if (retrievalCount > 1 && result.provenance.cacheStatus === "miss") {
          for (let i = 1; i < retrievalCount; i++) {
            await recordUsage("valyu", { isCacheHit: false });
          }
        }
        this.searchCache.set(cacheKey, result.data);
        log.info("Valyu", "Search completed", {
          query: query.substring(0, 50),
          resultsCount: retrievalCount,
          cacheStatus: result.provenance.cacheStatus,
          cost: result.data.total_deduction_dollars
        });
        return result.data;
      }
      async getEarnings(symbol) {
        const cacheKey = buildCacheKey("valyu", "earnings", symbol);
        const cached = this.earningsCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} latest quarterly earnings report EPS revenue net income`,
          {
            sources: ["valyu/valyu-earnings-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const epsMatch = content.match(/EPS[:\s]*\$?([\d.]+)/i);
        if (epsMatch) data.eps = parseFloat(epsMatch[1]);
        const revenueMatch = content.match(/revenue[:\s]*\$?([\d.]+)\s*(billion|million)?/i);
        if (revenueMatch) {
          let revenue = parseFloat(revenueMatch[1]);
          if (revenueMatch[2]?.toLowerCase() === "billion") revenue *= 1e9;
          if (revenueMatch[2]?.toLowerCase() === "million") revenue *= 1e6;
          data.revenue = revenue;
        }
        this.earningsCache.set(cacheKey, data);
        return data;
      }
      async getFinancialRatios(symbol) {
        const cacheKey = buildCacheKey("valyu", "ratios", symbol);
        const cached = this.ratiosCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} P/E ratio ROE debt to equity revenue growth financial ratios`,
          {
            sources: ["valyu/valyu-financial-ratios-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const peMatch = content.match(/P\/E[:\s]*([\d.]+)/i);
        if (peMatch) data.peRatio = parseFloat(peMatch[1]);
        const roeMatch = content.match(/ROE[:\s]*([\d.]+)%?/i);
        if (roeMatch) data.roe = parseFloat(roeMatch[1]);
        const debtMatch = content.match(/debt.?to.?equity[:\s]*([\d.]+)/i);
        if (debtMatch) data.debtToEquity = parseFloat(debtMatch[1]);
        this.ratiosCache.set(cacheKey, data);
        return data;
      }
      async getSECFiling(symbol, filingType = "10-K") {
        const cacheKey = buildCacheKey("valyu", "filing", symbol, filingType);
        const cached = this.filingsCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} ${filingType} SEC filing annual report`,
          {
            sources: ["valyu/valyu-sec-filings-US"],
            maxResults: 3
          }
        );
        const result = response.results[0];
        const data = {
          symbol,
          filingType,
          content: result?.content || "",
          url: result?.url
        };
        this.filingsCache.set(cacheKey, data);
        return data;
      }
      async getCompanyFinancials(symbol) {
        const [earnings, ratios] = await Promise.all([
          this.getEarnings(symbol),
          this.getFinancialRatios(symbol)
        ]);
        return { earnings, ratios };
      }
      async searchFinancialData(query) {
        return this.search(query, {
          sources: [
            "valyu/valyu-earnings-US",
            "valyu/valyu-financial-ratios-US",
            "valyu/valyu-balance-sheet-US",
            "valyu/valyu-income-statement-US",
            "valyu/valyu-cash-flow-US"
          ],
          maxResults: 15
        });
      }
      async getBalanceSheet(symbol) {
        const cacheKey = buildCacheKey("valyu", "balance", symbol);
        const cached = this.balanceSheetCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} balance sheet total assets liabilities equity cash debt`,
          {
            sources: ["valyu/valyu-balance-sheet-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const assetsMatch = content.match(/total\s*assets[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (assetsMatch) {
          data.totalAssets = this.parseFinancialValue(assetsMatch[1], assetsMatch[2]);
        }
        const liabilitiesMatch = content.match(/total\s*liabilities[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (liabilitiesMatch) {
          data.totalLiabilities = this.parseFinancialValue(liabilitiesMatch[1], liabilitiesMatch[2]);
        }
        const equityMatch = content.match(/(?:total\s*)?(?:shareholders?[']?\s*)?equity[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (equityMatch) {
          data.totalEquity = this.parseFinancialValue(equityMatch[1], equityMatch[2]);
        }
        const cashMatch = content.match(/cash\s*(?:and\s*)?(?:equivalents)?[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (cashMatch) {
          data.cashAndEquivalents = this.parseFinancialValue(cashMatch[1], cashMatch[2]);
        }
        const debtMatch = content.match(/total\s*debt[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (debtMatch) {
          data.totalDebt = this.parseFinancialValue(debtMatch[1], debtMatch[2]);
        }
        this.balanceSheetCache.set(cacheKey, data);
        log.info("Valyu", "Balance sheet fetched", { symbol, hasData: !!content });
        return data;
      }
      async getIncomeStatement(symbol) {
        const cacheKey = buildCacheKey("valyu", "income", symbol);
        const cached = this.incomeStatementCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} income statement revenue gross profit operating income net income`,
          {
            sources: ["valyu/valyu-income-statement-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const revenueMatch = content.match(/(?:total\s*)?revenue[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (revenueMatch) {
          data.revenue = this.parseFinancialValue(revenueMatch[1], revenueMatch[2]);
        }
        const costMatch = content.match(/cost\s*of\s*(?:goods\s*sold|revenue)[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (costMatch) {
          data.costOfRevenue = this.parseFinancialValue(costMatch[1], costMatch[2]);
        }
        const grossMatch = content.match(/gross\s*profit[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (grossMatch) {
          data.grossProfit = this.parseFinancialValue(grossMatch[1], grossMatch[2]);
        }
        const opIncomeMatch = content.match(/operating\s*income[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (opIncomeMatch) {
          data.operatingIncome = this.parseFinancialValue(opIncomeMatch[1], opIncomeMatch[2]);
        }
        const netIncomeMatch = content.match(/net\s*income[:\s]*\$?([\d.,]+)\s*(billion|million|B|M)?/i);
        if (netIncomeMatch) {
          data.netIncome = this.parseFinancialValue(netIncomeMatch[1], netIncomeMatch[2]);
        }
        this.incomeStatementCache.set(cacheKey, data);
        log.info("Valyu", "Income statement fetched", { symbol, hasData: !!content });
        return data;
      }
      async getCashFlow(symbol) {
        const cacheKey = buildCacheKey("valyu", "cashflow", symbol);
        const cached = this.cashFlowCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} cash flow statement operating investing financing free cash flow`,
          {
            sources: ["valyu/valyu-cash-flow-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const opCashMatch = content.match(/(?:net\s*)?(?:cash\s*from\s*)?operating\s*(?:activities|cash\s*flow)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i);
        if (opCashMatch) {
          data.operatingCashFlow = this.parseFinancialValue(opCashMatch[1], opCashMatch[2]);
        }
        const invCashMatch = content.match(/(?:net\s*)?(?:cash\s*from\s*)?investing\s*(?:activities)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i);
        if (invCashMatch) {
          data.investingCashFlow = this.parseFinancialValue(invCashMatch[1], invCashMatch[2]);
        }
        const finCashMatch = content.match(/(?:net\s*)?(?:cash\s*from\s*)?financing\s*(?:activities)?[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i);
        if (finCashMatch) {
          data.financingCashFlow = this.parseFinancialValue(finCashMatch[1], finCashMatch[2]);
        }
        const freeCashMatch = content.match(/free\s*cash\s*flow[:\s]*\$?([-\d.,]+)\s*(billion|million|B|M)?/i);
        if (freeCashMatch) {
          data.freeCashFlow = this.parseFinancialValue(freeCashMatch[1], freeCashMatch[2]);
        }
        this.cashFlowCache.set(cacheKey, data);
        log.info("Valyu", "Cash flow fetched", { symbol, hasData: !!content });
        return data;
      }
      async getDividends(symbol) {
        const cacheKey = buildCacheKey("valyu", "dividend", symbol);
        const cached = this.dividendCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} dividend yield amount ex-dividend date payment frequency`,
          {
            sources: ["valyu/valyu-dividends-US"],
            maxResults: 5
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          rawData: content
        };
        const amountMatch = content.match(/dividend\s*(?:amount)?[:\s]*\$?([\d.,]+)/i);
        if (amountMatch) {
          data.dividendAmount = this.parseFinancialValue(amountMatch[1]);
        }
        const yieldMatch = content.match(/(?:dividend\s*)?yield[:\s]*([\d.,]+)%?/i);
        if (yieldMatch) {
          data.dividendYield = parseFloat(yieldMatch[1].replace(/,/g, ""));
        }
        const exDateMatch = content.match(/ex[- ]?dividend\s*date[:\s]*(\d{4}[-/]\d{2}[-/]\d{2}|\w+\s+\d+,?\s*\d{4})/i);
        if (exDateMatch) {
          data.exDividendDate = exDateMatch[1];
        }
        const payDateMatch = content.match(/payment\s*date[:\s]*(\d{4}[-/]\d{2}[-/]\d{2}|\w+\s+\d+,?\s*\d{4})/i);
        if (payDateMatch) {
          data.paymentDate = payDateMatch[1];
        }
        const freqMatch = content.match(/(?:dividend\s*)?(?:payment\s*)?frequency[:\s]*(quarterly|monthly|annual|semi-?annual)/i);
        if (freqMatch) {
          data.frequency = freqMatch[1].toLowerCase();
        }
        this.dividendCache.set(cacheKey, data);
        log.info("Valyu", "Dividend data fetched", { symbol, yield: data.dividendYield });
        return data;
      }
      async getInsiderTransactions(symbol) {
        const cacheKey = buildCacheKey("valyu", "insider", symbol);
        const cached = this.insiderCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          `${symbol} insider trading transactions buy sell shares officers directors SEC Form 4`,
          {
            sources: ["valyu/valyu-insider-US"],
            maxResults: 10
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          symbol,
          transactions: [],
          netInsiderSentiment: "neutral",
          rawData: content
        };
        let totalBuyValue = 0;
        let totalSellValue = 0;
        const transactionPatterns = [
          /(\w+[\w\s,]+?)\s*(?:,\s*)?(CEO|CFO|COO|CTO|Director|Officer|President|VP|Chairman)?\s*(?:bought|purchased|acquired)\s*([\d,]+)\s*shares?\s*(?:at|@)\s*\$?([\d.]+)/gi,
          /(\w+[\w\s,]+?)\s*(?:,\s*)?(CEO|CFO|COO|CTO|Director|Officer|President|VP|Chairman)?\s*(?:sold|disposed)\s*([\d,]+)\s*shares?\s*(?:at|@)\s*\$?([\d.]+)/gi
        ];
        for (const pattern of transactionPatterns) {
          const isBuy = pattern.source.includes("bought|purchased|acquired");
          let match;
          while ((match = pattern.exec(content)) !== null) {
            const shares = parseInt(match[3].replace(/,/g, ""), 10);
            const price = parseFloat(match[4]);
            const value = shares * price;
            if (isBuy) {
              totalBuyValue += value;
            } else {
              totalSellValue += value;
            }
            data.transactions.push({
              insiderName: match[1].trim(),
              title: match[2] || void 0,
              transactionType: isBuy ? "buy" : "sell",
              shares,
              price
            });
          }
        }
        data.totalBuyValue = totalBuyValue;
        data.totalSellValue = totalSellValue;
        if (totalBuyValue > totalSellValue * 1.5) {
          data.netInsiderSentiment = "bullish";
        } else if (totalSellValue > totalBuyValue * 1.5) {
          data.netInsiderSentiment = "bearish";
        }
        this.insiderCache.set(cacheKey, data);
        log.info("Valyu", "Insider transactions fetched", {
          symbol,
          transactionCount: data.transactions.length,
          sentiment: data.netInsiderSentiment
        });
        return data;
      }
      async getMarketMovers() {
        const cacheKey = buildCacheKey("valyu", "market_movers");
        const cached = this.marketMoversCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const response = await this.search(
          "today top stock gainers losers most active volume market movers",
          {
            sources: ["valyu/valyu-market-movers-US"],
            maxResults: 10
          }
        );
        const content = response.results.map((r) => r.content).join("\n");
        const data = {
          gainers: [],
          losers: [],
          mostActive: [],
          rawData: content
        };
        const gainerPattern = /([A-Z]{1,5})\s*(?:\+|up\s*)([\d.]+)%/gi;
        let match;
        while ((match = gainerPattern.exec(content)) !== null) {
          data.gainers.push({
            symbol: match[1],
            change: parseFloat(match[2])
          });
        }
        const loserPattern = /([A-Z]{1,5})\s*(?:-|down\s*)([\d.]+)%/gi;
        while ((match = loserPattern.exec(content)) !== null) {
          data.losers.push({
            symbol: match[1],
            change: -parseFloat(match[2])
          });
        }
        data.gainers = data.gainers.slice(0, 10);
        data.losers = data.losers.slice(0, 10);
        this.marketMoversCache.set(cacheKey, data);
        log.info("Valyu", "Market movers fetched", {
          gainersCount: data.gainers.length,
          losersCount: data.losers.length
        });
        return data;
      }
      async getComprehensiveAnalysis(symbol) {
        const [earnings, ratios, balanceSheet, incomeStatement, cashFlow, dividends, insiderActivity] = await Promise.all([
          this.getEarnings(symbol),
          this.getFinancialRatios(symbol),
          this.getBalanceSheet(symbol),
          this.getIncomeStatement(symbol),
          this.getCashFlow(symbol),
          this.getDividends(symbol),
          this.getInsiderTransactions(symbol)
        ]);
        return { earnings, ratios, balanceSheet, incomeStatement, cashFlow, dividends, insiderActivity };
      }
      parseFinancialValue(valueStr, unit) {
        let value = parseFloat(valueStr.replace(/,/g, ""));
        if (unit) {
          const unitLower = unit.toLowerCase();
          if (unitLower === "billion" || unitLower === "b") {
            value *= 1e9;
          } else if (unitLower === "million" || unitLower === "m") {
            value *= 1e6;
          }
        }
        return value;
      }
      getConnectionStatus() {
        return {
          connected: this.isAvailable(),
          hasApiKey: this.isAvailable(),
          cacheSize: this.searchCache.size() + this.earningsCache.size() + this.ratiosCache.size() + this.filingsCache.size()
        };
      }
      clearCache() {
        this.searchCache.clear();
        this.earningsCache.clear();
        this.ratiosCache.clear();
        this.filingsCache.clear();
        this.balanceSheetCache.clear();
        this.incomeStatementCache.clear();
        this.cashFlowCache.clear();
        this.dividendCache.clear();
        this.insiderCache.clear();
        this.marketMoversCache.clear();
      }
    };
    valyu = new ValyuConnector();
  }
});

// server/connectors/huggingface.ts
var HF_INFERENCE_URL, HuggingFaceConnector, huggingface;
var init_huggingface = __esm({
  "server/connectors/huggingface.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    HF_INFERENCE_URL = "https://api-inference.huggingface.co/models";
    HuggingFaceConnector = class {
      rawSentimentCache = new ApiCache({
        freshDuration: 30 * 60 * 1e3,
        staleDuration: 2 * 60 * 60 * 1e3
      });
      enrichmentCache = new ApiCache({
        freshDuration: 15 * 60 * 1e3,
        staleDuration: 60 * 60 * 1e3
      });
      getApiKey() {
        return process.env.HUGGINGFACE_API_KEY || process.env.HF_API_KEY;
      }
      isAvailable() {
        return !!this.getApiKey();
      }
      async callModel(modelId, inputs, l1CacheKey, l1Cache) {
        const apiKey = this.getApiKey();
        if (!apiKey) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug("HuggingFace", `No API key, serving stale L1 data for ${l1CacheKey}`);
            return stale;
          }
          throw new Error("HUGGINGFACE_API_KEY is not configured");
        }
        const l1Cached = l1Cache.get(l1CacheKey);
        if (l1Cached?.isFresh) {
          log.debug("HuggingFace", `L1 cache hit for ${l1CacheKey}`);
          return l1Cached.data;
        }
        const url = `${HF_INFERENCE_URL}/${modelId}`;
        const cacheKey = buildCacheKey("huggingface", modelId, l1CacheKey);
        try {
          const result = await connectorFetch(url, {
            provider: "huggingface",
            endpoint: `model/${modelId}`,
            cacheKey,
            method: "POST",
            body: { inputs },
            headers: {
              Authorization: `Bearer ${apiKey}`
            }
          });
          l1Cache.set(l1CacheKey, result.data);
          return result.data;
        } catch (error) {
          const stale = l1Cache.getStale(l1CacheKey);
          if (stale) {
            log.debug("HuggingFace", `Error fetching, serving stale L1 data for ${l1CacheKey}`);
            return stale;
          }
          throw error;
        }
      }
      async analyzeSentiment(text3, model = "finbert") {
        const modelIds = {
          finbert: "ProsusAI/finbert",
          financialbert: "ahmedrachid/FinancialBERT-Sentiment-Analysis",
          deberta: "mrm8488/deberta-v3-ft-financial-news-sentiment-analysis"
        };
        const modelId = modelIds[model];
        const l1CacheKey = `sentiment_${model}_${text3.substring(0, 50)}`;
        const result = await this.callModel(
          modelId,
          text3,
          l1CacheKey,
          this.rawSentimentCache
        );
        if (!result || !result[0]) {
          return [{ label: "neutral", score: 0.5 }];
        }
        return result[0].map((r) => ({
          label: this.normalizeSentimentLabel(r.label),
          score: r.score
        }));
      }
      normalizeSentimentLabel(label) {
        const lower = label.toLowerCase();
        if (lower.includes("positive") || lower === "pos" || lower === "bullish") {
          return "positive";
        }
        if (lower.includes("negative") || lower === "neg" || lower === "bearish") {
          return "negative";
        }
        return "neutral";
      }
      async analyzeNewsHeadlines(headlines) {
        const results = [];
        for (const headline of headlines.slice(0, 10)) {
          try {
            const sentiment = await this.analyzeSentiment(headline);
            const topSentiment = sentiment.reduce(
              (a, b) => a.score > b.score ? a : b
            );
            results.push({
              headline,
              sentiment: topSentiment
            });
          } catch (error) {
            log.warn("HuggingFace", `Failed to analyze headline: ${headline.substring(0, 30)}...`);
            results.push({
              headline,
              sentiment: { label: "neutral", score: 0.5 }
            });
          }
        }
        return results;
      }
      async generateEnrichmentSignal(symbol, newsHeadlines, priceChange) {
        const l1CacheKey = `enrichment_${symbol}_${Date.now() % (15 * 60 * 1e3)}`;
        const cached = this.enrichmentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const sentimentResults = await this.analyzeNewsHeadlines(newsHeadlines);
        let positiveCount = 0;
        let negativeCount = 0;
        let totalScore = 0;
        let totalConfidence = 0;
        for (const result of sentimentResults) {
          if (result.sentiment.label === "positive") {
            positiveCount++;
            totalScore += result.sentiment.score;
          } else if (result.sentiment.label === "negative") {
            negativeCount++;
            totalScore -= result.sentiment.score;
          }
          totalConfidence += result.sentiment.score;
        }
        const netSentiment = sentimentResults.length > 0 ? totalScore / sentimentResults.length : 0;
        const avgConfidence = sentimentResults.length > 0 ? totalConfidence / sentimentResults.length : 0.5;
        let overallLabel = "neutral";
        if (netSentiment > 0.2) overallLabel = "positive";
        else if (netSentiment < -0.2) overallLabel = "negative";
        let trendStrength;
        if (priceChange !== void 0) {
          const priceDirection = priceChange > 0 ? 1 : priceChange < 0 ? -1 : 0;
          const sentimentDirection = netSentiment > 0 ? 1 : netSentiment < 0 ? -1 : 0;
          if (priceDirection === sentimentDirection) {
            trendStrength = Math.abs(netSentiment) * avgConfidence;
          } else {
            trendStrength = -Math.abs(netSentiment) * avgConfidence;
          }
        }
        const signal = {
          symbol,
          sentimentScore: netSentiment,
          sentimentLabel: overallLabel,
          confidence: avgConfidence,
          trendStrength,
          model: "finbert",
          timestamp: /* @__PURE__ */ new Date()
        };
        this.enrichmentCache.set(l1CacheKey, signal);
        log.info("HuggingFace", "Generated enrichment signal", {
          symbol,
          sentimentLabel: overallLabel,
          sentimentScore: netSentiment.toFixed(3),
          confidence: avgConfidence.toFixed(3),
          headlinesAnalyzed: sentimentResults.length
        });
        return signal;
      }
      async batchAnalyzeSymbols(symbolsWithNews) {
        const results = /* @__PURE__ */ new Map();
        for (const [symbol, headlines] of symbolsWithNews) {
          try {
            const signal = await this.generateEnrichmentSignal(symbol, headlines);
            results.set(symbol, signal);
          } catch (error) {
            log.warn("HuggingFace", `Failed to analyze ${symbol}: ${String(error)}`);
          }
        }
        return results;
      }
      getConnectionStatus() {
        return {
          connected: this.isAvailable(),
          hasApiKey: this.isAvailable(),
          cacheSize: this.rawSentimentCache.size() + this.enrichmentCache.size()
        };
      }
      clearCache() {
        this.rawSentimentCache.clear();
        this.enrichmentCache.clear();
      }
    };
    huggingface = new HuggingFaceConnector();
  }
});

// server/connectors/gdelt.ts
var GDELT_DOC_API, GdeltConnector, gdelt;
var init_gdelt = __esm({
  "server/connectors/gdelt.ts"() {
    "use strict";
    init_api_cache();
    init_connectorClient();
    init_logger();
    GDELT_DOC_API = "https://api.gdeltproject.org/api/v2/doc/doc";
    GdeltConnector = class {
      articleCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      volumeCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      toneCache = new ApiCache({
        freshDuration: 5 * 60 * 1e3,
        staleDuration: 15 * 60 * 1e3
      });
      sentimentCache = new ApiCache({
        freshDuration: 10 * 60 * 1e3,
        staleDuration: 30 * 60 * 1e3
      });
      isAvailable() {
        return true;
      }
      buildUrl(query, options = {}) {
        const params = new URLSearchParams({
          query,
          mode: options.mode || "ArtList",
          format: "json",
          timespan: options.timespan || "24hours",
          maxrecords: String(options.maxRecords || 75)
        });
        if (options.theme) {
          params.set("theme", options.theme);
        }
        if (options.sourceLang) {
          params.set("sourcelang", options.sourceLang);
        }
        if (options.sourceCountry) {
          params.set("sourcecountry", options.sourceCountry);
        }
        return `${GDELT_DOC_API}?${params.toString()}`;
      }
      async searchArticles(query, options = {}) {
        const l1CacheKey = `articles_${query}_${JSON.stringify(options)}`;
        const cached = this.articleCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { ...options, mode: "ArtList" });
        const cacheKey = buildCacheKey("gdelt", "articles", query, options.timespan || "24hours");
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "searchArticles",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const result = {
            articles: (data.articles || []).map((a) => ({
              url: a.url || "",
              title: a.title || "",
              domain: a.domain || "",
              language: a.language || "",
              seenDate: a.seendate || "",
              socialImage: a.socialimage,
              tone: a.tone ? parseFloat(String(a.tone)) : void 0
            })),
            totalResults: data.articles?.length || 0
          };
          this.articleCache.set(l1CacheKey, result);
          log.info("GDELT", "Articles fetched", { query, count: result.totalResults });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch articles", { query, error: String(error) });
          const stale = this.articleCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { articles: [], totalResults: 0 };
        }
      }
      async getVolumeTimeline(query, timespan = "24hours") {
        const l1CacheKey = `volume_${query}_${timespan}`;
        const cached = this.volumeCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { mode: "TimelineVol", timespan });
        const cacheKey = buildCacheKey("gdelt", "volume", query, timespan);
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "getVolumeTimeline",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const result = {
            timeline: (data.timeline || []).map((t) => ({
              date: t.date || "",
              value: parseFloat(String(t.value || 0))
            })),
            query
          };
          this.volumeCache.set(l1CacheKey, result);
          log.info("GDELT", "Volume timeline fetched", { query, points: result.timeline.length });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch volume", { query, error: String(error) });
          const stale = this.volumeCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { timeline: [], query };
        }
      }
      async getToneTimeline(query, timespan = "24hours") {
        const l1CacheKey = `tone_${query}_${timespan}`;
        const cached = this.toneCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const url = this.buildUrl(query, { mode: "TimelineTone", timespan });
        const cacheKey = buildCacheKey("gdelt", "tone", query, timespan);
        try {
          const response = await connectorFetch(url, {
            provider: "gdelt",
            endpoint: "getToneTimeline",
            cacheKey,
            headers: { Accept: "application/json" }
          });
          const data = response.data;
          const timeline = (data.timeline || []).map((t) => ({
            date: t.date || "",
            tone: parseFloat(String(t.tone || 0)),
            positiveScore: parseFloat(String(t.tonescore || 0)),
            negativeScore: parseFloat(String(t.negtonescore || 0))
          }));
          const avgTone = timeline.length > 0 ? timeline.reduce((sum, t) => sum + t.tone, 0) / timeline.length : 0;
          const result = {
            timeline,
            query,
            averageTone: avgTone
          };
          this.toneCache.set(l1CacheKey, result);
          log.info("GDELT", "Tone timeline fetched", { query, avgTone: avgTone.toFixed(2) });
          return result;
        } catch (error) {
          log.error("GDELT", "Failed to fetch tone", { query, error: String(error) });
          const stale = this.toneCache.getStale(l1CacheKey);
          if (stale) return stale;
          return { timeline: [], query, averageTone: 0 };
        }
      }
      async analyzeSymbolSentiment(symbol, companyName) {
        const query = companyName ? `${symbol} OR "${companyName}" stock` : `${symbol} stock`;
        const l1CacheKey = `sentiment_${symbol}`;
        const cached = this.sentimentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const [articles, volume24h, volume3h, tone] = await Promise.all([
          this.searchArticles(query, { timespan: "24hours", maxRecords: 50 }),
          this.getVolumeTimeline(query, "24hours"),
          this.getVolumeTimeline(query, "3hours"),
          this.getToneTimeline(query, "24hours")
        ]);
        const recentVolume = volume3h.timeline.length > 0 ? volume3h.timeline.slice(-3).reduce((sum, t) => sum + t.value, 0) / 3 : 0;
        const baselineVolume = volume24h.timeline.length > 0 ? volume24h.timeline.reduce((sum, t) => sum + t.value, 0) / volume24h.timeline.length : 0;
        const volumeSpike = baselineVolume > 0 && recentVolume > baselineVolume * 2;
        let sentiment = "neutral";
        if (tone.averageTone > 3) {
          sentiment = "bullish";
        } else if (tone.averageTone < -3) {
          sentiment = "bearish";
        }
        const result = {
          symbol,
          query,
          articleCount: articles.totalResults,
          averageTone: tone.averageTone,
          sentiment,
          volumeSpike,
          recentVolume,
          baselineVolume,
          topHeadlines: articles.articles.slice(0, 5).map((a) => a.title),
          timestamp: /* @__PURE__ */ new Date()
        };
        this.sentimentCache.set(l1CacheKey, result);
        log.info("GDELT", "Symbol sentiment analyzed", {
          symbol,
          sentiment,
          articleCount: articles.totalResults,
          volumeSpike
        });
        return result;
      }
      async detectBreakingNews(keywords, threshold = 2) {
        const alerts = [];
        for (const keyword of keywords) {
          const [volume3h, volume24h, articles] = await Promise.all([
            this.getVolumeTimeline(keyword, "3hours"),
            this.getVolumeTimeline(keyword, "24hours"),
            this.searchArticles(keyword, { timespan: "3hours", maxRecords: 10 })
          ]);
          const recentVolume = volume3h.timeline.length > 0 ? volume3h.timeline.slice(-2).reduce((sum, t) => sum + t.value, 0) / 2 : 0;
          const baselineVolume = volume24h.timeline.length > 6 ? volume24h.timeline.slice(0, -6).reduce((sum, t) => sum + t.value, 0) / (volume24h.timeline.length - 6) : 0;
          const volumeIncrease = baselineVolume > 0 ? recentVolume / baselineVolume : 0;
          const isBreaking = volumeIncrease >= threshold;
          alerts.push({
            query: keyword,
            isBreaking,
            volumeIncrease,
            toneShift: 0,
            relevantArticles: articles.articles.slice(0, 5)
          });
        }
        const breakingAlerts = alerts.filter((a) => a.isBreaking);
        if (breakingAlerts.length > 0) {
          log.warn("GDELT", "Breaking news detected", {
            keywords: breakingAlerts.map((a) => a.query)
          });
        }
        return alerts;
      }
      async getEconomicSentiment() {
        const [inflation, recession, interestRates] = await Promise.all([
          this.getToneTimeline("inflation economy", "24hours"),
          this.getToneTimeline("recession economic downturn", "24hours"),
          this.getToneTimeline("Federal Reserve interest rate", "24hours")
        ]);
        const avgTone = (inflation.averageTone + recession.averageTone + interestRates.averageTone) / 3;
        let overall = "neutral";
        if (avgTone > 2) {
          overall = "bullish";
        } else if (avgTone < -2) {
          overall = "bearish";
        }
        return { inflation, recession, interestRates, overall };
      }
      async getCryptoSentiment(cryptoName) {
        const cryptoNameMap = {
          BTC: "Bitcoin",
          ETH: "Ethereum",
          SOL: "Solana",
          XRP: "Ripple",
          DOGE: "Dogecoin",
          ADA: "Cardano",
          DOT: "Polkadot",
          LINK: "Chainlink",
          AVAX: "Avalanche",
          MATIC: "Polygon",
          LTC: "Litecoin",
          SHIB: "Shiba"
        };
        const fullName = cryptoNameMap[cryptoName.toUpperCase()] || cryptoName;
        const query = `${fullName} cryptocurrency`;
        const l1CacheKey = `crypto_sentiment_${cryptoName}`;
        const cached = this.sentimentCache.get(l1CacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        const [articles, volume, tone] = await Promise.all([
          this.searchArticles(query, { timespan: "24hours", maxRecords: 50 }),
          this.getVolumeTimeline(query, "24hours"),
          this.getToneTimeline(query, "24hours")
        ]);
        const recentVolume = volume.timeline.length > 0 ? volume.timeline.slice(-3).reduce((sum, t) => sum + t.value, 0) / 3 : 0;
        const baselineVolume = volume.timeline.length > 0 ? volume.timeline.reduce((sum, t) => sum + t.value, 0) / volume.timeline.length : 0;
        let sentiment = "neutral";
        if (tone.averageTone > 2) {
          sentiment = "bullish";
        } else if (tone.averageTone < -2) {
          sentiment = "bearish";
        }
        const result = {
          symbol: cryptoName.toUpperCase(),
          query,
          articleCount: articles.totalResults,
          averageTone: tone.averageTone,
          sentiment,
          volumeSpike: recentVolume > baselineVolume * 2,
          recentVolume,
          baselineVolume,
          topHeadlines: articles.articles.slice(0, 5).map((a) => a.title),
          timestamp: /* @__PURE__ */ new Date()
        };
        this.sentimentCache.set(l1CacheKey, result);
        return result;
      }
      getConnectionStatus() {
        return {
          connected: true,
          cacheSize: this.articleCache.size() + this.volumeCache.size() + this.toneCache.size() + this.sentimentCache.size(),
          lastRequest: null
        };
      }
      clearCache() {
        this.articleCache.clear();
        this.volumeCache.clear();
        this.toneCache.clear();
        this.sentimentCache.clear();
      }
    };
    gdelt = new GdeltConnector();
  }
});

// server/connectors/finra.ts
var REGSHO_BASE_URL, FINRAConnector, finra;
var init_finra = __esm({
  "server/connectors/finra.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    REGSHO_BASE_URL = "https://cdn.finra.org/equity/regsho/daily";
    FINRAConnector = class {
      shortInterestCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        // 4 hours - short interest updates twice monthly
        staleDuration: 7 * 24 * 60 * 60 * 1e3
        // 7 days
      });
      consolidatedCache = new ApiCache({
        freshDuration: 4 * 60 * 60 * 1e3,
        staleDuration: 7 * 24 * 60 * 60 * 1e3
      });
      regShoCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        // 1 hour - RegSHO updates daily
        staleDuration: 24 * 60 * 60 * 1e3
      });
      /**
       * Get RegSHO short volume data for a symbol
       * This is daily short volume data from FINRA's public RegSHO files
       */
      async getRegSHOShortVolume(symbol, days = 20) {
        const cacheKey = `regsho_${symbol}_${days}`;
        const cached = this.regShoCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("FINRA", `Cache hit for RegSHO ${symbol}`);
          return cached.data;
        }
        try {
          const results = [];
          const today = /* @__PURE__ */ new Date();
          for (let i = 0; i < days; i++) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dayOfWeek = date.getDay();
            if (dayOfWeek === 0 || dayOfWeek === 6) continue;
            const dateStr = this.formatDateForRegSHO(date);
            try {
              const data = await this.fetchRegSHOFile(dateStr);
              const symbolData = data.find((d) => d.symbol === symbol.toUpperCase());
              if (symbolData) {
                results.push(symbolData);
              }
            } catch {
            }
            if (results.length >= 10) break;
          }
          if (results.length > 0) {
            this.regShoCache.set(cacheKey, results);
            log.info("FINRA", `Fetched ${results.length} RegSHO records for ${symbol}`);
          }
          return results;
        } catch (error) {
          log.error("FINRA", `Failed to fetch RegSHO data for ${symbol}`, { error: String(error) });
          return cached?.data || [];
        }
      }
      /**
       * Fetch and parse FINRA RegSHO daily short sale file
       */
      async fetchRegSHOFile(dateStr) {
        const url = `${REGSHO_BASE_URL}/CNMSshvol${dateStr}.txt`;
        const response = await fetch(url, {
          headers: {
            "Accept": "text/plain"
          }
        });
        if (!response.ok) {
          throw new Error(`RegSHO file not available for ${dateStr}`);
        }
        const text3 = await response.text();
        return this.parseRegSHOFile(text3, dateStr);
      }
      /**
       * Parse FINRA RegSHO file format
       * Format: Date|Symbol|ShortVolume|ShortExemptVolume|TotalVolume|Market
       */
      parseRegSHOFile(text3, dateStr) {
        const lines = text3.split("\n").filter((line) => line.trim());
        const results = [];
        for (let i = 1; i < lines.length; i++) {
          const parts = lines[i].split("|");
          if (parts.length >= 5) {
            const shortVolume = parseInt(parts[2], 10) || 0;
            const shortExemptVolume = parseInt(parts[3], 10) || 0;
            const totalVolume = parseInt(parts[4], 10) || 0;
            if (totalVolume > 0) {
              results.push({
                symbol: parts[1],
                settlementDate: dateStr,
                shortVolume,
                shortExemptVolume,
                totalVolume,
                shortRatio: totalVolume > 0 ? shortVolume / totalVolume : 0,
                market: parts[5] || "N/A"
              });
            }
          }
        }
        return results;
      }
      /**
       * Get short interest summary with trend analysis
       */
      async getShortInterestSummary(symbol) {
        const historicalData = await this.getRegSHOShortVolume(symbol, 30);
        if (historicalData.length === 0) {
          return null;
        }
        const shortRatios = historicalData.map((d) => d.shortRatio);
        const latestShortRatio = shortRatios[0];
        const averageShortRatio = shortRatios.reduce((a, b) => a + b, 0) / shortRatios.length;
        const midpoint = Math.floor(shortRatios.length / 2);
        const recentAvg = shortRatios.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint || 0;
        const olderAvg = shortRatios.slice(midpoint).reduce((a, b) => a + b, 0) / (shortRatios.length - midpoint) || 0;
        let shortRatioTrend;
        const trendThreshold = 0.05;
        if (recentAvg > olderAvg * (1 + trendThreshold)) {
          shortRatioTrend = "increasing";
        } else if (recentAvg < olderAvg * (1 - trendThreshold)) {
          shortRatioTrend = "decreasing";
        } else {
          shortRatioTrend = "stable";
        }
        const avgVolume = historicalData.reduce((sum, d) => sum + d.totalVolume, 0) / historicalData.length;
        const avgShortVolume = historicalData.reduce((sum, d) => sum + d.shortVolume, 0) / historicalData.length;
        const daysToCover = avgVolume > 0 ? avgShortVolume / avgVolume * 10 : null;
        return {
          symbol: symbol.toUpperCase(),
          latestShortRatio,
          averageShortRatio,
          shortRatioTrend,
          daysTocover: daysToCover,
          lastUpdated: /* @__PURE__ */ new Date(),
          historicalData
        };
      }
      /**
       * Get short interest data for multiple symbols
       */
      async getBulkShortInterest(symbols) {
        const results = /* @__PURE__ */ new Map();
        const batchSize = 5;
        for (let i = 0; i < symbols.length; i += batchSize) {
          const batch = symbols.slice(i, i + batchSize);
          const batchResults = await Promise.all(
            batch.map(async (symbol) => {
              const summary = await this.getShortInterestSummary(symbol);
              return { symbol, summary };
            })
          );
          for (const { symbol, summary } of batchResults) {
            if (summary) {
              results.set(symbol, summary);
            }
          }
          if (i + batchSize < symbols.length) {
            await new Promise((resolve2) => setTimeout(resolve2, 500));
          }
        }
        log.info("FINRA", `Fetched short interest for ${results.size}/${symbols.length} symbols`);
        return results;
      }
      /**
       * Analyze short squeeze potential based on short interest metrics
       */
      analyzeShortSqueezePotential(summary) {
        const factors = [];
        let score = 0;
        if (summary.latestShortRatio > 0.5) {
          score += 40;
          factors.push(`Very high short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`);
        } else if (summary.latestShortRatio > 0.4) {
          score += 30;
          factors.push(`High short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`);
        } else if (summary.latestShortRatio > 0.3) {
          score += 20;
          factors.push(`Elevated short ratio: ${(summary.latestShortRatio * 100).toFixed(1)}%`);
        }
        if (summary.shortRatioTrend === "increasing") {
          score += 20;
          factors.push("Short interest is increasing");
        }
        if (summary.daysTocover && summary.daysTocover > 5) {
          score += 25;
          factors.push(`High days to cover: ${summary.daysTocover.toFixed(1)}`);
        } else if (summary.daysTocover && summary.daysTocover > 3) {
          score += 15;
          factors.push(`Elevated days to cover: ${summary.daysTocover.toFixed(1)}`);
        }
        if (summary.latestShortRatio > summary.averageShortRatio * 1.2) {
          score += 15;
          factors.push("Short ratio above 20-day average");
        }
        let potential;
        if (score >= 60) {
          potential = "high";
        } else if (score >= 35) {
          potential = "medium";
        } else {
          potential = "low";
        }
        return { potential, score, factors };
      }
      formatDateForRegSHO(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}${month}${day}`;
      }
      /**
       * Clear all caches
       */
      clearCache() {
        this.shortInterestCache.clear();
        this.consolidatedCache.clear();
        this.regShoCache.clear();
      }
      /**
       * Check connection status
       */
      getConnectionStatus() {
        const cacheSize = this.shortInterestCache.size() + this.consolidatedCache.size() + this.regShoCache.size();
        return {
          connected: true,
          // FINRA public data doesn't require authentication
          cacheSize
        };
      }
    };
    finra = new FINRAConnector();
  }
});

// server/lib/rateLimiter.ts
import Bottleneck from "bottleneck";
function getLimiter(provider) {
  if (limiters.has(provider)) {
    return limiters.get(provider);
  }
  const limits = PROVIDER_LIMITS[provider] || { maxPerMinute: 60, maxConcurrent: 5 };
  const limiter = new Bottleneck({
    maxConcurrent: limits.maxConcurrent || 5,
    minTime: limits.minTime || 0,
    reservoir: limits.maxPerMinute,
    reservoirRefreshAmount: limits.maxPerMinute,
    reservoirRefreshInterval: 60 * 1e3
  });
  if (limits.maxPerSecond) {
    const secondLimiter = new Bottleneck({
      reservoir: limits.maxPerSecond,
      reservoirRefreshAmount: limits.maxPerSecond,
      reservoirRefreshInterval: 1e3
    });
    secondLimiters.set(provider, secondLimiter);
    limiter.chain(secondLimiter);
    log.debug("RateLimiter", `[${provider}] Per-second limiter: ${limits.maxPerSecond}/s`);
  }
  if (limits.maxPerHour) {
    const hourlyLimiter = new Bottleneck({
      reservoir: limits.maxPerHour,
      reservoirRefreshAmount: limits.maxPerHour,
      reservoirRefreshInterval: 60 * 60 * 1e3
    });
    hourlyLimiters.set(provider, hourlyLimiter);
    limiter.chain(hourlyLimiter);
    log.debug("RateLimiter", `[${provider}] Per-hour limiter: ${limits.maxPerHour}/h`);
  }
  if (limits.maxPerDay) {
    const dailyLimiter = new Bottleneck({
      reservoir: limits.maxPerDay,
      reservoirRefreshAmount: limits.maxPerDay,
      reservoirRefreshInterval: 24 * 60 * 60 * 1e3
    });
    dailyLimiters.set(provider, dailyLimiter);
    limiter.chain(dailyLimiter);
    log.debug("RateLimiter", `[${provider}] Per-day limiter: ${limits.maxPerDay}/d`);
  }
  limiter.on("failed", (error, jobInfo) => {
    log.warn("RateLimiter", `[${provider}] Job failed: ${error.message}`);
    if (jobInfo.retryCount < 3) {
      return 1e3 * Math.pow(2, jobInfo.retryCount);
    }
    return void 0;
  });
  limiter.on("depleted", () => {
    log.debug("RateLimiter", `[${provider}] Rate limit depleted, requests queued`);
  });
  limiters.set(provider, limiter);
  return limiter;
}
function wrapWithLimiter(provider, fn) {
  return getLimiter(provider).schedule(fn);
}
var PROVIDER_LIMITS, limiters, secondLimiters, hourlyLimiters, dailyLimiters;
var init_rateLimiter = __esm({
  "server/lib/rateLimiter.ts"() {
    "use strict";
    init_logger();
    PROVIDER_LIMITS = {
      "sec-edgar": { maxPerSecond: 10, maxConcurrent: 5, minTime: 100 },
      "alpha-vantage": { maxPerDay: 25, maxPerMinute: 5, maxConcurrent: 1, minTime: 12e3 },
      "yfinance": { maxPerHour: 2e3, maxPerMinute: 60, maxConcurrent: 3 },
      "polygon-free": { maxPerMinute: 5, maxConcurrent: 1, minTime: 12e3 },
      "binance": { maxPerMinute: 1200, maxConcurrent: 10 },
      "defillama": { maxPerMinute: 60, maxConcurrent: 5 },
      "cryptocompare": { maxPerSecond: 50, maxPerDay: 2e5, maxConcurrent: 10 },
      "fred": { maxPerMinute: 120, maxConcurrent: 5 },
      "reddit": { maxPerMinute: 100, maxConcurrent: 2 },
      "stocktwits": { maxPerMinute: 200, maxConcurrent: 3 },
      "yahoo-scrape": { maxPerMinute: 60, maxConcurrent: 2, minTime: 1e3 },
      "huggingface-inference": { maxPerMinute: 30, maxConcurrent: 2 },
      "alpaca": { maxPerMinute: 180, maxConcurrent: 5, minTime: 333 },
      "finnhub": { maxPerMinute: 50, maxConcurrent: 3, minTime: 1200 },
      "coingecko": { maxPerMinute: 10, maxPerDay: 500, maxConcurrent: 2, minTime: 2100 },
      "newsapi": { maxPerDay: 80, maxConcurrent: 1, minTime: 3e3 },
      "twelvedata": { maxPerMinute: 6, maxPerDay: 700, maxConcurrent: 2, minTime: 1e4 },
      "valyu": { maxPerDay: 100, maxConcurrent: 1, minTime: 5e3 },
      "jina": { maxPerMinute: 30, maxConcurrent: 3, minTime: 2e3 },
      "gdelt": { maxPerMinute: 60, maxConcurrent: 3 },
      "openai": { maxPerMinute: 60, maxConcurrent: 5 },
      "claude": { maxPerMinute: 50, maxConcurrent: 3 },
      "openrouter": { maxPerMinute: 100, maxConcurrent: 5 },
      "groq": { maxPerMinute: 30, maxConcurrent: 3 },
      "together": { maxPerMinute: 60, maxConcurrent: 5 },
      "deepseek": { maxPerMinute: 60, maxConcurrent: 3 }
    };
    limiters = /* @__PURE__ */ new Map();
    secondLimiters = /* @__PURE__ */ new Map();
    hourlyLimiters = /* @__PURE__ */ new Map();
    dailyLimiters = /* @__PURE__ */ new Map();
  }
});

// server/connectors/sec-edgar.ts
import { z as z2 } from "zod";
async function fetchSEC(url) {
  return wrapWithLimiter("sec-edgar", async () => {
    const response = await fetch(url, {
      headers: {
        "User-Agent": SEC_USER_AGENT,
        "Accept": "application/json"
      }
    });
    if (!response.ok) {
      throw new Error(`SEC API error: ${response.status} ${response.statusText}`);
    }
    return response.json();
  });
}
async function getCIKByTicker(ticker) {
  const normalizedTicker = ticker.toUpperCase();
  if (cikCache.has(normalizedTicker)) {
    return cikCache.get(normalizedTicker);
  }
  try {
    const tickersData = await fetchSEC(`https://www.sec.gov/files/company_tickers.json`);
    for (const entry of Object.values(tickersData)) {
      if (entry.ticker === normalizedTicker) {
        const cik = String(entry.cik_str).padStart(10, "0");
        cikCache.set(normalizedTicker, cik);
        return cik;
      }
    }
    return null;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to get CIK for ${ticker}: ${error.message}`);
    return null;
  }
}
async function getCompanyInfo(ticker) {
  const cacheKey = `sec-company-${ticker}`;
  const cached = cache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const info = {
      cik,
      name: data.name,
      ticker: data.tickers?.[0] || ticker,
      exchanges: data.exchanges || [],
      sic: data.sic || "",
      sicDescription: data.sicDescription || "",
      category: data.category,
      fiscalYearEnd: data.fiscalYearEnd
    };
    cache.set(cacheKey, info);
    return info;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to fetch company info for ${ticker}: ${error.message}`);
    return null;
  }
}
async function getCompanyFacts(ticker) {
  const cacheKey = `sec-facts-${ticker}`;
  const cached = cache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/api/xbrl/companyfacts/CIK${cik}.json`);
    const parsed = CompanyFactsSchema.parse(data);
    const getLatestValue = (concept, namespace = "us-gaap") => {
      const facts = parsed.facts?.[namespace]?.[concept]?.units?.USD;
      if (!facts || facts.length === 0) return void 0;
      const annual = facts.filter((f) => f.form === "10-K").sort((a, b) => new Date(b.end).getTime() - new Date(a.end).getTime());
      return annual[0]?.val;
    };
    const fundamentals = {
      cik,
      ticker: ticker.toUpperCase(),
      name: parsed.entityName,
      revenue: getLatestValue("Revenues") || getLatestValue("RevenueFromContractWithCustomerExcludingAssessedTax") || getLatestValue("SalesRevenueNet"),
      netIncome: getLatestValue("NetIncomeLoss"),
      totalAssets: getLatestValue("Assets"),
      totalLiabilities: getLatestValue("Liabilities"),
      eps: getLatestValue("EarningsPerShareBasic"),
      sharesOutstanding: getLatestValue("CommonStockSharesOutstanding")
    };
    cache.set(cacheKey, fundamentals);
    log.info("SEC-EDGAR", `Fetched fundamentals for ${ticker}: revenue=${fundamentals.revenue}, netIncome=${fundamentals.netIncome}`);
    return fundamentals;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to fetch facts for ${ticker}: ${error.message}`);
    return null;
  }
}
async function getRecentFilings(ticker, formTypes = ["10-K", "10-Q", "8-K"], limit4 = 10) {
  const cik = await getCIKByTicker(ticker);
  if (!cik) return [];
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const filings = [];
    const recent = data.filings?.recent || data;
    const accessionNumbers = recent.accessionNumber || [];
    const forms = recent.form || [];
    const filingDates = recent.filingDate || [];
    const primaryDocuments = recent.primaryDocument || [];
    for (let i = 0; i < Math.min(accessionNumbers.length, 100); i++) {
      const form = forms[i];
      if (!formTypes.includes(form)) continue;
      const accNum = accessionNumbers[i];
      const primaryDoc = primaryDocuments[i] || "index.html";
      filings.push({
        accessionNumber: accNum,
        filingDate: new Date(filingDates[i]),
        form,
        primaryDocument: primaryDoc,
        documentUrl: `https://www.sec.gov/Archives/edgar/data/${parseInt(cik)}/${accNum.replace(/-/g, "")}/${primaryDoc}`
      });
      if (filings.length >= limit4) break;
    }
    log.info("SEC-EDGAR", `Found ${filings.length} filings for ${ticker}`);
    return filings;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to fetch filings for ${ticker}: ${error.message}`);
    return [];
  }
}
async function getBulkCompanyFacts(tickers) {
  const results = /* @__PURE__ */ new Map();
  const batchSize = 5;
  for (let i = 0; i < tickers.length; i += batchSize) {
    const batch = tickers.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(async (ticker) => {
        const facts = await getCompanyFacts(ticker);
        return { ticker, facts };
      })
    );
    for (const { ticker, facts } of batchResults) {
      if (facts) {
        results.set(ticker, facts);
      }
    }
    if (i + batchSize < tickers.length) {
      await new Promise((resolve2) => setTimeout(resolve2, 200));
    }
  }
  return results;
}
async function getInsiderTransactions(ticker, limit4 = 20) {
  const cik = await getCIKByTicker(ticker);
  if (!cik) return [];
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const transactions = [];
    const recent = data.filings?.recent || data;
    const accessionNumbers = recent.accessionNumber || [];
    const forms = recent.form || [];
    const filingDates = recent.filingDate || [];
    for (let i = 0; i < Math.min(accessionNumbers.length, 200); i++) {
      const form = forms[i];
      if (form !== "4" && form !== "4/A") continue;
      const accNum = accessionNumbers[i];
      const filingDate = new Date(filingDates[i]);
      try {
        const transaction = await parseForm4Filing(cik, accNum, filingDate);
        if (transaction) {
          transactions.push(...transaction);
        }
      } catch (e) {
      }
      if (transactions.length >= limit4) break;
    }
    log.info("SEC-EDGAR", `Found ${transactions.length} insider transactions for ${ticker}`);
    return transactions;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to fetch insider transactions for ${ticker}: ${error.message}`);
    return [];
  }
}
async function parseForm4Filing(companyCik, accessionNumber, filingDate) {
  const accNumClean = accessionNumber.replace(/-/g, "");
  const url = `https://www.sec.gov/Archives/edgar/data/${parseInt(companyCik)}/${accNumClean}`;
  try {
    const indexResponse = await wrapWithLimiter("sec-edgar", async () => {
      return fetch(`${url}/index.json`, {
        headers: { "User-Agent": SEC_USER_AGENT }
      });
    });
    if (!indexResponse.ok) return [];
    const indexData = await indexResponse.json();
    const xmlFile = indexData.directory?.item?.find(
      (item) => item.name?.endsWith(".xml") && !item.name?.includes("primary_doc")
    );
    if (!xmlFile) return [];
    const xmlResponse = await wrapWithLimiter("sec-edgar", async () => {
      return fetch(`${url}/${xmlFile.name}`, {
        headers: { "User-Agent": SEC_USER_AGENT }
      });
    });
    if (!xmlResponse.ok) return [];
    const xmlText = await xmlResponse.text();
    return parseForm4XML(xmlText, accessionNumber, filingDate, url);
  } catch {
    return [];
  }
}
function parseForm4XML(xml, accessionNumber, filingDate, baseUrl) {
  const transactions = [];
  const ownerMatch = xml.match(/<rptOwnerName>([^<]+)<\/rptOwnerName>/);
  const ownerCikMatch = xml.match(/<rptOwnerCik>([^<]+)<\/rptOwnerCik>/);
  const reportingOwner = ownerMatch?.[1] || "Unknown";
  const ownerCik = ownerCikMatch?.[1] || "";
  let relationship = "";
  if (xml.includes("<isDirector>true</isDirector>") || xml.includes("<isDirector>1</isDirector>")) relationship += "Director ";
  if (xml.includes("<isOfficer>true</isOfficer>") || xml.includes("<isOfficer>1</isOfficer>")) {
    const titleMatch = xml.match(/<officerTitle>([^<]+)<\/officerTitle>/);
    relationship += titleMatch?.[1] || "Officer ";
  }
  if (xml.includes("<isTenPercentOwner>true</isTenPercentOwner>") || xml.includes("<isTenPercentOwner>1</isTenPercentOwner>")) relationship += "10% Owner ";
  relationship = relationship.trim() || "Other";
  const transactionMatches = xml.matchAll(/<nonDerivativeTransaction>[\s\S]*?<\/nonDerivativeTransaction>/g);
  for (const match of transactionMatches) {
    const txXml = match[0];
    const dateMatch = txXml.match(/<transactionDate>[\s\S]*?<value>([^<]+)<\/value>/);
    const codeMatch = txXml.match(/<transactionCode>([^<]+)<\/transactionCode>/);
    const sharesMatch = txXml.match(/<transactionShares>[\s\S]*?<value>([^<]+)<\/value>/);
    const priceMatch = txXml.match(/<transactionPricePerShare>[\s\S]*?<value>([^<]*)<\/value>/);
    const sharesAfterMatch = txXml.match(/<sharesOwnedFollowingTransaction>[\s\S]*?<value>([^<]+)<\/value>/);
    const ownershipMatch = txXml.match(/<directOrIndirectOwnership>[\s\S]*?<value>([^<]+)<\/value>/);
    const acquiredDisposedMatch = txXml.match(/<transactionAcquiredDisposedCode>[\s\S]*?<value>([^<]+)<\/value>/);
    const transactionDate = dateMatch?.[1] ? new Date(dateMatch[1]) : filingDate;
    const transactionCode = codeMatch?.[1] || "";
    const sharesTransacted = parseFloat(sharesMatch?.[1] || "0");
    const pricePerShare = priceMatch?.[1] ? parseFloat(priceMatch[1]) : null;
    const sharesOwnedAfter = parseFloat(sharesAfterMatch?.[1] || "0");
    const isDirectOwnership = ownershipMatch?.[1]?.toUpperCase() === "D";
    const isAcquisition = acquiredDisposedMatch?.[1]?.toUpperCase() === "A";
    let transactionType = "P";
    if (transactionCode === "P") transactionType = "P";
    else if (transactionCode === "S") transactionType = "S";
    else if (transactionCode === "A") transactionType = "A";
    else if (transactionCode === "D") transactionType = "D";
    else if (transactionCode === "G") transactionType = "G";
    else if (transactionCode === "M") transactionType = "M";
    else if (transactionCode === "C") transactionType = "C";
    else if (transactionCode === "X") transactionType = "X";
    else transactionType = isAcquisition ? "P" : "S";
    const value = pricePerShare && sharesTransacted ? pricePerShare * sharesTransacted : null;
    transactions.push({
      filingDate,
      reportingOwner,
      ownerCik,
      relationship,
      transactionDate,
      transactionType,
      transactionCode,
      sharesTransacted,
      pricePerShare,
      sharesOwnedAfter,
      value,
      isDirectOwnership,
      accessionNumber,
      documentUrl: `${baseUrl}`
    });
  }
  return transactions;
}
async function getInsiderSummary(ticker, days = 90) {
  const cacheKey = `insider-${ticker}-${days}`;
  const cached = insiderCache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  const info = await getCompanyInfo(ticker);
  if (!info) return null;
  try {
    const transactions = await getInsiderTransactions(ticker, 50);
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - days);
    const recentTransactions = transactions.filter(
      (t) => t.transactionDate >= cutoffDate
    );
    let totalBuys = 0;
    let totalSells = 0;
    let buyValue = 0;
    let sellValue = 0;
    for (const t of recentTransactions) {
      if (t.transactionType === "P" || t.transactionCode === "P") {
        totalBuys += t.sharesTransacted;
        buyValue += t.value || 0;
      } else if (t.transactionType === "S" || t.transactionCode === "S") {
        totalSells += t.sharesTransacted;
        sellValue += t.value || 0;
      }
    }
    const netActivity = totalBuys - totalSells;
    const netValue = buyValue - sellValue;
    const buyToSellRatio = totalSells > 0 ? totalBuys / totalSells : totalBuys > 0 ? Infinity : 0;
    let sentiment = "neutral";
    if (buyToSellRatio > 1.5 || netValue > 1e5 && totalBuys > totalSells) {
      sentiment = "bullish";
    } else if (buyToSellRatio < 0.5 || netValue < -1e5 && totalSells > totalBuys) {
      sentiment = "bearish";
    }
    const summary = {
      ticker: ticker.toUpperCase(),
      cik,
      companyName: info.name,
      totalInsiderBuys: totalBuys,
      totalInsiderSells: totalSells,
      netInsiderActivity: netActivity,
      netInsiderValue: netValue,
      buyToSellRatio,
      recentTransactions: recentTransactions.slice(0, 10),
      sentiment,
      lastUpdated: /* @__PURE__ */ new Date()
    };
    insiderCache.set(cacheKey, summary);
    log.info("SEC-EDGAR", `Insider summary for ${ticker}: ${sentiment} (${recentTransactions.length} transactions)`);
    return summary;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to get insider summary for ${ticker}: ${error.message}`);
    return null;
  }
}
async function getInstitutionalOwnership(ticker) {
  const cacheKey = `institutional-${ticker}`;
  const cached = institutionalCache.getFresh(cacheKey);
  if (cached) return cached;
  const cik = await getCIKByTicker(ticker);
  if (!cik) return null;
  const info = await getCompanyInfo(ticker);
  if (!info) return null;
  try {
    const data = await fetchSEC(`${SEC_BASE_URL}/submissions/CIK${cik}.json`);
    const owners = data.owners || [];
    const ownership = {
      ticker: ticker.toUpperCase(),
      cik,
      companyName: info.name,
      totalInstitutionalShares: 0,
      totalInstitutionalValue: 0,
      numberOfInstitutions: owners.length,
      topHolders: [],
      quarterlyChange: null,
      lastUpdated: /* @__PURE__ */ new Date()
    };
    institutionalCache.set(cacheKey, ownership);
    log.info("SEC-EDGAR", `Institutional ownership for ${ticker}: ${owners.length} institutions found`);
    return ownership;
  } catch (error) {
    log.error("SEC-EDGAR", `Failed to get institutional ownership for ${ticker}: ${error.message}`);
    return null;
  }
}
async function getBulkInsiderSummaries(tickers) {
  const results = /* @__PURE__ */ new Map();
  const batchSize = 3;
  for (let i = 0; i < tickers.length; i += batchSize) {
    const batch = tickers.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(async (ticker) => {
        const summary = await getInsiderSummary(ticker);
        return { ticker, summary };
      })
    );
    for (const { ticker, summary } of batchResults) {
      if (summary) {
        results.set(ticker, summary);
      }
    }
    if (i + batchSize < tickers.length) {
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
    }
  }
  log.info("SEC-EDGAR", `Fetched insider summaries for ${results.size}/${tickers.length} tickers`);
  return results;
}
var SEC_BASE_URL, SEC_USER_AGENT, CompanyFactsSchema, cache, cikCache, insiderCache, institutionalCache, SECEdgarConnector, secEdgarConnector;
var init_sec_edgar = __esm({
  "server/connectors/sec-edgar.ts"() {
    "use strict";
    init_rateLimiter();
    init_api_cache();
    init_logger();
    SEC_BASE_URL = "https://data.sec.gov";
    SEC_USER_AGENT = `AI-Active-Trader/1.0 (support@aiactivetrader.com)`;
    CompanyFactsSchema = z2.object({
      cik: z2.union([z2.number(), z2.string()]).transform((v) => String(v)),
      entityName: z2.string(),
      facts: z2.object({
        "us-gaap": z2.record(z2.any()).optional(),
        "dei": z2.record(z2.any()).optional()
      })
    });
    cache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 24 * 60 * 60 * 1e3
    });
    cikCache = /* @__PURE__ */ new Map();
    insiderCache = new ApiCache({
      freshDuration: 60 * 60 * 1e3,
      // 1 hour
      staleDuration: 24 * 60 * 60 * 1e3
      // 24 hours
    });
    institutionalCache = new ApiCache({
      freshDuration: 6 * 60 * 60 * 1e3,
      // 6 hours - 13F filings are quarterly
      staleDuration: 30 * 24 * 60 * 60 * 1e3
      // 30 days
    });
    SECEdgarConnector = class {
      async getCompanyFacts(ticker) {
        return getCompanyFacts(ticker);
      }
      async getRecentFilings(ticker, formTypes, limit4) {
        return getRecentFilings(ticker, formTypes, limit4);
      }
      async getCompanyInfo(ticker) {
        return getCompanyInfo(ticker);
      }
      async getCIKByTicker(ticker) {
        return getCIKByTicker(ticker);
      }
      async getBulkCompanyFacts(tickers) {
        return getBulkCompanyFacts(tickers);
      }
      // Form 4 - Insider Trading
      async getInsiderTransactions(ticker, limit4) {
        return getInsiderTransactions(ticker, limit4);
      }
      async getInsiderSummary(ticker, days) {
        return getInsiderSummary(ticker, days);
      }
      async getBulkInsiderSummaries(tickers) {
        return getBulkInsiderSummaries(tickers);
      }
      // 13F - Institutional Ownership
      async getInstitutionalOwnership(ticker) {
        return getInstitutionalOwnership(ticker);
      }
    };
    secEdgarConnector = new SECEdgarConnector();
  }
});

// server/connectors/fred.ts
var FRED_BASE_URL, FRED_SERIES, CRITICAL_INDICATORS, FREDConnector, fred;
var init_fred = __esm({
  "server/connectors/fred.ts"() {
    "use strict";
    init_connectorClient();
    init_logger();
    FRED_BASE_URL = "https://api.stlouisfed.org/fred";
    FRED_SERIES = {
      "DGS10": { name: "10-Year Treasury Constant Maturity Rate", category: "treasury_yields" },
      "DGS2": { name: "2-Year Treasury Constant Maturity Rate", category: "treasury_yields" },
      "DGS30": { name: "30-Year Treasury Constant Maturity Rate", category: "treasury_yields" },
      "T10Y2Y": { name: "10-Year Treasury Minus 2-Year Treasury (Yield Curve)", category: "treasury_yields" },
      "T10Y3M": { name: "10-Year Treasury Minus 3-Month Treasury", category: "treasury_yields" },
      "CPIAUCSL": { name: "Consumer Price Index for All Urban Consumers", category: "inflation" },
      "CPILFESL": { name: "Core CPI (Less Food and Energy)", category: "inflation" },
      "PCEPI": { name: "Personal Consumption Expenditures Price Index", category: "inflation" },
      "UNRATE": { name: "Unemployment Rate", category: "employment" },
      "PAYEMS": { name: "Total Nonfarm Payrolls", category: "employment" },
      "ICSA": { name: "Initial Jobless Claims", category: "employment" },
      "VIXCLS": { name: "CBOE Volatility Index (VIX)", category: "volatility" },
      "FEDFUNDS": { name: "Federal Funds Effective Rate", category: "interest_rates" },
      "DFEDTARU": { name: "Federal Funds Target Rate - Upper Bound", category: "interest_rates" },
      "M2SL": { name: "M2 Money Stock", category: "money_supply" },
      "GDP": { name: "Gross Domestic Product", category: "gdp" },
      "GDPC1": { name: "Real Gross Domestic Product", category: "gdp" },
      "UMCSENT": { name: "University of Michigan Consumer Sentiment", category: "consumer" },
      "HOUST": { name: "Housing Starts", category: "housing" },
      "INDPRO": { name: "Industrial Production Index", category: "manufacturing" },
      "NAPM": { name: "ISM Manufacturing PMI", category: "manufacturing" }
    };
    CRITICAL_INDICATORS = [
      "DGS10",
      "DGS2",
      "T10Y2Y",
      "VIXCLS",
      "FEDFUNDS",
      "UNRATE",
      "CPIAUCSL",
      "UMCSENT"
    ];
    FREDConnector = class {
      CACHE_TTL_MS = 6 * 60 * 60 * 1e3;
      constructor() {
      }
      getApiKey() {
        const apiKey = process.env.FRED_API_KEY;
        if (!apiKey) {
          log.warn("FRED", "No API key configured, using unauthenticated access (limited)");
          return "";
        }
        return apiKey;
      }
      async getSeriesInfo(seriesId) {
        try {
          const apiKey = this.getApiKey();
          const url = `${FRED_BASE_URL}/series?series_id=${seriesId}&api_key=${apiKey}&file_type=json`;
          const response = await connectorFetch(url, {
            provider: "FRED",
            endpoint: "series",
            cacheKey: buildCacheKey("FRED", "series", seriesId),
            customTTLMs: 24 * 60 * 60 * 1e3
          });
          return response.data.seriess?.[0] || null;
        } catch (error) {
          log.error("FRED", `Failed to get series info for ${seriesId}`, { error });
          return null;
        }
      }
      async getLatestObservations(seriesId, limit4 = 10) {
        try {
          const apiKey = this.getApiKey();
          if (!apiKey) {
            log.warn("FRED", `Skipping ${seriesId}: No API key available`);
            return [];
          }
          const url = `${FRED_BASE_URL}/series/observations?series_id=${seriesId}&api_key=${apiKey}&file_type=json&sort_order=desc&limit=${limit4}`;
          const response = await connectorFetch(url, {
            provider: "FRED",
            endpoint: "observations",
            cacheKey: buildCacheKey("FRED", "observations", seriesId, limit4.toString()),
            customTTLMs: this.CACHE_TTL_MS
          });
          return response.data.observations || [];
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error("FRED", `Failed to get observations for ${seriesId}: ${errorMsg}`);
          return [];
        }
      }
      async getIndicatorData(seriesId) {
        const seriesConfig = FRED_SERIES[seriesId];
        if (!seriesConfig) {
          log.warn("FRED", `Unknown series ID: ${seriesId}`);
          return null;
        }
        try {
          const observations = await this.getLatestObservations(seriesId, 5);
          if (observations.length === 0) {
            return null;
          }
          const latestValue = observations[0]?.value === "." ? null : parseFloat(observations[0]?.value || "");
          const previousValue = observations[1]?.value === "." ? null : parseFloat(observations[1]?.value || "");
          let changePercent = null;
          if (latestValue !== null && previousValue !== null && previousValue !== 0) {
            changePercent = (latestValue - previousValue) / Math.abs(previousValue) * 100;
          }
          return {
            indicatorId: seriesId,
            name: seriesConfig.name,
            category: seriesConfig.category,
            latestValue: isNaN(latestValue) ? null : latestValue,
            previousValue: isNaN(previousValue) ? null : previousValue,
            changePercent: changePercent !== null && isNaN(changePercent) ? null : changePercent,
            frequency: "variable",
            lastUpdatedAt: /* @__PURE__ */ new Date(),
            source: "FRED",
            rawJson: {
              realtime_start: "",
              realtime_end: "",
              observation_start: "",
              observation_end: "",
              units: "",
              output_type: 0,
              file_type: "json",
              order_by: "observation_date",
              sort_order: "desc",
              count: observations.length,
              offset: 0,
              limit: 5,
              observations
            }
          };
        } catch (error) {
          log.error("FRED", `Failed to get indicator data for ${seriesId}`, { error });
          return null;
        }
      }
      async getCriticalIndicators() {
        const results = [];
        for (const seriesId of CRITICAL_INDICATORS) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        log.info("FRED", `Fetched ${results.length}/${CRITICAL_INDICATORS.length} critical indicators`);
        return results;
      }
      async getAllIndicators() {
        const results = [];
        for (const seriesId of Object.keys(FRED_SERIES)) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        log.info("FRED", `Fetched ${results.length}/${Object.keys(FRED_SERIES).length} indicators`);
        return results;
      }
      async getIndicatorsByCategory(category) {
        const seriesIds = Object.entries(FRED_SERIES).filter(([_, config]) => config.category === category).map(([id]) => id);
        const results = [];
        for (const seriesId of seriesIds) {
          const data = await this.getIndicatorData(seriesId);
          if (data) {
            results.push(data);
          }
        }
        return results;
      }
      getYieldCurveSpread() {
        return this.getIndicatorData("T10Y2Y");
      }
      getVIX() {
        return this.getIndicatorData("VIXCLS");
      }
      getFedFundsRate() {
        return this.getIndicatorData("FEDFUNDS");
      }
      getUnemploymentRate() {
        return this.getIndicatorData("UNRATE");
      }
      getCPI() {
        return this.getIndicatorData("CPIAUCSL");
      }
      isConfigured() {
        return !!process.env.FRED_API_KEY;
      }
      getAvailableSeries() {
        return Object.keys(FRED_SERIES);
      }
      getSeriesMetadata(seriesId) {
        return FRED_SERIES[seriesId] || null;
      }
    };
    fred = new FREDConnector();
  }
});

// server/connectors/frankfurter.ts
var FRANKFURTER_BASE_URL, MAJOR_FOREX_PAIRS, FrankfurterConnector, frankfurter;
var init_frankfurter = __esm({
  "server/connectors/frankfurter.ts"() {
    "use strict";
    init_api_cache();
    init_logger();
    FRANKFURTER_BASE_URL = "https://api.frankfurter.app";
    MAJOR_FOREX_PAIRS = [
      { base: "EUR", quote: "USD", name: "Euro / US Dollar" },
      { base: "GBP", quote: "USD", name: "British Pound / US Dollar" },
      { base: "USD", quote: "JPY", name: "US Dollar / Japanese Yen" },
      { base: "USD", quote: "CHF", name: "US Dollar / Swiss Franc" },
      { base: "AUD", quote: "USD", name: "Australian Dollar / US Dollar" },
      { base: "USD", quote: "CAD", name: "US Dollar / Canadian Dollar" },
      { base: "NZD", quote: "USD", name: "New Zealand Dollar / US Dollar" },
      { base: "EUR", quote: "GBP", name: "Euro / British Pound" },
      { base: "EUR", quote: "JPY", name: "Euro / Japanese Yen" },
      { base: "GBP", quote: "JPY", name: "British Pound / Japanese Yen" }
    ];
    FrankfurterConnector = class {
      latestRatesCache = new ApiCache({
        freshDuration: 60 * 60 * 1e3,
        // 1 hour - ECB updates once daily
        staleDuration: 24 * 60 * 60 * 1e3
        // 24 hours
      });
      historicalRatesCache = new ApiCache({
        freshDuration: 24 * 60 * 60 * 1e3,
        // Historical data doesn't change
        staleDuration: 7 * 24 * 60 * 60 * 1e3
        // 7 days
      });
      currenciesCache = new ApiCache({
        freshDuration: 24 * 60 * 60 * 1e3,
        // Currencies rarely change
        staleDuration: 30 * 24 * 60 * 60 * 1e3
        // 30 days
      });
      /**
       * Get latest exchange rates
       */
      async getLatestRates(base = "USD", symbols) {
        const cacheKey = `latest_${base}_${symbols?.join(",") || "all"}`;
        const cached = this.latestRatesCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("Frankfurter", `Cache hit for latest rates ${base}`);
          return cached.data;
        }
        try {
          let url = `${FRANKFURTER_BASE_URL}/latest?from=${base.toUpperCase()}`;
          if (symbols && symbols.length > 0) {
            url += `&to=${symbols.map((s) => s.toUpperCase()).join(",")}`;
          }
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          this.latestRatesCache.set(cacheKey, data);
          log.info("Frankfurter", `Fetched latest rates for ${base}: ${Object.keys(data.rates).length} currencies`);
          return data;
        } catch (error) {
          log.error("Frankfurter", `Failed to fetch latest rates for ${base}`, { error: String(error) });
          return cached?.data || null;
        }
      }
      /**
       * Get historical exchange rates for a date range
       */
      async getHistoricalRates(base, startDate, endDate, symbols) {
        const cacheKey = `historical_${base}_${startDate}_${endDate}_${symbols?.join(",") || "all"}`;
        const cached = this.historicalRatesCache.get(cacheKey);
        if (cached?.isFresh) {
          log.debug("Frankfurter", `Cache hit for historical rates ${base}`);
          return cached.data;
        }
        try {
          let url = `${FRANKFURTER_BASE_URL}/${startDate}..${endDate}?from=${base.toUpperCase()}`;
          if (symbols && symbols.length > 0) {
            url += `&to=${symbols.map((s) => s.toUpperCase()).join(",")}`;
          }
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status} ${response.statusText}`);
          }
          const data = await response.json();
          this.historicalRatesCache.set(cacheKey, data);
          log.info("Frankfurter", `Fetched historical rates for ${base} from ${startDate} to ${endDate}`);
          return data;
        } catch (error) {
          log.error("Frankfurter", `Failed to fetch historical rates for ${base}`, { error: String(error) });
          return cached?.data || null;
        }
      }
      /**
       * Get exchange rate for a specific date
       */
      async getRateOnDate(base, quote, date) {
        try {
          const url = `${FRANKFURTER_BASE_URL}/${date}?from=${base.toUpperCase()}&to=${quote.toUpperCase()}`;
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          return data.rates[quote.toUpperCase()] || null;
        } catch (error) {
          log.error("Frankfurter", `Failed to fetch rate for ${base}/${quote} on ${date}`, { error: String(error) });
          return null;
        }
      }
      /**
       * Get all available currencies
       */
      async getCurrencies() {
        const cacheKey = "currencies";
        const cached = this.currenciesCache.get(cacheKey);
        if (cached?.isFresh) {
          return cached.data;
        }
        try {
          const response = await fetch(`${FRANKFURTER_BASE_URL}/currencies`, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          const currencies = Object.entries(data).map(([code, name]) => ({
            code,
            name
          }));
          this.currenciesCache.set(cacheKey, currencies);
          log.info("Frankfurter", `Fetched ${currencies.length} currencies`);
          return currencies;
        } catch (error) {
          log.error("Frankfurter", "Failed to fetch currencies", { error: String(error) });
          return cached?.data || [];
        }
      }
      /**
       * Convert amount between currencies
       */
      async convert(amount, from, to, date) {
        try {
          const endpoint = date || "latest";
          const url = `${FRANKFURTER_BASE_URL}/${endpoint}?amount=${amount}&from=${from.toUpperCase()}&to=${to.toUpperCase()}`;
          const response = await fetch(url, {
            headers: { Accept: "application/json" }
          });
          if (!response.ok) {
            throw new Error(`Frankfurter API error: ${response.status}`);
          }
          const data = await response.json();
          const convertedAmount = data.rates[to.toUpperCase()];
          const rate = convertedAmount / amount;
          return {
            amount: convertedAmount,
            rate,
            date: data.date
          };
        } catch (error) {
          log.error("Frankfurter", `Failed to convert ${amount} ${from} to ${to}`, { error: String(error) });
          return null;
        }
      }
      /**
       * Get forex pair data with trend analysis
       */
      async getForexPairSummary(base, quote) {
        try {
          const latestRates = await this.getLatestRates(base, [quote]);
          if (!latestRates || !latestRates.rates[quote.toUpperCase()]) {
            return null;
          }
          const currentRate = latestRates.rates[quote.toUpperCase()];
          const today = /* @__PURE__ */ new Date();
          const thirtyDaysAgo = new Date(today);
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          const startDate = this.formatDate(thirtyDaysAgo);
          const endDate = this.formatDate(today);
          const historicalRates = await this.getHistoricalRates(base, startDate, endDate, [quote]);
          if (!historicalRates || !historicalRates.rates) {
            return {
              pair: `${base}/${quote}`,
              currentRate,
              previousRate: currentRate,
              change: 0,
              changePercent: 0,
              high30d: currentRate,
              low30d: currentRate,
              trend: "neutral",
              lastUpdated: /* @__PURE__ */ new Date()
            };
          }
          const rates = Object.values(historicalRates.rates).map((r) => r[quote.toUpperCase()]).filter((r) => r !== void 0);
          if (rates.length === 0) {
            return null;
          }
          const previousRate = rates[rates.length - 1] || currentRate;
          const change = currentRate - previousRate;
          const changePercent = previousRate !== 0 ? change / previousRate * 100 : 0;
          const high30d = Math.max(...rates, currentRate);
          const low30d = Math.min(...rates, currentRate);
          const midpoint = Math.floor(rates.length / 2);
          const recentAvg = rates.slice(0, midpoint).reduce((a, b) => a + b, 0) / midpoint || currentRate;
          const olderAvg = rates.slice(midpoint).reduce((a, b) => a + b, 0) / (rates.length - midpoint) || currentRate;
          let trend;
          const trendThreshold = 0.01;
          if (recentAvg > olderAvg * (1 + trendThreshold)) {
            trend = "bullish";
          } else if (recentAvg < olderAvg * (1 - trendThreshold)) {
            trend = "bearish";
          } else {
            trend = "neutral";
          }
          return {
            pair: `${base}/${quote}`,
            currentRate,
            previousRate,
            change,
            changePercent,
            high30d,
            low30d,
            trend,
            lastUpdated: /* @__PURE__ */ new Date()
          };
        } catch (error) {
          log.error("Frankfurter", `Failed to get summary for ${base}/${quote}`, { error: String(error) });
          return null;
        }
      }
      /**
       * Get summaries for all major forex pairs
       */
      async getMajorPairsSummaries() {
        const summaries = [];
        for (const pair of MAJOR_FOREX_PAIRS) {
          const summary = await this.getForexPairSummary(pair.base, pair.quote);
          if (summary) {
            summaries.push(summary);
          }
          await new Promise((resolve2) => setTimeout(resolve2, 100));
        }
        log.info("Frankfurter", `Fetched ${summaries.length} major forex pair summaries`);
        return summaries;
      }
      /**
       * Get USD strength index (simplified DXY proxy)
       * Compares USD against a basket of major currencies
       */
      async getUSDStrengthIndex() {
        try {
          const basket = [
            { currency: "EUR", weight: 0.576 },
            { currency: "JPY", weight: 0.136 },
            { currency: "GBP", weight: 0.119 },
            { currency: "CAD", weight: 0.091 },
            { currency: "SEK", weight: 0.042 },
            { currency: "CHF", weight: 0.036 }
          ];
          const rates = await this.getLatestRates("USD", basket.map((b) => b.currency));
          if (!rates) return null;
          const today = /* @__PURE__ */ new Date();
          const weekAgo = new Date(today);
          weekAgo.setDate(weekAgo.getDate() - 7);
          const historicalRates = await this.getHistoricalRates(
            "USD",
            this.formatDate(weekAgo),
            this.formatDate(today),
            basket.map((b) => b.currency)
          );
          const components = basket.map((b) => ({
            currency: b.currency,
            weight: b.weight,
            rate: rates.rates[b.currency] || 0,
            contribution: (rates.rates[b.currency] || 0) * b.weight
          }));
          const currentIndex = components.reduce((sum, c) => sum + c.contribution, 0) * 10;
          let trend = "stable";
          if (historicalRates) {
            const historicalDates = Object.keys(historicalRates.rates).sort();
            if (historicalDates.length > 0) {
              const oldestDate = historicalDates[0];
              const oldestRates = historicalRates.rates[oldestDate];
              const oldIndex = basket.reduce((sum, b) => sum + (oldestRates[b.currency] || 0) * b.weight, 0) * 10;
              const changePercent = (currentIndex - oldIndex) / oldIndex * 100;
              if (changePercent > 0.5) {
                trend = "weakening";
              } else if (changePercent < -0.5) {
                trend = "strengthening";
              }
            }
          }
          return {
            index: currentIndex,
            components,
            trend
          };
        } catch (error) {
          log.error("Frankfurter", "Failed to calculate USD strength index", { error: String(error) });
          return null;
        }
      }
      formatDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      /**
       * Clear all caches
       */
      clearCache() {
        this.latestRatesCache.clear();
        this.historicalRatesCache.clear();
        this.currenciesCache.clear();
      }
      /**
       * Check connection status
       */
      getConnectionStatus() {
        const cacheSize = this.latestRatesCache.size() + this.historicalRatesCache.size() + this.currenciesCache.size();
        return {
          connected: true,
          // No API key required
          cacheSize
        };
      }
    };
    frankfurter = new FrankfurterConnector();
  }
});

// server/ai/llmClient.ts
function createLLMError(message, provider, opts = {}) {
  const error = new Error(message);
  error.provider = provider;
  error.isRateLimit = opts.isRateLimit ?? false;
  error.isAuthError = opts.isAuthError ?? false;
  error.isBudgetExhausted = opts.isBudgetExhausted ?? false;
  error.statusCode = opts.statusCode;
  return error;
}
var init_llmClient = __esm({
  "server/ai/llmClient.ts"() {
    "use strict";
  }
});

// server/ai/openaiClient.ts
var DEFAULT_MODEL, DEFAULT_MAX_TOKENS, DEFAULT_TEMPERATURE, OpenAIClient, openaiClient;
var init_openaiClient = __esm({
  "server/ai/openaiClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL = "gpt-4o-mini";
    DEFAULT_MAX_TOKENS = 1e3;
    DEFAULT_TEMPERATURE = 0.3;
    OpenAIClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      constructor() {
        this.apiKey = process.env.AI_INTEGRATIONS_OPENAI_API_KEY || process.env.OPENAI_API_KEY || "";
        this.baseUrl = process.env.AI_INTEGRATIONS_OPENAI_BASE_URL || process.env.OPENAI_BASE_URL || "https://api.openai.com/v1";
        this.defaultModel = process.env.OPENAI_MODEL || DEFAULT_MODEL;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "openai";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError("OpenAI API key not configured", "openai", { isAuthError: true });
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        if (req.system) {
          messages2.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages2.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        const body = {
          model,
          messages: messages2,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        if (req.responseFormat) {
          if (req.responseFormat.type === "json_object") {
            body.response_format = { type: "json_object" };
          } else if (req.responseFormat.type === "json_schema" && req.responseFormat.json_schema) {
            body.response_format = {
              type: "json_schema",
              json_schema: req.responseFormat.json_schema
            };
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            const statusCode = response.status;
            const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
            const isAuthError = statusCode === 401 || statusCode === 403;
            log.error("OpenAI", "API request failed", {
              statusCode,
              latencyMs,
              isRateLimit,
              isAuthError
            });
            throw createLLMError(
              `OpenAI API error: ${statusCode}`,
              "openai",
              { isRateLimit, isAuthError, statusCode }
            );
          }
          const data = await response.json();
          const choice = data.choices[0];
          if (!choice) {
            throw createLLMError("OpenAI returned empty response", "openai");
          }
          const message = choice.message;
          const toolCalls = [];
          if (message.tool_calls) {
            for (const tc of message.tool_calls) {
              try {
                const args = JSON.parse(tc.function.arguments);
                toolCalls.push({
                  id: tc.id,
                  name: tc.function.name,
                  arguments: args
                });
              } catch (parseError) {
                log.warn("OpenAI", "Failed to parse tool call arguments", {
                  toolName: tc.function.name,
                  error: String(parseError)
                });
              }
            }
          }
          log.ai("OpenAI call complete", {
            model,
            tokensUsed: data.usage?.total_tokens,
            latencyMs,
            hasToolCalls: toolCalls.length > 0
          });
          return {
            text: message.content ?? void 0,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: data.usage?.total_tokens
          };
        } catch (error) {
          if (error.provider === "openai") {
            throw error;
          }
          log.error("OpenAI", "Request failed", { error: String(error) });
          throw createLLMError(`OpenAI request failed: ${String(error)}`, "openai");
        }
      }
    };
    openaiClient = new OpenAIClient();
  }
});

// server/ai/openrouterClient.ts
var DEFAULT_MODEL2, DEFAULT_MAX_TOKENS2, DEFAULT_TEMPERATURE2, BASE_URL, OpenRouterClient, openrouterClient;
var init_openrouterClient = __esm({
  "server/ai/openrouterClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL2 = "openai/gpt-4o-mini";
    DEFAULT_MAX_TOKENS2 = 1e3;
    DEFAULT_TEMPERATURE2 = 0.3;
    BASE_URL = "https://openrouter.ai/api/v1";
    OpenRouterClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      constructor() {
        this.apiKey = process.env.OPENROUTER_API_KEY || "";
        this.baseUrl = process.env.OPENROUTER_BASE_URL || BASE_URL;
        this.defaultModel = process.env.OPENROUTER_MODEL || DEFAULT_MODEL2;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "openrouter";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError("OpenRouter API key not configured", "openrouter", { isAuthError: true });
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        if (req.system) {
          messages2.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages2.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        const body = {
          model,
          messages: messages2,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS2,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE2
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        if (req.responseFormat) {
          if (req.responseFormat.type === "json_object") {
            body.response_format = { type: "json_object" };
          } else if (req.responseFormat.type === "json_schema" && req.responseFormat.json_schema) {
            body.response_format = {
              type: "json_schema",
              json_schema: req.responseFormat.json_schema
            };
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`,
              "HTTP-Referer": process.env.REPLIT_DEV_DOMAIN || "https://replit.com",
              "X-Title": "AI Active Trader"
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            const statusCode = response.status;
            const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
            const isAuthError = statusCode === 401 || statusCode === 403;
            log.error("OpenRouter", "API request failed", {
              statusCode,
              latencyMs,
              isRateLimit,
              isAuthError
            });
            throw createLLMError(
              `OpenRouter API error: ${statusCode}`,
              "openrouter",
              { isRateLimit, isAuthError, statusCode }
            );
          }
          const data = await response.json();
          const choice = data.choices[0];
          if (!choice) {
            throw createLLMError("OpenRouter returned empty response", "openrouter");
          }
          const message = choice.message;
          const toolCalls = [];
          if (message.tool_calls) {
            for (const tc of message.tool_calls) {
              try {
                const args = JSON.parse(tc.function.arguments);
                toolCalls.push({
                  id: tc.id,
                  name: tc.function.name,
                  arguments: args
                });
              } catch (parseError) {
                log.warn("OpenRouter", "Failed to parse tool call arguments", {
                  toolName: tc.function.name,
                  error: String(parseError)
                });
              }
            }
          }
          log.ai("OpenRouter call complete", {
            model,
            tokensUsed: data.usage?.total_tokens,
            latencyMs,
            hasToolCalls: toolCalls.length > 0
          });
          return {
            text: message.content ?? void 0,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: data.usage?.total_tokens
          };
        } catch (error) {
          if (error.provider === "openrouter") {
            throw error;
          }
          log.error("OpenRouter", "Request failed", { error: String(error) });
          throw createLLMError(`OpenRouter request failed: ${String(error)}`, "openrouter");
        }
      }
    };
    openrouterClient = new OpenRouterClient();
  }
});

// server/ai/groqClient.ts
var DEFAULT_MODEL3, DEFAULT_MAX_TOKENS3, DEFAULT_TEMPERATURE3, BASE_URL2, GroqClient, groqClient;
var init_groqClient = __esm({
  "server/ai/groqClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL3 = "llama-3.1-8b-instant";
    DEFAULT_MAX_TOKENS3 = 1e3;
    DEFAULT_TEMPERATURE3 = 0.3;
    BASE_URL2 = "https://api.groq.com/openai/v1";
    GroqClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      constructor() {
        this.apiKey = process.env.GROQ_API_KEY || "";
        this.baseUrl = process.env.GROQ_BASE_URL || BASE_URL2;
        this.defaultModel = process.env.GROQ_MODEL || DEFAULT_MODEL3;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "groq";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError("Groq API key not configured", "groq", { isAuthError: true });
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        if (req.system) {
          messages2.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages2.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        const body = {
          model,
          messages: messages2,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS3,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE3
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            const statusCode = response.status;
            const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
            const isAuthError = statusCode === 401 || statusCode === 403;
            log.error("Groq", "API request failed", {
              statusCode,
              latencyMs,
              isRateLimit,
              isAuthError
            });
            throw createLLMError(
              `Groq API error: ${statusCode}`,
              "groq",
              { isRateLimit, isAuthError, statusCode }
            );
          }
          const data = await response.json();
          const choice = data.choices[0];
          if (!choice) {
            throw createLLMError("Groq returned empty response", "groq");
          }
          const message = choice.message;
          const toolCalls = [];
          if (message.tool_calls) {
            for (const tc of message.tool_calls) {
              try {
                const args = JSON.parse(tc.function.arguments);
                toolCalls.push({
                  id: tc.id,
                  name: tc.function.name,
                  arguments: args
                });
              } catch (parseError) {
                log.warn("Groq", "Failed to parse tool call arguments", {
                  toolName: tc.function.name,
                  error: String(parseError)
                });
              }
            }
          }
          log.ai("Groq call complete", {
            model,
            tokensUsed: data.usage?.total_tokens,
            latencyMs,
            hasToolCalls: toolCalls.length > 0
          });
          return {
            text: message.content ?? void 0,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: data.usage?.total_tokens
          };
        } catch (error) {
          if (error.provider === "groq") {
            throw error;
          }
          log.error("Groq", "Request failed", { error: String(error) });
          throw createLLMError(`Groq request failed: ${String(error)}`, "groq");
        }
      }
    };
    groqClient = new GroqClient();
  }
});

// server/ai/togetherClient.ts
var DEFAULT_MODEL4, DEFAULT_MAX_TOKENS4, DEFAULT_TEMPERATURE4, BASE_URL3, TogetherClient, togetherClient;
var init_togetherClient = __esm({
  "server/ai/togetherClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL4 = "meta-llama/Llama-3.2-3B-Instruct-Turbo";
    DEFAULT_MAX_TOKENS4 = 1e3;
    DEFAULT_TEMPERATURE4 = 0.3;
    BASE_URL3 = "https://api.together.xyz/v1";
    TogetherClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      constructor() {
        this.apiKey = process.env.TOGETHER_API_KEY || "";
        this.baseUrl = process.env.TOGETHER_BASE_URL || BASE_URL3;
        this.defaultModel = process.env.TOGETHER_MODEL || DEFAULT_MODEL4;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "together";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError("Together.ai API key not configured", "together", { isAuthError: true });
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        if (req.system) {
          messages2.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages2.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        const body = {
          model,
          messages: messages2,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS4,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE4
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            const statusCode = response.status;
            const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
            const isAuthError = statusCode === 401 || statusCode === 403;
            log.error("Together", "API request failed", {
              statusCode,
              latencyMs,
              isRateLimit,
              isAuthError
            });
            throw createLLMError(
              `Together.ai API error: ${statusCode}`,
              "together",
              { isRateLimit, isAuthError, statusCode }
            );
          }
          const data = await response.json();
          const choice = data.choices[0];
          if (!choice) {
            throw createLLMError("Together.ai returned empty response", "together");
          }
          const message = choice.message;
          const toolCalls = [];
          if (message.tool_calls) {
            for (const tc of message.tool_calls) {
              try {
                const args = JSON.parse(tc.function.arguments);
                toolCalls.push({
                  id: tc.id,
                  name: tc.function.name,
                  arguments: args
                });
              } catch (parseError) {
                log.warn("Together", "Failed to parse tool call arguments", {
                  toolName: tc.function.name,
                  error: String(parseError)
                });
              }
            }
          }
          log.ai("Together.ai call complete", {
            model,
            tokensUsed: data.usage?.total_tokens,
            latencyMs,
            hasToolCalls: toolCalls.length > 0
          });
          return {
            text: message.content ?? void 0,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: data.usage?.total_tokens
          };
        } catch (error) {
          if (error.provider === "together") {
            throw error;
          }
          log.error("Together", "Request failed", { error: String(error) });
          throw createLLMError(`Together.ai request failed: ${String(error)}`, "together");
        }
      }
    };
    togetherClient = new TogetherClient();
  }
});

// server/ai/aimlClient.ts
var DEFAULT_MODEL5, DEFAULT_MAX_TOKENS5, DEFAULT_TEMPERATURE5, BASE_URL4, AIMLClient, aimlClient;
var init_aimlClient = __esm({
  "server/ai/aimlClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL5 = "gpt-4o-mini";
    DEFAULT_MAX_TOKENS5 = 1e3;
    DEFAULT_TEMPERATURE5 = 0.3;
    BASE_URL4 = "https://api.aimlapi.com/v1";
    AIMLClient = class {
      apiKey;
      baseUrl;
      defaultModel;
      constructor() {
        this.apiKey = process.env.AIMLAPI_KEY || "";
        this.baseUrl = process.env.AIMLAPI_BASE_URL || BASE_URL4;
        this.defaultModel = process.env.AIMLAPI_MODEL || DEFAULT_MODEL5;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "aimlapi";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError("AIML API key not configured", "aimlapi", { isAuthError: true });
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        if (req.system) {
          messages2.push({ role: "system", content: req.system });
        }
        for (const msg of req.messages) {
          messages2.push({
            role: msg.role,
            content: msg.content,
            tool_call_id: msg.tool_call_id,
            name: msg.name
          });
        }
        const body = {
          model,
          messages: messages2,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS5,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE5
        };
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools;
          if (req.toolChoice) {
            body.tool_choice = req.toolChoice;
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${this.apiKey}`
            },
            body: JSON.stringify(body)
          });
          const latencyMs = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text().catch(() => "Unknown error");
            const statusCode = response.status;
            const isRateLimit = statusCode === 429 || errorText.toLowerCase().includes("rate") || errorText.toLowerCase().includes("quota");
            const isAuthError = statusCode === 401 || statusCode === 403;
            log.error("AIMLAPI", "API request failed", {
              statusCode,
              latencyMs,
              isRateLimit,
              isAuthError
            });
            throw createLLMError(
              `AIML API error: ${statusCode}`,
              "aimlapi",
              { isRateLimit, isAuthError, statusCode }
            );
          }
          const data = await response.json();
          const choice = data.choices[0];
          if (!choice) {
            throw createLLMError("AIML API returned empty response", "aimlapi");
          }
          const message = choice.message;
          const toolCalls = [];
          if (message.tool_calls) {
            for (const tc of message.tool_calls) {
              try {
                const args = JSON.parse(tc.function.arguments);
                toolCalls.push({
                  id: tc.id,
                  name: tc.function.name,
                  arguments: args
                });
              } catch (parseError) {
                log.warn("AIMLAPI", "Failed to parse tool call arguments", {
                  toolName: tc.function.name,
                  error: String(parseError)
                });
              }
            }
          }
          log.ai("AIML API call complete", {
            model,
            tokensUsed: data.usage?.total_tokens,
            latencyMs,
            hasToolCalls: toolCalls.length > 0
          });
          return {
            text: message.content ?? void 0,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: data.usage?.total_tokens
          };
        } catch (error) {
          if (error.provider === "aimlapi") {
            throw error;
          }
          log.error("AIMLAPI", "Request failed", { error: String(error) });
          throw createLLMError(`AIML API request failed: ${String(error)}`, "aimlapi");
        }
      }
    };
    aimlClient = new AIMLClient();
  }
});

// server/ai/claudeClient.ts
var DEFAULT_MODEL6, DEFAULT_MAX_TOKENS6, ANTHROPIC_API_URL, ANTHROPIC_VERSION, ClaudeClient, claudeClient;
var init_claudeClient = __esm({
  "server/ai/claudeClient.ts"() {
    "use strict";
    init_logger();
    init_llmClient();
    DEFAULT_MODEL6 = "claude-sonnet-4-20250514";
    DEFAULT_MAX_TOKENS6 = 4096;
    ANTHROPIC_API_URL = "https://api.anthropic.com/v1/messages";
    ANTHROPIC_VERSION = "2023-06-01";
    ClaudeClient = class {
      apiKey;
      defaultModel;
      constructor() {
        this.apiKey = process.env.CLAUDE_API_KEY || process.env.ANTHROPIC_API_KEY || "";
        this.defaultModel = process.env.CLAUDE_MODEL || DEFAULT_MODEL6;
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "claude";
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw createLLMError(
            "Claude API key not configured. Set CLAUDE_API_KEY or ANTHROPIC_API_KEY environment variable.",
            "claude",
            { isAuthError: true }
          );
        }
        const model = req.model || this.defaultModel;
        const messages2 = [];
        for (const msg of req.messages) {
          if (msg.role === "system") {
            continue;
          }
          if (msg.role === "tool") {
            const toolResultBlock = {
              type: "tool_result",
              tool_use_id: msg.tool_call_id || "",
              content: [{ type: "text", text: msg.content }]
            };
            const lastMsg = messages2[messages2.length - 1];
            if (lastMsg && lastMsg.role === "user") {
              if (typeof lastMsg.content === "string") {
                lastMsg.content = [{ type: "text", text: lastMsg.content }];
              }
              lastMsg.content.push(toolResultBlock);
            } else {
              messages2.push({
                role: "user",
                content: [toolResultBlock]
              });
            }
          } else {
            messages2.push({
              role: msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
        }
        const body = {
          model,
          max_tokens: req.maxTokens ?? DEFAULT_MAX_TOKENS6,
          messages: messages2
        };
        if (req.system) {
          body.system = req.system;
        }
        if (req.temperature !== void 0) {
          body.temperature = req.temperature;
        }
        if (req.tools && req.tools.length > 0) {
          body.tools = req.tools.map((tool) => ({
            name: tool.function.name,
            description: tool.function.description,
            input_schema: {
              type: "object",
              properties: tool.function.parameters.properties,
              required: tool.function.parameters.required
            }
          }));
          if (req.toolChoice) {
            if (req.toolChoice === "auto") {
              body.tool_choice = { type: "auto" };
            } else if (req.toolChoice === "none") {
              delete body.tools;
            } else if (typeof req.toolChoice === "object" && req.toolChoice.function) {
              body.tool_choice = { type: "tool", name: req.toolChoice.function.name };
            }
          }
        }
        const startTime = Date.now();
        try {
          const response = await fetch(ANTHROPIC_API_URL, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-api-key": this.apiKey,
              "anthropic-version": ANTHROPIC_VERSION
            },
            body: JSON.stringify(body)
          });
          if (!response.ok) {
            const errorText = await response.text().catch(() => "");
            if (response.status === 401) {
              throw createLLMError(`Claude authentication failed: ${errorText}`, "claude", {
                isAuthError: true,
                statusCode: response.status
              });
            }
            if (response.status === 429) {
              throw createLLMError(`Claude rate limit exceeded: ${errorText}`, "claude", {
                isRateLimit: true,
                statusCode: response.status
              });
            }
            throw createLLMError(
              `Claude API error ${response.status}: ${errorText.substring(0, 200)}`,
              "claude",
              { statusCode: response.status }
            );
          }
          const data = await response.json();
          const latencyMs = Date.now() - startTime;
          let text3;
          const toolCalls = [];
          for (const block of data.content) {
            if (block.type === "text") {
              text3 = (text3 || "") + block.text;
            } else if (block.type === "tool_use") {
              toolCalls.push({
                id: block.id,
                name: block.name,
                arguments: block.input
              });
            }
          }
          log.debug("ClaudeClient", `Call completed in ${latencyMs}ms`, {
            model: data.model,
            inputTokens: data.usage.input_tokens,
            outputTokens: data.usage.output_tokens,
            stopReason: data.stop_reason
          });
          return {
            text: text3,
            content: text3,
            toolCalls: toolCalls.length > 0 ? toolCalls : void 0,
            raw: data,
            model: data.model,
            tokensUsed: {
              prompt: data.usage.input_tokens,
              completion: data.usage.output_tokens,
              total: data.usage.input_tokens + data.usage.output_tokens
            }
          };
        } catch (error) {
          if (error.provider === "claude") {
            throw error;
          }
          log.error("ClaudeClient", "API call failed", { error });
          throw createLLMError(
            `Claude API call failed: ${error instanceof Error ? error.message : "Unknown error"}`,
            "claude"
          );
        }
      }
    };
    claudeClient = new ClaudeClient();
  }
});

// server/ai/geminiClient.ts
var DEFAULT_TEMPERATURE6, DEFAULT_MODEL7, GEMINI_BASE_URL, GeminiClient, geminiClient;
var init_geminiClient = __esm({
  "server/ai/geminiClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_TEMPERATURE6 = 0.3;
    DEFAULT_MODEL7 = "gemini-2.5-flash-lite";
    GEMINI_BASE_URL = "https://generativelanguage.googleapis.com/v1beta";
    GeminiClient = class {
      apiKey;
      model;
      constructor() {
        this.apiKey = process.env.GOOGLE_GEMINI_API_KEY || process.env.GEMINI_API_KEY || "";
        this.model = process.env.GEMINI_MODEL || DEFAULT_MODEL7;
        if (this.apiKey) {
          log.info("GeminiClient", `Initialized with model: ${this.model}`, {
            apiKeyConfigured: true,
            freeModel: this.model.includes("flash-lite") || this.model.includes("flash")
          });
        } else {
          log.warn("GeminiClient", "No API key configured - Gemini provider will be unavailable");
        }
      }
      async call(req) {
        if (!this.apiKey) {
          throw new Error("Gemini API key not configured");
        }
        const model = req.model || this.model;
        const url = `${GEMINI_BASE_URL}/models/${model}:generateContent?key=${this.apiKey}`;
        log.debug("GeminiClient", "Preparing request", {
          model,
          systemPromptLength: req.systemPrompt?.length || 0,
          userPromptLength: req.userPrompt.length,
          temperature: req.temperature
        });
        const contents = [];
        if (req.systemPrompt) {
          contents.push({
            parts: [{ text: `${req.systemPrompt}

${req.userPrompt}` }],
            role: "user"
          });
        } else {
          contents.push({
            parts: [{ text: req.userPrompt }],
            role: "user"
          });
        }
        const geminiRequest = {
          contents,
          generationConfig: {
            temperature: req.temperature ?? DEFAULT_TEMPERATURE6,
            maxOutputTokens: req.maxTokens ?? 2048,
            topP: 0.95
          },
          // Disable safety filters for trading/financial content
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
          ]
        };
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(geminiRequest),
            signal: AbortSignal.timeout(6e4)
            // 60 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("GeminiClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            throw new Error(`Gemini API error ${response.status}: ${errorText}`);
          }
          const data = await response.json();
          if (!data.candidates || data.candidates.length === 0) {
            log.warn("GeminiClient", "No candidates in response (possibly blocked)", {
              latency
            });
            throw new Error("Gemini response blocked by safety filters");
          }
          const candidate = data.candidates[0];
          const content = candidate.content.parts.map((p) => p.text).join("");
          if (candidate.finishReason && candidate.finishReason !== "STOP") {
            log.warn("GeminiClient", `Response finished with reason: ${candidate.finishReason}`, {
              finishReason: candidate.finishReason,
              contentLength: content.length
            });
          }
          const usage = data.usageMetadata || {
            promptTokenCount: 0,
            candidatesTokenCount: 0,
            totalTokenCount: 0
          };
          log.info("GeminiClient", "Request successful", {
            model,
            latency,
            promptTokens: usage.promptTokenCount,
            completionTokens: usage.candidatesTokenCount,
            totalTokens: usage.totalTokenCount,
            finishReason: candidate.finishReason
          });
          return {
            content,
            model,
            provider: "gemini",
            usage: {
              promptTokens: usage.promptTokenCount,
              completionTokens: usage.candidatesTokenCount,
              totalTokens: usage.totalTokenCount
            },
            finishReason: candidate.finishReason,
            latencyMs: latency
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("GeminiClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.apiKey;
      }
      getProviderName() {
        return "gemini";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get available Gemini models
       */
      getAvailableModels() {
        return [
          "gemini-2.5-flash-lite",
          // Free tier optimized
          "gemini-2.5-flash",
          // Balanced
          "gemini-2.5-pro",
          // Highest quality
          "gemini-3-flash-preview"
          // Latest preview
        ];
      }
      /**
       * Check Gemini API health
       */
      async healthCheck() {
        if (!this.apiKey) {
          return false;
        }
        try {
          const response = await this.call({
            userPrompt: "Hello",
            systemPrompt: "You are a helpful assistant. Respond with 'OK'.",
            temperature: 0,
            maxTokens: 10
          });
          return response.content.toLowerCase().includes("ok");
        } catch (error) {
          log.error("GeminiClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    geminiClient = new GeminiClient();
  }
});

// server/ai/cloudflareClient.ts
var DEFAULT_MODEL8, DEFAULT_TEMPERATURE7, CloudflareClient, cloudflareClient;
var init_cloudflareClient = __esm({
  "server/ai/cloudflareClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_MODEL8 = "@cf/meta/llama-3.1-8b-instruct";
    DEFAULT_TEMPERATURE7 = 0.3;
    CloudflareClient = class {
      accountId;
      apiToken;
      model;
      constructor() {
        this.accountId = process.env.CLOUDFLARE_ACCOUNT_ID || "";
        this.apiToken = process.env.CLOUDFLARE_API_TOKEN || "";
        this.model = process.env.CLOUDFLARE_MODEL || DEFAULT_MODEL8;
        if (this.accountId && this.apiToken) {
          log.info("CloudflareClient", `Initialized with model: ${this.model}`, {
            accountConfigured: true,
            tokenConfigured: true
          });
        } else {
          log.warn("CloudflareClient", "Cloudflare credentials not configured - provider will be unavailable", {
            hasAccountId: !!this.accountId,
            hasApiToken: !!this.apiToken
          });
        }
      }
      async call(req) {
        if (!this.isAvailable()) {
          throw new Error("Cloudflare Workers AI credentials not configured");
        }
        const model = req.model || this.model;
        const url = `https://api.cloudflare.com/client/v4/accounts/${this.accountId}/ai/run/${model}`;
        log.debug("CloudflareClient", "Preparing request", {
          model,
          systemPresent: !!req.system,
          messageCount: req.messages?.length || 0
        });
        const messages2 = [];
        if (req.system) {
          messages2.push({
            role: "system",
            content: req.system
          });
        }
        if (req.messages && req.messages.length > 0) {
          for (const msg of req.messages) {
            if (msg.role === "tool") {
              continue;
            }
            messages2.push({
              role: msg.role === "system" ? "system" : msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
        }
        const cloudflareRequest = {
          messages: messages2,
          max_tokens: req.maxTokens ?? 2048,
          temperature: req.temperature ?? DEFAULT_TEMPERATURE7,
          stream: false
        };
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiToken}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(cloudflareRequest),
            signal: AbortSignal.timeout(3e4)
            // 30 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("CloudflareClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            let errorMessage = `Cloudflare API error ${response.status}`;
            try {
              const errorData = JSON.parse(errorText);
              if (errorData.errors && errorData.errors.length > 0) {
                errorMessage = errorData.errors[0].message;
              }
            } catch {
            }
            throw new Error(errorMessage);
          }
          const data = await response.json();
          if (!data.success) {
            const errorMsg = data.errors?.[0]?.message || "Unknown Cloudflare error";
            log.error("CloudflareClient", "API returned unsuccessful response", {
              error: errorMsg,
              latency
            });
            throw new Error(errorMsg);
          }
          const content = data.result.response;
          const estimatedTokens = Math.ceil((req.system || "").length / 4) + Math.ceil(req.messages.map((m) => m.content).join("").length / 4) + Math.ceil(content.length / 4);
          log.info("CloudflareClient", "Request successful", {
            model,
            latency,
            responseLength: content.length,
            estimatedTokens
          });
          return {
            content,
            model,
            raw: { provider: "cloudflare", latencyMs: latency },
            tokensUsed: {
              prompt: 0,
              // Cloudflare doesn't provide this
              completion: 0,
              total: estimatedTokens
              // Rough estimate
            }
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("CloudflareClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.accountId && !!this.apiToken;
      }
      getProviderName() {
        return "cloudflare";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get available Cloudflare AI models
       */
      getAvailableModels() {
        return [
          "@cf/meta/llama-3.1-8b-instruct",
          "@cf/meta/llama-3.2-1b-instruct",
          "@cf/meta/llama-3.2-3b-instruct",
          "@cf/mistral/mistral-7b-instruct-v0.2",
          "@cf/microsoft/phi-2",
          "@cf/qwen/qwen1.5-7b-chat-awq"
        ];
      }
      /**
       * Check Cloudflare Workers AI health
       */
      async healthCheck() {
        if (!this.isAvailable()) {
          return false;
        }
        try {
          const response = await this.call({
            system: "You are a helpful assistant. Respond with 'OK'.",
            messages: [{ role: "user", content: "Hello" }],
            temperature: 0,
            maxTokens: 10
          });
          return response.content?.toLowerCase().includes("ok") || false;
        } catch (error) {
          log.error("CloudflareClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    cloudflareClient = new CloudflareClient();
  }
});

// server/ai/huggingfaceClient.ts
var DEFAULT_MODEL9, DEFAULT_TEMPERATURE8, HF_API_BASE, HuggingFaceClient, huggingfaceClient;
var init_huggingfaceClient = __esm({
  "server/ai/huggingfaceClient.ts"() {
    "use strict";
    init_logger();
    DEFAULT_MODEL9 = "meta-llama/Llama-3.2-3B-Instruct";
    DEFAULT_TEMPERATURE8 = 0.3;
    HF_API_BASE = "https://api-inference.huggingface.co/models";
    HuggingFaceClient = class {
      apiKey;
      model;
      constructor() {
        this.apiKey = process.env.HUGGINGFACE_API_KEY || process.env.HF_API_KEY || "";
        this.model = process.env.HUGGINGFACE_MODEL || DEFAULT_MODEL9;
        if (this.apiKey) {
          log.info("HuggingFaceClient", `Initialized with model: ${this.model}`, {
            apiKeyConfigured: true
          });
        } else {
          log.warn("HuggingFaceClient", "No API key configured - HuggingFace provider will be unavailable");
        }
      }
      async call(req) {
        if (!this.apiKey) {
          throw new Error("HuggingFace API key not configured");
        }
        const model = req.model || this.model;
        const url = `${HF_API_BASE}/${model}`;
        log.debug("HuggingFaceClient", "Preparing request", {
          model,
          messageCount: req.messages?.length || 0
        });
        const isChatModel = model.includes("chat") || model.includes("instruct") || model.includes("Instruct");
        let requestBody;
        if (isChatModel && req.messages) {
          const messages2 = [];
          if (req.system) {
            messages2.push({ role: "system", content: req.system });
          }
          for (const msg of req.messages) {
            if (msg.role === "tool") continue;
            messages2.push({
              role: msg.role === "system" ? "system" : msg.role === "assistant" ? "assistant" : "user",
              content: msg.content
            });
          }
          requestBody = {
            messages: messages2,
            max_tokens: req.maxTokens ?? 2048,
            temperature: req.temperature ?? DEFAULT_TEMPERATURE8
          };
        } else {
          const prompt = req.system ? `${req.system}

${req.messages.map((m) => m.content).join("\n")}` : req.messages.map((m) => m.content).join("\n");
          requestBody = {
            inputs: prompt,
            parameters: {
              max_new_tokens: req.maxTokens ?? 512,
              temperature: req.temperature ?? DEFAULT_TEMPERATURE8,
              top_p: 0.95,
              return_full_text: false
            }
          };
        }
        const startTime = Date.now();
        try {
          const response = await fetch(url, {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${this.apiKey}`,
              "Content-Type": "application/json"
            },
            body: JSON.stringify(requestBody),
            signal: AbortSignal.timeout(6e4)
            // 60 second timeout
          });
          const latency = Date.now() - startTime;
          if (!response.ok) {
            const errorText = await response.text();
            log.error("HuggingFaceClient", "API request failed", {
              status: response.status,
              statusText: response.statusText,
              error: errorText,
              latency
            });
            if (response.status === 503) {
              throw new Error("Model is loading, please retry in a few seconds");
            } else if (response.status === 429) {
              throw new Error("Rate limit exceeded");
            } else {
              throw new Error(`HuggingFace API error ${response.status}: ${errorText}`);
            }
          }
          const data = await response.json();
          let content;
          let usage = { promptTokens: 0, completionTokens: 0, totalTokens: 0 };
          if (isChatModel && data.choices) {
            const chatData = data;
            content = chatData.choices[0].message.content;
            if (chatData.usage) {
              usage = {
                promptTokens: chatData.usage.prompt_tokens,
                completionTokens: chatData.usage.completion_tokens,
                totalTokens: chatData.usage.total_tokens
              };
            }
          } else if (Array.isArray(data)) {
            const textGenData = data;
            content = textGenData[0].generated_text;
            const inputText = req.system ? `${req.system}

${req.messages.map((m) => m.content).join("\n")}` : req.messages.map((m) => m.content).join("\n");
            usage = {
              promptTokens: Math.ceil(inputText.length / 4),
              completionTokens: Math.ceil(content.length / 4),
              totalTokens: Math.ceil((inputText.length + content.length) / 4)
            };
          } else {
            throw new Error("Unexpected response format from HuggingFace");
          }
          log.info("HuggingFaceClient", "Request successful", {
            model,
            latency,
            responseLength: content.length,
            totalTokens: usage.totalTokens
          });
          return {
            content,
            model,
            provider: "huggingface",
            usage,
            latencyMs: latency
          };
        } catch (error) {
          const latency = Date.now() - startTime;
          log.error("HuggingFaceClient", "Request failed", {
            error: error.message,
            latency,
            model
          });
          throw error;
        }
      }
      isAvailable() {
        return !!this.accountId && !!this.apiToken;
      }
      getProviderName() {
        return "huggingface";
      }
      getModel() {
        return this.model;
      }
      /**
       * Get popular Hugging Face models for different tasks
       */
      getAvailableModels() {
        return {
          textGeneration: [
            "meta-llama/Llama-3.2-3B-Instruct",
            "meta-llama/Llama-3.2-1B-Instruct",
            "mistralai/Mistral-7B-Instruct-v0.2",
            "microsoft/phi-2",
            "google/gemma-2b-it"
          ],
          sentiment: [
            "cardiffnlp/twitter-roberta-base-sentiment-latest",
            "finiteautomata/bertweet-base-sentiment-analysis",
            "ProsusAI/finbert"
          ],
          ner: [
            "dslim/bert-base-NER",
            "Jean-Baptiste/camembert-ner"
          ],
          classification: [
            "facebook/bart-large-mnli",
            "cross-encoder/nli-deberta-v3-base"
          ]
        };
      }
      /**
       * Call specialized sentiment model
       */
      async analyzeSentiment(text3) {
        const sentimentModel = "cardiffnlp/twitter-roberta-base-sentiment-latest";
        const url = `${HF_API_BASE}/${sentimentModel}`;
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${this.apiKey}`,
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ inputs: text3 })
        });
        if (!response.ok) {
          throw new Error(`Sentiment analysis failed: ${response.status}`);
        }
        const data = await response.json();
        const topResult = Array.isArray(data) && Array.isArray(data[0]) ? data[0][0] : data[0];
        return {
          label: topResult.label.toLowerCase(),
          score: topResult.score
        };
      }
      /**
       * Check HuggingFace API health
       */
      async healthCheck() {
        if (!this.isAvailable()) {
          return false;
        }
        try {
          const response = await this.call({
            system: "You are a helpful assistant.",
            messages: [{ role: "user", content: "Say 'OK'" }],
            temperature: 0,
            maxTokens: 10
          });
          return response.content.toLowerCase().includes("ok");
        } catch (error) {
          log.error("HuggingFaceClient", "Health check failed", {
            error: error.message
          });
          return false;
        }
      }
    };
    huggingfaceClient = new HuggingFaceClient();
  }
});

// server/ai/llmGateway.ts
var llmGateway_exports = {};
__export(llmGateway_exports, {
  callLLM: () => callLLM,
  clearLLMCache: () => clearLLMCache,
  clearLLMCacheForRole: () => clearLLMCacheForRole,
  generateTraceId: () => generateTraceId,
  getLLMCacheStats: () => getLLMCacheStats,
  llmGateway: () => llmGateway,
  resetLLMCacheStats: () => resetLLMCacheStats
});
import { randomUUID, createHash } from "crypto";
function estimateCost(tokens, costPer1kTokens) {
  return tokens / 1e3 * costPer1kTokens;
}
function getModelChain(role, criticality) {
  const roleChains = CRITICALITY_CHAINS[role];
  if (!roleChains) {
    return CRITICALITY_CHAINS.technical_analyst[criticality];
  }
  return roleChains[criticality] || roleChains.medium;
}
async function logCall(callData) {
  try {
    const metadata = JSON.stringify({
      traceId: callData.traceId,
      criticality: callData.criticality,
      purpose: callData.purpose
    });
    await db.insert(llmCalls).values({
      ...callData,
      metadata
    });
  } catch (error) {
    log.warn("LLMGateway", "Failed to log LLM call", { error: String(error) });
  }
}
function parseJsonFromText(text3) {
  try {
    return JSON.parse(text3);
  } catch {
    const jsonMatch = text3.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      try {
        return JSON.parse(jsonMatch[0]);
      } catch {
        return null;
      }
    }
    return null;
  }
}
function extractTokenCount(tokensUsed) {
  if (typeof tokensUsed === "number") {
    return tokensUsed;
  }
  if (tokensUsed && typeof tokensUsed === "object") {
    return tokensUsed.total || 0;
  }
  return 0;
}
async function callLLM(req) {
  const startTime = Date.now();
  const cachedEntry = llmResponseCache.get(req.role, req.system, req.messages);
  if (cachedEntry) {
    const cachedResponse = { ...cachedEntry.response, cached: true };
    if (llmResponseCache.needsRefresh(req.role, req.system, req.messages)) {
      callLLMUncached(req).then((freshResponse) => {
        llmResponseCache.set(req.role, req.system, req.messages, freshResponse);
      }).catch((err) => {
        log.warn("LLMGateway", "Background refresh failed", {
          role: req.role,
          error: String(err)
        });
      });
    }
    log.ai(`LLMGateway: Cache hit for ${req.role}/${req.criticality}`, {
      role: req.role,
      criticality: req.criticality,
      purpose: req.purpose,
      traceId: req.traceId,
      cacheKey: cachedEntry.cacheKey,
      cached: true
    });
    return cachedResponse;
  }
  const response = await callLLMUncached(req);
  llmResponseCache.set(req.role, req.system, req.messages, response);
  return response;
}
async function callLLMUncached(req) {
  const startTime = Date.now();
  const chain = getModelChain(req.role, req.criticality);
  let fallbackUsed = false;
  let fallbackReason;
  let lastError;
  for (let i = 0; i < chain.length; i++) {
    const modelConfig = chain[i];
    const providerEntry = PROVIDER_CLIENTS[modelConfig.provider];
    if (!providerEntry || !providerEntry.isAvailable()) {
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = `Primary provider ${modelConfig.provider} not available`;
      }
      continue;
    }
    try {
      const llmRequest = {
        model: modelConfig.model,
        system: req.system,
        messages: req.messages,
        tools: req.tools,
        toolChoice: req.toolChoice,
        maxTokens: req.maxTokens,
        temperature: req.temperature,
        responseFormat: req.responseFormat
      };
      const response = await providerEntry.client.call(llmRequest);
      const latencyMs2 = Date.now() - startTime;
      const tokensUsed = extractTokenCount(response.tokensUsed);
      const estimatedCost = estimateCost(tokensUsed, modelConfig.costPer1kTokens);
      let jsonResponse = null;
      if (req.responseFormat && response.text) {
        jsonResponse = parseJsonFromText(response.text);
      }
      await logCall({
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        promptTokens: null,
        completionTokens: null,
        totalTokens: tokensUsed || null,
        estimatedCost: estimatedCost.toFixed(6),
        latencyMs: latencyMs2,
        status: "success",
        systemPrompt: req.system || null,
        userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
        response: response.text?.slice(0, 2e3) || null,
        cacheHit: false,
        fallbackUsed,
        fallbackReason: fallbackReason || null,
        traceId: req.traceId,
        criticality: req.criticality,
        purpose: req.purpose
      });
      log.ai(`LLMGateway: ${req.role}/${req.criticality} succeeded`, {
        role: req.role,
        criticality: req.criticality,
        purpose: req.purpose,
        traceId: req.traceId,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed,
        estimatedCost,
        latencyMs: latencyMs2,
        fallbackUsed
      });
      return {
        text: response.text,
        json: jsonResponse,
        toolCalls: response.toolCalls,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed,
        latencyMs: latencyMs2,
        traceId: req.traceId,
        estimatedCost,
        fallbackUsed,
        fallbackReason
      };
    } catch (error) {
      lastError = error;
      const errorMsg = error.message || String(error);
      log.warn("LLMGateway", `${modelConfig.provider}/${modelConfig.model} failed for ${req.role}`, {
        traceId: req.traceId,
        criticality: req.criticality,
        purpose: req.purpose,
        error: errorMsg
      });
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = errorMsg.includes("rate") || errorMsg.includes("429") ? "Rate limit exceeded" : errorMsg.includes("401") || errorMsg.includes("403") ? "Auth error" : "Provider error";
      }
      if (errorMsg.includes("429") || errorMsg.includes("rate")) {
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
  }
  const latencyMs = Date.now() - startTime;
  await logCall({
    role: req.role,
    provider: "none",
    model: "none",
    status: "error",
    errorMessage: String(lastError),
    latencyMs,
    systemPrompt: req.system || null,
    userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
    fallbackUsed: true,
    fallbackReason: "All providers failed",
    traceId: req.traceId,
    criticality: req.criticality,
    purpose: req.purpose
  });
  log.error("LLMGateway", `All providers failed for ${req.role}/${req.criticality}`, {
    traceId: req.traceId,
    purpose: req.purpose,
    triedProviders: chain.map((c) => c.provider),
    lastError: String(lastError)
  });
  throw lastError || new Error(`All LLM providers failed for role: ${req.role}, criticality: ${req.criticality}`);
}
function generateTraceId() {
  return randomUUID();
}
function getLLMCacheStats() {
  return llmResponseCache.getStats();
}
function clearLLMCacheForRole(role) {
  llmResponseCache.clearRole(role);
}
function clearLLMCache() {
  llmResponseCache.clear();
}
function resetLLMCacheStats() {
  llmResponseCache.resetStats();
}
var ROLE_CACHE_CONFIG, LLMResponseCache, llmResponseCache, getEnvModel, CRITICALITY_CHAINS, PROVIDER_CLIENTS, llmGateway;
var init_llmGateway = __esm({
  "server/ai/llmGateway.ts"() {
    "use strict";
    init_logger();
    init_db();
    init_schema();
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    init_claudeClient();
    init_geminiClient();
    init_cloudflareClient();
    init_huggingfaceClient();
    ROLE_CACHE_CONFIG = {
      technical_analyst: {
        freshTtlMs: 5 * 60 * 1e3,
        // 5 minutes fresh
        staleTtlMs: 30 * 60 * 1e3,
        // 30 minutes stale
        enabled: true
      },
      risk_manager: {
        freshTtlMs: 5 * 60 * 1e3,
        // 5 minutes fresh
        staleTtlMs: 15 * 60 * 1e3,
        // 15 minutes stale
        enabled: true
      },
      market_news_summarizer: {
        freshTtlMs: 30 * 60 * 1e3,
        // 30 minutes fresh
        staleTtlMs: 2 * 60 * 60 * 1e3,
        // 2 hours stale
        enabled: true
      },
      execution_planner: {
        freshTtlMs: 1 * 60 * 1e3,
        // 1 minute fresh
        staleTtlMs: 5 * 60 * 1e3,
        // 5 minutes stale (time-sensitive)
        enabled: true
      },
      post_trade_reporter: {
        freshTtlMs: 30 * 60 * 1e3,
        // 30 minutes fresh
        staleTtlMs: 2 * 60 * 60 * 1e3,
        // 2 hours stale
        enabled: true
      },
      position_sizer: {
        freshTtlMs: 5 * 60 * 1e3,
        staleTtlMs: 15 * 60 * 1e3,
        enabled: true
      },
      sentiment_analyst: {
        freshTtlMs: 15 * 60 * 1e3,
        staleTtlMs: 60 * 60 * 1e3,
        enabled: true
      },
      post_trade_analyzer: {
        freshTtlMs: 30 * 60 * 1e3,
        staleTtlMs: 2 * 60 * 60 * 1e3,
        enabled: true
      },
      futures_analyst: {
        freshTtlMs: 5 * 60 * 1e3,
        staleTtlMs: 30 * 60 * 1e3,
        enabled: true
      }
    };
    LLMResponseCache = class {
      cache = /* @__PURE__ */ new Map();
      hitsByRole = /* @__PURE__ */ new Map();
      missByRole = /* @__PURE__ */ new Map();
      tokensSaved = 0;
      costSaved = 0;
      /**
       * Generate a cache key from role, system prompt, and messages
       */
      generateCacheKey(role, system, messages2) {
        const normalizeWhitespace = (text3) => text3.replace(/\s+/g, " ").trim();
        const systemNormalized = system ? normalizeWhitespace(system) : "";
        const messagesContent = messages2.map((m) => {
          if (typeof m.content === "string") {
            return normalizeWhitespace(m.content);
          }
          return JSON.stringify(m.content);
        }).join("|");
        const combined = `${role}:${systemNormalized}:${messagesContent}`;
        return createHash("md5").update(combined).digest("hex");
      }
      /**
       * Get cached response if available
       * Returns fresh or stale data based on TTL configuration
       */
      get(role, system, messages2) {
        const config = ROLE_CACHE_CONFIG[role];
        if (!config.enabled) {
          return null;
        }
        const cacheKey = this.generateCacheKey(role, system, messages2);
        const entry = this.cache.get(cacheKey);
        if (!entry) {
          this.recordMiss(role);
          return null;
        }
        const now = Date.now();
        if (now > entry.staleUntil) {
          this.cache.delete(cacheKey);
          this.recordMiss(role);
          return null;
        }
        this.recordHit(role);
        this.recordSavings(entry.response.tokensUsed, entry.response.estimatedCost);
        if (now <= entry.freshUntil) {
          log.ai(`LLMCache: Fresh hit for ${role}`, { cacheKey });
          return entry;
        }
        log.ai(`LLMCache: Stale hit for ${role} (will refresh in background)`, { cacheKey });
        return entry;
      }
      /**
       * Store response in cache with role-based TTL
       */
      set(role, system, messages2, response) {
        const config = ROLE_CACHE_CONFIG[role];
        if (!config.enabled) {
          return;
        }
        const cacheKey = this.generateCacheKey(role, system, messages2);
        const now = Date.now();
        const entry = {
          response: { ...response, cached: false },
          // Store original response without cache flag
          cachedAt: now,
          freshUntil: now + config.freshTtlMs,
          staleUntil: now + config.staleTtlMs,
          cacheKey
        };
        this.cache.set(cacheKey, entry);
        if (this.cache.size > 1e3) {
          this.evictOldest();
        }
      }
      /**
       * Check if entry needs refresh (is in stale window)
       */
      needsRefresh(role, system, messages2) {
        const config = ROLE_CACHE_CONFIG[role];
        if (!config.enabled) {
          return false;
        }
        const cacheKey = this.generateCacheKey(role, system, messages2);
        const entry = this.cache.get(cacheKey);
        if (!entry) {
          return false;
        }
        const now = Date.now();
        return now > entry.freshUntil && now <= entry.staleUntil;
      }
      /**
       * Clear cache for a specific role
       */
      clearRole(role) {
        const keysToDelete = [];
        this.cache.forEach((entry, key) => {
          if (key.startsWith(`${role}:`)) {
            keysToDelete.push(key);
          }
        });
        keysToDelete.forEach((key) => this.cache.delete(key));
      }
      /**
       * Clear all cache
       */
      clear() {
        this.cache.clear();
      }
      evictOldest() {
        let oldestKey = null;
        let oldestTime = Infinity;
        this.cache.forEach((entry, key) => {
          if (entry.cachedAt < oldestTime) {
            oldestTime = entry.cachedAt;
            oldestKey = key;
          }
        });
        if (oldestKey) {
          this.cache.delete(oldestKey);
        }
      }
      recordHit(role) {
        this.hitsByRole.set(role, (this.hitsByRole.get(role) || 0) + 1);
      }
      recordMiss(role) {
        this.missByRole.set(role, (this.missByRole.get(role) || 0) + 1);
      }
      recordSavings(tokens, cost) {
        this.tokensSaved += tokens;
        this.costSaved += cost;
      }
      /**
       * Get cache statistics by role
       */
      getStats() {
        let totalHits = 0;
        let totalMisses = 0;
        this.hitsByRole.forEach((hits) => totalHits += hits);
        this.missByRole.forEach((misses) => totalMisses += misses);
        const byRole = {};
        const hitRoles = Array.from(this.hitsByRole.keys());
        const missRoles = Array.from(this.missByRole.keys());
        const allRoles = /* @__PURE__ */ new Set([...hitRoles, ...missRoles]);
        allRoles.forEach((role) => {
          const hits = this.hitsByRole.get(role) || 0;
          const misses = this.missByRole.get(role) || 0;
          const total = hits + misses;
          byRole[role] = {
            hits,
            misses,
            hitRate: total > 0 ? hits / total : 0
          };
        });
        return {
          overall: {
            hitRate: totalHits + totalMisses > 0 ? totalHits / (totalHits + totalMisses) : 0,
            totalHits,
            totalMisses,
            tokensSaved: this.tokensSaved,
            costSaved: this.costSaved,
            cacheSize: this.cache.size
          },
          byRole
        };
      }
      /**
       * Reset statistics
       */
      resetStats() {
        this.hitsByRole.clear();
        this.missByRole.clear();
        this.tokensSaved = 0;
        this.costSaved = 0;
      }
    };
    llmResponseCache = new LLMResponseCache();
    getEnvModel = (key) => process.env[key];
    CRITICALITY_CHAINS = {
      technical_analyst: {
        high: [
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 },
          { provider: "openrouter", model: getEnvModel("TECH_ANALYST_HIGH_MODEL") || "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 },
          { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 }
        ],
        low: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      },
      risk_manager: {
        high: [
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 },
          { provider: "openrouter", model: getEnvModel("RISK_MANAGER_HIGH_MODEL") || "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 }
        ],
        low: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      },
      execution_planner: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "openrouter", model: "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "cloudflare", model: "@cf/meta/llama-3.1-8b-instruct", costPer1kTokens: 1e-5 },
          { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        low: [
          { provider: "cloudflare", model: "@cf/meta/llama-3.1-8b-instruct", costPer1kTokens: 1e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ]
      },
      market_news_summarizer: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        medium: [
          { provider: "gemini", model: "gemini-2.5-flash", costPer1kTokens: 2e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
          { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 }
        ],
        low: [
          { provider: "gemini", model: "gemini-2.5-flash-lite", costPer1kTokens: 1e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
          { provider: "cloudflare", model: "@cf/meta/llama-3.1-8b-instruct", costPer1kTokens: 1e-5 }
        ]
      },
      post_trade_reporter: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ],
        medium: [
          { provider: "gemini", model: "gemini-2.5-flash", costPer1kTokens: 2e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
          { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 }
        ],
        low: [
          { provider: "gemini", model: "gemini-2.5-flash-lite", costPer1kTokens: 1e-5 },
          { provider: "cloudflare", model: "@cf/meta/llama-3.1-8b-instruct", costPer1kTokens: 1e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
          { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 }
        ]
      },
      // NEW ROLE: Position sizing optimization based on risk and market conditions
      position_sizer: {
        high: [
          { provider: "openrouter", model: "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 },
          { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        low: [
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      },
      // NEW ROLE: Dedicated sentiment analysis from news and social sources
      sentiment_analyst: {
        high: [
          { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
          { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        medium: [
          { provider: "gemini", model: "gemini-2.5-flash", costPer1kTokens: 2e-5 },
          { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        low: [
          { provider: "gemini", model: "gemini-2.5-flash", costPer1kTokens: 2e-5 },
          { provider: "huggingface", model: "meta-llama/Llama-3.2-3B-Instruct", costPer1kTokens: 1e-5 },
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      },
      // NEW ROLE: Detailed post-trade performance analysis and learning
      post_trade_analyzer: {
        high: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 }
        ],
        medium: [
          { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        low: [
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      },
      // NEW ROLE: Specialized futures market analysis
      futures_analyst: {
        high: [
          { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
          { provider: "claude", model: "claude-sonnet-4-20250514", costPer1kTokens: 3e-3 },
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
        ],
        medium: [
          { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
          { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 }
        ],
        low: [
          { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 }
        ]
      }
    };
    PROVIDER_CLIENTS = {
      openai: { client: openaiClient, isAvailable: () => openaiClient.isAvailable() },
      groq: { client: groqClient, isAvailable: () => groqClient.isAvailable() },
      together: { client: togetherClient, isAvailable: () => togetherClient.isAvailable() },
      aimlapi: { client: aimlClient, isAvailable: () => aimlClient.isAvailable() },
      openrouter: { client: openrouterClient, isAvailable: () => openrouterClient.isAvailable() },
      claude: { client: claudeClient, isAvailable: () => claudeClient.isAvailable() },
      gemini: { client: geminiClient, isAvailable: () => geminiClient.isAvailable() },
      cloudflare: { client: cloudflareClient, isAvailable: () => cloudflareClient.isAvailable() },
      huggingface: { client: huggingfaceClient, isAvailable: () => huggingfaceClient.isAvailable() }
    };
    llmGateway = {
      call: callLLM,
      generateTraceId,
      getAvailableProviders: () => {
        return Object.entries(PROVIDER_CLIENTS).filter(([_, v]) => v.isAvailable()).map(([name]) => name);
      },
      cache: {
        getStats: getLLMCacheStats,
        clearRole: clearLLMCacheForRole,
        clear: clearLLMCache,
        resetStats: resetLLMCacheStats
      }
    };
  }
});

// server/ai/technical-analysis-fallback.ts
var CACHE_TTL_MS, analysisCache, ANALYSIS_CACHE_TTL_MS, ANALYSIS_STALE_TTL_MS, TechnicalAnalysisFallback, technicalAnalysisFallback;
var init_technical_analysis_fallback = __esm({
  "server/ai/technical-analysis-fallback.ts"() {
    "use strict";
    init_logger();
    CACHE_TTL_MS = 5 * 60 * 1e3;
    analysisCache = /* @__PURE__ */ new Map();
    ANALYSIS_CACHE_TTL_MS = 2 * 60 * 1e3;
    ANALYSIS_STALE_TTL_MS = 10 * 60 * 1e3;
    TechnicalAnalysisFallback = class {
      /**
       * Get cached analysis if available and fresh enough
       */
      getCachedAnalysis(symbol, currentPrice) {
        const cached = analysisCache.get(symbol);
        if (!cached) return null;
        const age = Date.now() - cached.timestamp.getTime();
        const priceChange = Math.abs(currentPrice - cached.marketData.currentPrice) / cached.marketData.currentPrice;
        if (priceChange > 0.02) {
          log.debug("TechFallback", `Cache invalid for ${symbol} - price moved ${(priceChange * 100).toFixed(1)}%`);
          return null;
        }
        if (age > ANALYSIS_STALE_TTL_MS) {
          analysisCache.delete(symbol);
          return null;
        }
        const isStale = age > ANALYSIS_CACHE_TTL_MS;
        return { decision: cached.decision, isStale };
      }
      /**
       * Cache analysis result
       */
      cacheAnalysis(symbol, decision, marketData) {
        analysisCache.set(symbol, {
          decision,
          timestamp: /* @__PURE__ */ new Date(),
          marketData
        });
      }
      /**
       * Main entry point - analyze opportunity without LLM
       */
      async analyzeWithoutLLM(symbol, marketData, newsContext, priceHistory) {
        const cached = this.getCachedAnalysis(symbol, marketData.currentPrice);
        if (cached && !cached.isStale) {
          log.info("TechFallback", `Using cached analysis for ${symbol}`, {
            confidence: cached.decision.confidence,
            action: cached.decision.action
          });
          return { ...cached.decision, reasoning: cached.decision.reasoning + " (cached)" };
        }
        log.info("TechFallback", `Analyzing ${symbol} without LLM`, {
          price: marketData.currentPrice,
          change: marketData.priceChangePercent24h,
          usingStaleCache: cached?.isStale || false
        });
        try {
          const prices = priceHistory || this.estimatePriceHistory(marketData);
          const indicators = this.calculateIndicators(prices, marketData);
          const regime = this.detectMarketRegime(indicators, marketData);
          const momentumScore = this.scoreMomentum(indicators, marketData);
          const trendScore = this.scoreTrend(indicators, marketData);
          const volatilityScore = this.scoreVolatility(indicators, marketData);
          const sentimentScore = this.scoreSentiment(newsContext);
          const combinedScore = this.combineScores([
            { score: momentumScore, weight: regime.adaptiveWeights.momentum },
            { score: trendScore, weight: regime.adaptiveWeights.trend },
            { score: volatilityScore, weight: regime.adaptiveWeights.volatility },
            { score: sentimentScore, weight: regime.adaptiveWeights.sentiment }
          ]);
          const decision = this.generateDecision(combinedScore, marketData, indicators, regime);
          this.cacheAnalysis(symbol, decision, marketData);
          log.info("TechFallback", `Analysis complete for ${symbol}`, {
            action: decision.action,
            confidence: decision.confidence,
            combinedSignal: combinedScore.signal,
            regime: regime.type,
            indicatorCount: Object.values(indicators).filter((v) => v !== null).length
          });
          return decision;
        } catch (error) {
          log.error("TechFallback", `Analysis failed for ${symbol}`, { error: String(error) });
          return this.getSafeDefaultDecision(symbol, marketData);
        }
      }
      /**
       * Estimate price history from available data when full history isn't available
       */
      estimatePriceHistory(marketData) {
        const { currentPrice, high24h, low24h, priceChange24h } = marketData;
        const prices = [];
        const previousPrice = priceChange24h !== void 0 ? currentPrice - priceChange24h : currentPrice;
        const range = (high24h ?? currentPrice * 1.02) - (low24h ?? currentPrice * 0.98);
        const volatility = range / currentPrice;
        for (let i = 0; i < 20; i++) {
          const progress = i / 19;
          const base = previousPrice + (currentPrice - previousPrice) * progress;
          const noise = (Math.random() - 0.5) * volatility * base * 0.5;
          prices.push(base + noise);
        }
        prices[prices.length - 1] = currentPrice;
        return prices;
      }
      /**
       * Calculate technical indicators from price data
       */
      calculateIndicators(prices, marketData) {
        const currentPrice = marketData.currentPrice;
        const high24h = marketData.high24h ?? currentPrice * 1.02;
        const low24h = marketData.low24h ?? currentPrice * 0.98;
        const rsi = this.calculateRSI(prices);
        const sma20 = this.calculateSMA(prices, 20);
        const sma50 = prices.length >= 50 ? this.calculateSMA(prices, 50) : null;
        const sma200 = prices.length >= 200 ? this.calculateSMA(prices, 200) : null;
        const macd = this.calculateMACD(prices);
        const bollinger = this.calculateBollinger(prices);
        const stochastic = this.calculateStochastic(prices, high24h, low24h);
        const williamsR = this.calculateWilliamsR(prices, high24h, low24h);
        const cci = this.calculateCCI(prices, high24h, low24h);
        const adxData = this.calculateADX(prices, high24h, low24h);
        const atr = this.calculateATR(prices, high24h, low24h);
        const rsiDivergence = this.detectRSIDivergence(prices, rsi);
        const macdDivergence = this.detectMACDDivergence(prices, macd.histogram);
        const trendStrength = this.determineTrendStrength(adxData.adx);
        return {
          // Core
          rsi,
          sma20,
          sma50,
          sma200,
          ema12: this.calculateEMA(prices, 12),
          ema26: this.calculateEMA(prices, 26),
          macdLine: macd.line,
          macdSignal: macd.signal,
          macdHistogram: macd.histogram,
          bollingerUpper: bollinger.upper,
          bollingerLower: bollinger.lower,
          bollingerWidth: bollinger.width,
          // Advanced
          stochasticK: stochastic.k,
          stochasticD: stochastic.d,
          williamsR,
          cci,
          adx: adxData.adx,
          plusDI: adxData.plusDI,
          minusDI: adxData.minusDI,
          atr,
          atrPercent: atr !== null ? atr / currentPrice * 100 : null,
          // Derived
          pricePosition: this.determinePricePosition(currentPrice, sma20),
          trendStrength,
          volumeTrend: this.estimateVolumeTrend(marketData),
          volatility: this.estimateVolatility(marketData),
          // Divergences
          rsiDivergence,
          macdDivergence
        };
      }
      /**
       * Calculate Stochastic Oscillator (%K and %D)
       */
      calculateStochastic(prices, high24h, low24h, period = 14) {
        if (prices.length < period) return { k: null, d: null };
        const recentPrices = prices.slice(-period);
        const highestHigh = Math.max(high24h, ...recentPrices);
        const lowestLow = Math.min(low24h, ...recentPrices);
        const currentPrice = prices[prices.length - 1];
        if (highestHigh === lowestLow) return { k: 50, d: 50 };
        const k = (currentPrice - lowestLow) / (highestHigh - lowestLow) * 100;
        const d = k * 0.85 + 7.5;
        return { k, d };
      }
      /**
       * Calculate Williams %R
       */
      calculateWilliamsR(prices, high24h, low24h, period = 14) {
        if (prices.length < period) return null;
        const recentPrices = prices.slice(-period);
        const highestHigh = Math.max(high24h, ...recentPrices);
        const lowestLow = Math.min(low24h, ...recentPrices);
        const currentPrice = prices[prices.length - 1];
        if (highestHigh === lowestLow) return -50;
        return (highestHigh - currentPrice) / (highestHigh - lowestLow) * -100;
      }
      /**
       * Calculate Commodity Channel Index (CCI)
       */
      calculateCCI(prices, high24h, low24h, period = 20) {
        if (prices.length < period) return null;
        const currentPrice = prices[prices.length - 1];
        const typicalPrice = (high24h + low24h + currentPrice) / 3;
        const sma = this.calculateSMA(prices, period);
        if (sma === null) return null;
        const recentPrices = prices.slice(-period);
        const meanDeviation = recentPrices.reduce((sum, p) => sum + Math.abs(p - sma), 0) / period;
        if (meanDeviation === 0) return 0;
        return (typicalPrice - sma) / (0.015 * meanDeviation);
      }
      /**
       * Calculate Average Directional Index (ADX) with +DI and -DI
       */
      calculateADX(prices, high24h, low24h, period = 14) {
        if (prices.length < period + 1) return { adx: null, plusDI: null, minusDI: null };
        let plusDM = 0;
        let minusDM = 0;
        let tr = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const currentHigh = Math.max(prices[i], prices[i] * 1.01);
          const currentLow = Math.min(prices[i], prices[i] * 0.99);
          const prevHigh = Math.max(prices[i - 1], prices[i - 1] * 1.01);
          const prevLow = Math.min(prices[i - 1], prices[i - 1] * 0.99);
          const prevClose = prices[i - 1];
          const trueRange = Math.max(
            currentHigh - currentLow,
            Math.abs(currentHigh - prevClose),
            Math.abs(currentLow - prevClose)
          );
          tr += trueRange;
          const upMove = currentHigh - prevHigh;
          const downMove = prevLow - currentLow;
          if (upMove > downMove && upMove > 0) {
            plusDM += upMove;
          }
          if (downMove > upMove && downMove > 0) {
            minusDM += downMove;
          }
        }
        if (tr === 0) return { adx: 0, plusDI: 0, minusDI: 0 };
        const plusDI = plusDM / tr * 100;
        const minusDI = minusDM / tr * 100;
        const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI + 1e-3) * 100;
        const adx = dx * 0.9;
        return { adx, plusDI, minusDI };
      }
      /**
       * Calculate Average True Range (ATR)
       */
      calculateATR(prices, high24h, low24h, period = 14) {
        if (prices.length < period + 1) return null;
        let atrSum = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const currentHigh = prices[i] * 1.005;
          const currentLow = prices[i] * 0.995;
          const prevClose = prices[i - 1];
          const trueRange = Math.max(
            currentHigh - currentLow,
            Math.abs(currentHigh - prevClose),
            Math.abs(currentLow - prevClose)
          );
          atrSum += trueRange;
        }
        return atrSum / period;
      }
      /**
       * Detect RSI divergence (price making new highs/lows but RSI not confirming)
       */
      detectRSIDivergence(prices, currentRSI) {
        if (currentRSI === null || prices.length < 10) return null;
        const recentPrices = prices.slice(-10);
        const midPrice = recentPrices[4];
        const currentPrice = recentPrices[recentPrices.length - 1];
        if (currentPrice < midPrice && currentRSI > 35) {
          return "bullish";
        }
        if (currentPrice > midPrice && currentRSI < 65) {
          return "bearish";
        }
        return null;
      }
      /**
       * Detect MACD divergence
       */
      detectMACDDivergence(prices, macdHistogram) {
        if (macdHistogram === null || prices.length < 10) return null;
        const recentPrices = prices.slice(-10);
        const midPrice = recentPrices[4];
        const currentPrice = recentPrices[recentPrices.length - 1];
        if (currentPrice < midPrice && macdHistogram > 0) {
          return "bullish";
        }
        if (currentPrice > midPrice && macdHistogram < 0) {
          return "bearish";
        }
        return null;
      }
      /**
       * Determine trend strength from ADX value
       */
      determineTrendStrength(adx) {
        if (adx === null) return null;
        if (adx >= 40) return "strong";
        if (adx >= 25) return "moderate";
        if (adx >= 15) return "weak";
        return "none";
      }
      /**
       * Detect market regime for adaptive weighting
       */
      detectMarketRegime(indicators, marketData) {
        const volatility = indicators.volatility;
        const adx = indicators.adx ?? 20;
        const bbWidth = indicators.bollingerWidth ?? 0.04;
        const priceChange = Math.abs(marketData.priceChangePercent24h ?? 0);
        let type = "ranging";
        let strength = 0.5;
        if (volatility === "high" || bbWidth > 0.08) {
          type = "volatile";
          strength = Math.min(bbWidth * 10, 1);
        } else if (adx >= 30) {
          const plusDI = indicators.plusDI ?? 0;
          const minusDI = indicators.minusDI ?? 0;
          type = plusDI > minusDI ? "trending_up" : "trending_down";
          strength = Math.min(adx / 50, 1);
        } else if (priceChange > 4 && adx >= 20) {
          type = "breakout";
          strength = Math.min(priceChange / 10, 1);
        } else {
          type = "ranging";
          strength = 1 - adx / 30;
        }
        const adaptiveWeights = this.getAdaptiveWeights(type, volatility);
        return { type, strength, adaptiveWeights };
      }
      /**
       * Get adaptive weights based on market regime
       */
      getAdaptiveWeights(regime, volatility) {
        const defaults = { momentum: 0.35, trend: 0.3, volatility: 0.15, sentiment: 0.2 };
        switch (regime) {
          case "trending_up":
          case "trending_down":
            return { momentum: 0.4, trend: 0.35, volatility: 0.1, sentiment: 0.15 };
          case "volatile":
            return { momentum: 0.25, trend: 0.25, volatility: 0.3, sentiment: 0.2 };
          case "breakout":
            return { momentum: 0.45, trend: 0.3, volatility: 0.1, sentiment: 0.15 };
          case "ranging":
            return { momentum: 0.3, trend: 0.25, volatility: 0.15, sentiment: 0.3 };
          default:
            return defaults;
        }
      }
      /**
       * Calculate RSI (Relative Strength Index)
       */
      calculateRSI(prices, period = 14) {
        if (prices.length < period + 1) return null;
        let gains = 0;
        let losses = 0;
        for (let i = prices.length - period; i < prices.length; i++) {
          const change = prices[i] - prices[i - 1];
          if (change > 0) gains += change;
          else losses -= change;
        }
        const avgGain = gains / period;
        const avgLoss = losses / period;
        if (avgLoss === 0) return 100;
        const rs = avgGain / avgLoss;
        return 100 - 100 / (1 + rs);
      }
      /**
       * Calculate Simple Moving Average
       */
      calculateSMA(prices, period) {
        if (prices.length < period) return null;
        const slice = prices.slice(-period);
        return slice.reduce((a, b) => a + b, 0) / period;
      }
      /**
       * Calculate Exponential Moving Average
       */
      calculateEMA(prices, period) {
        if (prices.length < period) return null;
        const multiplier = 2 / (period + 1);
        let ema = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
        for (let i = period; i < prices.length; i++) {
          ema = (prices[i] - ema) * multiplier + ema;
        }
        return ema;
      }
      /**
       * Calculate MACD with proper EMA9 signal line
       */
      calculateMACD(prices) {
        const ema12 = this.calculateEMA(prices, 12);
        const ema26 = this.calculateEMA(prices, 26);
        if (ema12 === null || ema26 === null) {
          return { line: null, signal: null, histogram: null };
        }
        const line = ema12 - ema26;
        if (prices.length >= 35) {
          const macdHistory = [];
          for (let i = 26; i <= prices.length; i++) {
            const slice = prices.slice(0, i);
            const e12 = this.calculateEMA(slice, 12);
            const e26 = this.calculateEMA(slice, 26);
            if (e12 !== null && e26 !== null) {
              macdHistory.push(e12 - e26);
            }
          }
          if (macdHistory.length >= 9) {
            const multiplier = 2 / (9 + 1);
            let ema = macdHistory.slice(0, 9).reduce((a, b) => a + b, 0) / 9;
            for (let i = 9; i < macdHistory.length; i++) {
              ema = (macdHistory[i] - ema) * multiplier + ema;
            }
            const signal2 = ema;
            const histogram2 = line - signal2;
            return { line, signal: signal2, histogram: histogram2 };
          }
        }
        const signal = line * 0.85;
        const histogram = line - signal;
        return { line, signal, histogram };
      }
      /**
       * Calculate Bollinger Bands with width metric
       */
      calculateBollinger(prices, period = 20) {
        const sma = this.calculateSMA(prices, period);
        if (sma === null || prices.length < period) {
          return { upper: null, lower: null, width: null };
        }
        const slice = prices.slice(-period);
        const variance = slice.reduce((sum, p) => sum + Math.pow(p - sma, 2), 0) / period;
        const stdDev = Math.sqrt(variance);
        const upper = sma + stdDev * 2;
        const lower = sma - stdDev * 2;
        const width = (upper - lower) / sma;
        return { upper, lower, width };
      }
      /**
       * Determine price position relative to SMA
       */
      determinePricePosition(price, sma) {
        if (sma === null) return null;
        const threshold = sma * 5e-3;
        if (price > sma + threshold) return "above_sma";
        if (price < sma - threshold) return "below_sma";
        return "at_sma";
      }
      /**
       * Estimate volume trend from available data
       */
      estimateVolumeTrend(marketData) {
        const changePercent = marketData.priceChangePercent24h ?? 0;
        if (Math.abs(changePercent) > 3) return "increasing";
        if (Math.abs(changePercent) < 1) return "stable";
        return "stable";
      }
      /**
       * Estimate volatility from price range
       */
      estimateVolatility(marketData) {
        const { currentPrice, high24h, low24h } = marketData;
        if (high24h === void 0 || low24h === void 0) return null;
        const range = (high24h - low24h) / currentPrice;
        if (range > 0.05) return "high";
        if (range > 0.02) return "medium";
        return "low";
      }
      /**
       * Score momentum indicators (enhanced with Stochastic, Williams %R, CCI)
       */
      scoreMomentum(indicators, marketData) {
        const signals = [];
        let bullishPoints = 0;
        let bearishPoints = 0;
        if (indicators.rsi !== null) {
          if (indicators.rsi < 30) {
            bullishPoints += 3;
            signals.push("RSI oversold (<30)");
          } else if (indicators.rsi > 70) {
            bearishPoints += 3;
            signals.push("RSI overbought (>70)");
          } else if (indicators.rsi < 40) {
            bullishPoints += 1;
            signals.push("RSI approaching oversold");
          } else if (indicators.rsi > 60) {
            bearishPoints += 1;
            signals.push("RSI elevated");
          }
        }
        if (indicators.stochasticK !== null && indicators.stochasticD !== null) {
          if (indicators.stochasticK < 20 && indicators.stochasticD < 20) {
            bullishPoints += 2;
            signals.push("Stochastic oversold");
          } else if (indicators.stochasticK > 80 && indicators.stochasticD > 80) {
            bearishPoints += 2;
            signals.push("Stochastic overbought");
          }
          if (indicators.stochasticK > indicators.stochasticD && indicators.stochasticK < 50) {
            bullishPoints += 1;
            signals.push("Stochastic bullish crossover");
          } else if (indicators.stochasticK < indicators.stochasticD && indicators.stochasticK > 50) {
            bearishPoints += 1;
            signals.push("Stochastic bearish crossover");
          }
        }
        if (indicators.williamsR !== null) {
          if (indicators.williamsR > -20) {
            bearishPoints += 1;
            signals.push("Williams %R overbought");
          } else if (indicators.williamsR < -80) {
            bullishPoints += 1;
            signals.push("Williams %R oversold");
          }
        }
        if (indicators.cci !== null) {
          if (indicators.cci > 100) {
            bearishPoints += 1;
            signals.push("CCI overbought (>100)");
          } else if (indicators.cci < -100) {
            bullishPoints += 1;
            signals.push("CCI oversold (<-100)");
          }
        }
        if (indicators.macdHistogram !== null) {
          if (indicators.macdHistogram > 0) {
            bullishPoints += 2;
            signals.push("MACD histogram positive");
          } else {
            bearishPoints += 2;
            signals.push("MACD histogram negative");
          }
          if (indicators.macdLine !== null && indicators.macdSignal !== null) {
            if (indicators.macdLine > indicators.macdSignal && indicators.macdHistogram > 0) {
              bullishPoints += 1;
              signals.push("MACD bullish crossover");
            } else if (indicators.macdLine < indicators.macdSignal && indicators.macdHistogram < 0) {
              bearishPoints += 1;
              signals.push("MACD bearish crossover");
            }
          }
        }
        if (indicators.rsiDivergence === "bullish") {
          bullishPoints += 3;
          signals.push("RSI bullish divergence detected");
        } else if (indicators.rsiDivergence === "bearish") {
          bearishPoints += 3;
          signals.push("RSI bearish divergence detected");
        }
        if (indicators.macdDivergence === "bullish") {
          bullishPoints += 2;
          signals.push("MACD bullish divergence");
        } else if (indicators.macdDivergence === "bearish") {
          bearishPoints += 2;
          signals.push("MACD bearish divergence");
        }
        const changePercent = marketData.priceChangePercent24h ?? 0;
        if (changePercent > 3) {
          bullishPoints += 2;
          signals.push(`Strong bullish momentum (+${changePercent.toFixed(1)}%)`);
        } else if (changePercent > 1) {
          bullishPoints += 1;
          signals.push(`Positive momentum (+${changePercent.toFixed(1)}%)`);
        } else if (changePercent < -3) {
          bearishPoints += 2;
          signals.push(`Strong bearish momentum (${changePercent.toFixed(1)}%)`);
        } else if (changePercent < -1) {
          bearishPoints += 1;
          signals.push(`Negative momentum (${changePercent.toFixed(1)}%)`);
        }
        const totalPoints = bullishPoints + bearishPoints;
        const strength = totalPoints > 0 ? Math.abs(bullishPoints - bearishPoints) / (totalPoints + 3) : 0;
        return {
          signal: bullishPoints > bearishPoints ? "bullish" : bearishPoints > bullishPoints ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: signals
        };
      }
      /**
       * Score trend indicators (enhanced with ADX, SMA200, multi-timeframe)
       */
      scoreTrend(indicators, marketData) {
        const signals = [];
        let bullishPoints = 0;
        let bearishPoints = 0;
        if (indicators.pricePosition === "above_sma") {
          bullishPoints += 2;
          signals.push("Price above SMA20");
        } else if (indicators.pricePosition === "below_sma") {
          bearishPoints += 2;
          signals.push("Price below SMA20");
        }
        if (indicators.sma50 !== null) {
          const price = marketData.currentPrice;
          if (price > indicators.sma50 * 1.02) {
            bullishPoints += 2;
            signals.push("Price above SMA50");
          } else if (price < indicators.sma50 * 0.98) {
            bearishPoints += 2;
            signals.push("Price below SMA50");
          }
        }
        if (indicators.sma200 !== null) {
          const price = marketData.currentPrice;
          if (price > indicators.sma200) {
            bullishPoints += 3;
            signals.push("Price above SMA200 (long-term bullish)");
          } else {
            bearishPoints += 3;
            signals.push("Price below SMA200 (long-term bearish)");
          }
        }
        if (indicators.adx !== null && indicators.plusDI !== null && indicators.minusDI !== null) {
          const trendStrength = indicators.trendStrength;
          if (trendStrength === "strong" || trendStrength === "moderate") {
            if (indicators.plusDI > indicators.minusDI) {
              bullishPoints += trendStrength === "strong" ? 4 : 2;
              signals.push(`ADX ${indicators.adx.toFixed(0)} - Strong uptrend (+DI>${-1}DI)`);
            } else {
              bearishPoints += trendStrength === "strong" ? 4 : 2;
              signals.push(`ADX ${indicators.adx.toFixed(0)} - Strong downtrend (-DI>+DI)`);
            }
          } else if (trendStrength === "weak" || trendStrength === "none") {
            signals.push(`ADX ${indicators.adx.toFixed(0)} - Ranging/weak trend`);
          }
        }
        if (indicators.ema12 !== null && indicators.ema26 !== null) {
          if (indicators.ema12 > indicators.ema26) {
            bullishPoints += 2;
            signals.push("EMA12 > EMA26 (bullish alignment)");
          } else {
            bearishPoints += 2;
            signals.push("EMA12 < EMA26 (bearish alignment)");
          }
        }
        if (indicators.bollingerLower !== null && indicators.bollingerUpper !== null) {
          const price = marketData.currentPrice;
          if (price < indicators.bollingerLower) {
            bullishPoints += 2;
            signals.push("Price at lower Bollinger (oversold)");
          } else if (price > indicators.bollingerUpper) {
            bearishPoints += 2;
            signals.push("Price at upper Bollinger (overbought)");
          }
          if (indicators.bollingerWidth !== null && indicators.bollingerWidth < 0.03) {
            signals.push("Bollinger squeeze - potential breakout");
          }
        }
        const totalPoints = bullishPoints + bearishPoints;
        const strength = totalPoints > 0 ? Math.abs(bullishPoints - bearishPoints) / (totalPoints + 4) : 0;
        return {
          signal: bullishPoints > bearishPoints ? "bullish" : bearishPoints > bullishPoints ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: signals
        };
      }
      /**
       * Score volatility conditions (enhanced with ATR analysis)
       */
      scoreVolatility(indicators, marketData) {
        const signals = [];
        let riskAdjustment = 0;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 5) {
            riskAdjustment -= 3;
            signals.push(`Very high ATR volatility (${indicators.atrPercent.toFixed(1)}%)`);
          } else if (indicators.atrPercent > 3) {
            riskAdjustment -= 2;
            signals.push(`High ATR volatility (${indicators.atrPercent.toFixed(1)}%)`);
          } else if (indicators.atrPercent > 1.5) {
            riskAdjustment -= 1;
            signals.push(`Moderate ATR volatility (${indicators.atrPercent.toFixed(1)}%)`);
          } else if (indicators.atrPercent < 1) {
            riskAdjustment += 1;
            signals.push(`Low ATR volatility (${indicators.atrPercent.toFixed(1)}%) - stable`);
          }
        }
        if (indicators.volatility === "high") {
          riskAdjustment -= 2;
          signals.push("High 24h price range volatility");
        } else if (indicators.volatility === "low") {
          riskAdjustment += 1;
          signals.push("Low 24h range - stable conditions");
        }
        if (indicators.bollingerWidth !== null) {
          if (indicators.bollingerWidth > 0.08) {
            riskAdjustment -= 2;
            signals.push("Wide Bollinger bands - high volatility");
          } else if (indicators.bollingerWidth < 0.02) {
            riskAdjustment += 1;
            signals.push("Tight Bollinger bands - low volatility");
          }
        }
        if (indicators.volumeTrend === "increasing") {
          signals.push("Volume increasing - confirming movement");
        }
        return {
          signal: riskAdjustment > 0 ? "bullish" : riskAdjustment < 0 ? "bearish" : "neutral",
          strength: Math.abs(riskAdjustment) / 5,
          indicators: signals
        };
      }
      /**
       * Score sentiment from news context
       */
      scoreSentiment(newsContext) {
        if (!newsContext) {
          return { signal: "neutral", strength: 0, indicators: ["No news data"] };
        }
        const signals = [];
        let sentimentScore = 0;
        if (newsContext.sentiment === "bullish") {
          sentimentScore = 1;
          signals.push("Bullish news sentiment");
        } else if (newsContext.sentiment === "bearish") {
          sentimentScore = -1;
          signals.push("Bearish news sentiment");
        }
        if (newsContext.headlines && newsContext.headlines.length > 0) {
          signals.push(`${newsContext.headlines.length} recent headlines`);
        }
        return {
          signal: sentimentScore > 0 ? "bullish" : sentimentScore < 0 ? "bearish" : "neutral",
          strength: Math.abs(sentimentScore) * 0.5,
          indicators: signals
        };
      }
      /**
       * Combine multiple signal scores with weights
       */
      combineScores(scores) {
        let weightedBullish = 0;
        let weightedBearish = 0;
        const allIndicators = [];
        for (const { score, weight } of scores) {
          if (score.signal === "bullish") {
            weightedBullish += score.strength * weight;
          } else if (score.signal === "bearish") {
            weightedBearish += score.strength * weight;
          }
          allIndicators.push(...score.indicators);
        }
        const netSignal = weightedBullish - weightedBearish;
        const strength = Math.abs(netSignal);
        return {
          signal: netSignal > 0.1 ? "bullish" : netSignal < -0.1 ? "bearish" : "neutral",
          strength: Math.min(strength, 1),
          indicators: allIndicators
        };
      }
      /**
       * Generate final decision from combined scores (enhanced with regime and ATR)
       */
      generateDecision(combinedScore, marketData, indicators, regime) {
        const { signal, strength, indicators: usedIndicators } = combinedScore;
        const actionThreshold = regime.type === "volatile" ? 0.35 : regime.type === "trending_up" || regime.type === "trending_down" ? 0.15 : regime.type === "breakout" ? 0.2 : 0.25;
        let action;
        if (signal === "bullish" && strength > actionThreshold) {
          action = "buy";
        } else if (signal === "bearish" && strength > actionThreshold) {
          action = "sell";
        } else {
          action = "hold";
        }
        const confidence = this.calculateDynamicConfidence(
          strength,
          indicators,
          regime,
          usedIndicators.length
        );
        const riskLevel = this.calculateRiskLevel(indicators, regime);
        const reasoning = this.generateReasoning(action, usedIndicators, signal, strength, regime);
        let stopLoss;
        let targetPrice;
        let suggestedQuantity;
        if (action === "buy") {
          const { stop, target } = this.calculateATRBasedTargets(marketData, indicators, riskLevel);
          stopLoss = stop;
          targetPrice = target;
          suggestedQuantity = this.calculateDynamicPositionSize(confidence, riskLevel, indicators);
        } else if (action === "sell") {
          suggestedQuantity = strength > 0.5 ? 0.5 : strength > 0.3 ? 0.35 : 0.25;
        }
        return {
          action,
          confidence,
          reasoning,
          riskLevel,
          suggestedQuantity,
          targetPrice,
          stopLoss
        };
      }
      /**
       * Calculate dynamic confidence based on multiple factors
       */
      calculateDynamicConfidence(signalStrength, indicators, regime, indicatorCount) {
        let confidence = 0.35 + signalStrength * 0.3;
        const totalPossibleIndicators = 20;
        const coverageRatio = indicatorCount / totalPossibleIndicators;
        confidence += coverageRatio * 0.1;
        if (regime.type === "trending_up" || regime.type === "trending_down") {
          confidence += 0.08;
        } else if (regime.type === "volatile") {
          confidence -= 0.1;
        } else if (regime.type === "breakout") {
          confidence += 0.05;
        }
        if (indicators.adx !== null) {
          if (indicators.adx >= 40) {
            confidence += 0.08;
          } else if (indicators.adx >= 25) {
            confidence += 0.04;
          } else if (indicators.adx < 15) {
            confidence -= 0.05;
          }
        }
        const oscillatorAgreement = this.checkOscillatorAgreement(indicators);
        confidence += oscillatorAgreement * 0.1;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 5) {
            confidence -= 0.1;
          } else if (indicators.atrPercent > 3) {
            confidence -= 0.05;
          }
        }
        return Math.max(0.4, Math.min(confidence, 0.88));
      }
      /**
       * Check if multiple oscillators agree on signal
       */
      checkOscillatorAgreement(indicators) {
        let bullishCount = 0;
        let bearishCount = 0;
        let total = 0;
        if (indicators.rsi !== null) {
          total++;
          if (indicators.rsi < 40) bullishCount++;
          else if (indicators.rsi > 60) bearishCount++;
        }
        if (indicators.stochasticK !== null) {
          total++;
          if (indicators.stochasticK < 30) bullishCount++;
          else if (indicators.stochasticK > 70) bearishCount++;
        }
        if (indicators.williamsR !== null) {
          total++;
          if (indicators.williamsR < -70) bullishCount++;
          else if (indicators.williamsR > -30) bearishCount++;
        }
        if (indicators.cci !== null) {
          total++;
          if (indicators.cci < -50) bullishCount++;
          else if (indicators.cci > 50) bearishCount++;
        }
        if (total === 0) return 0;
        return Math.max(bullishCount, bearishCount) / total;
      }
      /**
       * Calculate risk level from multiple volatility indicators
       */
      calculateRiskLevel(indicators, regime) {
        let riskScore = 0;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 4) riskScore += 3;
          else if (indicators.atrPercent > 2.5) riskScore += 2;
          else if (indicators.atrPercent > 1.5) riskScore += 1;
        }
        if (indicators.volatility === "high") riskScore += 2;
        else if (indicators.volatility === "medium") riskScore += 1;
        if (regime.type === "volatile") riskScore += 2;
        else if (regime.type === "breakout") riskScore += 1;
        else if (regime.type === "ranging") riskScore += 1;
        if (indicators.trendStrength === "strong") riskScore -= 1;
        else if (indicators.trendStrength === "none") riskScore += 1;
        if (riskScore >= 5) return "high";
        if (riskScore >= 2) return "medium";
        return "low";
      }
      /**
       * Calculate ATR-based stop loss and target price
       */
      calculateATRBasedTargets(marketData, indicators, riskLevel) {
        const currentPrice = marketData.currentPrice;
        const atr = indicators.atr;
        if (atr !== null && atr > 0) {
          const atrMultiplier = riskLevel === "high" ? 2.5 : riskLevel === "medium" ? 2 : 1.5;
          const targetMultiplier = riskLevel === "high" ? 3 : riskLevel === "medium" ? 3.5 : 4;
          const stop = currentPrice - atr * atrMultiplier;
          const target = currentPrice + atr * targetMultiplier;
          return { stop, target };
        }
        const stopPercent = riskLevel === "high" ? 0.05 : riskLevel === "medium" ? 0.04 : 0.03;
        const targetPercent = riskLevel === "high" ? 0.06 : riskLevel === "medium" ? 0.07 : 0.08;
        return {
          stop: currentPrice * (1 - stopPercent),
          target: currentPrice * (1 + targetPercent)
        };
      }
      /**
       * Calculate dynamic position size based on confidence and risk
       */
      calculateDynamicPositionSize(confidence, riskLevel, indicators) {
        const baseSize = riskLevel === "low" ? 0.1 : riskLevel === "medium" ? 0.06 : 0.03;
        const confidenceMultiplier = 0.7 + confidence * 0.6;
        let volatilityAdjustment = 1;
        if (indicators.atrPercent !== null) {
          if (indicators.atrPercent > 4) volatilityAdjustment = 0.6;
          else if (indicators.atrPercent > 2.5) volatilityAdjustment = 0.8;
          else if (indicators.atrPercent < 1) volatilityAdjustment = 1.2;
        }
        let trendBonus = 1;
        if (indicators.trendStrength === "strong") trendBonus = 1.15;
        else if (indicators.trendStrength === "moderate") trendBonus = 1.05;
        const finalSize = baseSize * confidenceMultiplier * volatilityAdjustment * trendBonus;
        return Math.max(0.02, Math.min(finalSize, 0.15));
      }
      /**
       * Generate human-readable reasoning with regime context
       */
      generateReasoning(action, indicators, signal, strength, regime) {
        const signalStrength = strength > 0.5 ? "strong" : strength > 0.25 ? "moderate" : "weak";
        const topIndicators = indicators.slice(0, 4).join(", ");
        const regimeDesc = this.getRegimeDescription(regime);
        if (action === "buy") {
          return `${signalStrength.charAt(0).toUpperCase() + signalStrength.slice(1)} bullish signal detected. ${regimeDesc}. Key indicators: ${topIndicators}. (Enhanced algorithmic analysis)`;
        } else if (action === "sell") {
          return `${signalStrength.charAt(0).toUpperCase() + signalStrength.slice(1)} bearish signal detected. ${regimeDesc}. Key indicators: ${topIndicators}. (Enhanced algorithmic analysis)`;
        } else {
          return `Mixed signals in ${regime.type} market. ${topIndicators}. Holding position recommended. (Enhanced algorithmic analysis)`;
        }
      }
      /**
       * Get human-readable regime description
       */
      getRegimeDescription(regime) {
        switch (regime.type) {
          case "trending_up":
            return "Market in confirmed uptrend";
          case "trending_down":
            return "Market in confirmed downtrend";
          case "volatile":
            return "High volatility environment";
          case "breakout":
            return "Potential breakout detected";
          case "ranging":
            return "Ranging/consolidation market";
          default:
            return "Market conditions analyzed";
        }
      }
      /**
       * Safe default when everything fails
       */
      getSafeDefaultDecision(symbol, marketData) {
        return {
          action: "hold",
          confidence: 0.4,
          reasoning: `Technical analysis fallback for ${symbol} at $${marketData.currentPrice.toFixed(2)}. Insufficient data for confident signal. Holding for safety.`,
          riskLevel: "medium"
        };
      }
      /**
       * Check if this fallback should be used
       */
      shouldUseFallback(llmError) {
        if (!llmError) return false;
        const errorLower = llmError.toLowerCase();
        return errorLower.includes("401") || // Unauthorized - invalid/not approved API key
        errorLower.includes("402") || // Payment required - out of credits
        errorLower.includes("403") || // Forbidden - access denied
        errorLower.includes("429") || // Rate limit exceeded
        errorLower.includes("rate limit") || errorLower.includes("budget") || errorLower.includes("credits") || errorLower.includes("payment") || errorLower.includes("all providers failed") || errorLower.includes("unavailable") || errorLower.includes("not approved") || errorLower.includes("api key") || errorLower.includes("authentication");
      }
    };
    technicalAnalysisFallback = new TechnicalAnalysisFallback();
  }
});

// server/ai/decision-engine.ts
import pLimit from "p-limit";
import pRetry from "p-retry";
async function executeToolCall(name, args) {
  try {
    switch (name) {
      case "get_news_sentiment": {
        const symbol = args.symbol;
        const isCrypto = args.isCrypto;
        if (isCrypto) {
          const sentiment = await gdelt.getCryptoSentiment(symbol);
          return JSON.stringify({
            sentiment: sentiment.sentiment,
            articleCount: sentiment.articleCount,
            averageTone: sentiment.averageTone,
            volumeSpike: sentiment.volumeSpike,
            topHeadlines: sentiment.topHeadlines.slice(0, 3)
          });
        } else {
          const articles = await gdelt.searchArticles(`${symbol} stock`, { timespan: "24hours", maxRecords: 20 });
          const tone = await gdelt.getToneTimeline(`${symbol} stock`, "24hours");
          const sentiment = tone.averageTone > 2 ? "bullish" : tone.averageTone < -2 ? "bearish" : "neutral";
          return JSON.stringify({
            sentiment,
            articleCount: articles.totalResults,
            averageTone: tone.averageTone,
            volumeSpike: false,
            topHeadlines: articles.articles.slice(0, 3).map((a) => a.title)
          });
        }
      }
      case "get_financial_ratios": {
        const ratios = await valyu.getFinancialRatios(args.symbol);
        return JSON.stringify({
          peRatio: ratios.peRatio,
          roe: ratios.roe,
          debtToEquity: ratios.debtToEquity,
          hasData: !!ratios.rawData
        });
      }
      case "get_earnings_data": {
        const earnings = await valyu.getEarnings(args.symbol);
        return JSON.stringify({
          eps: earnings.eps,
          revenue: earnings.revenue,
          hasData: !!earnings.rawData
        });
      }
      case "get_insider_transactions": {
        const insider = await valyu.getInsiderTransactions(args.symbol);
        const buys = insider.transactions.filter((t) => t.transactionType === "buy");
        const sells = insider.transactions.filter((t) => t.transactionType === "sell");
        return JSON.stringify({
          recentBuys: buys.length,
          recentSells: sells.length,
          netInsiderSentiment: insider.netInsiderSentiment,
          totalBuyValue: insider.totalBuyValue,
          totalSellValue: insider.totalSellValue
        });
      }
      case "get_additional_news": {
        const news = await newsapi.searchNews(args.query, "relevancy", 5);
        return JSON.stringify({
          articles: news.slice(0, 3).map((a) => ({
            title: a.title,
            source: a.source
          })),
          totalResults: news.length
        });
      }
      case "get_market_quote": {
        const quote = await finnhub.getQuote(args.symbol);
        return JSON.stringify({
          currentPrice: quote.c,
          change: quote.d,
          changePercent: quote.dp,
          high: quote.h,
          low: quote.l,
          open: quote.o,
          previousClose: quote.pc
        });
      }
      // New enhanced data source handlers
      case "get_short_interest": {
        const symbol = args.symbol;
        const summary = await finra.getShortInterestSummary(symbol);
        if (!summary) {
          return JSON.stringify({ error: `No short interest data available for ${symbol}` });
        }
        const analysis = finra.analyzeShortSqueezePotential(summary);
        return JSON.stringify({
          shortRatio: (summary.latestShortRatio * 100).toFixed(1) + "%",
          averageShortRatio: (summary.averageShortRatio * 100).toFixed(1) + "%",
          trend: summary.shortRatioTrend,
          daysToCover: summary.daysTocover?.toFixed(1) || "N/A",
          squeezePotential: analysis.potential,
          squeezeScore: analysis.score,
          factors: analysis.factors,
          dataSource: "FINRA RegSHO"
        });
      }
      case "get_sec_insider_activity": {
        const symbol = args.symbol;
        const summary = await secEdgarConnector.getInsiderSummary(symbol);
        if (!summary) {
          return JSON.stringify({ error: `No insider data available for ${symbol}` });
        }
        return JSON.stringify({
          totalBuys: summary.totalInsiderBuys,
          totalSells: summary.totalInsiderSells,
          netActivity: summary.netInsiderActivity,
          netValue: summary.netInsiderValue,
          buyToSellRatio: summary.buyToSellRatio === Infinity ? "All buys" : summary.buyToSellRatio.toFixed(2),
          sentiment: summary.sentiment,
          recentTransactions: summary.recentTransactions.slice(0, 5).map((t) => ({
            owner: t.reportingOwner,
            type: t.transactionType,
            shares: t.sharesTransacted,
            date: t.transactionDate.toISOString().split("T")[0]
          })),
          dataSource: "SEC EDGAR Form 4"
        });
      }
      case "get_sec_fundamentals": {
        const symbol = args.symbol;
        const facts = await secEdgarConnector.getCompanyFacts(symbol);
        if (!facts) {
          return JSON.stringify({ error: `No SEC fundamentals available for ${symbol}` });
        }
        return JSON.stringify({
          companyName: facts.name,
          revenue: facts.revenue ? `$${(facts.revenue / 1e9).toFixed(2)}B` : "N/A",
          netIncome: facts.netIncome ? `$${(facts.netIncome / 1e9).toFixed(2)}B` : "N/A",
          totalAssets: facts.totalAssets ? `$${(facts.totalAssets / 1e9).toFixed(2)}B` : "N/A",
          eps: facts.eps?.toFixed(2) || "N/A",
          sharesOutstanding: facts.sharesOutstanding ? `${(facts.sharesOutstanding / 1e9).toFixed(2)}B` : "N/A",
          dataSource: "SEC EDGAR XBRL"
        });
      }
      case "get_macro_indicators": {
        const indicators = await fred.getCriticalIndicators();
        const vix = indicators.find((i) => i.indicatorId === "VIXCLS");
        const fedFunds = indicators.find((i) => i.indicatorId === "FEDFUNDS");
        const yieldCurve = indicators.find((i) => i.indicatorId === "T10Y2Y");
        const unemployment = indicators.find((i) => i.indicatorId === "UNRATE");
        const cpi = indicators.find((i) => i.indicatorId === "CPIAUCSL");
        let marketRegime = "neutral";
        if (vix && vix.latestValue !== null) {
          if (vix.latestValue > 30) marketRegime = "risk_off (high fear)";
          else if (vix.latestValue < 15) marketRegime = "risk_on (low fear)";
        }
        return JSON.stringify({
          vix: vix?.latestValue?.toFixed(1) || "N/A",
          fedFundsRate: fedFunds?.latestValue?.toFixed(2) + "%" || "N/A",
          yieldCurve: yieldCurve?.latestValue?.toFixed(2) + "%" || "N/A",
          unemployment: unemployment?.latestValue?.toFixed(1) + "%" || "N/A",
          inflation: cpi?.changePercent?.toFixed(1) + "% (YoY change)" || "N/A",
          marketRegime,
          dataSource: "FRED (Federal Reserve)"
        });
      }
      case "get_forex_rate": {
        const base = args.base;
        const quote = args.quote;
        const summary = await frankfurter.getForexPairSummary(base, quote);
        if (!summary) {
          return JSON.stringify({ error: `No forex data available for ${base}/${quote}` });
        }
        return JSON.stringify({
          pair: summary.pair,
          rate: summary.currentRate.toFixed(4),
          change: summary.change.toFixed(4),
          changePercent: summary.changePercent.toFixed(2) + "%",
          high30d: summary.high30d.toFixed(4),
          low30d: summary.low30d.toFixed(4),
          trend: summary.trend,
          dataSource: "Frankfurter (ECB)"
        });
      }
      case "get_usd_strength": {
        const strength = await frankfurter.getUSDStrengthIndex();
        if (!strength) {
          return JSON.stringify({ error: "Unable to calculate USD strength index" });
        }
        return JSON.stringify({
          index: strength.index.toFixed(2),
          trend: strength.trend,
          components: strength.components.map((c) => ({
            currency: c.currency,
            weight: (c.weight * 100).toFixed(1) + "%",
            rate: c.rate.toFixed(4)
          })),
          dataSource: "Frankfurter (ECB)"
        });
      }
      default:
        return JSON.stringify({ error: `Unknown tool: ${name}` });
    }
  } catch (error) {
    log.warn("AI", `Tool call failed: ${name}`, { error: String(error) });
    return JSON.stringify({ error: `Failed to fetch data: ${error.message}` });
  }
}
function isRateLimitOrQuotaError(error) {
  const errorMsg = error?.message || String(error);
  return errorMsg.includes("401") || // Unauthorized - invalid/not approved API key
  errorMsg.includes("429") || errorMsg.includes("402") || // Payment required - budget exhausted
  errorMsg.includes("403") || errorMsg.includes("RATELIMIT_EXCEEDED") || errorMsg.toLowerCase().includes("quota") || errorMsg.toLowerCase().includes("rate limit") || errorMsg.toLowerCase().includes("spend limit") || errorMsg.toLowerCase().includes("exceeded") || errorMsg.toLowerCase().includes("budget") || errorMsg.toLowerCase().includes("credits") || errorMsg.toLowerCase().includes("payment");
}
var DATA_QUERY_TOOLS, limit, AIDecisionEngine, aiDecisionEngine;
var init_decision_engine = __esm({
  "server/ai/decision-engine.ts"() {
    "use strict";
    init_logger();
    init_gdelt();
    init_valyu();
    init_finnhub();
    init_newsapi();
    init_finra();
    init_sec_edgar();
    init_fred();
    init_frankfurter();
    init_llmGateway();
    init_technical_analysis_fallback();
    DATA_QUERY_TOOLS = [
      {
        type: "function",
        function: {
          name: "get_news_sentiment",
          description: "Get real-time news sentiment and headlines for a stock or crypto symbol from GDELT (free, updates every 15 min)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker (e.g., AAPL, MSFT) or crypto name (e.g., Bitcoin, Ethereum)"
              },
              isCrypto: {
                type: "boolean",
                description: "Whether this is a cryptocurrency (true) or stock (false)"
              }
            },
            required: ["symbol", "isCrypto"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_financial_ratios",
          description: "Get fundamental financial ratios for a stock (P/E, ROE, debt-to-equity, etc.) from Valyu.ai",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_earnings_data",
          description: "Get recent earnings data (EPS, revenue, surprises) for a stock",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_insider_transactions",
          description: "Get recent insider trading activity (buys/sells by executives)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_additional_news",
          description: "Get additional news headlines from NewsAPI for broader market context",
          parameters: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "Search query for news (e.g., 'Apple earnings', 'tech sector')"
              }
            },
            required: ["query"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_market_quote",
          description: "Get real-time stock quote data from Finnhub",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      // New tools for enhanced data sources
      {
        type: "function",
        function: {
          name: "get_short_interest",
          description: "Get FINRA RegSHO short interest data including short ratio, days to cover, and short squeeze potential",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT, GME)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_sec_insider_activity",
          description: "Get SEC EDGAR Form 4 insider trading activity (executives buying/selling) with sentiment analysis",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_sec_fundamentals",
          description: "Get SEC EDGAR company fundamentals from official filings (revenue, net income, assets, EPS)",
          parameters: {
            type: "object",
            properties: {
              symbol: {
                type: "string",
                description: "The stock ticker symbol (e.g., AAPL, MSFT)"
              }
            },
            required: ["symbol"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_macro_indicators",
          description: "Get FRED macroeconomic indicators including VIX, Fed Funds Rate, yield curve spread, unemployment rate, and inflation (CPI). Returns all critical indicators.",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_forex_rate",
          description: "Get exchange rate between two currencies from Frankfurter (ECB data)",
          parameters: {
            type: "object",
            properties: {
              base: {
                type: "string",
                description: "Base currency code (e.g., USD, EUR, GBP)"
              },
              quote: {
                type: "string",
                description: "Quote currency code (e.g., EUR, JPY, GBP)"
              }
            },
            required: ["base", "quote"]
          }
        }
      },
      {
        type: "function",
        function: {
          name: "get_usd_strength",
          description: "Get USD strength index (DXY proxy) showing dollar strength against major currencies",
          parameters: {
            type: "object",
            properties: {},
            required: []
          }
        }
      }
    ];
    limit = pLimit(2);
    AIDecisionEngine = class {
      getSystemPrompt() {
        return `You are an expert trading analyst AI assistant for a paper trading application. Your role is to analyze market data and provide trading recommendations.

You MUST respond with a valid JSON object containing these exact fields:
- action: "buy", "sell", or "hold"
- confidence: number between 0 and 1 (e.g., 0.75 for 75% confidence)
- reasoning: a brief explanation of your decision (2-3 sentences)
- riskLevel: "low", "medium", or "high"
- suggestedQuantity: optional number suggesting position size as a percentage of portfolio (0.01-0.25)
- targetPrice: optional number for take-profit target
- stopLoss: optional number for stop-loss level

Consider:
1. Current price action and technical indicators implied by price data
2. Market sentiment from news if available
3. Risk management - never suggest more than 25% of portfolio on any single trade
4. The strategy type and parameters if provided

This is for PAPER TRADING only - educational purposes. Be decisive but conservative.`;
      }
      async analyzeOpportunity(symbol, marketData, newsContext, strategy, options) {
        const systemPrompt = this.getSystemPrompt();
        const userPrompt = this.buildUserPrompt(symbol, marketData, newsContext, strategy);
        const traceId = options?.traceId || generateTraceId();
        const criticality = options?.criticality || "high";
        return limit(
          () => pRetry(
            async () => {
              try {
                const response = await callLLM({
                  role: "technical_analyst",
                  criticality,
                  purpose: "analyze_trade_opportunity",
                  traceId,
                  symbol,
                  system: systemPrompt,
                  messages: [{ role: "user", content: userPrompt }],
                  responseFormat: { type: "json_object" },
                  maxTokens: 1024,
                  temperature: 0.3
                });
                const content = response.text;
                if (!content) {
                  log.warn("AI", "Empty response from LLM Gateway", { traceId });
                  return { ...this.getDefaultDecision("AI returned empty response"), traceId };
                }
                const parsed = response.json || JSON.parse(content);
                return { ...this.validateDecision(parsed), traceId };
              } catch (error) {
                const errorMsg = error.message || String(error);
                log.error("AI", "LLM Gateway failed", { traceId, error: errorMsg });
                if (isRateLimitOrQuotaError(error) || technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
                  log.info("AI", "Using technical analysis fallback", { symbol, traceId, reason: errorMsg });
                  const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
                    symbol,
                    marketData,
                    newsContext
                  );
                  return { ...fallbackDecision, traceId, aiDecisionId: `tech-fallback-${Date.now()}` };
                }
                return { ...this.getDefaultDecision(`AI analysis failed: ${errorMsg}`), traceId };
              }
            },
            {
              retries: 2,
              minTimeout: 1e3,
              maxTimeout: 5e3,
              factor: 2,
              onFailedAttempt: async (error) => {
                const errorMsg = error.error.message || String(error.error);
                if (error.retriesLeft === 0 && technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
                  log.info("AI", "Retries exhausted, technical fallback will be used", { symbol, traceId });
                }
              }
            }
          )
        ).catch(async (error) => {
          const errorMsg = error.message || String(error);
          log.warn("AI", "All LLM retries failed, using technical analysis fallback", { symbol, traceId, error: errorMsg });
          const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
            symbol,
            marketData,
            newsContext
          );
          return { ...fallbackDecision, traceId, aiDecisionId: `tech-fallback-${Date.now()}` };
        });
      }
      async analyzeWithFunctionCalling(symbol, marketData, newsContext, strategy, options) {
        const systemPrompt = `You are an expert trading analyst AI assistant for a paper trading application.

You have access to tools to query real-time market data, news sentiment, financial ratios, earnings, and insider trading activity. Use these tools when you need additional information to make a better trading decision.

After gathering the data you need, provide your final recommendation as a valid JSON object with these fields:
- action: "buy", "sell", or "hold"
- confidence: number between 0 and 1
- reasoning: explanation of your decision including data sources used
- riskLevel: "low", "medium", or "high"
- suggestedQuantity: optional position size (0.01-0.25)
- targetPrice: optional take-profit target
- stopLoss: optional stop-loss level

This is for PAPER TRADING only. Be decisive but conservative.`;
        const userPrompt = this.buildUserPrompt(symbol, marketData, newsContext, strategy);
        const toolsUsed = [];
        const traceId = options?.traceId || generateTraceId();
        const criticality = options?.criticality || "high";
        try {
          const messages2 = [
            { role: "user", content: userPrompt }
          ];
          let response = await callLLM({
            role: "technical_analyst",
            criticality,
            purpose: "analyze_with_tools",
            traceId,
            symbol,
            system: systemPrompt,
            messages: messages2,
            tools: DATA_QUERY_TOOLS,
            toolChoice: "auto",
            maxTokens: 2048,
            temperature: 0.3
          });
          let iterations = 0;
          const maxIterations = 3;
          while (response.toolCalls && response.toolCalls.length > 0 && iterations < maxIterations) {
            for (const toolCall of response.toolCalls) {
              log.debug("AI", `Function call: ${toolCall.name}`, { args: toolCall.arguments });
              toolsUsed.push(toolCall.name);
              const result = await executeToolCall(toolCall.name, toolCall.arguments);
              messages2.push({
                role: "tool",
                content: result,
                tool_call_id: toolCall.id
              });
            }
            response = await callLLM({
              role: "technical_analyst",
              criticality,
              purpose: "analyze_with_tools_continue",
              traceId,
              symbol,
              system: systemPrompt,
              messages: messages2,
              tools: DATA_QUERY_TOOLS,
              toolChoice: "auto",
              maxTokens: 2048,
              temperature: 0.3
            });
            iterations++;
          }
          const content = response.text;
          if (!content) {
            log.warn("AI", "Empty response from function-calling analysis", { traceId });
            return { ...this.getDefaultDecision("Empty response"), toolsUsed, traceId };
          }
          const jsonMatch = content.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            log.warn("AI", "No JSON found in function-calling response", { traceId });
            return { ...this.getDefaultDecision("No JSON in response"), toolsUsed, traceId };
          }
          const parsed = JSON.parse(jsonMatch[0]);
          log.info("AI", `Function-calling analysis complete`, {
            symbol,
            action: parsed.action,
            toolsUsed: toolsUsed.length,
            traceId
          });
          return { ...this.validateDecision(parsed), toolsUsed, traceId };
        } catch (error) {
          const errorMsg = error.message || String(error);
          log.error("AI", "Function-calling analysis failed", { error: errorMsg, traceId });
          if (technicalAnalysisFallback.shouldUseFallback(errorMsg)) {
            log.info("AI", "Using technical analysis fallback for function-calling", { symbol, traceId });
            const fallbackDecision = await technicalAnalysisFallback.analyzeWithoutLLM(
              symbol,
              marketData,
              newsContext
            );
            return { ...fallbackDecision, toolsUsed, traceId, aiDecisionId: `tech-fallback-fc-${Date.now()}` };
          }
          return { ...await this.analyzeOpportunity(symbol, marketData, newsContext, strategy, { traceId, criticality }), toolsUsed };
        }
      }
      getDefaultDecision(reason) {
        return {
          action: "hold",
          confidence: 0.3,
          reasoning: reason + ". Defaulting to hold for safety.",
          riskLevel: "medium"
        };
      }
      buildUserPrompt(symbol, marketData, newsContext, strategy) {
        let prompt = `Analyze the following trading opportunity and provide a recommendation:

## Asset
Symbol: ${symbol}

## Market Data
- Current Price: $${marketData.currentPrice.toFixed(4)}`;
        if (marketData.priceChange24h !== void 0) {
          prompt += `
- 24h Price Change: $${marketData.priceChange24h.toFixed(4)}`;
        }
        if (marketData.priceChangePercent24h !== void 0) {
          prompt += `
- 24h Change %: ${marketData.priceChangePercent24h.toFixed(2)}%`;
        }
        if (marketData.high24h !== void 0) {
          prompt += `
- 24h High: $${marketData.high24h.toFixed(4)}`;
        }
        if (marketData.low24h !== void 0) {
          prompt += `
- 24h Low: $${marketData.low24h.toFixed(4)}`;
        }
        if (marketData.volume !== void 0) {
          prompt += `
- 24h Volume: $${marketData.volume.toLocaleString()}`;
        }
        if (newsContext) {
          prompt += `

## News Context`;
          if (newsContext.sentiment) {
            prompt += `
- Overall Sentiment: ${newsContext.sentiment}`;
          }
          if (newsContext.headlines && newsContext.headlines.length > 0) {
            prompt += `
- Recent Headlines:
${newsContext.headlines.slice(0, 5).map((h) => `  - ${h}`).join("\n")}`;
          }
          if (newsContext.summary) {
            prompt += `
- Summary: ${newsContext.summary}`;
          }
        }
        if (strategy) {
          prompt += `

## Strategy Context
- Strategy Name: ${strategy.name}
- Strategy Type: ${strategy.type}`;
          if (strategy.parameters) {
            prompt += `
- Parameters: ${JSON.stringify(strategy.parameters)}`;
          }
        }
        prompt += `

Based on this information, what is your trading recommendation? Provide your response as a JSON object.`;
        return prompt;
      }
      validateDecision(decision) {
        const validActions = ["buy", "sell", "hold"];
        const validRiskLevels = ["low", "medium", "high"];
        const action = validActions.includes(decision.action) ? decision.action : "hold";
        let confidence = Number(decision.confidence);
        if (isNaN(confidence) || confidence < 0 || confidence > 1) {
          confidence = 0.5;
        }
        const riskLevel = validRiskLevels.includes(decision.riskLevel) ? decision.riskLevel : "medium";
        let trailingStopPercent = decision.trailingStopPercent;
        if (trailingStopPercent !== void 0) {
          trailingStopPercent = Number(trailingStopPercent);
          if (isNaN(trailingStopPercent) || trailingStopPercent < 0.5 || trailingStopPercent > 20) {
            trailingStopPercent = void 0;
          }
        }
        return {
          action,
          confidence,
          reasoning: decision.reasoning || "Unable to provide detailed reasoning.",
          riskLevel,
          suggestedQuantity: decision.suggestedQuantity,
          targetPrice: decision.targetPrice,
          stopLoss: decision.stopLoss,
          trailingStopPercent
        };
      }
      async batchAnalyze(opportunities) {
        const results = /* @__PURE__ */ new Map();
        const promises = opportunities.map(async (opp) => {
          try {
            const decision = await this.analyzeOpportunity(
              opp.symbol,
              opp.marketData,
              opp.newsContext,
              opp.strategy
            );
            results.set(opp.symbol, decision);
          } catch (error) {
            log.error("AI", `Failed to analyze ${opp.symbol}`, { error: String(error) });
            results.set(opp.symbol, this.getDefaultDecision(`Analysis failed for ${opp.symbol}`));
          }
        });
        await Promise.all(promises);
        return results;
      }
      getStatus() {
        const { llmGateway: llmGateway2 } = (init_llmGateway(), __toCommonJS(llmGateway_exports));
        const availableProviders = llmGateway2.getAvailableProviders();
        return {
          available: availableProviders.length > 0,
          model: "dynamic (gateway-routed)",
          provider: availableProviders.length > 0 ? availableProviders.join(", ") : "none",
          usingGateway: true
        };
      }
    };
    aiDecisionEngine = new AIDecisionEngine();
  }
});

// server/fusion/data-fusion-engine.ts
var DataFusionEngine, dataFusionEngine;
var init_data_fusion_engine = __esm({
  "server/fusion/data-fusion-engine.ts"() {
    "use strict";
    init_coingecko();
    init_finnhub();
    DataFusionEngine = class {
      cache = /* @__PURE__ */ new Map();
      cacheDuration = 30 * 1e3;
      lastFusionTime = 0;
      getCached(key) {
        const entry = this.cache.get(key);
        if (entry && Date.now() - entry.timestamp < this.cacheDuration) {
          return entry.data;
        }
        return null;
      }
      setCache(key, data) {
        this.cache.set(key, { data, timestamp: Date.now() });
      }
      async getMarketIntelligence() {
        const cacheKey = "market_intelligence";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        const signals = [];
        let activeSources = 0;
        const totalSources = 4;
        let cryptoMomentum = 0.5;
        let cryptoVolatility = 0.5;
        let cryptoSentiment = 0.5;
        let cryptoVolume = 0.5;
        let stockMomentum = 0.5;
        let stockSentiment = 0.5;
        let hasCryptoData = false;
        let hasStockData = false;
        let hasNewsData = false;
        let hasGlobalData = false;
        try {
          const cryptoMarkets = await coingecko.getMarkets("usd", 20, 1, "market_cap_desc");
          if (cryptoMarkets && cryptoMarkets.length > 0) {
            hasCryptoData = true;
            activeSources++;
            const avgChange = cryptoMarkets.reduce((sum, c) => sum + (c.price_change_percentage_24h || 0), 0) / cryptoMarkets.length;
            const positiveCoins = cryptoMarkets.filter((c) => (c.price_change_percentage_24h || 0) > 0).length;
            const marketBreadth = positiveCoins / cryptoMarkets.length;
            cryptoMomentum = this.normalizeScore((avgChange + 10) / 20);
            cryptoSentiment = marketBreadth;
            const volatility = cryptoMarkets.reduce((sum, c) => {
              const range = c.high_24h && c.low_24h ? (c.high_24h - c.low_24h) / c.low_24h : 0;
              return sum + range;
            }, 0) / cryptoMarkets.length;
            cryptoVolatility = this.normalizeScore(1 - volatility * 5);
            const avgVolume = cryptoMarkets.reduce((sum, c) => sum + (c.total_volume || 0), 0) / cryptoMarkets.length;
            const avgMarketCap = cryptoMarkets.reduce((sum, c) => sum + (c.market_cap || 0), 0) / cryptoMarkets.length;
            const volumeRatio = avgVolume / avgMarketCap;
            cryptoVolume = this.normalizeScore(volumeRatio * 10);
            if (avgChange > 5) {
              signals.push({
                type: "bullish",
                source: "CoinGecko",
                message: `Crypto market up ${avgChange.toFixed(1)}% in 24h`,
                strength: Math.min(avgChange / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (avgChange < -5) {
              signals.push({
                type: "bearish",
                source: "CoinGecko",
                message: `Crypto market down ${Math.abs(avgChange).toFixed(1)}% in 24h`,
                strength: Math.min(Math.abs(avgChange) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
            if (marketBreadth > 0.7) {
              signals.push({
                type: "bullish",
                source: "CoinGecko",
                message: `${(marketBreadth * 100).toFixed(0)}% of top 20 coins are positive`,
                strength: marketBreadth,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (marketBreadth < 0.3) {
              signals.push({
                type: "bearish",
                source: "CoinGecko",
                message: `Only ${(marketBreadth * 100).toFixed(0)}% of top 20 coins are positive`,
                strength: 1 - marketBreadth,
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          console.error("Failed to fetch crypto data for fusion:", error);
        }
        try {
          const globalData = await coingecko.getGlobalData();
          if (globalData?.data) {
            hasGlobalData = true;
            activeSources++;
            const mcChange = globalData.data.market_cap_change_percentage_24h_usd;
            if (mcChange > 3) {
              signals.push({
                type: "bullish",
                source: "CoinGecko Global",
                message: `Total crypto market cap up ${mcChange.toFixed(1)}%`,
                strength: Math.min(mcChange / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (mcChange < -3) {
              signals.push({
                type: "bearish",
                source: "CoinGecko Global",
                message: `Total crypto market cap down ${Math.abs(mcChange).toFixed(1)}%`,
                strength: Math.min(Math.abs(mcChange) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          console.error("Failed to fetch global data for fusion:", error);
        }
        try {
          const stockSymbols = ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"];
          const quotes = await finnhub.getMultipleQuotes(stockSymbols);
          if (quotes.size > 0) {
            const changes = [];
            quotes.forEach((quote) => {
              if (quote.dp !== void 0 && !isNaN(quote.dp)) {
                changes.push(quote.dp);
              }
            });
            if (changes.length > 0) {
              hasStockData = true;
              activeSources++;
              const avgChange = changes.reduce((sum, c) => sum + c, 0) / changes.length;
              if (!isNaN(avgChange)) {
                const positiveStocks = changes.filter((c) => c > 0).length;
                const stockBreadth = positiveStocks / changes.length;
                stockMomentum = this.normalizeScore((avgChange + 5) / 10);
                stockSentiment = isNaN(stockBreadth) ? 0.5 : stockBreadth;
                if (avgChange > 2) {
                  signals.push({
                    type: "bullish",
                    source: "Finnhub",
                    message: `Tech stocks up ${avgChange.toFixed(1)}% average`,
                    strength: Math.min(avgChange / 5, 1),
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  });
                } else if (avgChange < -2) {
                  signals.push({
                    type: "bearish",
                    source: "Finnhub",
                    message: `Tech stocks down ${Math.abs(avgChange).toFixed(1)}% average`,
                    strength: Math.min(Math.abs(avgChange) / 5, 1),
                    timestamp: (/* @__PURE__ */ new Date()).toISOString()
                  });
                }
              }
            }
          }
        } catch (error) {
          console.error("Failed to fetch stock data for fusion:", error);
        }
        try {
          const news = await finnhub.getMarketNews("general");
          if (news && news.length > 0) {
            hasNewsData = true;
            activeSources++;
            const recentNews = news.slice(0, 10);
            const sentimentKeywords = {
              bullish: ["surge", "rally", "gains", "bullish", "record", "soar", "jump", "breakthrough", "growth", "strong"],
              bearish: ["crash", "plunge", "bearish", "decline", "fall", "drop", "slump", "weak", "fear", "concern"]
            };
            let bullishCount = 0;
            let bearishCount = 0;
            recentNews.forEach((article) => {
              const text3 = (article.headline + " " + article.summary).toLowerCase();
              sentimentKeywords.bullish.forEach((kw) => {
                if (text3.includes(kw)) bullishCount++;
              });
              sentimentKeywords.bearish.forEach((kw) => {
                if (text3.includes(kw)) bearishCount++;
              });
            });
            if (bullishCount > bearishCount + 3) {
              signals.push({
                type: "bullish",
                source: "Finnhub News",
                message: `News sentiment is predominantly positive`,
                strength: Math.min((bullishCount - bearishCount) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            } else if (bearishCount > bullishCount + 3) {
              signals.push({
                type: "bearish",
                source: "Finnhub News",
                message: `News sentiment is predominantly negative`,
                strength: Math.min((bearishCount - bullishCount) / 10, 1),
                timestamp: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
          }
        } catch (error) {
          console.error("Failed to fetch news for fusion:", error);
        }
        const momentumScore = hasCryptoData && hasStockData ? cryptoMomentum * 0.5 + stockMomentum * 0.5 : hasCryptoData ? cryptoMomentum : hasStockData ? stockMomentum : 0.5;
        const volatilityScore = hasCryptoData ? cryptoVolatility : 0.5;
        const volumeScore = hasCryptoData ? cryptoVolume : 0.5;
        const sentimentScore = hasCryptoData && hasStockData ? cryptoSentiment * 0.5 + stockSentiment * 0.5 : hasCryptoData ? cryptoSentiment : hasStockData ? stockSentiment : 0.5;
        const weights = { momentum: 0.35, volatility: 0.15, sentiment: 0.35, volume: 0.15 };
        const overall = momentumScore * weights.momentum + volatilityScore * weights.volatility + sentimentScore * weights.sentiment + volumeScore * weights.volume;
        let dataQuality;
        if (activeSources >= 4) dataQuality = "excellent";
        else if (activeSources >= 3) dataQuality = "good";
        else if (activeSources >= 2) dataQuality = "fair";
        else dataQuality = "poor";
        const result = {
          overall: this.normalizeScore(overall),
          components: {
            momentum: this.normalizeScore(momentumScore),
            volatility: this.normalizeScore(volatilityScore),
            sentiment: this.normalizeScore(sentimentScore),
            volume: this.normalizeScore(volumeScore)
          },
          signals: signals.slice(0, 5),
          dataQuality,
          activeSources,
          totalSources,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
        };
        this.setCache(cacheKey, result);
        this.lastFusionTime = Date.now();
        return result;
      }
      async getFusedMarketData() {
        const cacheKey = "fused_market_data";
        const cached = this.getCached(cacheKey);
        if (cached) return cached;
        let topCoins = [];
        let globalData = null;
        let marketCapChange24h = 0;
        let dominanceBTC = 0;
        let totalMarketCap = 0;
        try {
          topCoins = await coingecko.getMarkets("usd", 10, 1, "market_cap_desc");
        } catch (error) {
          console.error("Failed to fetch top coins:", error);
        }
        try {
          const global = await coingecko.getGlobalData();
          if (global?.data) {
            globalData = global.data;
            marketCapChange24h = global.data.market_cap_change_percentage_24h_usd || 0;
            dominanceBTC = global.data.market_cap_percentage?.btc || 0;
            totalMarketCap = global.data.total_market_cap?.usd || 0;
          }
        } catch (error) {
          console.error("Failed to fetch global data:", error);
        }
        let stockQuotes = {};
        let stockNews = [];
        let stockAvgChange = 0;
        let stockMarketSentiment = "neutral";
        try {
          const quotesMap = await finnhub.getMultipleQuotes(["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"]);
          const changes = [];
          quotesMap.forEach((quote, symbol) => {
            stockQuotes[symbol] = quote;
            if (quote.dp !== void 0 && !isNaN(quote.dp)) {
              changes.push(quote.dp);
            }
          });
          if (changes.length > 0) {
            const avgChange = changes.reduce((sum, c) => sum + c, 0) / changes.length;
            stockAvgChange = isNaN(avgChange) ? 0 : avgChange;
            stockMarketSentiment = stockAvgChange > 1 ? "bullish" : stockAvgChange < -1 ? "bearish" : "neutral";
          }
        } catch (error) {
          console.error("Failed to fetch stock quotes:", error);
        }
        try {
          stockNews = await finnhub.getMarketNews("general");
        } catch (error) {
          console.error("Failed to fetch stock news:", error);
        }
        const intelligence = await this.getMarketIntelligence();
        const result = {
          crypto: {
            topCoins,
            globalData,
            marketCapChange24h,
            dominanceBTC,
            totalMarketCap
          },
          stocks: {
            quotes: stockQuotes,
            news: stockNews.slice(0, 10),
            avgChange: stockAvgChange,
            marketSentiment: stockMarketSentiment
          },
          intelligence
        };
        this.setCache(cacheKey, result);
        return result;
      }
      normalizeScore(value) {
        return Math.max(0, Math.min(1, value));
      }
      getStatus() {
        return {
          available: true,
          lastFusionTime: this.lastFusionTime,
          cacheSize: this.cache.size
        };
      }
      clearCache() {
        this.cache.clear();
      }
    };
    dataFusionEngine = new DataFusionEngine();
  }
});

// server/orchestration/events.ts
import { EventEmitter } from "events";
var TradingEventBus, eventBus;
var init_events = __esm({
  "server/orchestration/events.ts"() {
    "use strict";
    TradingEventBus = class extends EventEmitter {
      eventHistory = [];
      maxHistorySize = 1e3;
      handlers = /* @__PURE__ */ new Map();
      constructor() {
        super();
        this.setMaxListeners(100);
      }
      emit(type, data, source, correlationId) {
        const event = {
          type,
          timestamp: /* @__PURE__ */ new Date(),
          source,
          data,
          correlationId
        };
        this.addToHistory(event);
        return super.emit(type, event);
      }
      subscribe(type, handler) {
        if (!this.handlers.has(type)) {
          this.handlers.set(type, /* @__PURE__ */ new Set());
        }
        this.handlers.get(type).add(handler);
        super.on(type, handler);
        return () => {
          this.unsubscribe(type, handler);
        };
      }
      unsubscribe(type, handler) {
        const typeHandlers = this.handlers.get(type);
        if (typeHandlers) {
          typeHandlers.delete(handler);
        }
        super.off(type, handler);
      }
      subscribeAll(handler) {
        const allTypes = [
          "market:data:update",
          "market:status:change",
          "strategy:started",
          "strategy:stopped",
          "strategy:signal",
          "strategy:error",
          "trade:executed",
          "trade:filled",
          "trade:cancelled",
          "trade:error",
          "position:opened",
          "position:closed",
          "position:updated",
          "ai:decision",
          "ai:analysis:complete",
          "portfolio:rebalanced",
          "system:heartbeat",
          "system:error",
          "system:warning",
          "connector:connected",
          "connector:disconnected",
          "connector:error"
        ];
        const unsubscribers = allTypes.map((type) => this.subscribe(type, handler));
        return () => {
          unsubscribers.forEach((unsub) => unsub());
        };
      }
      addToHistory(event) {
        this.eventHistory.push(event);
        if (this.eventHistory.length > this.maxHistorySize) {
          this.eventHistory = this.eventHistory.slice(-this.maxHistorySize);
        }
      }
      getEventHistory(filter) {
        let events = [...this.eventHistory];
        if (filter?.type) {
          events = events.filter((e) => e.type === filter.type);
        }
        if (filter?.source) {
          events = events.filter((e) => e.source === filter.source);
        }
        if (filter?.since) {
          events = events.filter((e) => e.timestamp >= filter.since);
        }
        if (filter?.limit) {
          events = events.slice(-filter.limit);
        }
        return events;
      }
      getRecentEvents(limit4 = 50) {
        return this.eventHistory.slice(-limit4);
      }
      clearHistory() {
        this.eventHistory = [];
      }
      getStats() {
        const eventsByType = {};
        for (const event of this.eventHistory) {
          eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;
        }
        return {
          totalEvents: this.eventHistory.length,
          eventsByType,
          oldestEvent: this.eventHistory.length > 0 ? this.eventHistory[0].timestamp : null,
          newestEvent: this.eventHistory.length > 0 ? this.eventHistory[this.eventHistory.length - 1].timestamp : null
        };
      }
    };
    eventBus = new TradingEventBus();
  }
});

// server/orchestration/logger.ts
var TradingLogger, logger;
var init_logger2 = __esm({
  "server/orchestration/logger.ts"() {
    "use strict";
    init_events();
    TradingLogger = class {
      logs = [];
      maxLogSize = 2e3;
      logLevel = "info";
      levelPriority = {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3,
        critical: 4
      };
      setLogLevel(level) {
        this.logLevel = level;
      }
      shouldLog(level) {
        return this.levelPriority[level] >= this.levelPriority[this.logLevel];
      }
      log(level, category, message, metadata, correlationId) {
        if (!this.shouldLog(level)) return;
        const entry = {
          timestamp: /* @__PURE__ */ new Date(),
          level,
          category,
          message,
          metadata,
          correlationId
        };
        this.logs.push(entry);
        if (this.logs.length > this.maxLogSize) {
          this.logs = this.logs.slice(-this.maxLogSize);
        }
        const formattedTime = entry.timestamp.toISOString().split("T")[1].slice(0, 12);
        const prefix = `[${formattedTime}] [${level.toUpperCase()}] [${category}]`;
        switch (level) {
          case "debug":
            console.debug(`${prefix} ${message}`, metadata || "");
            break;
          case "info":
            console.log(`${prefix} ${message}`, metadata ? JSON.stringify(metadata) : "");
            break;
          case "warn":
            console.warn(`${prefix} ${message}`, metadata || "");
            eventBus.emit("system:warning", {
              level: "warning",
              message,
              details: metadata
            }, category, correlationId);
            break;
          case "error":
          case "critical":
            console.error(`${prefix} ${message}`, metadata || "");
            eventBus.emit("system:error", {
              level: level === "critical" ? "critical" : "error",
              message,
              details: metadata
            }, category, correlationId);
            break;
        }
      }
      debug(category, message, metadata) {
        this.log("debug", category, message, metadata);
      }
      info(category, message, metadata) {
        this.log("info", category, message, metadata);
      }
      warn(category, message, metadata) {
        this.log("warn", category, message, metadata);
      }
      error(category, message, metadata) {
        this.log("error", category, message, metadata);
      }
      critical(category, message, metadata) {
        this.log("critical", category, message, metadata);
      }
      trade(action, details) {
        this.info("TRADE", action, details);
      }
      strategy(strategyName, action, details) {
        this.info("STRATEGY", `[${strategyName}] ${action}`, details);
      }
      market(symbol, action, details) {
        this.info("MARKET", `[${symbol}] ${action}`, details);
      }
      ai(action, details) {
        this.info("AI", action, details);
      }
      connector(connectorName, action, details) {
        this.info("CONNECTOR", `[${connectorName}] ${action}`, details);
      }
      getLogs(filter) {
        let entries = [...this.logs];
        if (filter?.level) {
          const minPriority = this.levelPriority[filter.level];
          entries = entries.filter((e) => this.levelPriority[e.level] >= minPriority);
        }
        if (filter?.category) {
          entries = entries.filter((e) => e.category === filter.category);
        }
        if (filter?.since) {
          entries = entries.filter((e) => e.timestamp >= filter.since);
        }
        if (filter?.limit) {
          entries = entries.slice(-filter.limit);
        }
        return entries;
      }
      getRecentLogs(limit4 = 100) {
        return this.logs.slice(-limit4);
      }
      getErrorLogs(limit4 = 50) {
        return this.logs.filter((e) => e.level === "error" || e.level === "critical").slice(-limit4);
      }
      clearLogs() {
        this.logs = [];
      }
      getStats() {
        const logsByLevel = {
          debug: 0,
          info: 0,
          warn: 0,
          error: 0,
          critical: 0
        };
        const logsByCategory = {};
        for (const log2 of this.logs) {
          logsByLevel[log2.level]++;
          logsByCategory[log2.category] = (logsByCategory[log2.category] || 0) + 1;
        }
        return {
          totalLogs: this.logs.length,
          logsByLevel,
          logsByCategory
        };
      }
    };
    logger = new TradingLogger();
    eventBus.subscribe("system:heartbeat", (event) => {
      logger.debug("SYSTEM", `Heartbeat from ${event.source}`, { status: event.data.status });
    });
  }
});

// server/orchestration/coordinator.ts
var TradingCoordinator, coordinator;
var init_coordinator = __esm({
  "server/orchestration/coordinator.ts"() {
    "use strict";
    init_events();
    init_logger2();
    init_storage();
    TradingCoordinator = class {
      config;
      startTime;
      heartbeatInterval = null;
      reconcileInterval = null;
      isRunning = false;
      activeStrategies = /* @__PURE__ */ new Set();
      errorCount = 0;
      warningCount = 0;
      tradeCount24h = 0;
      constructor() {
        this.config = {
          heartbeatIntervalMs: 3e4,
          autoReconcileEnabled: true,
          reconcileIntervalMs: 3e5,
          maxConcurrentStrategies: 10,
          emergencyStopLossPercent: 10
        };
        this.startTime = /* @__PURE__ */ new Date();
        this.setupEventListeners();
      }
      setupEventListeners() {
        eventBus.subscribe("strategy:signal", (event) => {
          this.handleStrategySignal(event);
        });
        eventBus.subscribe("trade:executed", (event) => {
          this.handleTradeExecuted(event);
        });
        eventBus.subscribe("trade:error", (event) => {
          this.handleTradeError(event);
        });
        eventBus.subscribe("system:error", () => {
          this.errorCount++;
        });
        eventBus.subscribe("system:warning", () => {
          this.warningCount++;
        });
        eventBus.subscribe("strategy:started", (event) => {
          this.activeStrategies.add(event.data.strategyId);
          logger.strategy(event.data.strategyId, "Started");
        });
        eventBus.subscribe("strategy:stopped", (event) => {
          this.activeStrategies.delete(event.data.strategyId);
          logger.strategy(event.data.strategyId, "Stopped");
        });
      }
      handleStrategySignal(event) {
        const { strategyName, symbol, signal, confidence, reason } = event.data;
        logger.strategy(strategyName, `Signal: ${signal.toUpperCase()} ${symbol}`, {
          confidence,
          reason
        });
      }
      handleTradeExecuted(event) {
        const { symbol, side, quantity, price, status } = event.data;
        this.tradeCount24h++;
        logger.trade(`${side.toUpperCase()} ${quantity} ${symbol} @ $${price}`, {
          status,
          tradeId: event.data.tradeId,
          orderId: event.data.orderId
        });
      }
      handleTradeError(event) {
        this.errorCount++;
        logger.error("TRADE", event.data.message, event.data.details);
      }
      async start() {
        if (this.isRunning) {
          logger.warn("COORDINATOR", "Coordinator is already running");
          return;
        }
        logger.info("COORDINATOR", "Starting trading coordinator...");
        this.isRunning = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.heartbeatInterval = setInterval(() => {
          this.sendHeartbeat();
        }, this.config.heartbeatIntervalMs);
        if (this.config.autoReconcileEnabled) {
          this.reconcileInterval = setInterval(() => {
            this.reconcilePositions();
          }, this.config.reconcileIntervalMs);
        }
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        eventBus.emit("system:heartbeat", { status: "started" }, "coordinator");
        logger.info("COORDINATOR", "Trading coordinator started successfully");
      }
      async stop() {
        if (!this.isRunning) {
          logger.warn("COORDINATOR", "Coordinator is not running");
          return;
        }
        logger.info("COORDINATOR", "Stopping trading coordinator...");
        if (this.heartbeatInterval) {
          clearInterval(this.heartbeatInterval);
          this.heartbeatInterval = null;
        }
        if (this.reconcileInterval) {
          clearInterval(this.reconcileInterval);
          this.reconcileInterval = null;
        }
        this.isRunning = false;
        await storage.updateAgentStatus({
          isRunning: false,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        eventBus.emit("system:heartbeat", { status: "stopped" }, "coordinator");
        logger.info("COORDINATOR", "Trading coordinator stopped");
      }
      sendHeartbeat() {
        eventBus.emit("system:heartbeat", {
          status: "running",
          activeStrategies: this.activeStrategies.size,
          uptime: Date.now() - this.startTime.getTime()
        }, "coordinator");
        storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() }).catch((err) => {
          logger.error("COORDINATOR", "Failed to update heartbeat in database", { error: String(err) });
        });
      }
      async reconcilePositions() {
        logger.info("COORDINATOR", "Starting position reconciliation...");
        try {
          eventBus.emit("system:heartbeat", { status: "reconciling" }, "coordinator");
          logger.info("COORDINATOR", "Position reconciliation completed");
        } catch (error) {
          logger.error("COORDINATOR", "Position reconciliation failed", { error: String(error) });
        }
      }
      emitMarketData(data) {
        eventBus.emit("market:data:update", data, "market-connector");
      }
      emitStrategySignal(signal) {
        eventBus.emit("strategy:signal", signal, signal.strategyName);
      }
      emitTradeExecuted(trade) {
        eventBus.emit("trade:executed", trade, "trading-engine");
      }
      emitPositionUpdate(position) {
        eventBus.emit("position:updated", position, "position-manager");
      }
      registerStrategy(strategyId) {
        if (this.activeStrategies.size >= this.config.maxConcurrentStrategies) {
          logger.warn("COORDINATOR", `Max concurrent strategies (${this.config.maxConcurrentStrategies}) reached`);
          return false;
        }
        this.activeStrategies.add(strategyId);
        eventBus.emit("strategy:started", { strategyId }, "coordinator");
        return true;
      }
      unregisterStrategy(strategyId) {
        this.activeStrategies.delete(strategyId);
        eventBus.emit("strategy:stopped", { strategyId }, "coordinator");
      }
      getStatus() {
        return {
          isRunning: this.isRunning,
          activeStrategies: this.activeStrategies.size,
          openPositions: 0,
          totalTrades24h: this.tradeCount24h,
          lastHeartbeat: this.isRunning ? /* @__PURE__ */ new Date() : null,
          errors: this.errorCount,
          warnings: this.warningCount,
          uptime: Date.now() - this.startTime.getTime()
        };
      }
      updateConfig(updates) {
        this.config = { ...this.config, ...updates };
        logger.info("COORDINATOR", "Configuration updated", { config: this.config });
      }
      getConfig() {
        return { ...this.config };
      }
      resetStats() {
        this.errorCount = 0;
        this.warningCount = 0;
        this.tradeCount24h = 0;
        logger.info("COORDINATOR", "Statistics reset");
      }
      async triggerReconcileNow() {
        if (!this.isRunning) {
          return { success: false, message: "Coordinator is not running" };
        }
        logger.info("COORDINATOR", "Manual reconciliation triggered");
        await this.reconcilePositions();
        return { success: true, message: "Reconciliation triggered" };
      }
      getActiveStrategies() {
        return Array.from(this.activeStrategies);
      }
    };
    coordinator = new TradingCoordinator();
  }
});

// server/orchestration/index.ts
var init_orchestration = __esm({
  "server/orchestration/index.ts"() {
    "use strict";
    init_events();
    init_logger2();
    init_coordinator();
  }
});

// server/utils/numeric.ts
function safeParseFloat(value, defaultValue = 0) {
  if (value === null || value === void 0 || value === "") {
    return defaultValue;
  }
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : defaultValue;
  }
  const parsed = parseFloat(value);
  return Number.isFinite(parsed) ? parsed : defaultValue;
}
function calculatePnL(entryPrice, exitPrice, quantity, side = "long") {
  if (!Number.isFinite(entryPrice) || !Number.isFinite(exitPrice) || !Number.isFinite(quantity)) {
    return 0;
  }
  if (side === "long") {
    return (exitPrice - entryPrice) * quantity;
  } else {
    return (entryPrice - exitPrice) * quantity;
  }
}
var init_numeric = __esm({
  "server/utils/numeric.ts"() {
    "use strict";
  }
});

// server/ai/data-fusion-engine.ts
function fuseMarketData(input) {
  const {
    symbol,
    assetType = "unknown",
    marketData = [],
    sentimentData = [],
    fundamentalData = [],
    technicalData = [],
    shortInterestData = [],
    macroData = []
  } = input;
  const warnings = [];
  const now = /* @__PURE__ */ new Date();
  const fusedPrice = fusePriceData(marketData, warnings);
  const fusedSentiment = fuseSentimentData(sentimentData, warnings);
  const fusedFundamentals = fuseFundamentalData(fundamentalData, warnings);
  const fusedTechnicals = fuseTechnicalData(technicalData, warnings);
  const fusedShortInterest = fuseShortInterestData(shortInterestData, warnings);
  const fusedMacro = fuseMacroData(macroData, warnings);
  const trendStrength = calculateTrendStrength(fusedPrice, fusedSentiment, fusedTechnicals);
  const volatilityIndicator = calculateVolatilityWithTechnicals(marketData, technicalData);
  const signalAgreement = calculateSignalAgreementWithTechnicals(fusedPrice, fusedSentiment, fusedFundamentals, fusedTechnicals);
  const dataQuality = assessDataQuality(marketData, sentimentData, fundamentalData, now);
  log.debug("DataFusion", `Fused data for ${symbol}`, {
    priceSources: fusedPrice.sources.length,
    sentimentSources: fusedSentiment.sources.length,
    fundamentalSources: fusedFundamentals?.sources.length || 0,
    technicalSources: fusedTechnicals?.sources.length || 0,
    shortInterestSources: fusedShortInterest?.sources.length || 0,
    macroSources: fusedMacro?.sources.length || 0,
    signalAgreement: signalAgreement.toFixed(2),
    warnings: warnings.length
  });
  return {
    symbol,
    assetType,
    price: fusedPrice,
    sentiment: fusedSentiment,
    fundamentals: fusedFundamentals,
    technicals: fusedTechnicals,
    shortInterest: fusedShortInterest,
    macro: fusedMacro,
    trendStrength,
    volatilityIndicator,
    signalAgreement,
    dataQuality,
    warnings,
    timestamp: now
  };
}
function fusePriceData(data, warnings) {
  if (data.length === 0) {
    warnings.push("No price data available");
    return {
      current: 0,
      change: 0,
      changePercent: 0,
      confidence: 0,
      sources: []
    };
  }
  data.sort((a, b) => (SOURCE_RELIABILITY[a.source] || 0.5) - (SOURCE_RELIABILITY[b.source] || 0.5));
  data.reverse();
  let totalWeight = 0;
  let weightedPrice = 0;
  let weightedChange = 0;
  let weightedChangePercent = 0;
  const sources = [];
  for (const point of data) {
    if (point.price === void 0) continue;
    const weight = point.reliability * (SOURCE_RELIABILITY[point.source] || 0.5);
    weightedPrice += point.price * weight;
    weightedChange += (point.priceChange || 0) * weight;
    weightedChangePercent += (point.priceChangePercent || 0) * weight;
    totalWeight += weight;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  if (totalWeight === 0) {
    warnings.push("No valid price data after filtering");
    return {
      current: 0,
      change: 0,
      changePercent: 0,
      confidence: 0,
      sources: []
    };
  }
  const prices = data.filter((d) => d.price !== void 0).map((d) => d.price);
  const avgPrice = prices.reduce((a, b) => a + b, 0) / prices.length;
  const priceVariance = prices.reduce((sum, p) => sum + Math.pow(p - avgPrice, 2), 0) / prices.length;
  const priceStdDev = Math.sqrt(priceVariance);
  const priceConsistency = avgPrice > 0 ? Math.max(0, 1 - priceStdDev / avgPrice) : 0;
  if (priceConsistency < 0.95) {
    warnings.push(`Price sources show ${((1 - priceConsistency) * 100).toFixed(1)}% variance`);
  }
  return {
    current: weightedPrice / totalWeight,
    change: weightedChange / totalWeight,
    changePercent: weightedChangePercent / totalWeight,
    confidence: Math.min(1, totalWeight / data.length * priceConsistency),
    sources
  };
}
function fuseSentimentData(data, warnings) {
  if (data.length === 0) {
    return {
      overall: "neutral",
      score: 0,
      confidence: 0,
      agreementLevel: 0,
      sources: []
    };
  }
  let totalWeight = 0;
  let weightedScore = 0;
  const sources = [];
  let positiveCount = 0;
  let negativeCount = 0;
  let neutralCount = 0;
  for (const point of data) {
    const weight = point.confidence * (SOURCE_RELIABILITY[point.source] || 0.5);
    let normalizedScore = point.score;
    if (point.sentiment === "positive") {
      normalizedScore = Math.abs(normalizedScore);
      positiveCount++;
    } else if (point.sentiment === "negative") {
      normalizedScore = -Math.abs(normalizedScore);
      negativeCount++;
    } else {
      neutralCount++;
    }
    weightedScore += normalizedScore * weight;
    totalWeight += weight;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const avgScore = totalWeight > 0 ? weightedScore / totalWeight : 0;
  let overall = "neutral";
  if (avgScore > 0.15) overall = "bullish";
  else if (avgScore < -0.15) overall = "bearish";
  const totalSentiments = positiveCount + negativeCount + neutralCount;
  const maxCount = Math.max(positiveCount, negativeCount, neutralCount);
  const agreementLevel = totalSentiments > 0 ? maxCount / totalSentiments : 0;
  if (agreementLevel < 0.6 && data.length > 1) {
    warnings.push("Sentiment sources show conflicting signals");
  }
  return {
    overall,
    score: avgScore,
    confidence: Math.min(1, totalWeight / data.length),
    agreementLevel,
    sources
  };
}
function fuseFundamentalData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let eps;
  let peRatio;
  let pbRatio;
  let roe;
  let roa;
  let revenueGrowth;
  let freeCashFlow;
  let dividendYield;
  let debtToEquity;
  let currentRatio;
  let grossMargin;
  let netProfitMargin;
  let beta;
  let epsGrowth;
  let weekHigh52;
  let weekLow52;
  let insiderSentiment;
  let insiderBullishCount = 0;
  let insiderBearishCount = 0;
  for (const point of data) {
    if (point.eps !== void 0 && eps === void 0) eps = point.eps;
    if (point.peRatio !== void 0 && peRatio === void 0) peRatio = point.peRatio;
    if (point.pbRatio !== void 0 && pbRatio === void 0) pbRatio = point.pbRatio;
    if (point.roe !== void 0 && roe === void 0) roe = point.roe;
    if (point.roa !== void 0 && roa === void 0) roa = point.roa;
    if (point.revenueGrowth !== void 0 && revenueGrowth === void 0) revenueGrowth = point.revenueGrowth;
    if (point.freeCashFlow !== void 0 && freeCashFlow === void 0) freeCashFlow = point.freeCashFlow;
    if (point.dividendYield !== void 0 && dividendYield === void 0) dividendYield = point.dividendYield;
    if (point.debtToEquity !== void 0 && debtToEquity === void 0) debtToEquity = point.debtToEquity;
    if (point.currentRatio !== void 0 && currentRatio === void 0) currentRatio = point.currentRatio;
    if (point.grossMargin !== void 0 && grossMargin === void 0) grossMargin = point.grossMargin;
    if (point.netProfitMargin !== void 0 && netProfitMargin === void 0) netProfitMargin = point.netProfitMargin;
    if (point.beta !== void 0 && beta === void 0) beta = point.beta;
    if (point.epsGrowth !== void 0 && epsGrowth === void 0) epsGrowth = point.epsGrowth;
    if (point.weekHigh52 !== void 0 && weekHigh52 === void 0) weekHigh52 = point.weekHigh52;
    if (point.weekLow52 !== void 0 && weekLow52 === void 0) weekLow52 = point.weekLow52;
    if (point.insiderSentiment) {
      if (point.insiderSentiment === "bullish") insiderBullishCount++;
      else if (point.insiderSentiment === "bearish") insiderBearishCount++;
    }
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  if (insiderBullishCount > insiderBearishCount) {
    insiderSentiment = "bullish";
  } else if (insiderBearishCount > insiderBullishCount) {
    insiderSentiment = "bearish";
  } else if (insiderBullishCount > 0 || insiderBearishCount > 0) {
    insiderSentiment = "neutral";
  }
  const coreFields = [eps, peRatio, revenueGrowth].filter((f) => f !== void 0).length;
  const valuationFields = [pbRatio, roe, roa].filter((f) => f !== void 0).length;
  const marginFields = [grossMargin, netProfitMargin].filter((f) => f !== void 0).length;
  const rangeFields = [weekHigh52, weekLow52].filter((f) => f !== void 0).length;
  const extendedFields = [freeCashFlow, dividendYield, debtToEquity, currentRatio, beta, epsGrowth, insiderSentiment].filter((f) => f !== void 0).length;
  const totalFields = coreFields + valuationFields + marginFields + rangeFields + extendedFields;
  const maxFields = 17;
  const confidence = Math.min(1, totalFields / maxFields);
  if (insiderSentiment === "bearish" && coreFields > 0) {
    warnings.push("Insider activity shows bearish sentiment - insiders selling");
  }
  return {
    eps,
    peRatio,
    pbRatio,
    roe,
    roa,
    revenueGrowth,
    freeCashFlow,
    dividendYield,
    debtToEquity,
    currentRatio,
    grossMargin,
    netProfitMargin,
    beta,
    epsGrowth,
    weekHigh52,
    weekLow52,
    insiderSentiment,
    confidence,
    sources
  };
}
function fuseTechnicalData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let totalBuyCount = 0;
  let totalSellCount = 0;
  let totalNeutralCount = 0;
  let adxSum = 0;
  let adxCount = 0;
  let trendingCount = 0;
  let supportSum = 0;
  let supportCount = 0;
  let resistanceSum = 0;
  let resistanceCount = 0;
  let volatilitySum = 0;
  let volatilityCount = 0;
  let bullishTrendCount = 0;
  let bearishTrendCount = 0;
  for (const point of data) {
    if (point.buyCount !== void 0) totalBuyCount += point.buyCount;
    if (point.sellCount !== void 0) totalSellCount += point.sellCount;
    if (point.neutralCount !== void 0) totalNeutralCount += point.neutralCount;
    if (point.adx !== void 0) {
      adxSum += point.adx;
      adxCount++;
    }
    if (point.isTrending) trendingCount++;
    if (point.support !== void 0) {
      supportSum += point.support;
      supportCount++;
    }
    if (point.resistance !== void 0) {
      resistanceSum += point.resistance;
      resistanceCount++;
    }
    if (point.volatility !== void 0) {
      volatilitySum += point.volatility;
      volatilityCount++;
    }
    if (point.trend === "bullish") bullishTrendCount++;
    else if (point.trend === "bearish") bearishTrendCount++;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const overallSignal = totalBuyCount > totalSellCount + totalNeutralCount ? "buy" : totalSellCount > totalBuyCount + totalNeutralCount ? "sell" : "neutral";
  const trend = bullishTrendCount > bearishTrendCount ? "bullish" : bearishTrendCount > bullishTrendCount ? "bearish" : "neutral";
  const totalIndicators = totalBuyCount + totalSellCount + totalNeutralCount;
  const confidence = totalIndicators > 0 ? Math.max(totalBuyCount, totalSellCount) / totalIndicators : 0;
  if (overallSignal === "sell" && totalSellCount > totalBuyCount * 2) {
    warnings.push("Strong sell signals from technical indicators");
  }
  return {
    signal: overallSignal,
    buyCount: totalBuyCount,
    sellCount: totalSellCount,
    neutralCount: totalNeutralCount,
    adx: adxCount > 0 ? adxSum / adxCount : void 0,
    isTrending: trendingCount > data.length / 2,
    support: supportCount > 0 ? supportSum / supportCount : void 0,
    resistance: resistanceCount > 0 ? resistanceSum / resistanceCount : void 0,
    volatility: volatilityCount > 0 ? volatilitySum / volatilityCount : void 0,
    trend,
    confidence,
    sources
  };
}
function fuseShortInterestData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let totalWeight = 0;
  let weightedShortRatio = 0;
  let daysToCoverSum = 0;
  let daysToCoverCount = 0;
  let increasingCount = 0;
  let decreasingCount = 0;
  let highSqueezeCount = 0;
  let mediumSqueezeCount = 0;
  for (const point of data) {
    const weight = SOURCE_RELIABILITY[point.source] || 0.5;
    weightedShortRatio += point.shortRatio * weight;
    totalWeight += weight;
    if (point.daysToCover !== void 0) {
      daysToCoverSum += point.daysToCover;
      daysToCoverCount++;
    }
    if (point.shortRatioTrend === "increasing") increasingCount++;
    else if (point.shortRatioTrend === "decreasing") decreasingCount++;
    if (point.shortSqueezePotential === "high") highSqueezeCount++;
    else if (point.shortSqueezePotential === "medium") mediumSqueezeCount++;
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  const avgShortRatio = totalWeight > 0 ? weightedShortRatio / totalWeight : 0;
  const avgDaysToCover = daysToCoverCount > 0 ? daysToCoverSum / daysToCoverCount : void 0;
  const trend = increasingCount > decreasingCount ? "increasing" : decreasingCount > increasingCount ? "decreasing" : "stable";
  const squeezePotential = highSqueezeCount > 0 ? "high" : mediumSqueezeCount > 0 ? "medium" : "low";
  if (avgShortRatio > 0.4) {
    warnings.push(`High short interest: ${(avgShortRatio * 100).toFixed(1)}% of volume is short selling`);
  }
  if (squeezePotential === "high" && trend === "increasing") {
    warnings.push("Potential short squeeze setup detected");
  }
  return {
    shortRatio: avgShortRatio,
    daysToCover: avgDaysToCover,
    trend,
    squeezePotential,
    confidence: Math.min(1, totalWeight / data.length),
    sources
  };
}
function fuseMacroData(data, warnings) {
  if (data.length === 0) {
    return void 0;
  }
  const sources = [];
  let vix;
  let fedFundsRate;
  let yieldCurve;
  let inflation;
  let unemployment;
  for (const point of data) {
    const indicator = point.indicator.toUpperCase();
    if (indicator.includes("VIX") && vix === void 0) {
      vix = point.value;
    } else if ((indicator.includes("FEDFUNDS") || indicator.includes("FED_FUNDS")) && fedFundsRate === void 0) {
      fedFundsRate = point.value;
    } else if ((indicator.includes("T10Y2Y") || indicator.includes("YIELD_CURVE")) && yieldCurve === void 0) {
      yieldCurve = point.value;
    } else if ((indicator.includes("CPI") || indicator.includes("INFLATION")) && inflation === void 0) {
      inflation = point.value;
    } else if ((indicator.includes("UNRATE") || indicator.includes("UNEMPLOYMENT")) && unemployment === void 0) {
      unemployment = point.value;
    }
    if (!sources.includes(point.source)) {
      sources.push(point.source);
    }
  }
  let marketRegime = "neutral";
  if (vix !== void 0) {
    if (vix > 30) {
      marketRegime = "risk_off";
      warnings.push(`Elevated VIX (${vix.toFixed(1)}) indicates high market fear`);
    } else if (vix < 15) {
      marketRegime = "risk_on";
    }
  }
  if (yieldCurve !== void 0 && yieldCurve < 0) {
    if (marketRegime === "risk_on") {
      marketRegime = "neutral";
    } else {
      marketRegime = "risk_off";
    }
    warnings.push("Inverted yield curve detected - recession warning signal");
  }
  const fieldsPresent = [vix, fedFundsRate, yieldCurve, inflation, unemployment].filter((f) => f !== void 0).length;
  const confidence = Math.min(1, fieldsPresent / 5);
  return {
    vix,
    fedFundsRate,
    yieldCurve,
    inflation,
    unemployment,
    marketRegime,
    confidence,
    sources
  };
}
function calculateTrendStrength(price, sentiment, technicals) {
  if (price.confidence === 0) return 0;
  const priceDirection = price.changePercent > 0 ? 1 : price.changePercent < 0 ? -1 : 0;
  const sentimentDirection = sentiment.score > 0 ? 1 : sentiment.score < 0 ? -1 : 0;
  const technicalDirection = technicals ? technicals.signal === "buy" ? 1 : technicals.signal === "sell" ? -1 : 0 : 0;
  const priceStrength = Math.min(1, Math.abs(price.changePercent) / 5);
  const sentimentStrength = Math.abs(sentiment.score);
  const technicalStrength = technicals?.confidence || 0;
  const directions = [priceDirection, sentimentDirection];
  const strengths = [priceStrength * price.confidence, sentimentStrength * sentiment.confidence];
  if (technicals && technicals.confidence > 0) {
    directions.push(technicalDirection);
    strengths.push(technicalStrength);
  }
  const totalStrength = strengths.reduce((a, b) => a + b, 0);
  const avgDirection = directions.reduce((a, b) => a + b, 0) / directions.length;
  if (Math.abs(avgDirection) > 0.5) {
    return totalStrength / strengths.length * Math.sign(avgDirection);
  }
  if (priceDirection === sentimentDirection && priceDirection !== 0) {
    return (priceStrength + sentimentStrength) / 2 * price.confidence * sentiment.confidence;
  }
  if (priceDirection !== sentimentDirection && priceDirection !== 0 && sentimentDirection !== 0) {
    return -Math.abs(priceStrength - sentimentStrength) / 2;
  }
  return priceStrength * price.confidence;
}
function calculateVolatility(data) {
  if (data.length === 0) return 0;
  const withRange = data.filter((d) => d.high !== void 0 && d.low !== void 0 && d.price);
  if (withRange.length === 0) return 0;
  let totalVolatility = 0;
  for (const point of withRange) {
    const range = (point.high - point.low) / point.price;
    totalVolatility += range;
  }
  return Math.min(1, totalVolatility / withRange.length);
}
function calculateVolatilityWithTechnicals(marketData, technicalData) {
  const baseVolatility = calculateVolatility(marketData);
  if (technicalData.length === 0) return baseVolatility;
  const technicalVolatilities = technicalData.filter((t) => t.volatility !== void 0).map((t) => t.volatility);
  if (technicalVolatilities.length === 0) return baseVolatility;
  const avgTechnicalVolatility = technicalVolatilities.reduce((a, b) => a + b, 0) / technicalVolatilities.length;
  const normalizedTechnicalVolatility = Math.min(1, avgTechnicalVolatility / 100);
  return baseVolatility * 0.6 + normalizedTechnicalVolatility * 0.4;
}
function calculateSignalAgreementWithTechnicals(price, sentiment, fundamentals, technicals) {
  const signals = [];
  if (price.confidence > 0) {
    signals.push(price.changePercent > 0 ? 1 : price.changePercent < 0 ? -1 : 0);
  }
  if (sentiment.confidence > 0) {
    signals.push(sentiment.score > 0.1 ? 1 : sentiment.score < -0.1 ? -1 : 0);
  }
  if (fundamentals && fundamentals.confidence > 0) {
    let fundamentalSignal = 0;
    if (fundamentals.revenueGrowth !== void 0) {
      fundamentalSignal = fundamentals.revenueGrowth > 0 ? 1 : -1;
    }
    if (fundamentalSignal !== 0) signals.push(fundamentalSignal);
  }
  if (technicals && technicals.confidence > 0) {
    const technicalSignal = technicals.signal === "buy" ? 1 : technicals.signal === "sell" ? -1 : 0;
    if (technicalSignal !== 0) signals.push(technicalSignal);
  }
  if (signals.length <= 1) return 1;
  const sum = signals.reduce((a, b) => a + b, 0);
  const agreement = Math.abs(sum) / signals.length;
  return agreement;
}
function assessDataQuality(marketData, sentimentData, fundamentalData, now) {
  const hasMarket = marketData.length > 0;
  const hasSentiment = sentimentData.length > 0;
  const hasFundamentals = fundamentalData.length > 0;
  const completeness = (Number(hasMarket) + Number(hasSentiment) + Number(hasFundamentals)) / 3;
  const allTimestamps = [
    ...marketData.map((d) => d.timestamp),
    ...sentimentData.map((d) => d.timestamp),
    ...fundamentalData.map((d) => d.timestamp)
  ];
  let freshness = 0;
  if (allTimestamps.length > 0) {
    const avgAge = allTimestamps.reduce((sum, ts) => sum + (now.getTime() - ts.getTime()), 0) / allTimestamps.length;
    const maxFreshAge = 60 * 60 * 1e3;
    freshness = Math.max(0, 1 - avgAge / maxFreshAge);
  }
  const avgReliability = [
    ...marketData.map((d) => SOURCE_RELIABILITY[d.source] || 0.5),
    ...sentimentData.map((d) => SOURCE_RELIABILITY[d.source] || 0.5)
  ];
  const reliability = avgReliability.length > 0 ? avgReliability.reduce((a, b) => a + b, 0) / avgReliability.length : 0;
  return {
    completeness,
    freshness,
    reliability
  };
}
var SOURCE_RELIABILITY;
var init_data_fusion_engine2 = __esm({
  "server/ai/data-fusion-engine.ts"() {
    "use strict";
    init_logger();
    SOURCE_RELIABILITY = {
      // Primary market data sources
      alpaca: 0.95,
      finnhub: 0.9,
      coingecko: 0.85,
      coinmarketcap: 0.85,
      twelvedata: 0.85,
      // Fundamental data sources
      valyu: 0.9,
      "sec-edgar": 0.95,
      // Official SEC filings - highest reliability
      secedgar: 0.95,
      // Short interest data
      finra: 0.9,
      // Official FINRA RegSHO data
      // Forex data
      frankfurter: 0.9,
      // ECB-backed exchange rates
      // Sentiment sources
      newsapi: 0.75,
      huggingface: 0.8,
      finbert: 0.8,
      gdelt: 0.8,
      // Macro data
      fred: 0.95
      // Federal Reserve Economic Data
    };
  }
});

// server/ai/enhanced-decision-log.ts
function createInputSnapshot(marketData, newsContext, strategy, fusedIntelligence) {
  const snapshot = {
    marketData: {
      symbol: marketData.symbol,
      price: marketData.currentPrice,
      change24h: marketData.priceChange24h,
      changePercent24h: marketData.priceChangePercent24h,
      volume: marketData.volume,
      high24h: marketData.high24h,
      low24h: marketData.low24h
    }
  };
  if (newsContext) {
    snapshot.sentiment = {
      overall: newsContext.sentiment || "neutral",
      score: 0,
      confidence: 0.5,
      sources: ["newsapi"],
      headlines: newsContext.headlines?.slice(0, 5)
    };
  }
  if (fusedIntelligence) {
    snapshot.sentiment = {
      overall: fusedIntelligence.sentiment.overall,
      score: fusedIntelligence.sentiment.score,
      confidence: fusedIntelligence.sentiment.confidence,
      sources: fusedIntelligence.sentiment.sources
    };
    if (fusedIntelligence.fundamentals) {
      snapshot.fundamentals = {
        eps: fusedIntelligence.fundamentals.eps,
        peRatio: fusedIntelligence.fundamentals.peRatio,
        revenueGrowth: fusedIntelligence.fundamentals.revenueGrowth,
        sources: fusedIntelligence.fundamentals.sources
      };
    }
    snapshot.fusedIntelligence = {
      trendStrength: fusedIntelligence.trendStrength,
      signalAgreement: fusedIntelligence.signalAgreement,
      dataQuality: fusedIntelligence.dataQuality,
      warnings: fusedIntelligence.warnings
    };
  }
  if (strategy) {
    snapshot.strategyContext = {
      id: strategy.id,
      name: strategy.name,
      type: strategy.type,
      parameters: strategy.parameters
    };
  }
  return snapshot;
}
function generateReasoningSteps(input, decision) {
  const steps = [];
  let stepNum = 1;
  steps.push({
    step: stepNum++,
    category: "market_analysis",
    observation: `Current price: $${input.marketData.price.toFixed(2)}, 24h change: ${(input.marketData.changePercent24h || 0).toFixed(2)}%`,
    implication: input.marketData.changePercent24h && input.marketData.changePercent24h > 0 ? "Positive short-term momentum" : input.marketData.changePercent24h && input.marketData.changePercent24h < 0 ? "Negative short-term momentum" : "Neutral price action",
    weight: 0.3
  });
  if (input.sentiment) {
    steps.push({
      step: stepNum++,
      category: "sentiment_analysis",
      observation: `Sentiment: ${input.sentiment.overall} (score: ${input.sentiment.score.toFixed(2)}, confidence: ${(input.sentiment.confidence * 100).toFixed(0)}%)`,
      implication: input.sentiment.overall === "bullish" ? "Market sentiment supports buying" : input.sentiment.overall === "bearish" ? "Market sentiment suggests caution" : "Neutral sentiment, no strong directional bias",
      weight: 0.25
    });
  }
  if (input.fundamentals) {
    const fundObs = [];
    if (input.fundamentals.peRatio !== void 0) {
      fundObs.push(`P/E: ${input.fundamentals.peRatio.toFixed(1)}`);
    }
    if (input.fundamentals.revenueGrowth !== void 0) {
      fundObs.push(`Revenue growth: ${(input.fundamentals.revenueGrowth * 100).toFixed(1)}%`);
    }
    if (fundObs.length > 0) {
      steps.push({
        step: stepNum++,
        category: "fundamental_analysis",
        observation: fundObs.join(", "),
        implication: input.fundamentals.revenueGrowth && input.fundamentals.revenueGrowth > 0 ? "Fundamentals indicate growth" : "Fundamentals suggest caution",
        weight: 0.2
      });
    }
  }
  if (input.fusedIntelligence) {
    steps.push({
      step: stepNum++,
      category: "signal_synthesis",
      observation: `Signal agreement: ${(input.fusedIntelligence.signalAgreement * 100).toFixed(0)}%, Trend strength: ${(input.fusedIntelligence.trendStrength * 100).toFixed(0)}%`,
      implication: input.fusedIntelligence.signalAgreement > 0.7 ? "Strong consensus across data sources" : input.fusedIntelligence.signalAgreement < 0.3 ? "Conflicting signals suggest uncertainty" : "Mixed signals require careful evaluation",
      weight: 0.15
    });
  }
  steps.push({
    step: stepNum++,
    category: "risk_assessment",
    observation: `Risk level: ${decision.riskLevel}, Confidence: ${(decision.confidence * 100).toFixed(0)}%`,
    implication: decision.riskLevel === "low" ? "Low risk supports position taking" : decision.riskLevel === "high" ? "High risk warrants smaller position or waiting" : "Moderate risk, proceed with caution",
    weight: 0.1
  });
  steps.push({
    step: stepNum++,
    category: "final_decision",
    observation: `Action: ${decision.action.toUpperCase()}`,
    implication: decision.reasoning,
    weight: 1
  });
  return steps;
}
function generateAlternatives(input, chosenDecision) {
  const alternatives = [];
  const actions = ["buy", "sell", "hold"];
  for (const action of actions) {
    if (action === chosenDecision.action) continue;
    let confidence = 0;
    let reasoning = "";
    let whyRejected = "";
    switch (action) {
      case "buy":
        confidence = input.sentiment?.overall === "bullish" ? 0.4 : 0.2;
        if (input.marketData.changePercent24h && input.marketData.changePercent24h > 0) {
          confidence += 0.1;
        }
        reasoning = "Potential entry point based on market conditions";
        whyRejected = chosenDecision.action === "hold" ? "Insufficient conviction for entry" : "Better opportunity identified in opposite direction";
        break;
      case "sell":
        confidence = input.sentiment?.overall === "bearish" ? 0.4 : 0.2;
        if (input.marketData.changePercent24h && input.marketData.changePercent24h < 0) {
          confidence += 0.1;
        }
        reasoning = "Exit or short opportunity based on bearish signals";
        whyRejected = chosenDecision.action === "hold" ? "No existing position or insufficient bearish confirmation" : "Bullish signals outweigh bearish indicators";
        break;
      case "hold":
        confidence = 0.5;
        reasoning = "Wait for clearer signals before acting";
        whyRejected = chosenDecision.confidence > 0.6 ? "Strong signals support taking action" : "Opportunity cost of waiting outweighed by potential gains";
        break;
    }
    alternatives.push({
      action,
      confidence,
      reasoning,
      whyRejected
    });
  }
  alternatives.sort((a, b) => b.confidence - a.confidence);
  return alternatives;
}
function createEnhancedDecisionLog(decision, marketData, newsContext, strategy, fusedIntelligence, providerInfo, cycleId) {
  const id = `decision_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const input = createInputSnapshot(marketData, newsContext, strategy, fusedIntelligence);
  const reasoning = generateReasoningSteps(input, decision);
  const alternatives = generateAlternatives(input, decision);
  const dataSourcesUsed = [];
  if (input.marketData) dataSourcesUsed.push("market_data");
  if (input.sentiment) dataSourcesUsed.push(...input.sentiment.sources || []);
  if (input.fundamentals) dataSourcesUsed.push(...input.fundamentals.sources || []);
  const keyFactors = [];
  const sortedSteps = [...reasoning].sort((a, b) => b.weight - a.weight);
  for (const step of sortedSteps.slice(0, 3)) {
    if (step.category !== "final_decision") {
      keyFactors.push(step.implication);
    }
  }
  const enhancedLog = {
    id,
    timestamp: /* @__PURE__ */ new Date(),
    cycleId,
    input,
    reasoning: {
      steps: reasoning,
      summary: decision.reasoning,
      keyFactors
    },
    alternatives,
    decision,
    providerInfo: {
      provider: providerInfo?.provider || "unknown",
      model: providerInfo?.model || "unknown",
      tokensUsed: providerInfo?.tokensUsed,
      latencyMs: providerInfo?.latencyMs,
      cost: providerInfo?.cost
    },
    metadata: {
      dataSourcesUsed: [...new Set(dataSourcesUsed)],
      enrichmentApplied: !!fusedIntelligence,
      fusionConfidence: fusedIntelligence?.dataQuality.reliability || 0,
      warningCount: fusedIntelligence?.warnings.length || 0
    }
  };
  log.ai("Enhanced decision logged", {
    id,
    symbol: marketData.symbol,
    action: decision.action,
    confidence: decision.confidence,
    alternativesCount: alternatives.length,
    reasoningSteps: reasoning.length
  });
  return enhancedLog;
}
var init_enhanced_decision_log = __esm({
  "server/ai/enhanced-decision-log.ts"() {
    "use strict";
    init_logger();
  }
});

// server/lib/order-execution-cache.ts
var order_execution_cache_exports = {};
__export(order_execution_cache_exports, {
  cacheAccountSnapshot: () => cacheAccountSnapshot,
  cacheQuickQuote: () => cacheQuickQuote,
  cacheTradability: () => cacheTradability,
  clearOrderCaches: () => clearOrderCaches,
  getAccountSnapshot: () => getAccountSnapshot,
  getCachedBuyingPower: () => getCachedBuyingPower,
  getCachedPrice: () => getCachedPrice,
  getOrderCacheStats: () => getOrderCacheStats,
  getQuickQuote: () => getQuickQuote,
  getTradability: () => getTradability,
  isTradable: () => isTradable,
  preloadOrderValidationData: () => preloadOrderValidationData
});
function cacheQuickQuote(quote) {
  quickQuoteCache.set(quote.symbol, quote);
}
function getQuickQuote(symbol) {
  const result = quickQuoteCache.get(symbol);
  return result?.data ?? null;
}
function getCachedPrice(symbol) {
  const quote = getQuickQuote(symbol);
  return quote?.price ?? null;
}
function cacheTradability(asset) {
  tradabilityCache.set(asset.symbol, asset);
}
function getTradability(symbol) {
  const result = tradabilityCache.get(symbol);
  return result?.data ?? null;
}
function isTradable(symbol) {
  const asset = getTradability(symbol);
  return asset?.tradable ?? null;
}
function cacheAccountSnapshot(snapshot) {
  accountSnapshotCache.set("account", snapshot);
}
function getAccountSnapshot() {
  const result = accountSnapshotCache.get("account");
  return result?.data ?? null;
}
function getCachedBuyingPower() {
  const snapshot = getAccountSnapshot();
  return snapshot?.buyingPower ?? null;
}
function preloadOrderValidationData(symbols, getQuote, getAsset, getAccount) {
  const now = Date.now();
  const quotePromises = symbols.map(async (symbol) => {
    const cached = getQuickQuote(symbol);
    if (cached) return;
    try {
      const quote = await getQuote(symbol);
      cacheQuickQuote({
        symbol,
        price: quote.price,
        bid: quote.bid,
        ask: quote.ask,
        spread: quote.ask - quote.bid,
        timestamp: now
      });
    } catch {
    }
  });
  const assetPromises = symbols.map(async (symbol) => {
    const cached = getTradability(symbol);
    if (cached) return;
    try {
      const asset = await getAsset(symbol);
      cacheTradability({
        symbol,
        tradable: asset.tradable,
        fractionable: asset.fractionable,
        shortable: asset.shortable,
        marginable: asset.marginable,
        timestamp: now
      });
    } catch {
    }
  });
  const accountPromise = (async () => {
    const cached = getAccountSnapshot();
    if (cached) return;
    try {
      const account = await getAccount();
      cacheAccountSnapshot({
        buyingPower: parseFloat(account.buying_power),
        cash: parseFloat(account.cash),
        equity: parseFloat(account.equity),
        timestamp: now
      });
    } catch {
    }
  })();
  return Promise.all([...quotePromises, ...assetPromises, accountPromise]).then(() => {
  });
}
function clearOrderCaches() {
  quickQuoteCache.clear();
  tradabilityCache.clear();
  accountSnapshotCache.clear();
}
function getOrderCacheStats() {
  return {
    quotes: quickQuoteCache.size(),
    tradability: tradabilityCache.size(),
    hasAccountSnapshot: accountSnapshotCache.has("account")
  };
}
var quickQuoteCache, tradabilityCache, accountSnapshotCache;
var init_order_execution_cache = __esm({
  "server/lib/order-execution-cache.ts"() {
    "use strict";
    init_api_cache();
    quickQuoteCache = new ApiCache({
      freshDuration: 5 * 1e3,
      staleDuration: 30 * 1e3,
      maxEntries: 500
    });
    tradabilityCache = new ApiCache({
      freshDuration: 5 * 60 * 1e3,
      staleDuration: 60 * 60 * 1e3,
      maxEntries: 1e3
    });
    accountSnapshotCache = new ApiCache({
      freshDuration: 10 * 1e3,
      staleDuration: 60 * 1e3,
      maxEntries: 1
    });
  }
});

// server/services/tradability-service.ts
function mapAlpacaAssetToInsert(asset) {
  return {
    alpacaId: asset.id,
    symbol: asset.symbol.toUpperCase(),
    name: asset.name,
    assetClass: asset.class === "crypto" ? "crypto" : "us_equity",
    exchange: asset.exchange,
    status: asset.status,
    tradable: asset.tradable,
    marginable: asset.marginable,
    shortable: asset.shortable,
    easyToBorrow: asset.easy_to_borrow,
    fractionable: asset.fractionable,
    lastSyncedAt: /* @__PURE__ */ new Date()
  };
}
function brokerAssetToTradabilityCheck(asset) {
  return {
    symbol: asset.symbol,
    tradable: asset.tradable,
    assetClass: asset.assetClass,
    exchange: asset.exchange,
    fractionable: asset.fractionable,
    marginable: asset.marginable,
    shortable: asset.shortable,
    lastSyncedAt: asset.lastSyncedAt,
    reason: asset.tradable ? void 0 : `Asset status: ${asset.status}`
  };
}
var SYNC_STALE_THRESHOLD_MS, CACHE_TTL_MS2, memoryCache, TradabilityService, tradabilityService;
var init_tradability_service = __esm({
  "server/services/tradability-service.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_logger();
    SYNC_STALE_THRESHOLD_MS = 24 * 60 * 60 * 1e3;
    CACHE_TTL_MS2 = 5 * 60 * 1e3;
    memoryCache = /* @__PURE__ */ new Map();
    TradabilityService = class {
      async validateSymbolTradable(symbol) {
        const normalizedSymbol = symbol.toUpperCase();
        const cached = memoryCache.get(normalizedSymbol);
        if (cached && Date.now() - cached.cachedAt < CACHE_TTL_MS2) {
          return cached.check;
        }
        const dbAsset = await storage.getBrokerAsset(normalizedSymbol);
        if (dbAsset) {
          const check = brokerAssetToTradabilityCheck(dbAsset);
          memoryCache.set(normalizedSymbol, { check, cachedAt: Date.now() });
          return check;
        }
        try {
          const alpacaAsset = await alpaca.getAsset(normalizedSymbol);
          if (alpacaAsset) {
            const insertAsset = mapAlpacaAssetToInsert(alpacaAsset);
            const savedAsset = await storage.upsertBrokerAsset(insertAsset);
            const check = brokerAssetToTradabilityCheck(savedAsset);
            memoryCache.set(normalizedSymbol, { check, cachedAt: Date.now() });
            return check;
          }
        } catch (error) {
          log.warn("tradability", `Failed to fetch asset ${normalizedSymbol} from Alpaca`, { error: error.message });
        }
        const notFoundCheck = {
          symbol: normalizedSymbol,
          tradable: false,
          reason: "Symbol not found in broker asset universe"
        };
        memoryCache.set(normalizedSymbol, { check: notFoundCheck, cachedAt: Date.now() });
        return notFoundCheck;
      }
      async validateSymbolsTradable(symbols) {
        const results = /* @__PURE__ */ new Map();
        for (const symbol of symbols) {
          const check = await this.validateSymbolTradable(symbol);
          results.set(symbol.toUpperCase(), check);
        }
        return results;
      }
      async syncAssetUniverse(assetClass = "us_equity") {
        const errors = [];
        let synced = 0;
        let tradable = 0;
        try {
          log.info("tradability", `Starting universe sync for ${assetClass}`);
          const assets = await alpaca.getAssets("active", assetClass);
          log.info("tradability", `Fetched ${assets.length} ${assetClass} assets from Alpaca`);
          const insertAssets = assets.map(mapAlpacaAssetToInsert);
          synced = await storage.bulkUpsertBrokerAssets(insertAssets);
          tradable = assets.filter((a) => a.tradable).length;
          log.info("tradability", `Universe sync complete: ${synced} synced, ${tradable} tradable`);
        } catch (error) {
          errors.push(`Sync failed for ${assetClass}: ${error.message}`);
          log.error("tradability", `Universe sync error: ${error.message}`);
        }
        return { synced, tradable, errors };
      }
      async getUniverseStats() {
        const equityCount = await storage.getBrokerAssetCount("us_equity");
        const cryptoCount = await storage.getBrokerAssetCount("crypto");
        const lastSyncedAt = await storage.getLastAssetSyncTime();
        const tradableEquities = (await storage.getBrokerAssets("us_equity", true)).length;
        const tradableCrypto = (await storage.getBrokerAssets("crypto", true)).length;
        const isStale = !lastSyncedAt || Date.now() - lastSyncedAt.getTime() > SYNC_STALE_THRESHOLD_MS;
        return {
          totalAssets: equityCount + cryptoCount,
          tradableEquities,
          tradableCrypto,
          lastSyncedAt,
          isStale
        };
      }
      async searchSymbols(query, limit4 = 20) {
        return storage.searchBrokerAssets(query, limit4);
      }
      clearMemoryCache() {
        memoryCache.clear();
        log.info("tradability", "Memory cache cleared");
      }
    };
    tradabilityService = new TradabilityService();
  }
});

// server/trading/alpaca-trading-engine.ts
var alpaca_trading_engine_exports = {};
__export(alpaca_trading_engine_exports, {
  alpacaTradingEngine: () => alpacaTradingEngine
});
var AlpacaTradingEngine, alpacaTradingEngine;
var init_alpaca_trading_engine = __esm({
  "server/trading/alpaca-trading-engine.ts"() {
    "use strict";
    init_storage();
    init_alpaca();
    init_decision_engine();
    init_llmGateway();
    init_newsapi();
    init_orchestration();
    init_numeric();
    init_data_fusion_engine2();
    init_enhanced_decision_log();
    init_huggingface();
    init_valyu();
    init_gdelt();
    init_logger();
    init_order_execution_cache();
    init_tradability_service();
    AlpacaTradingEngine = class {
      strategyRunners = /* @__PURE__ */ new Map();
      strategyStates = /* @__PURE__ */ new Map();
      checkIntervalMs = 6e4;
      backgroundGeneratorInterval = null;
      backgroundGeneratorIntervalMs = 12e4;
      initialized = false;
      autoStartStrategyId = null;
      orchestratorControlEnabled = true;
      enableOrchestratorControl() {
        this.orchestratorControlEnabled = true;
        console.log("[AlpacaTradingEngine] Orchestrator control ENABLED - autonomous trading disabled");
      }
      disableOrchestratorControl() {
        this.orchestratorControlEnabled = false;
        console.log("[AlpacaTradingEngine] Orchestrator control DISABLED - autonomous trading allowed");
      }
      isOrchestratorControlEnabled() {
        return this.orchestratorControlEnabled;
      }
      DEFAULT_WATCHLIST = [
        "AAPL",
        "GOOGL",
        "MSFT",
        "AMZN",
        "TSLA",
        "NVDA",
        "META",
        "JPM",
        "V",
        "UNH",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ];
      normalizeSymbolForAlpaca(symbol, forOrder = false) {
        if (forOrder && this.isCryptoSymbol(symbol)) {
          return this.normalizeCryptoSymbol(symbol);
        }
        return symbol.replace("/", "").toUpperCase();
      }
      isCryptoSymbol(symbol) {
        const upperSymbol = symbol.toUpperCase();
        const cryptoPairs = [
          "BTC/USD",
          "ETH/USD",
          "SOL/USD",
          "DOGE/USD",
          "SHIB/USD",
          "AVAX/USD",
          "DOT/USD",
          "LINK/USD",
          "UNI/USD",
          "AAVE/USD",
          "LTC/USD",
          "BCH/USD",
          "BTCUSD",
          "ETHUSD",
          "SOLUSD",
          "DOGEUSD",
          "SHIBUSD",
          "AVAXUSD",
          "DOTUSD",
          "LINKUSD",
          "UNIUSD",
          "AAVEUSD",
          "LTCUSD",
          "BCHUSD"
        ];
        return cryptoPairs.includes(upperSymbol) || symbol.includes("/") && upperSymbol.endsWith("USD");
      }
      normalizeCryptoSymbol(symbol) {
        const upperSymbol = symbol.toUpperCase();
        if (upperSymbol.includes("/")) {
          return upperSymbol;
        }
        if (upperSymbol === "BTCUSD") return "BTC/USD";
        if (upperSymbol === "ETHUSD") return "ETH/USD";
        if (upperSymbol === "SOLUSD") return "SOL/USD";
        if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
          const base = upperSymbol.slice(0, -3);
          return `${base}/USD`;
        }
        return upperSymbol;
      }
      async initialize() {
        if (this.initialized) return;
        this.initialized = true;
        try {
          const strategies2 = await storage.getStrategies();
          let autoPilotStrategy = strategies2.find((s) => s.name === "Auto-Pilot Strategy");
          if (!autoPilotStrategy) {
            console.log("Creating default Auto-Pilot Strategy...");
            autoPilotStrategy = await storage.createStrategy({
              name: "Auto-Pilot Strategy",
              type: "momentum",
              description: "Default AI-powered trading strategy that automatically analyzes market opportunities",
              isActive: true,
              assets: this.DEFAULT_WATCHLIST,
              parameters: JSON.stringify({
                riskLevel: "medium",
                maxPositionSize: 0.05,
                confidenceThreshold: 0.6,
                autoExecute: true
              })
            });
            console.log(`Created Auto-Pilot Strategy with ID: ${autoPilotStrategy.id}`);
          }
          this.autoStartStrategyId = autoPilotStrategy.id;
          this.startBackgroundAIGenerator();
          await storage.updateAgentStatus({
            isRunning: true,
            lastHeartbeat: /* @__PURE__ */ new Date()
          });
          console.log("Trading agent initialized and active by default");
          this.warmupCaches().catch(
            (err) => console.log("Cache warmup skipped:", err.message)
          );
          setTimeout(async () => {
            try {
              const isConnected = await this.isAlpacaConnected();
              if (isConnected) {
                console.log("Alpaca connected, auto-starting all active strategies...");
                const allStrategies = await storage.getStrategies();
                const activeStrategies = allStrategies.filter((s) => s.isActive);
                for (const strategy of activeStrategies) {
                  if (!this.strategyRunners.has(strategy.id)) {
                    console.log(`Auto-starting strategy: ${strategy.name}`);
                    const result = await this.startStrategy(strategy.id);
                    if (result.success) {
                      console.log(`Strategy "${strategy.name}" started successfully`);
                    } else {
                      console.log(`Could not start strategy "${strategy.name}": ${result.error}`);
                    }
                  }
                }
                if (activeStrategies.length === 0 && this.autoStartStrategyId) {
                  console.log("No active strategies found, starting Auto-Pilot Strategy...");
                  const result = await this.startStrategy(this.autoStartStrategyId);
                  if (result.success) {
                    console.log("Auto-Pilot Strategy started successfully");
                  }
                }
              } else {
                console.log("Alpaca not connected - running in AI suggestion mode only");
              }
            } catch (err) {
              console.error("Error during auto-start:", err);
            }
          }, 5e3);
        } catch (error) {
          console.error("Failed to initialize trading engine:", error);
        }
      }
      async warmupCaches() {
        console.log("[Cache] Warming up order execution caches...");
        const startTime = Date.now();
        try {
          const account = await alpaca.getAccount();
          cacheAccountSnapshot({
            buyingPower: parseFloat(account.buying_power),
            cash: parseFloat(account.cash),
            equity: parseFloat(account.equity),
            timestamp: Date.now()
          });
          const symbols = this.DEFAULT_WATCHLIST.slice(0, 10);
          const snapshots = await alpaca.getSnapshots(symbols);
          for (const symbol of symbols) {
            const snapshot = snapshots[symbol];
            if (snapshot?.latestTrade) {
              cacheQuickQuote({
                symbol,
                price: snapshot.latestTrade.p,
                bid: snapshot.latestQuote?.bp || snapshot.latestTrade.p,
                ask: snapshot.latestQuote?.ap || snapshot.latestTrade.p,
                spread: (snapshot.latestQuote?.ap || 0) - (snapshot.latestQuote?.bp || 0),
                timestamp: Date.now()
              });
            }
          }
          const assets = await alpaca.getAssets();
          const relevantAssets = assets.filter((a) => symbols.includes(a.symbol));
          for (const asset of relevantAssets) {
            cacheTradability({
              symbol: asset.symbol,
              tradable: asset.tradable,
              fractionable: asset.fractionable,
              shortable: asset.shortable,
              marginable: asset.marginable,
              timestamp: Date.now()
            });
          }
          const elapsed = Date.now() - startTime;
          const stats = getOrderCacheStats();
          console.log(`[Cache] Warmup complete in ${elapsed}ms: ${stats.quotes} quotes, ${stats.tradability} assets cached`);
        } catch (error) {
          console.log("[Cache] Warmup failed:", error.message);
        }
      }
      startBackgroundAIGenerator() {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
        }
        console.log("Starting background AI suggestion generator...");
        this.generateBackgroundAISuggestions();
        this.backgroundGeneratorInterval = setInterval(
          () => this.generateBackgroundAISuggestions(),
          this.backgroundGeneratorIntervalMs
        );
      }
      async generateBackgroundAISuggestions() {
        try {
          const agentStatus2 = await storage.getAgentStatus();
          if (agentStatus2?.killSwitchActive) {
            console.log("Kill switch active - skipping background AI generation");
            return;
          }
          const batchTraceId = generateTraceId();
          console.log(`Generating background AI suggestions... (batchTraceId: ${batchTraceId})`);
          const symbolsToAnalyze = this.DEFAULT_WATCHLIST.slice(0, 5);
          for (const symbol of symbolsToAnalyze) {
            try {
              await this.analyzeSymbol(symbol, void 0, batchTraceId);
              console.log(`Generated AI suggestion for ${symbol}`);
            } catch (err) {
              console.log(`Could not analyze ${symbol}:`, err.message);
            }
            await new Promise((resolve2) => setTimeout(resolve2, 2e3));
          }
          await storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() });
        } catch (error) {
          console.error("Background AI generation error:", error);
        }
      }
      stopBackgroundGenerator() {
        if (this.backgroundGeneratorInterval) {
          clearInterval(this.backgroundGeneratorInterval);
          this.backgroundGeneratorInterval = null;
          console.log("Background AI generator stopped");
        }
      }
      async isAlpacaConnected() {
        try {
          const status = alpaca.getConnectionStatus();
          if (!status.hasCredentials) return false;
          await alpaca.getAccount();
          return true;
        } catch {
          return false;
        }
      }
      async getAlpacaAccount() {
        return await alpaca.getAccount();
      }
      async getAlpacaPositions() {
        return await alpaca.getPositions();
      }
      async getMarketStatus() {
        return await alpaca.getMarketStatus();
      }
      async getClock() {
        return await alpaca.getClock();
      }
      async canTradeExtendedHours(symbol) {
        if (this.isCryptoSymbol(symbol)) {
          return { allowed: false, reason: "Extended hours trading is not available for crypto" };
        }
        const marketStatus = await this.getMarketStatus();
        if (marketStatus.session === "regular") {
          return { allowed: true };
        }
        if (marketStatus.isExtendedHours || marketStatus.session === "pre-market" || marketStatus.session === "after-hours") {
          return { allowed: true };
        }
        return { allowed: false, reason: "Market is closed and not in extended hours session (4AM-8PM ET on weekdays)" };
      }
      async executeAlpacaTrade(request) {
        try {
          const {
            symbol,
            side,
            quantity,
            strategyId,
            notes,
            orderType = "market",
            limitPrice,
            stopLossPrice,
            takeProfitPrice,
            useBracketOrder,
            trailingStopPercent,
            extendedHours = false
          } = request;
          if (quantity <= 0) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Quantity must be greater than 0`, {
              symbol,
              side,
              quantity,
              reason: "INVALID_QUANTITY"
            });
            return { success: false, error: "Quantity must be greater than 0" };
          }
          if (this.orchestratorControlEnabled && !request.authorizedByOrchestrator) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Orchestrator control active`, {
              symbol,
              side,
              quantity,
              reason: "ORCHESTRATOR_CONTROL_ACTIVE",
              orchestratorControlEnabled: this.orchestratorControlEnabled,
              authorizedByOrchestrator: request.authorizedByOrchestrator
            });
            return { success: false, error: "Orchestrator control active - direct trade execution blocked. Trades must go through the work queue." };
          }
          if (side === "sell") {
            const alpacaSymbolForCheck = this.normalizeSymbolForAlpaca(symbol, true);
            try {
              const position = await alpaca.getPosition(alpacaSymbolForCheck);
              if (position) {
                const entryPrice = safeParseFloat(position.avg_entry_price);
                const currentPrice = safeParseFloat(position.current_price);
                const isAtLoss = currentPrice < entryPrice;
                const isStopLossOrEmergency = notes?.toLowerCase().includes("stop-loss") || notes?.toLowerCase().includes("emergency") || notes?.toLowerCase().includes("stop loss");
                if (isAtLoss && !isStopLossOrEmergency) {
                  const lossPercent = ((entryPrice - currentPrice) / entryPrice * 100).toFixed(2);
                  log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Loss protection active`, {
                    symbol,
                    side,
                    quantity,
                    reason: "LOSS_PROTECTION_ACTIVE",
                    entryPrice,
                    currentPrice,
                    lossPercent: parseFloat(lossPercent),
                    isStopLossOrEmergency
                  });
                  return {
                    success: false,
                    error: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`
                  };
                }
              }
            } catch (posError) {
            }
          }
          const riskCheck = await this.checkRiskLimits(symbol, side, quantity);
          if (!riskCheck.allowed) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Risk limit exceeded`, {
              symbol,
              side,
              quantity,
              reason: "RISK_LIMIT_EXCEEDED",
              riskCheckReason: riskCheck.reason
            });
            return { success: false, error: riskCheck.reason };
          }
          const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
          if (!tradabilityCheck.tradable) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Symbol not tradable`, {
              symbol,
              side,
              quantity,
              reason: "SYMBOL_NOT_TRADABLE",
              tradabilityReason: tradabilityCheck.reason
            });
            return { success: false, error: `Symbol ${symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}` };
          }
          const alpacaSymbol = this.normalizeSymbolForAlpaca(symbol, true);
          const isCrypto = this.isCryptoSymbol(symbol);
          let order;
          if (extendedHours && isCrypto) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Extended hours not available for crypto`, {
              symbol,
              side,
              quantity,
              reason: "EXTENDED_HOURS_CRYPTO_NOT_SUPPORTED"
            });
            return { success: false, error: "Extended hours trading is not available for crypto" };
          }
          if (extendedHours && !["limit", "stop_limit"].includes(orderType)) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Extended hours requires limit or stop_limit orders`, {
              symbol,
              side,
              quantity,
              orderType,
              reason: "EXTENDED_HOURS_REQUIRES_LIMIT_OR_STOP_LIMIT"
            });
            return { success: false, error: "Extended hours trading requires limit or stop_limit orders only" };
          }
          if (extendedHours && !limitPrice) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Extended hours requires limit price`, {
              symbol,
              side,
              quantity,
              reason: "EXTENDED_HOURS_REQUIRES_LIMIT_PRICE"
            });
            return { success: false, error: "Extended hours trading requires a limit price" };
          }
          if (extendedHours && !Number.isInteger(quantity)) {
            log.warn("Trading", `ORDER_BLOCKED: ${symbol} - Extended hours requires whole shares`, {
              symbol,
              side,
              quantity,
              reason: "EXTENDED_HOURS_REQUIRES_WHOLE_SHARES"
            });
            return { success: false, error: "Extended hours trading requires whole share quantities (no fractional shares)" };
          }
          const shouldUseBracketOrder = useBracketOrder && side === "buy" && stopLossPrice && takeProfitPrice && !isCrypto && !extendedHours;
          if (shouldUseBracketOrder) {
            const bracketParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: orderType === "limit" ? "limit" : "market",
              time_in_force: "day",
              // FIXED: Was "gtc" which causes 422 rejection
              take_profit_price: takeProfitPrice.toFixed(2),
              stop_loss_price: stopLossPrice.toFixed(2)
            };
            if (orderType === "limit" && limitPrice) {
              bracketParams.limit_price = limitPrice.toString();
            }
            logger.info("Trading", `Creating bracket order for ${symbol}: Entry=${limitPrice || "market"}, TP=$${takeProfitPrice.toFixed(2)}, SL=$${stopLossPrice.toFixed(2)}, TIF=day`);
            order = await alpaca.createBracketOrder(bracketParams);
            logger.info("Trading", `Bracket order submitted for ${symbol}`, { orderId: order.id, status: order.status });
          } else if (trailingStopPercent && side === "sell" && !isCrypto && !extendedHours) {
            console.log(`[Trading] Creating trailing stop order for ${symbol}: trail=${trailingStopPercent}%`);
            order = await alpaca.createTrailingStopOrder({
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              trail_percent: trailingStopPercent,
              time_in_force: "gtc"
            });
          } else if (extendedHours) {
            const orderParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: "limit",
              time_in_force: "day",
              limit_price: limitPrice.toString(),
              extended_hours: true
            };
            console.log(`[Trading] Creating extended hours limit order for ${symbol}: ${side} ${quantity} @ $${limitPrice}`);
            order = await alpaca.createOrder(orderParams);
          } else {
            const effectiveTif = orderType === "market" ? "day" : isCrypto ? "gtc" : "day";
            const orderParams = {
              symbol: alpacaSymbol,
              qty: quantity.toString(),
              side,
              type: orderType,
              time_in_force: effectiveTif
            };
            if (orderType === "limit" && limitPrice) {
              orderParams.limit_price = limitPrice.toString();
            }
            order = await alpaca.createOrder(orderParams);
          }
          const filledPrice = order.filled_avg_price ? safeParseFloat(order.filled_avg_price) : limitPrice || 0;
          let tradeNotes = notes || `Alpaca Order ID: ${order.id}`;
          if (shouldUseBracketOrder) {
            tradeNotes += ` | Bracket: SL=$${stopLossPrice?.toFixed(2)}, TP=$${takeProfitPrice?.toFixed(2)}`;
          }
          const trade = await storage.createTrade({
            symbol: symbol.toUpperCase(),
            side,
            quantity: quantity.toString(),
            price: filledPrice.toString(),
            strategyId: strategyId || null,
            status: order.status,
            notes: tradeNotes,
            pnl: null
          });
          await this.updateAgentStats();
          const tradeEvent = {
            tradeId: trade.id,
            orderId: order.id,
            symbol: symbol.toUpperCase(),
            side,
            quantity,
            price: filledPrice,
            status: order.status,
            strategyId
          };
          eventBus.emit("trade:executed", tradeEvent, "alpaca-trading-engine");
          logger.trade(`Executed ${side} ${quantity} ${symbol} @ $${filledPrice}`, { orderId: order.id, status: order.status });
          if (side === "buy" && order.status === "filled" && !shouldUseBracketOrder && !isCrypto && !extendedHours) {
            try {
              const entryPrice = filledPrice || limitPrice || 0;
              const stopLossPrice2 = entryPrice * 0.98;
              logger.info("Trading", `Creating automated stop-loss for ${symbol}`, {
                entryPrice,
                stopLossPrice: stopLossPrice2.toFixed(2),
                quantity
              });
              const stopLossOrder = await alpaca.createOrder({
                symbol: alpacaSymbol,
                qty: quantity.toString(),
                side: "sell",
                type: "stop",
                stop_price: stopLossPrice2.toFixed(2),
                time_in_force: "gtc"
              });
              await storage.updateTrade(trade.id, {
                notes: `${tradeNotes} | Stop-Loss: Order ${stopLossOrder.id} @ $${stopLossPrice2.toFixed(2)}`
              });
              logger.info("Trading", `Automated stop-loss created for ${symbol}`, {
                stopLossOrderId: stopLossOrder.id,
                stopLossPrice: stopLossPrice2.toFixed(2),
                tradeId: trade.id
              });
            } catch (stopLossError) {
              logger.error("Trading", `Failed to create automated stop-loss for ${symbol}`, {
                error: stopLossError.message,
                tradeId: trade.id
              });
            }
          }
          return { success: true, order, trade };
        } catch (error) {
          const errorMsg = error.message;
          logger.error("Trading", `Trade execution FAILED for ${request.symbol}: ${errorMsg}`, {
            symbol: request.symbol,
            side: request.side,
            quantity: request.quantity,
            orderType: request.orderType,
            useBracketOrder: request.useBracketOrder,
            error: errorMsg
          });
          eventBus.emit("trade:error", {
            symbol: request.symbol,
            side: request.side,
            quantity: request.quantity,
            message: errorMsg,
            orderType: request.orderType,
            useBracketOrder: request.useBracketOrder
          }, "alpaca-trading-engine");
          return { success: false, error: errorMsg };
        }
      }
      async closeAlpacaPosition(symbol, strategyId, options = {}) {
        try {
          if (this.orchestratorControlEnabled && !options.authorizedByOrchestrator && !options.isEmergencyStop) {
            console.log(`[AlpacaTradingEngine] Position close blocked for ${symbol} - orchestrator has control. Direct position close blocked.`);
            return { success: false, error: "Orchestrator control active - direct position close blocked. Must go through work queue or be an emergency stop." };
          }
          const alpacaSymbol = this.isCryptoSymbol(symbol) ? this.normalizeCryptoSymbol(symbol) : this.normalizeSymbolForAlpaca(symbol);
          let position = null;
          try {
            position = await alpaca.getPosition(alpacaSymbol);
          } catch (posError) {
            const errorMsg = posError.message?.toLowerCase() || "";
            if (errorMsg.includes("404") || errorMsg.includes("not found") || errorMsg.includes("position does not exist")) {
              return { success: true, error: `Position for ${symbol} already closed or does not exist` };
            }
            throw posError;
          }
          if (!position) {
            return { success: true, error: `No position found for ${symbol} - may already be closed` };
          }
          const entryPrice = safeParseFloat(position.avg_entry_price);
          const currentPrice = safeParseFloat(position.current_price);
          const isAtLoss = currentPrice < entryPrice;
          const isProtectedClose = options.isStopLossTriggered || options.isEmergencyStop;
          if (isAtLoss && !isProtectedClose) {
            const lossPercent = ((entryPrice - currentPrice) / entryPrice * 100).toFixed(2);
            console.log(`[LossProtection] Blocking close of ${symbol} at ${lossPercent}% loss - waiting for stop-loss or price recovery`);
            return {
              success: false,
              error: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`
            };
          }
          let order;
          try {
            order = await alpaca.closePosition(alpacaSymbol);
          } catch (closeError) {
            const errorMsg = closeError.message?.toLowerCase() || "";
            if (errorMsg.includes("404") || errorMsg.includes("not found") || errorMsg.includes("position does not exist")) {
              return { success: true, error: `Position for ${symbol} was already closed` };
            }
            throw closeError;
          }
          const quantity = safeParseFloat(position.qty);
          const exitPrice = safeParseFloat(order.filled_avg_price || position.current_price);
          const isShort = position.side === "short";
          const pnl = calculatePnL(entryPrice, exitPrice, quantity, isShort ? "short" : "long");
          const tradeSide = isShort ? "buy" : "sell";
          const trade = await storage.createTrade({
            symbol: symbol.toUpperCase(),
            side: tradeSide,
            quantity: quantity.toString(),
            price: exitPrice.toString(),
            strategyId: strategyId || null,
            status: "completed",
            notes: `Closed Alpaca ${position.side} position. Order ID: ${order.id}`,
            pnl: pnl.toString()
          });
          await this.updateAgentStats();
          const positionEvent = {
            symbol: symbol.toUpperCase(),
            quantity: 0,
            entryPrice,
            currentPrice: exitPrice,
            unrealizedPnl: 0,
            side: isShort ? "short" : "long"
          };
          eventBus.emit("position:closed", positionEvent, "alpaca-trading-engine");
          logger.trade(`Closed ${position.side} position ${symbol}`, { pnl, exitPrice });
          return { success: true, order, trade };
        } catch (error) {
          console.error("Close Alpaca position error:", error);
          eventBus.emit("trade:error", { message: error.message }, "alpaca-trading-engine");
          return { success: false, error: error.message };
        }
      }
      async analyzeSymbol(symbol, strategyId, traceId) {
        const effectiveTraceId = traceId || generateTraceId();
        const marketData = await this.getMarketDataForSymbol(symbol);
        if (!marketData) {
          throw new Error(`Could not get market data for ${symbol}`);
        }
        let strategy;
        let newsContext;
        let fusedIntelligence;
        if (strategyId) {
          strategy = await storage.getStrategy(strategyId);
        }
        try {
          const newsArticles = await newsapi.getStockNews(symbol, 5);
          if (newsArticles.length > 0) {
            newsContext = {
              headlines: newsArticles.map((a) => a.title),
              sentiment: this.analyzeSentiment(newsArticles.map((a) => a.title)),
              summary: `Recent news about ${symbol}`
            };
          }
        } catch (e) {
          console.log(`Could not fetch news for ${symbol}:`, e);
        }
        const enrichmentData = await this.gatherEnrichmentData(symbol, marketData, newsContext);
        if (enrichmentData.hasEnrichment) {
          try {
            fusedIntelligence = fuseMarketData({
              symbol,
              assetType: this.isCryptoSymbol(symbol) ? "crypto" : "stock",
              marketData: [{
                source: "alpaca",
                symbol,
                price: marketData.currentPrice,
                priceChange: marketData.priceChange24h,
                priceChangePercent: marketData.priceChangePercent24h,
                volume: marketData.volume,
                timestamp: /* @__PURE__ */ new Date(),
                reliability: 0.95
              }],
              sentimentData: enrichmentData.sentimentData,
              fundamentalData: enrichmentData.fundamentalData
            });
            log.info("AI", `Fused intelligence for ${symbol}`, {
              signalAgreement: fusedIntelligence.signalAgreement,
              trendStrength: fusedIntelligence.trendStrength,
              dataQuality: fusedIntelligence.dataQuality.completeness
            });
          } catch (e) {
            log.warn("AI", `Data fusion failed for ${symbol}`, { error: e.message });
          }
        }
        const strategyContext = strategy ? {
          id: strategy.id,
          name: strategy.name,
          type: strategy.type,
          parameters: strategy.parameters ? JSON.parse(strategy.parameters) : void 0
        } : void 0;
        const decision = await aiDecisionEngine.analyzeOpportunity(
          symbol,
          marketData,
          newsContext,
          strategyContext,
          { traceId: effectiveTraceId }
        );
        const enhancedLog = createEnhancedDecisionLog(
          decision,
          marketData,
          newsContext,
          strategyContext,
          fusedIntelligence,
          { provider: "openai", model: "gpt-4o-mini" }
        );
        await storage.createAiDecision({
          strategyId: strategyId || null,
          symbol,
          action: decision.action,
          confidence: decision.confidence.toString(),
          reasoning: decision.reasoning,
          traceId: effectiveTraceId,
          marketContext: JSON.stringify({
            marketData,
            newsContext,
            riskLevel: decision.riskLevel,
            suggestedQuantity: decision.suggestedQuantity,
            targetPrice: decision.targetPrice,
            stopLoss: decision.stopLoss,
            fusedIntelligence: fusedIntelligence ? {
              signalAgreement: fusedIntelligence.signalAgreement,
              trendStrength: fusedIntelligence.trendStrength,
              dataQuality: fusedIntelligence.dataQuality,
              warnings: fusedIntelligence.warnings
            } : void 0,
            enhancedLogId: enhancedLog.id
          })
        });
        return { decision, marketData, fusedIntelligence, enhancedLog };
      }
      /**
       * Gather enrichment data from optional sources (Hugging Face, Valyu.ai, GDELT)
       * Returns empty arrays if API keys aren't configured
       */
      async gatherEnrichmentData(symbol, marketData, newsContext) {
        const sentimentData = [];
        const fundamentalData = [];
        const enrichmentPromises = [];
        if (newsContext?.headlines && newsContext.headlines.length > 0 && huggingface.isAvailable()) {
          enrichmentPromises.push(
            (async () => {
              try {
                const signal = await huggingface.generateEnrichmentSignal(
                  symbol,
                  newsContext.headlines,
                  marketData.priceChangePercent24h
                );
                if (signal) {
                  const sentiment = signal.sentimentScore > 0.2 ? "positive" : signal.sentimentScore < -0.2 ? "negative" : "neutral";
                  sentimentData.push({
                    source: "huggingface_finbert",
                    symbol,
                    sentiment,
                    score: signal.sentimentScore,
                    confidence: signal.confidence,
                    timestamp: /* @__PURE__ */ new Date()
                  });
                }
              } catch (e) {
                log.debug("AI", `HuggingFace enrichment skipped for ${symbol}`, { reason: e.message });
              }
            })()
          );
        }
        const isCrypto = this.isCryptoSymbol(symbol);
        enrichmentPromises.push(
          (async () => {
            try {
              const gdeltSentiment = isCrypto ? await gdelt.getCryptoSentiment(symbol.replace(/USD$|USDT$|\/USD$/i, "")) : await gdelt.analyzeSymbolSentiment(symbol);
              if (gdeltSentiment && gdeltSentiment.articleCount > 0) {
                const sentiment = gdeltSentiment.sentiment === "bullish" ? "positive" : gdeltSentiment.sentiment === "bearish" ? "negative" : "neutral";
                sentimentData.push({
                  source: "gdelt",
                  symbol,
                  sentiment,
                  score: gdeltSentiment.averageTone / 10,
                  confidence: Math.min(0.9, gdeltSentiment.articleCount / 50),
                  headlines: gdeltSentiment.topHeadlines,
                  timestamp: /* @__PURE__ */ new Date()
                });
                if (gdeltSentiment.volumeSpike) {
                  log.info("GDELT", `Breaking news detected for ${symbol}`, {
                    articleCount: gdeltSentiment.articleCount,
                    sentiment: gdeltSentiment.sentiment
                  });
                }
              }
            } catch (e) {
              log.debug("AI", `GDELT enrichment skipped for ${symbol}`, { reason: e.message });
            }
          })()
        );
        if (!isCrypto && valyu.isAvailable()) {
          enrichmentPromises.push(
            (async () => {
              try {
                const [ratios, cashFlow, dividends, insiderData] = await Promise.all([
                  valyu.getFinancialRatios(symbol),
                  valyu.getCashFlow(symbol).catch(() => null),
                  valyu.getDividends(symbol).catch(() => null),
                  valyu.getInsiderTransactions(symbol).catch(() => null)
                ]);
                if (ratios || cashFlow || dividends || insiderData) {
                  fundamentalData.push({
                    source: "valyu",
                    symbol,
                    peRatio: ratios?.peRatio,
                    revenueGrowth: ratios?.revenueGrowth,
                    debtToEquity: ratios?.debtToEquity,
                    freeCashFlow: cashFlow?.freeCashFlow,
                    dividendYield: dividends?.dividendYield,
                    insiderSentiment: insiderData?.netInsiderSentiment,
                    timestamp: /* @__PURE__ */ new Date()
                  });
                  if (insiderData?.netInsiderSentiment === "bearish") {
                    log.warn("Valyu", `Insider selling detected for ${symbol}`, {
                      sentiment: insiderData.netInsiderSentiment,
                      sellValue: insiderData.totalSellValue
                    });
                  }
                }
              } catch (e) {
                log.debug("AI", `Valyu.ai enrichment skipped for ${symbol}`, { reason: e.message });
              }
            })()
          );
        }
        await Promise.allSettled(enrichmentPromises);
        return {
          hasEnrichment: sentimentData.length > 0 || fundamentalData.length > 0,
          sentimentData,
          fundamentalData
        };
      }
      async analyzeAndExecute(symbol, strategyId, traceId) {
        const effectiveTraceId = traceId || generateTraceId();
        const { decision, marketData } = await this.analyzeSymbol(symbol, strategyId, effectiveTraceId);
        if (this.orchestratorControlEnabled) {
          console.log(`[AlpacaTradingEngine] ${symbol} analysis complete (${decision.action}, ${(decision.confidence * 100).toFixed(0)}% confidence) - orchestrator has control, skipping autonomous execution`);
          return { decision };
        }
        const agentStatus2 = await storage.getAgentStatus();
        if (!agentStatus2?.isRunning) {
          return { decision };
        }
        if (decision.action === "hold") {
          return { decision };
        }
        if (decision.confidence < 0.6) {
          return { decision };
        }
        if (!marketData.currentPrice || marketData.currentPrice <= 0 || !Number.isFinite(marketData.currentPrice)) {
          console.warn(`Skipping trade for ${symbol}: invalid price data (currentPrice=${marketData.currentPrice})`);
          this.strategyStates.set(strategyId || symbol, {
            strategyId: strategyId || symbol,
            isRunning: true,
            lastCheck: /* @__PURE__ */ new Date(),
            error: `Invalid price data for ${symbol} - market data unavailable`
          });
          return { decision };
        }
        const account = await alpaca.getAccount();
        const buyingPower = safeParseFloat(account.buying_power);
        if (!Number.isFinite(buyingPower) || buyingPower <= 0) {
          console.warn(`Skipping trade for ${symbol}: invalid buying power (${buyingPower})`);
          return { decision };
        }
        const positionSizePercent = decision.suggestedQuantity || 0.1;
        const tradeValue = buyingPower * positionSizePercent;
        const quantity = Math.floor(tradeValue / marketData.currentPrice);
        if (!Number.isFinite(quantity) || quantity < 1) {
          return { decision };
        }
        const notes = `AI Decision: ${decision.action.toUpperCase()} with ${(decision.confidence * 100).toFixed(0)}% confidence. Risk: ${decision.riskLevel}. ${decision.reasoning}`;
        if (decision.action === "sell") {
          try {
            const alpacaSellSymbol = this.isCryptoSymbol(symbol) ? this.normalizeCryptoSymbol(symbol) : this.normalizeSymbolForAlpaca(symbol);
            const position = await alpaca.getPosition(alpacaSellSymbol);
            if (!position) {
              return { decision };
            }
            const tradeResult2 = await this.closeAlpacaPosition(symbol, strategyId);
            if (tradeResult2.success && tradeResult2.trade) {
              await this.linkAiDecisionToTrade(symbol, strategyId, tradeResult2.trade.id);
            }
            return { decision, tradeResult: tradeResult2 };
          } catch (posError) {
            const errorMsg = posError.message?.toLowerCase() || "";
            if (errorMsg.includes("404") || errorMsg.includes("not found") || errorMsg.includes("position does not exist")) {
              return { decision };
            }
            throw posError;
          }
        }
        const stopLossPrice = decision.stopLoss || marketData.currentPrice * 0.95;
        const takeProfitPrice = decision.targetPrice || marketData.currentPrice * 1.1;
        try {
          const alpacaSymbolCheck = this.isCryptoSymbol(symbol) ? this.normalizeCryptoSymbol(symbol) : this.normalizeSymbolForAlpaca(symbol);
          const openOrders = await alpaca.getOrders("open");
          const symbolSellOrders = openOrders.filter(
            (o) => o.symbol === alpacaSymbolCheck && o.side === "sell"
          );
          if (symbolSellOrders.length > 0) {
            console.log(`[Trading] Skipping buy for ${symbol}: existing sell orders would trigger wash trade (${symbolSellOrders.length} pending sell orders)`);
            return { decision };
          }
        } catch (err) {
          console.log(`[Trading] Could not check open orders for ${symbol}, proceeding with caution: ${err}`);
        }
        const marketStatus = await this.getMarketStatus();
        const isExtendedHoursSession = marketStatus.isExtendedHours && !marketStatus.isOpen;
        const isCrypto = this.isCryptoSymbol(symbol);
        const useBracketOrder = !isCrypto && !isExtendedHoursSession;
        const useExtendedHours = isExtendedHoursSession && !isCrypto;
        const limitPrice = useExtendedHours ? Math.round(marketData.currentPrice * 1.005 * 100) / 100 : void 0;
        const tradeResult = await this.executeAlpacaTrade({
          symbol,
          side: "buy",
          quantity,
          strategyId,
          notes,
          stopLossPrice: useBracketOrder ? stopLossPrice : void 0,
          takeProfitPrice: useBracketOrder ? takeProfitPrice : void 0,
          useBracketOrder,
          extendedHours: useExtendedHours,
          orderType: useExtendedHours ? "limit" : "market",
          limitPrice
        });
        if (tradeResult.success && tradeResult.trade) {
          await this.linkAiDecisionToTrade(symbol, strategyId, tradeResult.trade.id);
        }
        return { decision, tradeResult };
      }
      async linkAiDecisionToTrade(symbol, strategyId, tradeId) {
        try {
          const latestDecision = await storage.getLatestAiDecisionForSymbol(symbol, strategyId);
          if (latestDecision && !latestDecision.executedTradeId) {
            await storage.updateAiDecision(latestDecision.id, { executedTradeId: tradeId });
            console.log(`Linked AI decision ${latestDecision.id} to trade ${tradeId}`);
          }
        } catch (error) {
          console.error(`Failed to link AI decision to trade: ${error}`);
        }
      }
      async startStrategy(strategyId) {
        const strategy = await storage.getStrategy(strategyId);
        if (!strategy) {
          return { success: false, error: "Strategy not found" };
        }
        if (!strategy.assets || strategy.assets.length === 0) {
          return {
            success: false,
            error: "Strategy has no assets configured. Please add at least one symbol/asset to trade before starting the strategy."
          };
        }
        const isConnected = await this.isAlpacaConnected();
        if (!isConnected) {
          return { success: false, error: "Alpaca API not connected" };
        }
        const agentStatus2 = await storage.getAgentStatus();
        if (agentStatus2?.killSwitchActive) {
          return { success: false, error: "Kill switch is active - trading disabled" };
        }
        if (this.strategyRunners.has(strategyId)) {
          return { success: false, error: "Strategy is already running" };
        }
        if (this.orchestratorControlEnabled) {
          console.log(`[AlpacaTradingEngine] Strategy ${strategyId} start skipped - orchestrator has control. AI suggestions will still be generated.`);
          return { success: false, error: "Orchestrator has control - autonomous strategy execution disabled. Use orchestrator for trade execution." };
        }
        await storage.toggleStrategy(strategyId, true);
        await storage.updateAgentStatus({ isRunning: true, lastHeartbeat: /* @__PURE__ */ new Date() });
        const runStrategy = async () => {
          try {
            const currentStrategy = await storage.getStrategy(strategyId);
            if (!currentStrategy || !currentStrategy.isActive) {
              this.stopStrategy(strategyId);
              return;
            }
            const agentStatus3 = await storage.getAgentStatus();
            if (agentStatus3?.killSwitchActive) {
              this.stopStrategy(strategyId);
              return;
            }
            const assets = currentStrategy.assets || [];
            let lastSuccessfulDecision;
            let lastError;
            const runTraceId = generateTraceId();
            for (const asset of assets) {
              try {
                const result = await this.analyzeAndExecute(asset, strategyId, runTraceId);
                lastSuccessfulDecision = result.decision;
              } catch (assetError) {
                const errorMsg = assetError.message || String(assetError);
                console.error(`Error analyzing ${asset}:`, errorMsg);
                lastError = `${asset}: ${errorMsg}`;
              }
            }
            this.strategyStates.set(strategyId, {
              strategyId,
              isRunning: true,
              lastCheck: /* @__PURE__ */ new Date(),
              lastDecision: lastSuccessfulDecision,
              error: lastError
            });
            await storage.updateAgentStatus({ lastHeartbeat: /* @__PURE__ */ new Date() });
          } catch (error) {
            console.error(`Strategy ${strategyId} run error:`, error);
            this.strategyStates.set(strategyId, {
              strategyId,
              isRunning: true,
              lastCheck: /* @__PURE__ */ new Date(),
              error: error.message
            });
          }
        };
        await runStrategy();
        const interval = setInterval(runStrategy, this.checkIntervalMs);
        this.strategyRunners.set(strategyId, interval);
        this.strategyStates.set(strategyId, {
          strategyId,
          isRunning: true,
          lastCheck: /* @__PURE__ */ new Date()
        });
        eventBus.emit("strategy:started", { strategyId, strategyName: strategy.name }, "alpaca-trading-engine");
        logger.strategy(strategy.name, "Started", { assets: strategy.assets });
        return { success: true };
      }
      async stopStrategy(strategyId) {
        const interval = this.strategyRunners.get(strategyId);
        if (interval) {
          clearInterval(interval);
          this.strategyRunners.delete(strategyId);
        }
        const strategy = await storage.getStrategy(strategyId);
        await storage.toggleStrategy(strategyId, false);
        this.strategyStates.set(strategyId, {
          strategyId,
          isRunning: false,
          lastCheck: /* @__PURE__ */ new Date()
        });
        const runningStrategies = await storage.getStrategies();
        const anyActive = runningStrategies.some((s) => s.isActive);
        if (!anyActive) {
          await storage.updateAgentStatus({ isRunning: false });
        }
        eventBus.emit("strategy:stopped", { strategyId, strategyName: strategy?.name || strategyId }, "alpaca-trading-engine");
        logger.strategy(strategy?.name || strategyId, "Stopped");
        return { success: true };
      }
      async stopAllStrategies() {
        for (const [strategyId] of this.strategyRunners) {
          await this.stopStrategy(strategyId);
        }
        this.stopBackgroundGenerator();
        await storage.updateAgentStatus({ isRunning: false });
      }
      async resumeAgent() {
        console.log("Resuming trading agent...");
        this.startBackgroundAIGenerator();
        await storage.updateAgentStatus({
          isRunning: true,
          lastHeartbeat: /* @__PURE__ */ new Date()
        });
        if (this.autoStartStrategyId) {
          const isConnected = await this.isAlpacaConnected();
          if (isConnected) {
            await this.startStrategy(this.autoStartStrategyId);
          }
        }
      }
      getStrategyState(strategyId) {
        return this.strategyStates.get(strategyId);
      }
      getAllStrategyStates() {
        return Array.from(this.strategyStates.values());
      }
      getRunningStrategiesCount() {
        return this.strategyRunners.size;
      }
      async getMarketDataForSymbol(symbol) {
        try {
          const isCrypto = this.isCryptoSymbol(symbol);
          const lookupSymbol = isCrypto ? this.normalizeCryptoSymbol(symbol) : this.normalizeSymbolForAlpaca(symbol);
          const snapshots = isCrypto ? await alpaca.getCryptoSnapshots([lookupSymbol]) : await alpaca.getSnapshots([lookupSymbol]);
          const snapshot = snapshots[lookupSymbol];
          if (snapshot) {
            const currentPrice = snapshot.latestTrade?.p || snapshot.dailyBar?.c || snapshot.prevDailyBar?.c || 0;
            if (!currentPrice || currentPrice <= 0) {
              console.warn(`No valid price sources for ${symbol}: latestTrade=${snapshot.latestTrade?.p}, dailyBar.c=${snapshot.dailyBar?.c}, prevDailyBar.c=${snapshot.prevDailyBar?.c}`);
              return null;
            }
            const prevClose = snapshot.prevDailyBar?.c || currentPrice;
            const priceChange = currentPrice - prevClose;
            const priceChangePercent = prevClose > 0 ? priceChange / prevClose * 100 : 0;
            return {
              symbol: symbol.toUpperCase(),
              currentPrice,
              priceChange24h: priceChange,
              priceChangePercent24h: priceChangePercent,
              high24h: snapshot.dailyBar?.h,
              low24h: snapshot.dailyBar?.l,
              volume: snapshot.dailyBar?.v
            };
          }
          console.warn(`No snapshot data returned for ${symbol}`);
          return null;
        } catch (error) {
          console.error(`Failed to get market data for ${symbol}:`, error);
          return null;
        }
      }
      analyzeSentiment(headlines) {
        const bullishWords = ["surge", "rally", "gain", "rise", "up", "growth", "positive", "beat", "record", "high"];
        const bearishWords = ["drop", "fall", "decline", "down", "loss", "negative", "miss", "crash", "low", "sell"];
        let score = 0;
        const text3 = headlines.join(" ").toLowerCase();
        for (const word of bullishWords) {
          if (text3.includes(word)) score++;
        }
        for (const word of bearishWords) {
          if (text3.includes(word)) score--;
        }
        if (score > 1) return "bullish";
        if (score < -1) return "bearish";
        return "neutral";
      }
      async checkRiskLimits(symbol, side, quantity) {
        const status = await storage.getAgentStatus();
        if (status?.killSwitchActive) {
          return { allowed: false, reason: "Kill switch is active - trading halted" };
        }
        if (side === "buy") {
          try {
            const account = await alpaca.getAccount();
            const positions2 = await alpaca.getPositions();
            const maxPositions = status?.maxPositionsCount ?? 10;
            if (positions2.length >= maxPositions) {
              return { allowed: false, reason: `Maximum positions limit reached (${maxPositions})` };
            }
            const riskSymbol = this.normalizeSymbolForAlpaca(symbol);
            const snapshot = await alpaca.getSnapshots([riskSymbol]);
            const snapshotData = snapshot[riskSymbol];
            const price = snapshotData?.latestTrade?.p || snapshotData?.dailyBar?.c || snapshotData?.prevDailyBar?.c || 0;
            if (!price || price <= 0 || !Number.isFinite(price)) {
              console.warn(`Risk check: invalid price for ${symbol} (price=${price})`);
              return { allowed: false, reason: `Cannot verify trade value - no valid price data for ${symbol}` };
            }
            const tradeValue = quantity * price;
            if (!Number.isFinite(tradeValue)) {
              return { allowed: false, reason: `Invalid trade value calculation for ${symbol}` };
            }
            const buyingPower = safeParseFloat(account.buying_power);
            const rawPercent = status?.maxPositionSizePercent;
            const parsedPercent = rawPercent ? safeParseFloat(rawPercent) : NaN;
            const maxPositionSizePercent = isNaN(parsedPercent) || parsedPercent <= 0 ? 10 : parsedPercent;
            const maxPositionSizeDecimal = maxPositionSizePercent / 100;
            const maxTradeValue = buyingPower * maxPositionSizeDecimal;
            if (tradeValue > maxTradeValue) {
              return {
                allowed: false,
                reason: `Trade exceeds max position size (${maxPositionSizePercent.toFixed(0)}% = $${maxTradeValue.toFixed(2)})`
              };
            }
          } catch (error) {
            console.error("Risk check error:", error);
            return { allowed: false, reason: "Could not verify risk limits" };
          }
        }
        return { allowed: true };
      }
      async updateAgentStats() {
        try {
          const trades3 = await storage.getTrades(1e3);
          const closingTrades = trades3.filter((t) => t.pnl !== null && t.pnl !== "0");
          const totalRealizedPnl = closingTrades.reduce(
            (sum, t) => sum + safeParseFloat(t.pnl, 0),
            0
          );
          const winningTrades = closingTrades.filter((t) => safeParseFloat(t.pnl, 0) > 0);
          const winRate = closingTrades.length > 0 ? winningTrades.length / closingTrades.length * 100 : 0;
          await storage.updateAgentStatus({
            totalTrades: trades3.length,
            totalPnl: totalRealizedPnl.toString(),
            winRate: winRate.toString(),
            lastHeartbeat: /* @__PURE__ */ new Date()
          });
        } catch (error) {
          console.error("Failed to update agent stats:", error);
        }
      }
      getStatus() {
        const states = this.getAllStrategyStates();
        return {
          alpacaConnected: alpaca.getConnectionStatus().hasCredentials,
          runningStrategies: this.strategyRunners.size,
          strategyStates: states
        };
      }
      async cancelStaleOrders(maxAgeMinutes = 60) {
        const cancelled = [];
        const errors = [];
        const PENDING_ORDER_MAX_AGE_MINUTES = 10;
        const DEFAULT_ORDER_MAX_AGE_MINUTES = maxAgeMinutes;
        try {
          const openOrders = await alpaca.getOrders("open", 100);
          const now = /* @__PURE__ */ new Date();
          for (const order of openOrders) {
            const createdAt = new Date(order.created_at);
            const ageMs = now.getTime() - createdAt.getTime();
            const ageMinutes = ageMs / 6e4;
            if (order.status === "filled" || order.status === "partially_filled") {
              continue;
            }
            const isPendingOrder = order.status === "pending" || order.status === "new" || order.status === "pending_new";
            const effectiveMaxAgeMinutes = isPendingOrder ? PENDING_ORDER_MAX_AGE_MINUTES : DEFAULT_ORDER_MAX_AGE_MINUTES;
            if (ageMinutes > effectiveMaxAgeMinutes) {
              try {
                await alpaca.cancelOrder(order.id);
                cancelled.push(order.id);
                console.log(`[Reconciliation] Cancelled stale ${order.status} order ${order.id} for ${order.symbol} (age: ${Math.round(ageMinutes)} min, threshold: ${effectiveMaxAgeMinutes} min)`);
              } catch (err) {
                errors.push({ orderId: order.id, error: err.message });
              }
            }
          }
          console.log(`[Reconciliation] Cancelled ${cancelled.length} stale orders, ${errors.length} errors`);
        } catch (err) {
          console.error("[Reconciliation] Failed to cancel stale orders:", err);
          throw err;
        }
        return { cancelled, errors };
      }
      async cancelAllOpenOrders() {
        try {
          const ordersBefore = await alpaca.getOrders("open", 100);
          const countBefore = ordersBefore.length;
          if (countBefore === 0) {
            console.log("[Reconciliation] No open orders to cancel");
            return { cancelled: 0, ordersCancelledBefore: 0, remainingAfter: 0 };
          }
          await alpaca.cancelAllOrders();
          await new Promise((resolve2) => setTimeout(resolve2, 500));
          const ordersAfter = await alpaca.getOrders("open", 100);
          const countAfter = ordersAfter.length;
          const actualCancelled = countBefore - countAfter;
          console.log(`[Reconciliation] Cancelled ${actualCancelled} orders (before: ${countBefore}, remaining: ${countAfter})`);
          return {
            cancelled: actualCancelled,
            ordersCancelledBefore: countBefore,
            remainingAfter: countAfter
          };
        } catch (err) {
          console.error("[Reconciliation] Failed to cancel all orders:", err);
          return { cancelled: 0, ordersCancelledBefore: 0, remainingAfter: 0, error: err.message };
        }
      }
      async reconcilePositions() {
        const alpacaPositions = await alpaca.getPositions();
        const dbPositions = await storage.getPositions();
        const alpacaMap = new Map(
          alpacaPositions.map((p) => [p.symbol.toUpperCase(), p])
        );
        const dbMap = new Map(
          dbPositions.map((p) => [p.symbol.toUpperCase(), p])
        );
        const discrepancies = [];
        for (const [symbol, alpacaPos] of alpacaMap) {
          const dbPos = dbMap.get(symbol);
          if (!dbPos) {
            discrepancies.push({
              symbol,
              alpacaQty: alpacaPos.qty,
              dbQty: "0",
              action: "create_in_db"
            });
          } else if (alpacaPos.qty !== dbPos.quantity) {
            discrepancies.push({
              symbol,
              alpacaQty: alpacaPos.qty,
              dbQty: dbPos.quantity,
              action: "update_db_quantity"
            });
          }
        }
        for (const [symbol, dbPos] of dbMap) {
          if (!alpacaMap.has(symbol)) {
            discrepancies.push({
              symbol,
              alpacaQty: "0",
              dbQty: dbPos.quantity,
              action: "remove_from_db"
            });
          }
        }
        console.log(`[Reconciliation] Found ${discrepancies.length} discrepancies between Alpaca and DB`);
        return {
          alpacaPositions: alpacaPositions.map((p) => ({
            symbol: p.symbol,
            qty: p.qty,
            side: p.side,
            marketValue: p.market_value,
            unrealizedPnl: p.unrealized_pl
          })),
          dbPositions: dbPositions.map((p) => ({
            id: p.id,
            symbol: p.symbol,
            quantity: p.quantity
          })),
          discrepancies,
          synced: discrepancies.length === 0
        };
      }
      async syncPositionsFromAlpaca(userId) {
        const created = [];
        const updated = [];
        const removed = [];
        const errors = [];
        try {
          const alpacaPositions = await alpaca.getPositions();
          let effectiveUserId = userId;
          if (!effectiveUserId) {
            const adminUser = await storage.getUserByUsername("admintest");
            if (!adminUser) {
              throw new Error("No admin user found for system-level position sync");
            }
            effectiveUserId = adminUser.id;
            console.log(`[Sync] Using admin user ${adminUser.username} for system-level sync`);
          }
          const dbPositions = await storage.getPositions(effectiveUserId);
          const alpacaMap = new Map(
            alpacaPositions.map((p) => [p.symbol.toUpperCase(), p])
          );
          const dbMap = new Map(
            dbPositions.map((p) => [p.symbol.toUpperCase(), p])
          );
          for (const [symbol, alpacaPos] of alpacaMap) {
            try {
              const dbPos = dbMap.get(symbol);
              if (!dbPos) {
                await storage.createPosition({
                  userId: effectiveUserId,
                  symbol: alpacaPos.symbol,
                  side: alpacaPos.side,
                  quantity: alpacaPos.qty,
                  entryPrice: alpacaPos.avg_entry_price,
                  currentPrice: alpacaPos.current_price,
                  unrealizedPnl: alpacaPos.unrealized_pl,
                  strategyId: null
                });
                created.push(symbol);
                console.log(`[Sync] Created position for ${symbol} (user: ${effectiveUserId})`);
              } else {
                await storage.updatePosition(dbPos.id, {
                  quantity: alpacaPos.qty,
                  currentPrice: alpacaPos.current_price,
                  unrealizedPnl: alpacaPos.unrealized_pl
                });
                updated.push(symbol);
              }
            } catch (err) {
              errors.push({ symbol, error: err.message });
            }
          }
          for (const [symbol, dbPos] of dbMap) {
            if (!alpacaMap.has(symbol)) {
              try {
                await storage.deletePosition(dbPos.id);
                removed.push(symbol);
                console.log(`[Sync] Removed stale position for ${symbol}`);
              } catch (err) {
                errors.push({ symbol, error: err.message });
              }
            }
          }
          console.log(`[Sync] Completed: ${created.length} created, ${updated.length} updated, ${removed.length} removed`);
        } catch (err) {
          console.error("[Sync] Failed to sync positions:", err);
          throw err;
        }
        return { created, updated, removed, errors };
      }
      async closeAllPositions() {
        const closed = [];
        const errors = [];
        let tradesCreated = 0;
        try {
          const positions2 = await alpaca.getPositions();
          for (const position of positions2) {
            try {
              const qty = safeParseFloat(position.qty);
              const entryPrice = safeParseFloat(position.avg_entry_price);
              const currentPrice = safeParseFloat(position.current_price);
              const isShort = position.side === "short";
              const order = await alpaca.closePosition(position.symbol);
              const exitPrice = order.filled_avg_price ? safeParseFloat(order.filled_avg_price) : currentPrice;
              const realizedPnl = calculatePnL(entryPrice, exitPrice, qty, isShort ? "short" : "long");
              const tradeSide = isShort ? "buy" : "sell";
              await storage.createTrade({
                symbol: position.symbol,
                side: tradeSide,
                quantity: position.qty,
                price: exitPrice.toString(),
                strategyId: null,
                status: "completed",
                notes: `Closed all positions (${position.side}). Order ID: ${order.id}. Entry: $${entryPrice.toFixed(2)}, Exit: $${exitPrice.toFixed(2)}`,
                pnl: realizedPnl.toString()
              });
              tradesCreated++;
              closed.push({
                symbol: position.symbol,
                qty: position.qty,
                pnl: realizedPnl.toFixed(2)
              });
              console.log(`[Reconciliation] Closed ${position.side} position for ${position.symbol}: qty=${qty}, PnL=$${realizedPnl.toFixed(2)}`);
            } catch (err) {
              errors.push({ symbol: position.symbol, error: err.message });
            }
          }
          await this.syncPositionsFromAlpaca();
          await this.updateAgentStats();
          console.log(`[Reconciliation] Closed ${closed.length} positions, created ${tradesCreated} trades, ${errors.length} errors`);
        } catch (err) {
          console.error("[Reconciliation] Failed to close all positions:", err);
          throw err;
        }
        return { closed, tradesCreated, errors };
      }
      async getOpenOrders() {
        return await alpaca.getOrders("open", 100);
      }
      async getOrderDetails(orderId) {
        return await alpaca.getOrder(orderId);
      }
      async getCurrentAllocations() {
        const account = await alpaca.getAccount();
        const positions2 = await alpaca.getPositions();
        const cashBalance = safeParseFloat(account.cash);
        let positionsValue = 0;
        const allocations = [];
        for (const position of positions2) {
          const marketValue = safeParseFloat(position.market_value);
          const quantity = safeParseFloat(position.qty);
          const price = safeParseFloat(position.current_price);
          positionsValue += marketValue;
          allocations.push({
            symbol: position.symbol.toUpperCase(),
            currentPercent: 0,
            currentValue: marketValue,
            quantity,
            price
          });
        }
        const portfolioValue = cashBalance + positionsValue;
        for (const allocation of allocations) {
          allocation.currentPercent = portfolioValue > 0 ? allocation.currentValue / portfolioValue * 100 : 0;
        }
        allocations.push({
          symbol: "CASH",
          currentPercent: portfolioValue > 0 ? cashBalance / portfolioValue * 100 : 100,
          currentValue: cashBalance,
          quantity: cashBalance,
          price: 1
        });
        return { allocations, portfolioValue, cashBalance };
      }
      async previewRebalance(targetAllocations) {
        const { allocations: currentAllocations, portfolioValue, cashBalance } = await this.getCurrentAllocations();
        const totalTargetPercent = targetAllocations.reduce((sum, t) => sum + t.targetPercent, 0);
        if (totalTargetPercent > 100) {
          throw new Error(`Target allocations sum to ${totalTargetPercent}%, must be <= 100%`);
        }
        const proposedTrades = [];
        let estimatedCashChange = 0;
        const currentMap = new Map(
          currentAllocations.filter((a) => a.symbol !== "CASH").map((a) => [a.symbol, a])
        );
        for (const target of targetAllocations) {
          if (target.symbol === "CASH") continue;
          const symbol = target.symbol.toUpperCase();
          const targetValue = target.targetPercent / 100 * portfolioValue;
          const current = currentMap.get(symbol);
          const currentValue = current?.currentValue || 0;
          const currentPercent = current?.currentPercent || 0;
          const currentPrice = current?.price || 0;
          const valueDiff = targetValue - currentValue;
          if (Math.abs(valueDiff) < 10) continue;
          if (valueDiff > 0 && currentPrice > 0) {
            const buyQuantity = Math.floor(valueDiff / currentPrice);
            if (buyQuantity >= 1) {
              proposedTrades.push({
                symbol,
                side: "buy",
                quantity: buyQuantity,
                estimatedValue: buyQuantity * currentPrice,
                currentPercent,
                targetPercent: target.targetPercent,
                reason: `Increase allocation from ${currentPercent.toFixed(1)}% to ${target.targetPercent}%`
              });
              estimatedCashChange -= buyQuantity * currentPrice;
            }
          } else if (valueDiff < 0 && currentPrice > 0 && current) {
            const sellQuantity = Math.min(
              Math.floor(Math.abs(valueDiff) / currentPrice),
              current.quantity
            );
            if (sellQuantity >= 1) {
              proposedTrades.push({
                symbol,
                side: "sell",
                quantity: sellQuantity,
                estimatedValue: sellQuantity * currentPrice,
                currentPercent,
                targetPercent: target.targetPercent,
                reason: `Decrease allocation from ${currentPercent.toFixed(1)}% to ${target.targetPercent}%`
              });
              estimatedCashChange += sellQuantity * currentPrice;
            }
          }
        }
        for (const [symbol, current] of currentMap) {
          const hasTarget = targetAllocations.some(
            (t) => t.symbol.toUpperCase() === symbol
          );
          if (!hasTarget && current.quantity > 0) {
            proposedTrades.push({
              symbol,
              side: "sell",
              quantity: current.quantity,
              estimatedValue: current.currentValue,
              currentPercent: current.currentPercent,
              targetPercent: 0,
              reason: `Close position - not in target allocation`
            });
            estimatedCashChange += current.currentValue;
          }
        }
        proposedTrades.sort((a, b) => {
          if (a.side === "sell" && b.side === "buy") return -1;
          if (a.side === "buy" && b.side === "sell") return 1;
          return b.estimatedValue - a.estimatedValue;
        });
        const estimatedTradingCost = proposedTrades.length * 0.01;
        return {
          currentAllocations,
          targetAllocations,
          proposedTrades,
          portfolioValue,
          cashAvailable: cashBalance,
          cashAfterRebalance: cashBalance + estimatedCashChange,
          estimatedTradingCost
        };
      }
      async executeRebalance(targetAllocations, dryRun = false) {
        const preview = await this.previewRebalance(targetAllocations);
        const portfolioValueBefore = safeParseFloat(preview.portfolioValue);
        if (dryRun) {
          return {
            success: true,
            tradesExecuted: preview.proposedTrades.map((t) => ({
              symbol: t.symbol,
              side: t.side,
              quantity: Math.floor(safeParseFloat(t.quantity)),
              status: "dry_run"
            })),
            errors: [],
            portfolioValueBefore,
            portfolioValueAfter: portfolioValueBefore
          };
        }
        const tradesExecuted = [];
        const errors = [];
        const sellTrades = preview.proposedTrades.filter((t) => t.side === "sell");
        for (const trade of sellTrades) {
          try {
            const quantity = Math.floor(safeParseFloat(trade.quantity));
            if (quantity < 1) continue;
            const result = await this.executeAlpacaTrade({
              symbol: trade.symbol,
              side: "sell",
              quantity,
              notes: `Rebalance: ${trade.reason}`
            });
            tradesExecuted.push({
              symbol: trade.symbol,
              side: "sell",
              quantity,
              status: result.success ? "executed" : "failed",
              orderId: result.order?.id,
              error: result.error
            });
            if (!result.success) {
              errors.push(`${trade.symbol} sell failed: ${result.error}`);
            }
          } catch (err) {
            const errorMsg = err.message;
            errors.push(`${trade.symbol} sell error: ${errorMsg}`);
            tradesExecuted.push({
              symbol: trade.symbol,
              side: "sell",
              quantity: Math.floor(safeParseFloat(trade.quantity)),
              status: "error",
              error: errorMsg
            });
          }
        }
        if (sellTrades.length > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, 2e3));
        }
        const { allocations: refreshedAllocations, portfolioValue: refreshedPortfolioValue, cashBalance: availableCash } = await this.getCurrentAllocations();
        const refreshedPositionMap = new Map(
          refreshedAllocations.filter((a) => a.symbol !== "CASH").map((a) => [a.symbol, a])
        );
        for (const target of targetAllocations) {
          if (target.symbol === "CASH") continue;
          const symbol = target.symbol.toUpperCase();
          const targetValue = safeParseFloat(target.targetPercent) / 100 * refreshedPortfolioValue;
          const current = refreshedPositionMap.get(symbol);
          const currentValue = current ? safeParseFloat(current.currentValue) : 0;
          const currentPrice = current ? safeParseFloat(current.price) : 0;
          const valueDiff = targetValue - currentValue;
          if (valueDiff <= 10 || currentPrice <= 0) continue;
          const maxBuyValue = Math.min(valueDiff, availableCash * 0.95);
          const buyQuantity = Math.floor(maxBuyValue / currentPrice);
          if (buyQuantity < 1) continue;
          try {
            const result = await this.executeAlpacaTrade({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              notes: `Rebalance: Increase allocation to ${target.targetPercent}%`
            });
            tradesExecuted.push({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              status: result.success ? "executed" : "failed",
              orderId: result.order?.id,
              error: result.error
            });
            if (!result.success) {
              errors.push(`${symbol} buy failed: ${result.error}`);
            }
          } catch (err) {
            const errorMsg = err.message;
            errors.push(`${symbol} buy error: ${errorMsg}`);
            tradesExecuted.push({
              symbol,
              side: "buy",
              quantity: buyQuantity,
              status: "error",
              error: errorMsg
            });
          }
        }
        await this.syncPositionsFromAlpaca();
        await this.updateAgentStats();
        const finalAccount = await alpaca.getAccount();
        const finalPositions = await alpaca.getPositions();
        const cashAfter = safeParseFloat(finalAccount.cash);
        const positionsValueAfter = finalPositions.reduce(
          (sum, p) => sum + safeParseFloat(p.market_value),
          0
        );
        const portfolioValueAfter = cashAfter + positionsValueAfter;
        logger.trade(`Rebalance complete: ${tradesExecuted.length} trades, ${errors.length} errors`, {
          tradesExecuted: tradesExecuted.length,
          errors: errors.length,
          portfolioValueBefore,
          portfolioValueAfter
        });
        eventBus.emit("portfolio:rebalanced", {
          tradesExecuted: tradesExecuted.length,
          errors: errors.length,
          portfolioValueBefore,
          portfolioValueAfter
        }, "alpaca-trading-engine");
        return {
          success: errors.length === 0,
          tradesExecuted,
          errors,
          portfolioValueBefore,
          portfolioValueAfter
        };
      }
      async getRebalanceSuggestions() {
        const { allocations: currentAllocations, portfolioValue } = await this.getCurrentAllocations();
        const nonCashAllocations = currentAllocations.filter((a) => a.symbol !== "CASH");
        if (nonCashAllocations.length === 0) {
          return {
            currentAllocations,
            suggestedAllocations: this.DEFAULT_WATCHLIST.slice(0, 5).map((symbol, i) => ({
              symbol,
              targetPercent: 15
            })),
            reasoning: "No current positions. Suggesting equal-weight allocation across top 5 watchlist stocks (15% each, 25% cash reserve)."
          };
        }
        const symbolCount = nonCashAllocations.length;
        const equalWeight = Math.floor(80 / symbolCount);
        const suggestedAllocations = nonCashAllocations.map((a) => ({
          symbol: a.symbol,
          targetPercent: equalWeight
        }));
        const allocatedPercent = suggestedAllocations.reduce((sum, a) => sum + a.targetPercent, 0);
        if (allocatedPercent < 80 && suggestedAllocations.length > 0) {
          suggestedAllocations[0].targetPercent += 80 - allocatedPercent;
        }
        return {
          currentAllocations,
          suggestedAllocations,
          reasoning: `Suggesting equal-weight rebalancing across ${symbolCount} positions (~${equalWeight}% each) with 20% cash reserve for risk management.`
        };
      }
    };
    alpacaTradingEngine = new AlpacaTradingEngine();
  }
});

// server/services/trading-session-manager.ts
var trading_session_manager_exports = {};
__export(trading_session_manager_exports, {
  tradingSessionManager: () => tradingSessionManager
});
var US_MARKET_HOLIDAYS_2024_2025, MARKET_SESSIONS, TradingSessionManager, tradingSessionManager;
var init_trading_session_manager = __esm({
  "server/services/trading-session-manager.ts"() {
    "use strict";
    init_logger();
    US_MARKET_HOLIDAYS_2024_2025 = [
      // 2024
      "2024-01-01",
      // New Year's Day
      "2024-01-15",
      // Martin Luther King Jr. Day
      "2024-02-19",
      // Presidents' Day
      "2024-03-29",
      // Good Friday
      "2024-05-27",
      // Memorial Day
      "2024-06-19",
      // Juneteenth
      "2024-07-04",
      // Independence Day
      "2024-09-02",
      // Labor Day
      "2024-11-28",
      // Thanksgiving
      "2024-12-25",
      // Christmas
      // 2025
      "2025-01-01",
      // New Year's Day
      "2025-01-20",
      // Martin Luther King Jr. Day
      "2025-02-17",
      // Presidents' Day
      "2025-04-18",
      // Good Friday
      "2025-05-26",
      // Memorial Day
      "2025-06-19",
      // Juneteenth
      "2025-07-04",
      // Independence Day
      "2025-09-01",
      // Labor Day
      "2025-11-27",
      // Thanksgiving
      "2025-12-25"
      // Christmas
    ];
    MARKET_SESSIONS = {
      US_EQUITIES: {
        name: "US Equities",
        exchange: "NYSE/NASDAQ",
        timezone: "America/New_York",
        regularHours: {
          start: "09:30",
          end: "16:00"
        },
        extendedHours: {
          preMarket: {
            start: "04:00",
            end: "09:30"
          },
          afterHours: {
            start: "16:00",
            end: "20:00"
          }
        },
        holidays: US_MARKET_HOLIDAYS_2024_2025
      },
      CRYPTO: {
        name: "Cryptocurrency",
        exchange: "24/7",
        timezone: "UTC",
        regularHours: {
          start: "00:00",
          end: "23:59"
        },
        holidays: []
        // Crypto markets never close
      },
      EUROPEAN_DAX: {
        name: "European DAX",
        exchange: "XETRA",
        timezone: "Europe/Berlin",
        regularHours: {
          start: "09:00",
          end: "17:30"
        },
        holidays: []
        // Simplified - would need European holiday calendar
      },
      ASIAN_NIKKEI: {
        name: "Asian Nikkei",
        exchange: "TSE",
        timezone: "Asia/Tokyo",
        regularHours: {
          start: "09:00",
          end: "15:00"
        },
        holidays: []
        // Simplified - would need Japanese holiday calendar
      }
    };
    TradingSessionManager = class {
      sessionCache = /* @__PURE__ */ new Map();
      CACHE_TTL_MS = 6e4;
      // 1 minute cache
      /**
       * Get the market session configuration for an exchange
       */
      getSessionConfig(exchange) {
        return MARKET_SESSIONS[exchange] || null;
      }
      /**
       * Check if a market is open right now
       */
      isMarketOpen(exchange, now = /* @__PURE__ */ new Date()) {
        const session = this.getCurrentSession(exchange, now);
        return session.isOpen;
      }
      /**
       * Get the next market open time
       */
      getNextMarketOpen(exchange, now = /* @__PURE__ */ new Date()) {
        const config = MARKET_SESSIONS[exchange];
        if (!config) {
          log.warn("SessionManager", `Unknown exchange: ${exchange}`);
          return null;
        }
        if (exchange === "CRYPTO") {
          return now;
        }
        const session = this.getCurrentSession(exchange, now);
        if (session.nextOpen) {
          return session.nextOpen;
        }
        const nextOpen = this.calculateNextOpen(config, now);
        return nextOpen;
      }
      /**
       * Get the next market close time
       */
      getNextMarketClose(exchange, now = /* @__PURE__ */ new Date()) {
        const config = MARKET_SESSIONS[exchange];
        if (!config) {
          log.warn("SessionManager", `Unknown exchange: ${exchange}`);
          return null;
        }
        if (exchange === "CRYPTO") {
          return null;
        }
        const session = this.getCurrentSession(exchange, now);
        if (session.nextClose) {
          return session.nextClose;
        }
        return this.calculateNextClose(config, now);
      }
      /**
       * Get the current session type (pre-market, regular, after-hours, closed)
       */
      getCurrentSession(exchange, now = /* @__PURE__ */ new Date()) {
        const cacheKey = `${exchange}-${now.getTime()}`;
        const cached = this.sessionCache.get(exchange);
        if (cached && now.getTime() - cached.timestamp < this.CACHE_TTL_MS) {
          return cached.info;
        }
        const config = MARKET_SESSIONS[exchange];
        if (!config) {
          return {
            session: "closed",
            isOpen: false,
            isExtendedHours: false,
            nextOpen: null,
            nextClose: null,
            volatilityMultiplier: 1,
            timezone: "UTC"
          };
        }
        const info = this.calculateSessionInfo(config, now);
        this.sessionCache.set(exchange, { info, timestamp: now.getTime() });
        return info;
      }
      /**
       * Alias for getCurrentSession for backward compatibility
       * @deprecated Use getCurrentSession instead
       */
      getSessionInfo(exchange, now = /* @__PURE__ */ new Date()) {
        return this.getCurrentSession(exchange, now);
      }
      /**
       * Check if a specific date is a market holiday
       */
      isHoliday(exchange, date) {
        const config = MARKET_SESSIONS[exchange];
        if (!config) return false;
        const dateStr = this.formatDateISO(date);
        return config.holidays.includes(dateStr);
      }
      /**
       * Get volatility multiplier based on session
       * Higher volatility during extended hours and market opens/closes
       */
      getSessionVolatilityMultiplier(exchange, session) {
        if (exchange === "CRYPTO") {
          return 1.5;
        }
        switch (session) {
          case "pre_market":
            return 2;
          // Highest volatility - low liquidity
          case "after_hours":
            return 1.8;
          // High volatility - reduced liquidity
          case "regular":
            return 1;
          // Normal volatility
          case "closed":
            return 0;
          // Market is closed
          default:
            return 1;
        }
      }
      /**
       * Calculate detailed session information
       */
      calculateSessionInfo(config, now) {
        const timezone = config.timezone;
        const dateStr = this.formatDateISO(now);
        const isHoliday = config.holidays.includes(dateStr);
        const dayOfWeek = now.getDay();
        const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
        if (config.exchange === "24/7") {
          return {
            session: "regular",
            isOpen: true,
            isExtendedHours: false,
            nextOpen: null,
            nextClose: null,
            volatilityMultiplier: 1.5,
            // Crypto baseline volatility
            timezone
          };
        }
        if (isWeekend || isHoliday) {
          const nextOpen2 = this.calculateNextOpen(config, now);
          return {
            session: "closed",
            isOpen: false,
            isExtendedHours: false,
            nextOpen: nextOpen2,
            nextClose: null,
            volatilityMultiplier: 0,
            timezone
          };
        }
        const currentTime = this.getTimeInTimezone(now, timezone);
        const currentMinutes = this.timeToMinutes(currentTime);
        const regularStart = this.timeToMinutes(config.regularHours.start);
        const regularEnd = this.timeToMinutes(config.regularHours.end);
        if (currentMinutes >= regularStart && currentMinutes < regularEnd) {
          const nextClose = this.createDateFromTime(now, config.regularHours.end, timezone);
          return {
            session: "regular",
            isOpen: true,
            isExtendedHours: false,
            nextOpen: null,
            nextClose,
            volatilityMultiplier: this.getSessionVolatilityMultiplier(config.exchange, "regular"),
            timezone
          };
        }
        if (config.extendedHours) {
          const preMarketStart = this.timeToMinutes(config.extendedHours.preMarket.start);
          const preMarketEnd = this.timeToMinutes(config.extendedHours.preMarket.end);
          const afterHoursStart = this.timeToMinutes(config.extendedHours.afterHours.start);
          const afterHoursEnd = this.timeToMinutes(config.extendedHours.afterHours.end);
          if (currentMinutes >= preMarketStart && currentMinutes < preMarketEnd) {
            const nextClose = this.createDateFromTime(now, config.extendedHours.preMarket.end, timezone);
            return {
              session: "pre_market",
              isOpen: true,
              isExtendedHours: true,
              nextOpen: null,
              nextClose,
              volatilityMultiplier: this.getSessionVolatilityMultiplier(config.exchange, "pre_market"),
              timezone
            };
          }
          if (currentMinutes >= afterHoursStart && currentMinutes < afterHoursEnd) {
            const nextClose = this.createDateFromTime(now, config.extendedHours.afterHours.end, timezone);
            return {
              session: "after_hours",
              isOpen: true,
              isExtendedHours: true,
              nextOpen: null,
              nextClose,
              volatilityMultiplier: this.getSessionVolatilityMultiplier(config.exchange, "after_hours"),
              timezone
            };
          }
        }
        const nextOpen = this.calculateNextOpen(config, now);
        return {
          session: "closed",
          isOpen: false,
          isExtendedHours: false,
          nextOpen,
          nextClose: null,
          volatilityMultiplier: 0,
          timezone
        };
      }
      /**
       * Calculate the next market open time
       */
      calculateNextOpen(config, now) {
        const timezone = config.timezone;
        let checkDate = new Date(now);
        if (config.exchange === "24/7") {
          return now;
        }
        for (let i = 0; i < 10; i++) {
          const dayOfWeek = checkDate.getDay();
          const dateStr = this.formatDateISO(checkDate);
          const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
          const isHoliday = config.holidays.includes(dateStr);
          if (isWeekend || isHoliday) {
            checkDate = this.addDays(checkDate, 1);
            continue;
          }
          const currentTime = this.getTimeInTimezone(now, timezone);
          const currentMinutes = this.timeToMinutes(currentTime);
          const openTime = config.extendedHours ? config.extendedHours.preMarket.start : config.regularHours.start;
          const openMinutes = this.timeToMinutes(openTime);
          if (this.isSameDay(checkDate, now) && currentMinutes < openMinutes) {
            return this.createDateFromTime(checkDate, openTime, timezone);
          }
          if (this.isSameDay(checkDate, now)) {
            checkDate = this.addDays(checkDate, 1);
            continue;
          }
          return this.createDateFromTime(checkDate, openTime, timezone);
        }
        return this.addDays(now, 1);
      }
      /**
       * Calculate the next market close time
       */
      calculateNextClose(config, now) {
        const timezone = config.timezone;
        const currentTime = this.getTimeInTimezone(now, timezone);
        const currentMinutes = this.timeToMinutes(currentTime);
        const closeTime = config.extendedHours ? config.extendedHours.afterHours.end : config.regularHours.end;
        const closeMinutes = this.timeToMinutes(closeTime);
        if (currentMinutes < closeMinutes) {
          return this.createDateFromTime(now, closeTime, timezone);
        }
        const tomorrow = this.addDays(now, 1);
        return this.createDateFromTime(tomorrow, closeTime, timezone);
      }
      /**
       * Get all available exchanges
       */
      getAvailableExchanges() {
        return Object.keys(MARKET_SESSIONS);
      }
      /**
       * Get session info for all exchanges
       */
      getAllSessionInfo(now = /* @__PURE__ */ new Date()) {
        const result = {};
        for (const exchange of this.getAvailableExchanges()) {
          result[exchange] = this.getCurrentSession(exchange, now);
        }
        return result;
      }
      /**
       * Detect exchange from symbol
       */
      detectExchange(symbol) {
        const upperSymbol = symbol.toUpperCase();
        if (upperSymbol.includes("/") || upperSymbol.includes("BTC") || upperSymbol.includes("ETH") || upperSymbol.includes("USD") && upperSymbol.length <= 8) {
          return "CRYPTO";
        }
        return "US_EQUITIES";
      }
      // Utility functions
      formatDateISO(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
      }
      getTimeInTimezone(date, timezone) {
        const options = {
          timeZone: timezone,
          hour: "2-digit",
          minute: "2-digit",
          hour12: false
        };
        return new Intl.DateTimeFormat("en-US", options).format(date);
      }
      timeToMinutes(time) {
        const [hours, minutes] = time.split(":").map(Number);
        return hours * 60 + minutes;
      }
      createDateFromTime(date, time, timezone) {
        const [hours, minutes] = time.split(":").map(Number);
        const result = new Date(date);
        result.setHours(hours, minutes, 0, 0);
        if (timezone === "America/New_York") {
          result.setHours(result.getHours() + 5);
        }
        return result;
      }
      addDays(date, days) {
        const result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
      }
      isSameDay(date1, date2) {
        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
      }
      /**
       * Clear the session cache (useful for testing)
       */
      clearCache() {
        this.sessionCache.clear();
      }
    };
    tradingSessionManager = new TradingSessionManager();
  }
});

// server/lib/sse-emitter.ts
var sse_emitter_exports = {};
__export(sse_emitter_exports, {
  emitAIDecision: () => emitAIDecision,
  emitAgentStatus: () => emitAgentStatus,
  emitAlert: () => emitAlert,
  emitOrderFill: () => emitOrderFill,
  emitOrderUpdate: () => emitOrderUpdate,
  emitPositionUpdate: () => emitPositionUpdate,
  emitPriceUpdate: () => emitPriceUpdate,
  emitStrategyUpdate: () => emitStrategyUpdate,
  emitTradeNew: () => emitTradeNew,
  sseEmitter: () => sseEmitter
});
import { EventEmitter as EventEmitter2 } from "node:events";
var SSEEmitter, sseEmitter, emitOrderUpdate, emitOrderFill, emitPositionUpdate, emitTradeNew, emitPriceUpdate, emitAIDecision, emitAgentStatus, emitStrategyUpdate, emitAlert;
var init_sse_emitter = __esm({
  "server/lib/sse-emitter.ts"() {
    "use strict";
    SSEEmitter = class extends EventEmitter2 {
      clients = /* @__PURE__ */ new Map();
      userClients = /* @__PURE__ */ new Map();
      // userId -> Set<clientId>
      /**
       * Add a new SSE client connection
       */
      addClient(clientId, res, userId) {
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        this.sendToClient(res, {
          type: "agent:status",
          data: { connected: true, clientId },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        this.clients.set(clientId, res);
        if (userId) {
          if (!this.userClients.has(userId)) {
            this.userClients.set(userId, /* @__PURE__ */ new Set());
          }
          this.userClients.get(userId).add(clientId);
        }
        res.on("close", () => {
          this.removeClient(clientId, userId);
        });
        console.log(`[SSE] Client connected: ${clientId} (user: ${userId || "anonymous"})`);
        console.log(`[SSE] Total clients: ${this.clients.size}`);
      }
      /**
       * Remove a client connection
       */
      removeClient(clientId, userId) {
        this.clients.delete(clientId);
        if (userId) {
          const userSet = this.userClients.get(userId);
          if (userSet) {
            userSet.delete(clientId);
            if (userSet.size === 0) {
              this.userClients.delete(userId);
            }
          }
        }
        console.log(`[SSE] Client disconnected: ${clientId}`);
        console.log(`[SSE] Total clients: ${this.clients.size}`);
      }
      /**
       * Broadcast event to all connected clients
       */
      broadcast(event) {
        const fullEvent = {
          ...event,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        let successCount = 0;
        let errorCount = 0;
        for (const [clientId, res] of this.clients) {
          try {
            this.sendToClient(res, fullEvent);
            successCount++;
          } catch (error) {
            console.error(`[SSE] Failed to send to client ${clientId}:`, error);
            errorCount++;
            this.removeClient(clientId);
          }
        }
        if (this.clients.size > 0) {
          console.log(`[SSE] Broadcast ${event.type}: ${successCount} sent, ${errorCount} failed`);
        }
      }
      /**
       * Send event to specific user's clients
       */
      sendToUser(userId, event) {
        const clientIds = this.userClients.get(userId);
        if (!clientIds || clientIds.size === 0) {
          return;
        }
        const fullEvent = {
          ...event,
          userId,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
        let successCount = 0;
        const deadClients = [];
        for (const clientId of clientIds) {
          const res = this.clients.get(clientId);
          if (!res) {
            deadClients.push(clientId);
            continue;
          }
          try {
            this.sendToClient(res, fullEvent);
            successCount++;
          } catch (error) {
            console.error(`[SSE] Failed to send to user ${userId} client ${clientId}:`, error);
            deadClients.push(clientId);
          }
        }
        for (const clientId of deadClients) {
          this.removeClient(clientId, userId);
        }
        if (successCount > 0) {
          console.log(`[SSE] Sent ${event.type} to user ${userId}: ${successCount} clients`);
        }
      }
      /**
       * Send SSE formatted message to a specific client
       */
      sendToClient(res, event) {
        const eventData = `event: ${event.type}
data: ${JSON.stringify(event.data)}
id: ${Date.now()}

`;
        res.write(eventData);
      }
      /**
       * Send keepalive ping to all clients
       */
      sendKeepalive() {
        for (const [clientId, res] of this.clients) {
          try {
            res.write(": keepalive\n\n");
          } catch (error) {
            console.error(`[SSE] Keepalive failed for client ${clientId}:`, error);
            this.removeClient(clientId);
          }
        }
      }
      /**
       * Get statistics
       */
      getStats() {
        return {
          totalClients: this.clients.size,
          totalUsers: this.userClients.size,
          clientsPerUser: Array.from(this.userClients.entries()).map(([userId, clients]) => ({
            userId,
            clientCount: clients.size
          }))
        };
      }
    };
    sseEmitter = new SSEEmitter();
    setInterval(() => {
      sseEmitter.sendKeepalive();
    }, 3e4);
    emitOrderUpdate = (orderId, orderData, userId) => {
      const event = { type: "order:update", data: { orderId, ...orderData } };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitOrderFill = (orderId, fillData, userId) => {
      const event = { type: "order:fill", data: { orderId, ...fillData } };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitPositionUpdate = (positionData, userId) => {
      const event = { type: "position:update", data: positionData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitTradeNew = (tradeData, userId) => {
      const event = { type: "trade:new", data: tradeData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitPriceUpdate = (symbol, priceData) => {
      const event = { type: "price:update", data: { symbol, ...priceData } };
      sseEmitter.broadcast(event);
    };
    emitAIDecision = (decisionData, userId) => {
      const event = { type: "ai:decision", data: decisionData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitAgentStatus = (statusData) => {
      const event = { type: "agent:status", data: statusData };
      sseEmitter.broadcast(event);
    };
    emitStrategyUpdate = (strategyId, statusData, userId) => {
      const event = { type: "strategy:update", data: { strategyId, ...statusData } };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
    emitAlert = (alertData, userId) => {
      const event = { type: "alert:new", data: alertData };
      if (userId) {
        sseEmitter.sendToUser(userId, event);
      } else {
        sseEmitter.broadcast(event);
      }
    };
  }
});

// server/lib/performance-metrics.ts
var performance_metrics_exports = {};
__export(performance_metrics_exports, {
  performanceTracker: () => performanceTracker
});
function createEmptyMetric() {
  return {
    count: 0,
    totalMs: 0,
    minMs: Infinity,
    maxMs: 0,
    p50Ms: 0,
    p95Ms: 0,
    p99Ms: 0,
    samples: []
  };
}
function calculatePercentile(samples, percentile) {
  if (samples.length === 0) return 0;
  const sorted = [...samples].sort((a, b) => a - b);
  const index2 = Math.ceil(percentile / 100 * sorted.length) - 1;
  return sorted[Math.max(0, index2)];
}
function updateMetric(metric, durationMs) {
  metric.count++;
  metric.totalMs += durationMs;
  metric.minMs = Math.min(metric.minMs, durationMs);
  metric.maxMs = Math.max(metric.maxMs, durationMs);
  metric.samples.push(durationMs);
  if (metric.samples.length > MAX_SAMPLES) {
    metric.samples.shift();
  }
  metric.p50Ms = calculatePercentile(metric.samples, 50);
  metric.p95Ms = calculatePercentile(metric.samples, 95);
  metric.p99Ms = calculatePercentile(metric.samples, 99);
}
var MAX_SAMPLES, PerformanceTracker, performanceTracker;
var init_performance_metrics = __esm({
  "server/lib/performance-metrics.ts"() {
    "use strict";
    MAX_SAMPLES = 1e3;
    PerformanceTracker = class {
      metrics = {
        orderExecution: createEmptyMetric(),
        quoteRetrieval: createEmptyMetric(),
        aiDecision: createEmptyMetric(),
        databaseQuery: createEmptyMetric(),
        apiCall: createEmptyMetric()
      };
      startTimes = /* @__PURE__ */ new Map();
      startTimer(operationId) {
        this.startTimes.set(operationId, Date.now());
      }
      endTimer(operationId, metricType) {
        const startTime = this.startTimes.get(operationId);
        if (!startTime) return 0;
        const durationMs = Date.now() - startTime;
        this.startTimes.delete(operationId);
        updateMetric(this.metrics[metricType], durationMs);
        return durationMs;
      }
      recordLatency(metricType, durationMs) {
        updateMetric(this.metrics[metricType], durationMs);
      }
      async measure(metricType, operation) {
        const start = Date.now();
        const result = await operation();
        const durationMs = Date.now() - start;
        updateMetric(this.metrics[metricType], durationMs);
        return { result, durationMs };
      }
      getMetrics() {
        return { ...this.metrics };
      }
      getMetricSummary(metricType) {
        const metric = this.metrics[metricType];
        return {
          avgMs: metric.count > 0 ? metric.totalMs / metric.count : 0,
          minMs: metric.minMs === Infinity ? 0 : metric.minMs,
          maxMs: metric.maxMs,
          p50Ms: metric.p50Ms,
          p95Ms: metric.p95Ms,
          p99Ms: metric.p99Ms,
          count: metric.count
        };
      }
      getSLOStatus() {
        return {
          orderExecutionP99Under50ms: this.metrics.orderExecution.p99Ms < 50,
          quoteRetrievalP99Under10ms: this.metrics.quoteRetrieval.p99Ms < 10,
          aiDecisionP99Under5s: this.metrics.aiDecision.p99Ms < 5e3
        };
      }
      reset() {
        this.metrics = {
          orderExecution: createEmptyMetric(),
          quoteRetrieval: createEmptyMetric(),
          aiDecision: createEmptyMetric(),
          databaseQuery: createEmptyMetric(),
          apiCall: createEmptyMetric()
        };
        this.startTimes.clear();
      }
    };
    performanceTracker = new PerformanceTracker();
  }
});

// server/lib/notification-service.ts
var notification_service_exports = {};
__export(notification_service_exports, {
  createDefaultTemplates: () => createDefaultTemplates,
  deleteChannel: () => deleteChannel,
  deleteTemplate: () => deleteTemplate,
  getChannel: () => getChannel,
  getChannels: () => getChannels,
  getNotificationHistory: () => getNotificationHistory,
  getNotificationStats: () => getNotificationStats,
  getTemplates: () => getTemplates,
  registerChannel: () => registerChannel,
  registerTemplate: () => registerTemplate,
  sendDirectNotification: () => sendDirectNotification,
  sendNotification: () => sendNotification,
  updateChannel: () => updateChannel,
  updateTemplate: () => updateTemplate
});
function registerChannel(channel) {
  channels.set(channel.id, channel);
}
function getChannel(id) {
  return channels.get(id);
}
function getChannels() {
  return Array.from(channels.values());
}
function updateChannel(id, updates) {
  const channel = channels.get(id);
  if (!channel) return null;
  const updated = { ...channel, ...updates, id: channel.id };
  channels.set(id, updated);
  return updated;
}
function deleteChannel(id) {
  return channels.delete(id);
}
function registerTemplate(template) {
  templates.set(template.id, template);
}
function getTemplates() {
  return Array.from(templates.values());
}
function updateTemplate(id, updates) {
  const template = templates.get(id);
  if (!template) return null;
  const updated = { ...template, ...updates, id: template.id };
  templates.set(id, updated);
  return updated;
}
function deleteTemplate(id) {
  return templates.delete(id);
}
function formatMessage(template, data) {
  let message = template;
  for (const [key, value] of Object.entries(data)) {
    const regex = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, "g");
    message = message.replace(regex, String(value ?? ""));
  }
  message = message.replace(/\{\{[^}]+\}\}/g, "");
  return message;
}
async function sendTelegram(config, message) {
  const url = `https://api.telegram.org/bot${config.botToken}/sendMessage`;
  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      chat_id: config.chatId,
      text: message,
      parse_mode: "HTML"
    })
  });
  if (!response.ok) {
    const error = await response.text();
    throw new Error(`Telegram API error: ${response.status} - ${error}`);
  }
}
async function sendSlack(config, message) {
  const response = await fetch(config.webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      text: message,
      channel: config.channel
    })
  });
  if (!response.ok) {
    throw new Error(`Slack webhook error: ${response.status}`);
  }
}
async function sendDiscord(config, message) {
  const response = await fetch(config.webhookUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ content: message })
  });
  if (!response.ok) {
    throw new Error(`Discord webhook error: ${response.status}`);
  }
}
async function sendToChannel(channel, message) {
  const result = {
    channelId: channel.id,
    channelType: channel.type,
    success: false,
    timestamp: /* @__PURE__ */ new Date()
  };
  try {
    switch (channel.type) {
      case "telegram":
        await sendTelegram(channel.config, message);
        result.success = true;
        break;
      case "slack":
        await sendSlack(channel.config, message);
        result.success = true;
        break;
      case "discord":
        await sendDiscord(channel.config, message);
        result.success = true;
        break;
      case "email":
        result.error = "Email notifications not yet implemented - skipping";
        console.warn("[Notification] Email channel skipped - not implemented");
        break;
      default:
        result.error = `Unsupported channel type: ${channel.type}`;
    }
  } catch (error) {
    result.error = error instanceof Error ? error.message : String(error);
  }
  notificationHistory.unshift(result);
  if (notificationHistory.length > MAX_HISTORY2) {
    notificationHistory.pop();
  }
  return result;
}
async function sendNotification(eventType, data) {
  const results = [];
  for (const template of templates.values()) {
    if (!template.enabled) continue;
    if (template.eventType !== eventType && template.eventType !== "*") continue;
    const message = formatMessage(template.messageTemplate, { ...data, eventType });
    for (const channelId of template.channels) {
      const channel = channels.get(channelId);
      if (!channel || !channel.enabled) continue;
      const result = await sendToChannel(channel, message);
      results.push(result);
    }
  }
  return results;
}
async function sendDirectNotification(channelId, message) {
  const channel = channels.get(channelId);
  if (!channel) return null;
  return sendToChannel(channel, message);
}
function getNotificationHistory(limit4 = 50) {
  return notificationHistory.slice(0, limit4);
}
function getNotificationStats() {
  const total = notificationHistory.length;
  const successful = notificationHistory.filter((n) => n.success).length;
  return {
    totalChannels: channels.size,
    enabledChannels: Array.from(channels.values()).filter((c) => c.enabled).length,
    totalTemplates: templates.size,
    recentNotifications: total,
    successRate: total > 0 ? successful / total : 1
  };
}
function createDefaultTemplates() {
  const defaultTemplates = [
    {
      id: "trade-order-submitted",
      name: "Trade Order Submitted",
      eventType: "trade.order.submitted",
      channels: [],
      messageTemplate: "\u{1F4CA} <b>Order Submitted</b>\n{{side}} {{qty}} {{symbol}} @ ${{price}}\nOrder ID: {{orderId}}",
      enabled: true
    },
    {
      id: "trade-order-filled",
      name: "Trade Order Filled",
      eventType: "trade.order.filled",
      channels: [],
      messageTemplate: "\u2705 <b>Order Filled</b>\n{{side}} {{qty}} {{symbol}} @ ${{price}}\nOrder ID: {{orderId}}",
      enabled: true
    },
    {
      id: "trade-order-rejected",
      name: "Trade Order Rejected",
      eventType: "trade.order.rejected",
      channels: [],
      messageTemplate: "\u274C <b>Order Rejected</b>\n{{side}} {{qty}} {{symbol}}\nReason: {{reason}}",
      enabled: true
    },
    {
      id: "ai-decision",
      name: "AI Decision Generated",
      eventType: "ai.decision.generated",
      channels: [],
      messageTemplate: "\u{1F916} <b>AI Decision</b>\nSymbol: {{symbol}}\nAction: {{action}}\nConfidence: {{confidence}}%\nReason: {{reasoning}}",
      enabled: true
    },
    {
      id: "position-opened",
      name: "Position Opened",
      eventType: "trade.position.opened",
      channels: [],
      messageTemplate: "\u{1F4C8} <b>Position Opened</b>\n{{side}} {{qty}} {{symbol}} @ ${{entryPrice}}",
      enabled: true
    },
    {
      id: "position-closed",
      name: "Position Closed",
      eventType: "trade.position.closed",
      channels: [],
      messageTemplate: "\u{1F4C9} <b>Position Closed</b>\n{{symbol}} closed\nP/L: ${{pnl}} ({{pnlPercent}}%)",
      enabled: true
    }
  ];
  for (const template of defaultTemplates) {
    if (!templates.has(template.id)) {
      templates.set(template.id, template);
    }
  }
}
var channels, templates, notificationHistory, MAX_HISTORY2;
var init_notification_service = __esm({
  "server/lib/notification-service.ts"() {
    "use strict";
    channels = /* @__PURE__ */ new Map();
    templates = /* @__PURE__ */ new Map();
    notificationHistory = [];
    MAX_HISTORY2 = 200;
    createDefaultTemplates();
  }
});

// server/lib/technical-indicators.ts
function calculateSMA(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function calculateEMA(prices, period) {
  const result = [];
  const multiplier = 2 / (period + 1);
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      const sma = prices.slice(0, period).reduce((a, b) => a + b, 0) / period;
      result.push(sma);
    } else {
      const prevEma = result[i - 1];
      if (prevEma !== null) {
        const ema = (prices[i] - prevEma) * multiplier + prevEma;
        result.push(ema);
      } else {
        result.push(null);
      }
    }
  }
  return result;
}
function calculateRSI(prices, period = 14) {
  const result = [];
  if (prices.length < period + 1) {
    return prices.map(() => null);
  }
  let avgGain = 0;
  let avgLoss = 0;
  for (let i = 0; i < prices.length; i++) {
    if (i === 0) {
      result.push(null);
      continue;
    }
    const change = prices[i] - prices[i - 1];
    const gain = change > 0 ? change : 0;
    const loss = change < 0 ? -change : 0;
    if (i < period) {
      avgGain += gain;
      avgLoss += loss;
      result.push(null);
    } else if (i === period) {
      avgGain = (avgGain + gain) / period;
      avgLoss = (avgLoss + loss) / period;
      if (avgLoss === 0) {
        result.push(100);
      } else {
        const rs = avgGain / avgLoss;
        result.push(100 - 100 / (1 + rs));
      }
    } else {
      avgGain = (avgGain * (period - 1) + gain) / period;
      avgLoss = (avgLoss * (period - 1) + loss) / period;
      if (avgLoss === 0) {
        result.push(100);
      } else {
        const rs = avgGain / avgLoss;
        result.push(100 - 100 / (1 + rs));
      }
    }
  }
  return result;
}
function calculateMACD(prices, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
  const emaFast = calculateEMA(prices, fastPeriod);
  const emaSlow = calculateEMA(prices, slowPeriod);
  const macdLine = [];
  for (let i = 0; i < prices.length; i++) {
    if (emaFast[i] !== null && emaSlow[i] !== null) {
      macdLine.push(emaFast[i] - emaSlow[i]);
    } else {
      macdLine.push(null);
    }
  }
  const validMacd = macdLine.filter((v) => v !== null);
  const signalLine = calculateEMA(validMacd, signalPeriod);
  const signal = [];
  const histogram = [];
  let signalIdx = 0;
  for (let i = 0; i < prices.length; i++) {
    if (macdLine[i] !== null) {
      const sig = signalLine[signalIdx] ?? null;
      signal.push(sig);
      histogram.push(sig !== null ? macdLine[i] - sig : null);
      signalIdx++;
    } else {
      signal.push(null);
      histogram.push(null);
    }
  }
  return { macd: macdLine, signal, histogram };
}
function calculateBollingerBands(prices, period = 20, stdDevMultiplier = 2) {
  const middle = calculateSMA(prices, period);
  const upper = [];
  const lower = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1 || middle[i] === null) {
      upper.push(null);
      lower.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const mean = middle[i];
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
      const stdDev = Math.sqrt(variance);
      upper.push(mean + stdDevMultiplier * stdDev);
      lower.push(mean - stdDevMultiplier * stdDev);
    }
  }
  return { upper, middle, lower };
}
function calculateATR(highs, lows, closes, period = 14) {
  const trueRanges = [];
  for (let i = 0; i < highs.length; i++) {
    if (i === 0) {
      trueRanges.push(highs[i] - lows[i]);
    } else {
      const highLow = highs[i] - lows[i];
      const highPrevClose = Math.abs(highs[i] - closes[i - 1]);
      const lowPrevClose = Math.abs(lows[i] - closes[i - 1]);
      trueRanges.push(Math.max(highLow, highPrevClose, lowPrevClose));
    }
  }
  const result = [];
  for (let i = 0; i < trueRanges.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else if (i === period - 1) {
      const atr = trueRanges.slice(0, period).reduce((a, b) => a + b, 0) / period;
      result.push(atr);
    } else {
      const prevAtr = result[i - 1];
      if (prevAtr !== null) {
        const atr = (prevAtr * (period - 1) + trueRanges[i]) / period;
        result.push(atr);
      } else {
        result.push(null);
      }
    }
  }
  return result;
}
function calculateROC(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period) {
      result.push(null);
    } else {
      const roc = (prices[i] - prices[i - period]) / prices[i - period];
      result.push(roc);
    }
  }
  return result;
}
function computeAllIndicators(bars) {
  if (bars.length < 200) {
    return null;
  }
  const closes = bars.map((b) => b.close);
  const highs = bars.map((b) => b.high);
  const lows = bars.map((b) => b.low);
  const lastIdx = closes.length - 1;
  const sma20 = calculateSMA(closes, 20);
  const sma50 = calculateSMA(closes, 50);
  const sma200 = calculateSMA(closes, 200);
  const ema12 = calculateEMA(closes, 12);
  const ema26 = calculateEMA(closes, 26);
  const rsi14 = calculateRSI(closes, 14);
  const macdResult = calculateMACD(closes, 12, 26, 9);
  const atr14 = calculateATR(highs, lows, closes, 14);
  const bollingerBands = calculateBollingerBands(closes, 20, 2);
  return {
    sma20: sma20[lastIdx],
    sma50: sma50[lastIdx],
    sma200: sma200[lastIdx],
    ema12: ema12[lastIdx],
    ema26: ema26[lastIdx],
    rsi14: rsi14[lastIdx],
    macd: macdResult.macd[lastIdx],
    macdSignal: macdResult.signal[lastIdx],
    macdHistogram: macdResult.histogram[lastIdx],
    atr14: atr14[lastIdx],
    bollingerUpper: bollingerBands.upper[lastIdx],
    bollingerLower: bollingerBands.lower[lastIdx],
    adx14: null
  };
}
var init_technical_indicators = __esm({
  "server/lib/technical-indicators.ts"() {
    "use strict";
  }
});

// server/services/position-reconciler.ts
var position_reconciler_exports = {};
__export(position_reconciler_exports, {
  positionReconciler: () => positionReconciler
});
var PositionReconciler, positionReconciler;
var init_position_reconciler = __esm({
  "server/services/position-reconciler.ts"() {
    "use strict";
    init_alpaca();
    init_storage();
    init_logger();
    PositionReconciler = class {
      lastReconciliation = null;
      reconciliationInterval = 5 * 60 * 1e3;
      // 5 minutes
      isReconciling = false;
      async reconcile(force = false) {
        if (this.isReconciling) {
          log.info("PositionReconciler", "Reconciliation already in progress, skipping");
          return this.createSkippedResult("Already reconciling");
        }
        if (!force && this.lastReconciliation) {
          const elapsed = Date.now() - this.lastReconciliation.getTime();
          if (elapsed < this.reconciliationInterval) {
            log.info("PositionReconciler", `Skipping reconciliation, last run ${Math.round(elapsed / 1e3)}s ago`);
            return this.createSkippedResult(`Last run ${Math.round(elapsed / 1e3)}s ago`);
          }
        }
        this.isReconciling = true;
        const startTime = Date.now();
        log.info("PositionReconciler", "Starting position reconciliation...");
        try {
          const [brokerPositions, dbPositions] = await Promise.all([
            this.fetchBrokerPositions(),
            this.fetchDBPositions()
          ]);
          const result = await this.performReconciliation(brokerPositions, dbPositions);
          result.duration_ms = Date.now() - startTime;
          this.lastReconciliation = /* @__PURE__ */ new Date();
          log.info("PositionReconciler", `Reconciliation completed in ${result.duration_ms}ms`, {
            synced: result.synced,
            added: result.added,
            removed: result.removed,
            conflicts: result.conflicts.length,
            brokerPositions: result.brokerPositions,
            dbPositions: result.dbPositions,
            totalValue: result.totalValue
          });
          return result;
        } catch (error) {
          log.error("PositionReconciler", "Reconciliation failed", { error });
          return {
            timestamp: /* @__PURE__ */ new Date(),
            status: "failed",
            brokerPositions: 0,
            dbPositions: 0,
            synced: 0,
            added: 0,
            removed: 0,
            conflicts: [],
            totalValue: 0,
            duration_ms: Date.now() - startTime
          };
        } finally {
          this.isReconciling = false;
        }
      }
      async fetchBrokerPositions() {
        try {
          const positions2 = await alpaca.getPositions();
          return positions2.map((p) => ({
            symbol: p.symbol,
            qty: parseFloat(p.qty),
            side: parseFloat(p.qty) >= 0 ? "long" : "short",
            marketValue: parseFloat(p.market_value),
            avgEntryPrice: parseFloat(p.avg_entry_price),
            currentPrice: parseFloat(p.current_price),
            unrealizedPL: parseFloat(p.unrealized_pl),
            unrealizedPLPercent: parseFloat(p.unrealized_plpc) * 100
          }));
        } catch (error) {
          log.error("PositionReconciler", "Failed to fetch broker positions", { error });
          throw error;
        }
      }
      async fetchDBPositions() {
        try {
          const positions2 = await storage.getPositions();
          return positions2;
        } catch (error) {
          log.error("PositionReconciler", "Failed to fetch DB positions", { error });
          throw error;
        }
      }
      async performReconciliation(brokerPositions, dbPositions) {
        const conflicts = [];
        let synced = 0;
        let added = 0;
        let removed = 0;
        const brokerSymbols = new Set(brokerPositions.map((p) => p.symbol));
        const dbSymbols = new Set(dbPositions.map((p) => p.symbol));
        for (const brokerPos of brokerPositions) {
          const dbPos = dbPositions.find((p) => p.symbol === brokerPos.symbol);
          if (!dbPos) {
            await this.addPositionToDB(brokerPos);
            added++;
            log.info("PositionReconciler", `Added missing position: ${brokerPos.symbol} x ${brokerPos.qty}`, {
              symbol: brokerPos.symbol,
              qty: brokerPos.qty,
              source: "broker_not_in_db"
            });
          } else if (Math.abs(parseFloat(dbPos.quantity) - brokerPos.qty) > 1e-4) {
            const dbQty = parseFloat(dbPos.quantity);
            const conflict = {
              symbol: brokerPos.symbol,
              brokerQty: brokerPos.qty,
              dbQty,
              brokerValue: brokerPos.marketValue,
              dbValue: dbQty * brokerPos.currentPrice,
              resolution: "use_broker",
              // Broker is source of truth
              resolved: false
            };
            await this.updateDBPosition(dbPos.id, brokerPos);
            conflict.resolved = true;
            conflicts.push(conflict);
            synced++;
            log.warn("PositionReconciler", `Resolved quantity conflict for ${brokerPos.symbol}`, {
              symbol: brokerPos.symbol,
              brokerQty: brokerPos.qty,
              dbQty: dbPos.quantity,
              resolution: "use_broker"
            });
          } else {
            await this.updateDBPositionPrices(dbPos.id, brokerPos);
            synced++;
          }
        }
        for (const dbPos of dbPositions) {
          if (!brokerSymbols.has(dbPos.symbol)) {
            await this.closeDBPosition(dbPos.id);
            removed++;
            log.info("PositionReconciler", `Closed stale position: ${dbPos.symbol}`, {
              symbol: dbPos.symbol,
              positionId: dbPos.id,
              source: "db_not_in_broker"
            });
          }
        }
        const totalValue = brokerPositions.reduce((sum, p) => sum + p.marketValue, 0);
        return {
          timestamp: /* @__PURE__ */ new Date(),
          status: conflicts.length > 0 ? "partial" : "success",
          brokerPositions: brokerPositions.length,
          dbPositions: dbPositions.length,
          synced,
          added,
          removed,
          conflicts,
          totalValue,
          duration_ms: 0
          // Will be set by caller
        };
      }
      async addPositionToDB(brokerPos) {
        const newPosition = {
          symbol: brokerPos.symbol,
          quantity: brokerPos.qty.toString(),
          side: brokerPos.side,
          entryPrice: brokerPos.avgEntryPrice.toString(),
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString(),
          strategyId: null
          // Unknown strategy - came from external trade or reconciliation
        };
        await storage.createPosition(newPosition);
      }
      async updateDBPosition(positionId, brokerPos) {
        await storage.updatePosition(positionId, {
          quantity: brokerPos.qty.toString(),
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString()
        });
      }
      async updateDBPositionPrices(positionId, brokerPos) {
        await storage.updatePosition(positionId, {
          currentPrice: brokerPos.currentPrice.toString(),
          unrealizedPnl: brokerPos.unrealizedPL.toString()
        });
      }
      async closeDBPosition(positionId) {
        log.info("PositionReconciler", `Position ${positionId} marked for closure (external)`);
      }
      createSkippedResult(reason) {
        return {
          timestamp: /* @__PURE__ */ new Date(),
          status: "skipped",
          brokerPositions: 0,
          dbPositions: 0,
          synced: 0,
          added: 0,
          removed: 0,
          conflicts: [],
          totalValue: 0,
          duration_ms: 0
        };
      }
      // Get reconciliation status
      getStatus() {
        const nextRunIn = this.lastReconciliation ? Math.max(0, this.reconciliationInterval - (Date.now() - this.lastReconciliation.getTime())) : null;
        return {
          lastRun: this.lastReconciliation,
          interval: this.reconciliationInterval,
          isReconciling: this.isReconciling,
          nextRunIn
        };
      }
      // Force immediate reconciliation
      async forceReconcile() {
        return this.reconcile(true);
      }
      // Set reconciliation interval (in ms)
      setInterval(intervalMs) {
        this.reconciliationInterval = intervalMs;
        log.info("PositionReconciler", `Reconciliation interval set to ${intervalMs}ms`);
      }
    };
    positionReconciler = new PositionReconciler();
  }
});

// server/middleware/audit-logger.ts
var audit_logger_exports = {};
__export(audit_logger_exports, {
  auditLogger: () => auditLogger,
  getRecentAuditLogs: () => getRecentAuditLogs,
  getResourceAuditLogs: () => getResourceAuditLogs,
  getUserAuditLogs: () => getUserAuditLogs
});
function sanitizeRequestBody(body) {
  if (!body || typeof body !== "object") {
    return body;
  }
  const sanitized = { ...body };
  for (const field of SENSITIVE_FIELDS) {
    if (field in sanitized) {
      sanitized[field] = "[REDACTED]";
    }
  }
  for (const key in sanitized) {
    if (typeof sanitized[key] === "object" && sanitized[key] !== null) {
      sanitized[key] = sanitizeRequestBody(sanitized[key]);
    }
  }
  return sanitized;
}
function getActionName(method, path2) {
  const pathSegments = path2.split("/").filter(Boolean);
  let resource = "unknown";
  if (pathSegments.length >= 2 && pathSegments[0] === "api") {
    resource = pathSegments[1];
  }
  const actionMap = {
    "POST": "create",
    "PUT": "update",
    "PATCH": "update",
    "DELETE": "delete"
  };
  const verb = actionMap[method] || method.toLowerCase();
  return `${verb}_${resource}`;
}
function extractResourceId(req) {
  if (req.params.id) {
    return req.params.id;
  }
  for (const param of ["userId", "strategyId", "orderId", "tradeId", "backtestId"]) {
    if (req.params[param]) {
      return req.params[param];
    }
  }
  if (req.body?.id) {
    return req.body.id;
  }
  return void 0;
}
function getClientIp(req) {
  return req.headers["x-forwarded-for"]?.split(",")[0]?.trim() || req.headers["x-real-ip"] || req.socket.remoteAddress || "unknown";
}
async function auditLogger(req, res, next) {
  const startTime = Date.now();
  if (!["POST", "PUT", "PATCH", "DELETE"].includes(req.method)) {
    return next();
  }
  if (req.path.startsWith("/health") || !req.path.startsWith("/api")) {
    return next();
  }
  const userId = req.userId || null;
  let username = null;
  if (userId) {
    try {
      const user = await storage.getUser(userId);
      username = user?.username || null;
    } catch (error) {
      console.error("[AuditLogger] Failed to get username:", error);
    }
  }
  const auditLog = {
    userId,
    username,
    action: getActionName(req.method, req.path),
    resource: req.path.split("/")[2] || "unknown",
    // Extract from /api/resource/...
    resourceId: extractResourceId(req),
    method: req.method,
    path: req.path,
    ipAddress: getClientIp(req),
    userAgent: req.headers["user-agent"] || null,
    requestBody: sanitizeRequestBody(req.body),
    responseStatus: null,
    errorMessage: null
  };
  const originalSend = res.send;
  const originalJson = res.json;
  let responseBody;
  res.send = function(body) {
    responseBody = body;
    return originalSend.call(this, body);
  };
  res.json = function(body) {
    responseBody = body;
    return originalJson.call(this, body);
  };
  res.on("finish", async () => {
    try {
      auditLog.responseStatus = res.statusCode;
      if (res.statusCode >= 400) {
        if (typeof responseBody === "string") {
          try {
            const parsed = JSON.parse(responseBody);
            auditLog.errorMessage = parsed.error || parsed.message || "Unknown error";
          } catch {
            auditLog.errorMessage = responseBody.substring(0, 500);
          }
        } else if (responseBody?.error || responseBody?.message) {
          auditLog.errorMessage = responseBody.error || responseBody.message;
        }
      }
      await storage.createAuditLog(auditLog);
      const duration = Date.now() - startTime;
      console.log(
        `[Audit] ${auditLog.method} ${auditLog.path} - ${auditLog.responseStatus} - ${duration}ms - User: ${username || "anonymous"}`
      );
    } catch (error) {
      console.error("[AuditLogger] Failed to save audit log:", error);
    }
  });
  next();
}
async function getUserAuditLogs(userId, limit4 = 100, offset = 0) {
  return storage.getUserAuditLogs(userId, limit4, offset);
}
async function getResourceAuditLogs(resource, resourceId, limit4 = 50) {
  return storage.getResourceAuditLogs(resource, resourceId, limit4);
}
async function getRecentAuditLogs(limit4 = 100, offset = 0) {
  return storage.getRecentAuditLogs(limit4, offset);
}
var SENSITIVE_FIELDS;
var init_audit_logger = __esm({
  "server/middleware/audit-logger.ts"() {
    "use strict";
    init_storage();
    SENSITIVE_FIELDS = [
      "password",
      "token",
      "apiKey",
      "secret",
      "authorization",
      "cookie",
      "session"
    ];
  }
});

// server/strategies/adaptive-risk-service.ts
var adaptive_risk_service_exports = {};
__export(adaptive_risk_service_exports, {
  ADAPTIVE_THRESHOLDS: () => ADAPTIVE_THRESHOLDS,
  choosePresetFromMarket: () => choosePresetFromMarket,
  getAdaptiveRiskStatus: () => getAdaptiveRiskStatus,
  updateStrategyRiskIfNeeded: () => updateStrategyRiskIfNeeded
});
function getPresetIndex(preset) {
  return PRESET_ORDER.indexOf(preset);
}
function stepPreset(current, direction, basePresetId) {
  const currentIdx = getPresetIndex(current);
  if (direction === "conservative") {
    const newIdx = Math.max(0, currentIdx - 1);
    return PRESET_ORDER[newIdx];
  }
  if (direction === "aggressive") {
    const newIdx = Math.min(PRESET_ORDER.length - 1, currentIdx + 1);
    return PRESET_ORDER[newIdx];
  }
  if (direction === "toward" && basePresetId) {
    const baseIdx = getPresetIndex(basePresetId);
    if (currentIdx === baseIdx) return current;
    const step = currentIdx > baseIdx ? -1 : 1;
    return PRESET_ORDER[currentIdx + step];
  }
  return current;
}
function choosePresetFromMarket(intelligence, basePresetId, currentPresetId) {
  const { overall, components } = intelligence;
  const { volatility, sentiment, momentum } = components;
  const isStressed = overall <= ADAPTIVE_THRESHOLDS.conservative.overall || volatility <= ADAPTIVE_THRESHOLDS.conservative.volatility || sentiment <= ADAPTIVE_THRESHOLDS.conservative.sentiment;
  if (isStressed) {
    return stepPreset(currentPresetId, "conservative");
  }
  const isStrong = overall >= ADAPTIVE_THRESHOLDS.aggressive.overall && momentum >= ADAPTIVE_THRESHOLDS.aggressive.momentum && volatility >= ADAPTIVE_THRESHOLDS.aggressive.volatility && sentiment >= ADAPTIVE_THRESHOLDS.aggressive.sentiment;
  if (isStrong) {
    return stepPreset(currentPresetId, "aggressive");
  }
  return stepPreset(currentPresetId, "toward", basePresetId);
}
function shouldRunAdaptiveUpdate(config) {
  if (config.lastAdaptiveUpdateAt === null || config.lastAdaptiveUpdateAt === void 0) return true;
  const intervalMs = (config.adaptiveRiskIntervalMinutes || 15) * 60 * 1e3;
  const lastUpdate = new Date(config.lastAdaptiveUpdateAt).getTime();
  const now = Date.now();
  return now - lastUpdate >= intervalMs;
}
async function updateStrategyRiskIfNeeded(config) {
  if (!config.adaptiveRiskEnabled) {
    return {
      updated: false,
      previousPreset: config.currentPresetId,
      newPreset: config.currentPresetId || "balanced",
      reason: "Adaptive risk mode disabled",
      config
    };
  }
  if (!shouldRunAdaptiveUpdate(config)) {
    const currentPreset2 = config.currentPresetId || config.basePresetId || "balanced";
    return {
      updated: false,
      previousPreset: currentPreset2,
      newPreset: currentPreset2,
      reason: "Adaptive update interval not reached",
      config
    };
  }
  const intelligence = await dataFusionEngine.getMarketIntelligence();
  const currentPreset = config.currentPresetId || config.basePresetId || "balanced";
  const basePreset = config.basePresetId || "balanced";
  const configWithTimestamp = {
    ...config,
    lastAdaptiveUpdateAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (intelligence.dataQuality === "poor" || intelligence.activeSources < ADAPTIVE_THRESHOLDS.dataQuality.minimumSources) {
    if (currentPreset !== basePreset) {
      const reason2 = intelligence.dataQuality === "poor" ? "Data quality is poor. Reverting to base preset." : `Only ${intelligence.activeSources} data sources active. Reverting to base preset.`;
      const updatedConfig2 = applyPresetToConfig(configWithTimestamp, basePreset, reason2);
      log.info("AdaptiveRisk", `Preset change: ${currentPreset} -> ${basePreset}`, {
        symbol: config.symbol,
        reason: reason2,
        dataQuality: intelligence.dataQuality,
        activeSources: intelligence.activeSources
      });
      return {
        updated: true,
        previousPreset: currentPreset,
        newPreset: basePreset,
        reason: reason2,
        config: updatedConfig2
      };
    }
    return {
      updated: true,
      previousPreset: currentPreset,
      newPreset: currentPreset,
      reason: "Insufficient data quality. Maintaining base preset.",
      config: configWithTimestamp
    };
  }
  const newPreset = choosePresetFromMarket(intelligence, basePreset, currentPreset);
  if (newPreset === currentPreset) {
    return {
      updated: true,
      previousPreset: currentPreset,
      newPreset: currentPreset,
      reason: `Maintaining ${currentPreset} preset after evaluation`,
      config: configWithTimestamp
    };
  }
  const reasons = [];
  if (newPreset === "conservative") {
    const { overall, components } = intelligence;
    if (overall <= ADAPTIVE_THRESHOLDS.conservative.overall) reasons.push(`overall=${overall.toFixed(2)}`);
    if (components.volatility <= ADAPTIVE_THRESHOLDS.conservative.volatility) reasons.push(`volatility=${components.volatility.toFixed(2)}`);
    if (components.sentiment <= ADAPTIVE_THRESHOLDS.conservative.sentiment) reasons.push(`sentiment=${components.sentiment.toFixed(2)}`);
  } else if (newPreset === "aggressive") {
    reasons.push("Strong market conditions");
  } else {
    reasons.push("Moving toward base preset");
  }
  const reason = `Market conditions: ${reasons.join(", ")}`;
  const updatedConfig = applyPresetToConfig(configWithTimestamp, newPreset, reason);
  log.info("AdaptiveRisk", `Preset change: ${currentPreset} -> ${newPreset}`, {
    symbol: config.symbol,
    reason,
    overall: intelligence.overall,
    components: intelligence.components
  });
  return {
    updated: true,
    previousPreset: currentPreset,
    newPreset,
    reason,
    config: updatedConfig
  };
}
function getAdaptiveRiskStatus(config) {
  if (!config.adaptiveRiskEnabled) {
    const preset = config.currentPresetId || config.basePresetId || "balanced";
    return {
      enabled: false,
      mode: "Fixed",
      currentPreset: preset.charAt(0).toUpperCase() + preset.slice(1),
      basePreset: preset.charAt(0).toUpperCase() + preset.slice(1),
      lastUpdate: null
    };
  }
  const current = config.currentPresetId || config.basePresetId || "balanced";
  const base = config.basePresetId || "balanced";
  return {
    enabled: true,
    mode: "Adaptive",
    currentPreset: current.charAt(0).toUpperCase() + current.slice(1),
    basePreset: base.charAt(0).toUpperCase() + base.slice(1),
    lastUpdate: config.lastAdaptiveUpdateAt || null
  };
}
var ADAPTIVE_THRESHOLDS, PRESET_ORDER;
var init_adaptive_risk_service = __esm({
  "server/strategies/adaptive-risk-service.ts"() {
    "use strict";
    init_logger();
    init_data_fusion_engine();
    init_moving_average_crossover();
    ADAPTIVE_THRESHOLDS = {
      conservative: {
        overall: -0.2,
        volatility: -0.4,
        sentiment: -0.3
      },
      aggressive: {
        overall: 0.6,
        momentum: 0.4,
        volatility: 0.3,
        sentiment: 0
      },
      dataQuality: {
        minimumSources: 2
      }
    };
    PRESET_ORDER = ["conservative", "balanced", "aggressive"];
  }
});

// server/strategies/moving-average-crossover.ts
var moving_average_crossover_exports = {};
__export(moving_average_crossover_exports, {
  ADAPTIVE_DEFAULTS: () => ADAPTIVE_DEFAULTS,
  MOVING_AVERAGE_PRESETS: () => MOVING_AVERAGE_PRESETS2,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA,
  applyPresetToConfig: () => applyPresetToConfig,
  backtestMovingAverageStrategy: () => backtestMovingAverageStrategy,
  normalizeMovingAverageConfig: () => normalizeMovingAverageConfig
});
function normalizeMovingAverageConfig(input) {
  const adaptiveRiskEnabled = input.adaptiveRiskEnabled ?? false;
  const basePresetId = input.basePresetId;
  const currentPresetId = input.currentPresetId ?? basePresetId;
  const preset = MOVING_AVERAGE_PRESETS2.find((p) => p.id === (currentPresetId || "balanced"));
  let fastPeriod = input.fastPeriod ?? preset.fastPeriod;
  let slowPeriod = input.slowPeriod ?? preset.slowPeriod;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  fastPeriod = Math.max(PARAMETER_BOUNDS.fastPeriod.min, Math.min(PARAMETER_BOUNDS.fastPeriod.max, Math.round(fastPeriod)));
  slowPeriod = Math.max(PARAMETER_BOUNDS.slowPeriod.min, Math.min(PARAMETER_BOUNDS.slowPeriod.max, Math.round(slowPeriod)));
  allocationPct = Math.max(PARAMETER_BOUNDS.allocationPct.min, Math.min(PARAMETER_BOUNDS.allocationPct.max, allocationPct));
  riskLimitPct = Math.max(PARAMETER_BOUNDS.riskLimitPct.min, Math.min(PARAMETER_BOUNDS.riskLimitPct.max, riskLimitPct));
  if (fastPeriod >= slowPeriod) {
    fastPeriod = Math.max(PARAMETER_BOUNDS.fastPeriod.min, slowPeriod - 5);
  }
  const effectiveBasePresetId = basePresetId || "balanced";
  const effectiveCurrentPresetId = currentPresetId || effectiveBasePresetId;
  const config = {
    id: input.id || `ma_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    fastPeriod,
    slowPeriod,
    allocationPct,
    riskLimitPct,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString(),
    adaptiveRiskEnabled,
    basePresetId: effectiveBasePresetId,
    currentPresetId: effectiveCurrentPresetId,
    adaptiveRiskIntervalMinutes: input.adaptiveRiskIntervalMinutes ?? ADAPTIVE_DEFAULTS.intervalMinutes,
    lastAdaptiveUpdateAt: input.lastAdaptiveUpdateAt ?? null,
    lastPresetChangeAt: input.lastPresetChangeAt ?? null,
    lastPresetChangeReason: input.lastPresetChangeReason ?? null
  };
  return config;
}
function applyPresetToConfig(config, presetId, reason) {
  const preset = MOVING_AVERAGE_PRESETS2.find((p) => p.id === presetId);
  if (!preset) {
    return config;
  }
  return {
    ...config,
    fastPeriod: preset.fastPeriod,
    slowPeriod: preset.slowPeriod,
    allocationPct: preset.allocationPct,
    riskLimitPct: preset.riskLimitPct,
    currentPresetId: presetId,
    lastPresetChangeAt: (/* @__PURE__ */ new Date()).toISOString(),
    lastPresetChangeReason: reason
  };
}
function calculateSMA2(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function detectCrossovers(fastSMA, slowSMA) {
  const crossovers = [];
  for (let i = 1; i < fastSMA.length; i++) {
    const prevFast = fastSMA[i - 1];
    const currFast = fastSMA[i];
    const prevSlow = slowSMA[i - 1];
    const currSlow = slowSMA[i];
    if (prevFast === null || currFast === null || prevSlow === null || currSlow === null) {
      continue;
    }
    if (prevFast <= prevSlow && currFast > currSlow) {
      crossovers.push({ index: i, type: "bullish" });
    } else if (prevFast >= prevSlow && currFast < currSlow) {
      crossovers.push({ index: i, type: "bearish" });
    }
  }
  return crossovers;
}
async function backtestMovingAverageStrategy(config, lookbackDays = 365) {
  let normalizedConfig = normalizeMovingAverageConfig(config);
  const { updateStrategyRiskIfNeeded: updateStrategyRiskIfNeeded2 } = await Promise.resolve().then(() => (init_adaptive_risk_service(), adaptive_risk_service_exports));
  const adaptiveResult = await updateStrategyRiskIfNeeded2(normalizedConfig);
  normalizedConfig = adaptiveResult.config;
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(`Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`);
  }
  if (!bars || bars.length < normalizedConfig.slowPeriod + 10) {
    throw new Error(`Insufficient historical data for ${normalizedConfig.symbol}. Need at least ${normalizedConfig.slowPeriod + 10} days of data.`);
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map((bar) => Math.floor(new Date(bar.t).getTime() / 1e3));
  const fastSMA = calculateSMA2(closePrices, normalizedConfig.fastPeriod);
  const slowSMA = calculateSMA2(closePrices, normalizedConfig.slowPeriod);
  const crossovers = detectCrossovers(fastSMA, slowSMA);
  const trades3 = [];
  const smaCrossoverPoints = [];
  let position = null;
  for (const crossover of crossovers) {
    const date = new Date(timestamps[crossover.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[crossover.index];
    smaCrossoverPoints.push({ date, type: crossover.type, price });
    if (crossover.type === "bullish" && !position) {
      position = { entryIndex: crossover.index, entryPrice: price };
    } else if (crossover.type === "bearish" && position) {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long"
      });
      position = null;
    }
  }
  if (position && closePrices.length > position.entryIndex) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: "long"
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const crossover = crossovers.find((c) => c.index === i);
    if (crossover?.type === "bullish" && !inPosition) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
    } else if (crossover?.type === "bearish" && inPosition) {
      const returnPct = (price - entryPrice) / entryPrice;
      equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct * 10);
      inPosition = false;
    } else if (inPosition) {
      const unrealizedPct = (price - entryPrice) / entryPrice;
      const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct * 10);
      equity = currentEquity;
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length : 0;
  const variance = dailyReturns.length > 0 ? dailyReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / dailyReturns.length : 0;
  const stdDev = Math.sqrt(variance);
  const sharpeRatio = stdDev > 0 ? avgReturn / stdDev * Math.sqrt(252) : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(losingTrades.reduce((sum, t) => sum + t.pnlPct, 0));
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatio * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100
    },
    equityCurve,
    smaCrossoverPoints
  };
}
var ADAPTIVE_DEFAULTS, MOVING_AVERAGE_PRESETS2, PARAMETER_BOUNDS, STRATEGY_SCHEMA;
var init_moving_average_crossover = __esm({
  "server/strategies/moving-average-crossover.ts"() {
    "use strict";
    init_alpaca();
    ADAPTIVE_DEFAULTS = {
      intervalMinutes: 15
    };
    MOVING_AVERAGE_PRESETS2 = [
      {
        id: "conservative",
        name: "Conservative",
        fastPeriod: 10,
        slowPeriod: 30,
        allocationPct: 0.05,
        riskLimitPct: 0.05,
        description: "Lower risk with wider SMA gaps, smaller positions. Best for beginners."
      },
      {
        id: "balanced",
        name: "Balanced",
        fastPeriod: 7,
        slowPeriod: 20,
        allocationPct: 0.1,
        riskLimitPct: 0.1,
        description: "Classic 7/20 SMA crossover. Good balance of signals and reliability."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        fastPeriod: 5,
        slowPeriod: 15,
        allocationPct: 0.15,
        riskLimitPct: 0.15,
        description: "Faster signals with tighter SMAs. More trades, higher volatility."
      }
    ];
    PARAMETER_BOUNDS = {
      fastPeriod: { min: 3, max: 20, default: 7 },
      slowPeriod: { min: 10, max: 60, default: 20 },
      allocationPct: { min: 0.01, max: 0.25, default: 0.1 },
      riskLimitPct: { min: 0.02, max: 0.3, default: 0.1 }
    };
    STRATEGY_SCHEMA = {
      id: "moving_average_crossover",
      name: "Moving Average Crossover (SMA)",
      description: "A simple trend-following strategy that generates buy signals when a short-term moving average crosses above a longer-term moving average, and sell signals when it crosses below. The classic 7/20 SMA version has historically shown ~21% annualized returns in backtests.",
      presets: MOVING_AVERAGE_PRESETS2,
      parameterBounds: PARAMETER_BOUNDS,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
  }
});

// server/ai/ai-strategy-validator.ts
var ai_strategy_validator_exports = {};
__export(ai_strategy_validator_exports, {
  getValidatorStatus: () => getValidatorStatus,
  validateMovingAverageConfig: () => validateMovingAverageConfig
});
import pLimit3 from "p-limit";
import pRetry2 from "p-retry";
function isRateLimitError(error) {
  const errorMsg = error?.message || String(error);
  return errorMsg.includes("429") || errorMsg.includes("RATELIMIT_EXCEEDED") || errorMsg.toLowerCase().includes("quota") || errorMsg.toLowerCase().includes("rate limit");
}
async function validateMovingAverageConfig(config, marketIntelligence) {
  const systemPrompt = `You are an AI trading agent evaluating a Moving Average Crossover strategy for a retail user inside a paper-trading environment.

Voice and rules:
- Write with the precision and restraint of an AI model, not a human analyst.
- Keep every answer concise and signal-focused.
- No paragraphs longer than one sentence.
- No filler, no storytelling, no disclaimers.
- Insights should read as if they were derived directly from data.

Your tasks:
1. Describe the strategy behavior in exactly ONE short, clear sentence.
2. Give a risk assessment in exactly ONE sentence.
3. Provide 2 bullet points of parameter feedback. Each bullet must be:
   - specific,
   - no longer than one sentence,
   - describing either a strength or a risk in the configuration.
4. Use MARKET INTELLIGENCE when provided (trend, volatility, sentiment):
   - Include ONE sentence giving a strategy adjustment or caution that logically follows from the market conditions.
5. Do not include any flair lines, taglines, or meta statements. The tone alone must feel like AI-curated insight.

Output format:
Return a JSON object with EXACT fields:
- summary: one concise sentence.
- riskAssessment: one concise sentence.
- parameterFeedback: array of 2 short, precise bullet points.
- marketSuggestion: one sentence reflecting market intelligence.
- suitability: "retail_friendly" | "borderline" | "advanced_only"
- confidence: number between 0 and 1

Keep the output tight, data-driven, and free of unnecessary explanation.
`;
  const userPrompt = buildValidationPrompt(config, marketIntelligence);
  return limit3(
    () => pRetry2(
      async () => {
        try {
          const response = await callLLM({
            role: "risk_manager",
            criticality: "medium",
            purpose: "strategy_validation",
            traceId: generateTraceId(),
            system: systemPrompt,
            messages: [{ role: "user", content: userPrompt }],
            responseFormat: { type: "json_object" },
            maxTokens: 1024
          });
          const content = response.text;
          if (!content) {
            throw new Error("Empty response from AI");
          }
          const parsed = JSON.parse(content);
          return validateResult(parsed);
        } catch (error) {
          if (isRateLimitError(error)) {
            throw error;
          }
          const abortError = new Error(error.message);
          abortError.name = "AbortError";
          throw abortError;
        }
      },
      {
        retries: 3,
        minTimeout: 1e3,
        maxTimeout: 1e4,
        factor: 2
      }
    )
  );
}
function buildValidationPrompt(config, marketIntelligence) {
  let prompt = `Please review this Moving Average Crossover strategy configuration:

## Configuration
- Symbol: ${config.symbol}
- Fast SMA Period: ${config.fastPeriod} days
- Slow SMA Period: ${config.slowPeriod} days
- Position Allocation: ${(config.allocationPct * 100).toFixed(1)}% of portfolio
- Risk Limit: ${(config.riskLimitPct * 100).toFixed(1)}% max loss

## Strategy Explanation
This strategy generates buy signals when the ${config.fastPeriod}-day moving average crosses above the ${config.slowPeriod}-day moving average (golden cross), and sell signals when it crosses below (death cross).`;
  if (marketIntelligence) {
    prompt += `

## Current Market Context`;
    if (marketIntelligence.currentTrend) {
      prompt += `
- Market Trend: ${marketIntelligence.currentTrend}`;
    }
    if (marketIntelligence.volatility) {
      prompt += `
- Volatility Level: ${marketIntelligence.volatility}`;
    }
    if (marketIntelligence.recentNews && marketIntelligence.recentNews.length > 0) {
      prompt += `
- Recent News:
${marketIntelligence.recentNews.slice(0, 3).map((n) => `  - ${n}`).join("\n")}`;
    }
  }
  prompt += `

Provide your assessment as a JSON object.`;
  return prompt;
}
function validateResult(result) {
  const validSuitability = ["retail_friendly", "borderline", "advanced_only"];
  const suitability = validSuitability.includes(result.suitability) ? result.suitability : "borderline";
  let confidence = Number(result.confidence);
  if (isNaN(confidence) || confidence < 0 || confidence > 1) {
    confidence = 0.7;
  }
  return {
    summary: result.summary || "This moving average crossover strategy follows price trends by tracking when short-term momentum crosses long-term averages.",
    riskAssessment: result.riskAssessment || "Risk assessment pending. Please review parameters carefully.",
    parameterFeedback: Array.isArray(result.parameterFeedback) ? result.parameterFeedback : [],
    suitability,
    confidence
  };
}
function getValidatorStatus() {
  return {
    available: !!(process.env.AI_INTEGRATIONS_OPENAI_BASE_URL && process.env.AI_INTEGRATIONS_OPENAI_API_KEY),
    model: MODEL
  };
}
var MODEL, limit3;
var init_ai_strategy_validator = __esm({
  "server/ai/ai-strategy-validator.ts"() {
    "use strict";
    init_llmGateway();
    MODEL = "gpt-4o";
    limit3 = pLimit3(2);
  }
});

// server/strategies/mean-reversion-scalper.ts
var mean_reversion_scalper_exports = {};
__export(mean_reversion_scalper_exports, {
  MEAN_REVERSION_PRESETS: () => MEAN_REVERSION_PRESETS,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS2,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA2,
  backtestMeanReversionStrategy: () => backtestMeanReversionStrategy,
  generateMeanReversionSignal: () => generateMeanReversionSignal,
  normalizeMeanReversionConfig: () => normalizeMeanReversionConfig
});
function normalizeMeanReversionConfig(input) {
  const preset = MEAN_REVERSION_PRESETS.find((p) => p.id === "balanced");
  let lookbackPeriod = input.lookbackPeriod ?? preset.lookbackPeriod;
  let deviationThreshold = input.deviationThreshold ?? preset.deviationThreshold;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  let maxHoldingPeriod = input.maxHoldingPeriod ?? preset.maxHoldingPeriod;
  lookbackPeriod = Math.max(PARAMETER_BOUNDS2.lookbackPeriod.min, Math.min(PARAMETER_BOUNDS2.lookbackPeriod.max, Math.round(lookbackPeriod)));
  deviationThreshold = Math.max(PARAMETER_BOUNDS2.deviationThreshold.min, Math.min(PARAMETER_BOUNDS2.deviationThreshold.max, deviationThreshold));
  allocationPct = Math.max(PARAMETER_BOUNDS2.allocationPct.min, Math.min(PARAMETER_BOUNDS2.allocationPct.max, allocationPct));
  riskLimitPct = Math.max(PARAMETER_BOUNDS2.riskLimitPct.min, Math.min(PARAMETER_BOUNDS2.riskLimitPct.max, riskLimitPct));
  maxHoldingPeriod = Math.max(PARAMETER_BOUNDS2.maxHoldingPeriod.min, Math.min(PARAMETER_BOUNDS2.maxHoldingPeriod.max, Math.round(maxHoldingPeriod)));
  return {
    id: input.id || `mrs_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    lookbackPeriod,
    deviationThreshold,
    allocationPct,
    riskLimitPct,
    maxHoldingPeriod,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString()
  };
}
function calculateSMA3(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const sum = slice.reduce((a, b) => a + b, 0);
      result.push(sum / period);
    }
  }
  return result;
}
function calculateStdDev(prices, period) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    if (i < period - 1) {
      result.push(null);
    } else {
      const slice = prices.slice(i - period + 1, i + 1);
      const mean = slice.reduce((a, b) => a + b, 0) / period;
      const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
      result.push(Math.sqrt(variance));
    }
  }
  return result;
}
function calculateZScore(prices, sma, stdDev) {
  const result = [];
  for (let i = 0; i < prices.length; i++) {
    const mean = sma[i];
    const std = stdDev[i];
    if (mean === null || std === null || std === 0) {
      result.push(null);
    } else {
      result.push((prices[i] - mean) / std);
    }
  }
  return result;
}
function detectBandCrossings(zScores, threshold) {
  const crossings = [];
  for (let i = 1; i < zScores.length; i++) {
    const prevZ = zScores[i - 1];
    const currZ = zScores[i];
    if (prevZ === null || currZ === null) continue;
    if (prevZ > -threshold && currZ <= -threshold) {
      crossings.push({ index: i, type: "oversold" });
    } else if (prevZ < threshold && currZ >= threshold) {
      crossings.push({ index: i, type: "overbought" });
    }
  }
  return crossings;
}
async function backtestMeanReversionStrategy(config, lookbackDays = 365) {
  const normalizedConfig = normalizeMeanReversionConfig(config);
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(`Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`);
  }
  if (!bars || bars.length < normalizedConfig.lookbackPeriod + 10) {
    throw new Error(`Insufficient historical data for ${normalizedConfig.symbol}. Need at least ${normalizedConfig.lookbackPeriod + 10} days of data.`);
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map((bar) => Math.floor(new Date(bar.t).getTime() / 1e3));
  const sma = calculateSMA3(closePrices, normalizedConfig.lookbackPeriod);
  const stdDev = calculateStdDev(closePrices, normalizedConfig.lookbackPeriod);
  const zScores = calculateZScore(closePrices, sma, stdDev);
  const crossings = detectBandCrossings(zScores, normalizedConfig.deviationThreshold);
  const trades3 = [];
  const bandCrossings = [];
  let position = null;
  for (const crossing of crossings) {
    const date = new Date(timestamps[crossing.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[crossing.index];
    const zScore = zScores[crossing.index] || 0;
    bandCrossings.push({ date, type: crossing.type, price, zScore });
    if (crossing.type === "oversold" && !position) {
      position = { entryIndex: crossing.index, entryPrice: price, side: "long" };
    } else if (crossing.type === "overbought" && position?.side === "long") {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long",
        exitReason: "reversion"
      });
      position = null;
    }
  }
  if (position) {
    for (let i = position.entryIndex + 1; i < closePrices.length; i++) {
      const holdingDays2 = i - position.entryIndex;
      if (holdingDays2 >= normalizedConfig.maxHoldingPeriod) {
        const exitPrice = closePrices[i];
        const pnlPct = position.side === "long" ? (exitPrice - position.entryPrice) / position.entryPrice * 100 : (position.entryPrice - exitPrice) / position.entryPrice * 100;
        const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
        const exitDate = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
        trades3.push({
          entryDate,
          exitDate,
          entryPrice: position.entryPrice,
          exitPrice,
          pnlPct,
          side: position.side,
          exitReason: "timeout"
        });
        position = null;
        break;
      }
    }
  }
  if (position) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = position.side === "long" ? (exitPrice - position.entryPrice) / position.entryPrice * 100 : (position.entryPrice - exitPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: position.side,
      exitReason: "timeout"
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let positionSide = "long";
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  let holdingDays = 0;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const z6 = zScores[i];
    if (!inPosition && z6 !== null && z6 <= -normalizedConfig.deviationThreshold) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
      positionSide = "long";
      holdingDays = 0;
    } else if (inPosition) {
      holdingDays++;
      const shouldExit = positionSide === "long" && z6 !== null && z6 >= 0 || holdingDays >= normalizedConfig.maxHoldingPeriod;
      if (shouldExit) {
        const returnPct = positionSide === "long" ? (price - entryPrice) / entryPrice : (entryPrice - price) / entryPrice;
        equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct);
        inPosition = false;
      } else {
        const unrealizedPct = positionSide === "long" ? (price - entryPrice) / entryPrice : (entryPrice - price) / entryPrice;
        const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct);
        equity = currentEquity;
      }
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length : 0;
  const variance = dailyReturns.length > 0 ? dailyReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / dailyReturns.length : 0;
  const stdDevReturns = Math.sqrt(variance);
  const sharpeRatio = stdDevReturns > 0 ? avgReturn / stdDevReturns * Math.sqrt(252) : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(losingTrades.reduce((sum, t) => sum + t.pnlPct, 0));
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  const avgHoldingPeriod = trades3.length > 0 ? trades3.reduce((sum, t) => {
    const entry = new Date(t.entryDate).getTime();
    const exit = new Date(t.exitDate).getTime();
    return sum + (exit - entry) / (1e3 * 60 * 60 * 24);
  }, 0) / trades3.length : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatio * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100,
      avgHoldingPeriod: Math.round(avgHoldingPeriod * 100) / 100
    },
    equityCurve,
    bandCrossings
  };
}
function generateMeanReversionSignal(prices, config) {
  if (prices.length < config.lookbackPeriod) {
    return null;
  }
  const recentPrices = prices.slice(-config.lookbackPeriod);
  const mean = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
  const variance = recentPrices.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / recentPrices.length;
  const stdDev = Math.sqrt(variance);
  const currentPrice = prices[prices.length - 1];
  const zScore = stdDev > 0 ? (currentPrice - mean) / stdDev : 0;
  const upperBand = mean + config.deviationThreshold * stdDev;
  const lowerBand = mean - config.deviationThreshold * stdDev;
  let signal = "hold";
  let strength = 0;
  if (zScore <= -config.deviationThreshold) {
    signal = "buy";
    strength = Math.min(1, Math.abs(zScore) / (config.deviationThreshold * 2));
  } else if (zScore >= config.deviationThreshold) {
    signal = "sell";
    strength = Math.min(1, Math.abs(zScore) / (config.deviationThreshold * 2));
  }
  return {
    symbol: config.symbol,
    timestamp: /* @__PURE__ */ new Date(),
    price: currentPrice,
    zScore: Math.round(zScore * 100) / 100,
    signal,
    strength: Math.round(strength * 100) / 100,
    upperBand: Math.round(upperBand * 100) / 100,
    lowerBand: Math.round(lowerBand * 100) / 100,
    mean: Math.round(mean * 100) / 100
  };
}
var MEAN_REVERSION_PRESETS, PARAMETER_BOUNDS2, STRATEGY_SCHEMA2;
var init_mean_reversion_scalper = __esm({
  "server/strategies/mean-reversion-scalper.ts"() {
    "use strict";
    init_alpaca();
    MEAN_REVERSION_PRESETS = [
      {
        id: "conservative",
        name: "Conservative",
        lookbackPeriod: 20,
        deviationThreshold: 2.5,
        allocationPct: 0.03,
        riskLimitPct: 0.02,
        maxHoldingPeriod: 5,
        description: "Wider deviation bands, smaller positions. Fewer but higher-probability trades."
      },
      {
        id: "balanced",
        name: "Balanced",
        lookbackPeriod: 14,
        deviationThreshold: 2,
        allocationPct: 0.05,
        riskLimitPct: 0.03,
        maxHoldingPeriod: 3,
        description: "Classic 14-period mean reversion with 2 std dev bands. Good balance of frequency and quality."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        lookbackPeriod: 10,
        deviationThreshold: 1.5,
        allocationPct: 0.08,
        riskLimitPct: 0.05,
        maxHoldingPeriod: 2,
        description: "Tighter bands for more frequent scalping. Higher trade frequency, smaller profits per trade."
      }
    ];
    PARAMETER_BOUNDS2 = {
      lookbackPeriod: { min: 5, max: 50, default: 14 },
      deviationThreshold: { min: 1, max: 4, default: 2 },
      allocationPct: { min: 0.01, max: 0.15, default: 0.05 },
      riskLimitPct: { min: 0.01, max: 0.1, default: 0.03 },
      maxHoldingPeriod: { min: 1, max: 10, default: 3 }
    };
    STRATEGY_SCHEMA2 = {
      id: "mean_reversion_scalper",
      name: "Mean Reversion Scalper",
      description: "A high-frequency strategy that identifies when price deviates significantly from its mean and trades the expected reversion. Buys when price falls below the lower band and sells when it rises above the upper band. Best for range-bound markets.",
      presets: MEAN_REVERSION_PRESETS,
      parameterBounds: PARAMETER_BOUNDS2,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
  }
});

// server/strategies/momentum-strategy.ts
var momentum_strategy_exports = {};
__export(momentum_strategy_exports, {
  MOMENTUM_PRESETS: () => MOMENTUM_PRESETS,
  PARAMETER_BOUNDS: () => PARAMETER_BOUNDS3,
  STRATEGY_SCHEMA: () => STRATEGY_SCHEMA3,
  backtestMomentumStrategy: () => backtestMomentumStrategy,
  generateMomentumSignal: () => generateMomentumSignal,
  normalizeMomentumConfig: () => normalizeMomentumConfig
});
function normalizeMomentumConfig(input) {
  const preset = MOMENTUM_PRESETS.find((p) => p.id === "balanced");
  let lookbackPeriod = input.lookbackPeriod ?? preset.lookbackPeriod;
  let momentumThreshold = input.momentumThreshold ?? preset.momentumThreshold;
  let rsiPeriod = input.rsiPeriod ?? preset.rsiPeriod;
  let rsiOverbought = input.rsiOverbought ?? preset.rsiOverbought;
  let rsiOversold = input.rsiOversold ?? preset.rsiOversold;
  let allocationPct = input.allocationPct ?? preset.allocationPct;
  let riskLimitPct = input.riskLimitPct ?? preset.riskLimitPct;
  lookbackPeriod = Math.max(PARAMETER_BOUNDS3.lookbackPeriod.min, Math.min(PARAMETER_BOUNDS3.lookbackPeriod.max, Math.round(lookbackPeriod)));
  momentumThreshold = Math.max(PARAMETER_BOUNDS3.momentumThreshold.min, Math.min(PARAMETER_BOUNDS3.momentumThreshold.max, momentumThreshold));
  rsiPeriod = Math.max(PARAMETER_BOUNDS3.rsiPeriod.min, Math.min(PARAMETER_BOUNDS3.rsiPeriod.max, Math.round(rsiPeriod)));
  rsiOverbought = Math.max(PARAMETER_BOUNDS3.rsiOverbought.min, Math.min(PARAMETER_BOUNDS3.rsiOverbought.max, Math.round(rsiOverbought)));
  rsiOversold = Math.max(PARAMETER_BOUNDS3.rsiOversold.min, Math.min(PARAMETER_BOUNDS3.rsiOversold.max, Math.round(rsiOversold)));
  allocationPct = Math.max(PARAMETER_BOUNDS3.allocationPct.min, Math.min(PARAMETER_BOUNDS3.allocationPct.max, allocationPct));
  riskLimitPct = Math.max(PARAMETER_BOUNDS3.riskLimitPct.min, Math.min(PARAMETER_BOUNDS3.riskLimitPct.max, riskLimitPct));
  if (rsiOversold >= rsiOverbought) {
    rsiOversold = rsiOverbought - 20;
  }
  return {
    id: input.id || `mom_${Date.now()}`,
    symbol: input.symbol?.toUpperCase() || "AAPL",
    lookbackPeriod,
    momentumThreshold,
    rsiPeriod,
    rsiOverbought,
    rsiOversold,
    allocationPct,
    riskLimitPct,
    universe: input.universe || "US_EQUITY",
    createdAt: input.createdAt || (/* @__PURE__ */ new Date()).toISOString()
  };
}
function detectMomentumSignals(momentum, rsi, config) {
  const signals = [];
  for (let i = 1; i < momentum.length; i++) {
    const prevMom = momentum[i - 1];
    const currMom = momentum[i];
    const currRsi = rsi[i];
    if (prevMom === null || currMom === null || currRsi === null) continue;
    if (currMom > config.momentumThreshold && currRsi > config.rsiOversold && currRsi < config.rsiOverbought) {
      if (prevMom <= config.momentumThreshold) {
        signals.push({ index: i, type: "buy" });
      }
    } else if (currMom < -config.momentumThreshold || currRsi >= config.rsiOverbought) {
      if (prevMom >= -config.momentumThreshold && (momentum[i - 1] === null || rsi[i - 1] === null || rsi[i - 1] !== null && rsi[i - 1] < config.rsiOverbought)) {
        signals.push({ index: i, type: "sell" });
      }
    }
  }
  return signals;
}
async function backtestMomentumStrategy(config, lookbackDays = 365) {
  const normalizedConfig = normalizeMomentumConfig(config);
  const now = /* @__PURE__ */ new Date();
  const from = new Date(now.getTime() - lookbackDays * 24 * 60 * 60 * 1e3);
  let bars;
  try {
    const response = await alpaca.getBars(
      [normalizedConfig.symbol],
      "1Day",
      from.toISOString(),
      now.toISOString(),
      lookbackDays + 50
    );
    bars = response.bars[normalizedConfig.symbol] || [];
  } catch (error) {
    throw new Error(`Failed to fetch historical data for ${normalizedConfig.symbol}: ${error.message}`);
  }
  if (!bars || bars.length < Math.max(normalizedConfig.lookbackPeriod, normalizedConfig.rsiPeriod) + 10) {
    throw new Error(`Insufficient historical data for ${normalizedConfig.symbol}.`);
  }
  const closePrices = bars.map((bar) => bar.c);
  const timestamps = bars.map((bar) => Math.floor(new Date(bar.t).getTime() / 1e3));
  const momentum = calculateROC2(closePrices, normalizedConfig.lookbackPeriod);
  const rsi = calculateRSI2(closePrices, normalizedConfig.rsiPeriod);
  const signals = detectMomentumSignals(momentum, rsi, normalizedConfig);
  const trades3 = [];
  const momentumSignals = [];
  let position = null;
  for (let i = 0; i < closePrices.length; i++) {
    const m = momentum[i];
    const r = rsi[i];
    if (m !== null && r !== null) {
      const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
      let signal = "hold";
      const matchingSignal = signals.find((s) => s.index === i);
      if (matchingSignal) {
        signal = matchingSignal.type;
      }
      momentumSignals.push({
        date,
        momentum: Math.round(m * 1e4) / 100,
        rsi: Math.round(r * 100) / 100,
        signal
      });
    }
  }
  for (const signal of signals) {
    const date = new Date(timestamps[signal.index] * 1e3).toISOString().split("T")[0];
    const price = closePrices[signal.index];
    const m = momentum[signal.index] || 0;
    const r = rsi[signal.index] || 50;
    if (signal.type === "buy" && !position) {
      position = {
        entryIndex: signal.index,
        entryPrice: price,
        entryMomentum: m,
        entryRsi: r
      };
    } else if (signal.type === "sell" && position) {
      const exitPrice = price;
      const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
      const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
      trades3.push({
        entryDate,
        exitDate: date,
        entryPrice: position.entryPrice,
        exitPrice,
        pnlPct,
        side: "long",
        entryMomentum: position.entryMomentum,
        entryRsi: position.entryRsi
      });
      position = null;
    }
  }
  if (position && closePrices.length > position.entryIndex) {
    const exitPrice = closePrices[closePrices.length - 1];
    const pnlPct = (exitPrice - position.entryPrice) / position.entryPrice * 100;
    const entryDate = new Date(timestamps[position.entryIndex] * 1e3).toISOString().split("T")[0];
    const exitDate = new Date(timestamps[timestamps.length - 1] * 1e3).toISOString().split("T")[0];
    trades3.push({
      entryDate,
      exitDate,
      entryPrice: position.entryPrice,
      exitPrice,
      pnlPct,
      side: "long",
      entryMomentum: position.entryMomentum,
      entryRsi: position.entryRsi
    });
  }
  const equityCurve = [];
  let equity = 1e4;
  let inPosition = false;
  let entryEquity = equity;
  let entryPrice = 0;
  let maxEquity = equity;
  let maxDrawdown = 0;
  const dailyReturns = [];
  let prevEquity = equity;
  for (let i = 0; i < closePrices.length; i++) {
    const date = new Date(timestamps[i] * 1e3).toISOString().split("T")[0];
    const price = closePrices[i];
    const signal = signals.find((s) => s.index === i);
    if (signal?.type === "buy" && !inPosition) {
      inPosition = true;
      entryPrice = price;
      entryEquity = equity;
    } else if (signal?.type === "sell" && inPosition) {
      const returnPct = (price - entryPrice) / entryPrice;
      equity = entryEquity * (1 + returnPct * normalizedConfig.allocationPct);
      inPosition = false;
    } else if (inPosition) {
      const unrealizedPct = (price - entryPrice) / entryPrice;
      const currentEquity = entryEquity * (1 + unrealizedPct * normalizedConfig.allocationPct);
      equity = currentEquity;
    }
    equityCurve.push({ date, value: Math.round(equity * 100) / 100 });
    if (equity > maxEquity) maxEquity = equity;
    const drawdown = (maxEquity - equity) / maxEquity * 100;
    if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    if (i > 0) {
      const dailyReturn = (equity - prevEquity) / prevEquity;
      dailyReturns.push(dailyReturn);
    }
    prevEquity = equity;
  }
  const totalReturnPct = (equity - 1e4) / 1e4 * 100;
  const tradingDays = closePrices.length;
  const yearsTraded = tradingDays / 252;
  const annualReturnPct = yearsTraded > 0 ? (Math.pow(1 + totalReturnPct / 100, 1 / yearsTraded) - 1) * 100 : 0;
  const avgReturn = dailyReturns.length > 0 ? dailyReturns.reduce((a, b) => a + b, 0) / dailyReturns.length : 0;
  const variance = dailyReturns.length > 0 ? dailyReturns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / dailyReturns.length : 0;
  const stdDev = Math.sqrt(variance);
  const sharpeRatio = stdDev > 0 ? avgReturn / stdDev * Math.sqrt(252) : 0;
  const negativeReturns = dailyReturns.filter((r) => r < 0);
  const downsideVariance = negativeReturns.length > 0 ? negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length : 0;
  const downsideStdDev = Math.sqrt(downsideVariance);
  const sortinoRatio = downsideStdDev > 0 ? avgReturn / downsideStdDev * Math.sqrt(252) : 0;
  const winningTrades = trades3.filter((t) => t.pnlPct > 0);
  const losingTrades = trades3.filter((t) => t.pnlPct <= 0);
  const winRatePct = trades3.length > 0 ? winningTrades.length / trades3.length * 100 : 0;
  const avgWinPct = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + t.pnlPct, 0) / winningTrades.length : 0;
  const avgLossPct = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + t.pnlPct, 0) / losingTrades.length : 0;
  const grossProfit = winningTrades.reduce((sum, t) => sum + t.pnlPct, 0);
  const grossLoss = Math.abs(losingTrades.reduce((sum, t) => sum + t.pnlPct, 0));
  const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : grossProfit > 0 ? Infinity : 0;
  const avgMomentum = trades3.length > 0 ? trades3.reduce((sum, t) => sum + t.entryMomentum, 0) / trades3.length : 0;
  return {
    symbol: normalizedConfig.symbol,
    config: normalizedConfig,
    trades: trades3,
    metrics: {
      annualReturnPct: Math.round(annualReturnPct * 100) / 100,
      totalReturnPct: Math.round(totalReturnPct * 100) / 100,
      maxDrawdownPct: Math.round(maxDrawdown * 100) / 100,
      sharpeRatio: Math.round(sharpeRatio * 100) / 100,
      sortinoRatio: Math.round(sortinoRatio * 100) / 100,
      totalTrades: trades3.length,
      winRatePct: Math.round(winRatePct * 100) / 100,
      avgWinPct: Math.round(avgWinPct * 100) / 100,
      avgLossPct: Math.round(avgLossPct * 100) / 100,
      profitFactor: Math.round(profitFactor * 100) / 100,
      avgMomentum: Math.round(avgMomentum * 1e4) / 100
    },
    equityCurve,
    momentumSignals
  };
}
function generateMomentumSignal(prices, config) {
  const requiredLength = Math.max(config.lookbackPeriod, config.rsiPeriod) + 1;
  if (prices.length < requiredLength) {
    return null;
  }
  const currentPrice = prices[prices.length - 1];
  const previousPrice = prices[prices.length - 1 - config.lookbackPeriod];
  const momentum = (currentPrice - previousPrice) / previousPrice;
  const rsi = calculateRSI2(prices, config.rsiPeriod);
  const currentRsi = rsi[rsi.length - 1] || 50;
  let signal = "hold";
  let strength = 0;
  let trend = "neutral";
  if (momentum > config.momentumThreshold) {
    trend = "bullish";
    if (currentRsi > config.rsiOversold && currentRsi < config.rsiOverbought) {
      signal = "buy";
      strength = Math.min(1, momentum / (config.momentumThreshold * 3));
    }
  } else if (momentum < -config.momentumThreshold) {
    trend = "bearish";
    if (currentRsi >= config.rsiOverbought) {
      signal = "sell";
      strength = Math.min(1, Math.abs(momentum) / (config.momentumThreshold * 3));
    }
  }
  if (currentRsi >= config.rsiOverbought) {
    signal = "sell";
    strength = Math.max(strength, (currentRsi - config.rsiOverbought) / (100 - config.rsiOverbought));
  }
  return {
    symbol: config.symbol,
    timestamp: /* @__PURE__ */ new Date(),
    price: currentPrice,
    momentum: Math.round(momentum * 1e4) / 100,
    rsi: Math.round(currentRsi * 100) / 100,
    signal,
    strength: Math.round(strength * 100) / 100,
    trend
  };
}
var MOMENTUM_PRESETS, PARAMETER_BOUNDS3, STRATEGY_SCHEMA3, calculateROC2, calculateRSI2;
var init_momentum_strategy = __esm({
  "server/strategies/momentum-strategy.ts"() {
    "use strict";
    init_alpaca();
    init_technical_indicators();
    MOMENTUM_PRESETS = [
      {
        id: "conservative",
        name: "Conservative",
        lookbackPeriod: 20,
        momentumThreshold: 0.03,
        rsiPeriod: 14,
        rsiOverbought: 75,
        rsiOversold: 25,
        allocationPct: 0.05,
        riskLimitPct: 0.03,
        description: "Longer lookback with stricter RSI filters. Fewer but higher-conviction trades."
      },
      {
        id: "balanced",
        name: "Balanced",
        lookbackPeriod: 14,
        momentumThreshold: 0.02,
        rsiPeriod: 14,
        rsiOverbought: 70,
        rsiOversold: 30,
        allocationPct: 0.08,
        riskLimitPct: 0.05,
        description: "Classic momentum with RSI confirmation. Good balance of signal quality and frequency."
      },
      {
        id: "aggressive",
        name: "Aggressive",
        lookbackPeriod: 10,
        momentumThreshold: 0.015,
        rsiPeriod: 10,
        rsiOverbought: 65,
        rsiOversold: 35,
        allocationPct: 0.12,
        riskLimitPct: 0.08,
        description: "Faster signals with looser filters. More trades, captures quick momentum moves."
      }
    ];
    PARAMETER_BOUNDS3 = {
      lookbackPeriod: { min: 5, max: 30, default: 14 },
      momentumThreshold: { min: 5e-3, max: 0.1, default: 0.02 },
      rsiPeriod: { min: 5, max: 21, default: 14 },
      rsiOverbought: { min: 60, max: 85, default: 70 },
      rsiOversold: { min: 15, max: 40, default: 30 },
      allocationPct: { min: 0.02, max: 0.2, default: 0.08 },
      riskLimitPct: { min: 0.02, max: 0.15, default: 0.05 }
    };
    STRATEGY_SCHEMA3 = {
      id: "momentum_strategy",
      name: "Momentum Strategy",
      description: "A trend-following strategy that trades in the direction of price momentum. Uses rate of change and RSI indicators to identify strong momentum moves. Buys when momentum is positive and RSI confirms, sells when momentum reverses.",
      presets: MOMENTUM_PRESETS,
      parameterBounds: PARAMETER_BOUNDS3,
      supportedSymbols: [
        "AAPL",
        "MSFT",
        "GOOGL",
        "AMZN",
        "NVDA",
        "META",
        "TSLA",
        "JPM",
        "V",
        "UNH",
        "JNJ",
        "WMT",
        "PG",
        "MA",
        "HD",
        "CVX",
        "ABBV",
        "MRK",
        "KO",
        "PEP",
        "COST",
        "TMO",
        "AVGO",
        "ORCL",
        "ACN",
        "MCD",
        "CSCO",
        "ABT",
        "AMD",
        "INTC",
        "IBM",
        "CRM",
        "NFLX",
        "ADBE",
        "PYPL",
        "DIS",
        "BTC/USD",
        "ETH/USD",
        "SOL/USD"
      ]
    };
    calculateROC2 = calculateROC;
    calculateRSI2 = calculateRSI;
  }
});

// server/strategies/index.ts
var strategies_exports = {};
__export(strategies_exports, {
  ADAPTIVE_DEFAULTS: () => ADAPTIVE_DEFAULTS,
  ADAPTIVE_THRESHOLDS: () => ADAPTIVE_THRESHOLDS,
  ALL_STRATEGIES: () => ALL_STRATEGIES,
  MA_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS,
  MA_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA,
  MEAN_REVERSION_PRESETS: () => MEAN_REVERSION_PRESETS,
  MOMENTUM_PRESETS: () => MOMENTUM_PRESETS,
  MOM_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS3,
  MOM_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA3,
  MOVING_AVERAGE_PRESETS: () => MOVING_AVERAGE_PRESETS2,
  MRS_PARAMETER_BOUNDS: () => PARAMETER_BOUNDS2,
  MRS_STRATEGY_SCHEMA: () => STRATEGY_SCHEMA2,
  STRATEGY_TYPES: () => STRATEGY_TYPES,
  applyPresetToConfig: () => applyPresetToConfig,
  backtestMeanReversionStrategy: () => backtestMeanReversionStrategy,
  backtestMomentumStrategy: () => backtestMomentumStrategy,
  backtestMovingAverageStrategy: () => backtestMovingAverageStrategy,
  choosePresetFromMarket: () => choosePresetFromMarket,
  generateMeanReversionSignal: () => generateMeanReversionSignal,
  generateMomentumSignal: () => generateMomentumSignal,
  getAdaptiveRiskStatus: () => getAdaptiveRiskStatus,
  getStrategySchema: () => getStrategySchema,
  normalizeMeanReversionConfig: () => normalizeMeanReversionConfig,
  normalizeMomentumConfig: () => normalizeMomentumConfig,
  normalizeMovingAverageConfig: () => normalizeMovingAverageConfig,
  updateStrategyRiskIfNeeded: () => updateStrategyRiskIfNeeded
});
function getStrategySchema(type) {
  switch (type) {
    case STRATEGY_TYPES.MOVING_AVERAGE_CROSSOVER:
      return STRATEGY_SCHEMA;
    case STRATEGY_TYPES.MEAN_REVERSION_SCALPER:
      return STRATEGY_SCHEMA2;
    case STRATEGY_TYPES.MOMENTUM_STRATEGY:
      return STRATEGY_SCHEMA3;
    default:
      return null;
  }
}
var ALL_STRATEGIES, STRATEGY_TYPES;
var init_strategies = __esm({
  "server/strategies/index.ts"() {
    "use strict";
    init_moving_average_crossover();
    init_adaptive_risk_service();
    init_mean_reversion_scalper();
    init_momentum_strategy();
    init_moving_average_crossover();
    init_mean_reversion_scalper();
    init_momentum_strategy();
    ALL_STRATEGIES = [
      STRATEGY_SCHEMA,
      STRATEGY_SCHEMA2,
      STRATEGY_SCHEMA3
    ];
    STRATEGY_TYPES = {
      MOVING_AVERAGE_CROSSOVER: "moving_average_crossover",
      MEAN_REVERSION_SCALPER: "mean_reversion_scalper",
      MOMENTUM_STRATEGY: "momentum_strategy"
    };
  }
});

// server/lib/valyuBudget.ts
var valyuBudget_exports = {};
__export(valyuBudget_exports, {
  checkValyuBudget: () => checkValyuBudget,
  classifySourceTier: () => classifySourceTier,
  getMaxPriceForTier: () => getMaxPriceForTier,
  getValyuBudgetConfig: () => getValyuBudgetConfig,
  getValyuBudgetStatus: () => getValyuBudgetStatus,
  recordValyuRetrievals: () => recordValyuRetrievals,
  resetValyuBudget: () => resetValyuBudget,
  updateValyuBudgetConfig: () => updateValyuBudgetConfig
});
import { eq as eq26, and as and18 } from "drizzle-orm";
function getCurrentMonthKey() {
  const now = /* @__PURE__ */ new Date();
  return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, "0")}`;
}
function getNextMonthResetDate() {
  const now = /* @__PURE__ */ new Date();
  return new Date(now.getFullYear(), now.getMonth() + 1, 1, 0, 0, 0, 0);
}
function getLimitForTier(tier) {
  switch (tier) {
    case "web":
      return currentConfig.webRetrievalsPerMonth;
    case "finance":
      return currentConfig.financeRetrievalsPerMonth;
    case "proprietary":
      return currentConfig.proprietaryRetrievalsPerMonth;
  }
}
function classifySourceTier(sources) {
  if (!sources || sources.length === 0) {
    return "web";
  }
  for (const source of sources) {
    const lowerSource = source.toLowerCase();
    if (lowerSource.includes("proprietary")) {
      return "proprietary";
    }
  }
  for (const source of sources) {
    if (source.startsWith("valyu/")) {
      return "finance";
    }
  }
  return "web";
}
function getMaxPriceForTier(tier) {
  return MAX_PRICE_BY_TIER[tier];
}
async function getOrCreateCounter(tier, monthKey) {
  try {
    const existing = await db.select().from(valyuRetrievalCounters).where(
      and18(
        eq26(valyuRetrievalCounters.sourceTier, tier),
        eq26(valyuRetrievalCounters.monthKey, monthKey)
      )
    ).limit(1);
    if (existing.length > 0) {
      return { id: existing[0].id, retrievalCount: existing[0].retrievalCount };
    }
    const inserted = await db.insert(valyuRetrievalCounters).values({
      sourceTier: tier,
      monthKey,
      retrievalCount: 0
    }).returning();
    return { id: inserted[0].id, retrievalCount: 0 };
  } catch (error) {
    log.error("ValyuBudget", "Failed to get/create counter", { tier, monthKey, error });
    return { id: "", retrievalCount: 0 };
  }
}
async function checkValyuBudget(tier) {
  const monthKey = getCurrentMonthKey();
  const limit4 = getLimitForTier(tier);
  try {
    const counter = await getOrCreateCounter(tier, monthKey);
    const used = counter.retrievalCount;
    const remaining = Math.max(0, limit4 - used);
    if (used >= limit4) {
      return {
        allowed: false,
        tier,
        reason: `Valyu ${tier} tier budget exhausted: ${used}/${limit4} retrievals this month`,
        used,
        limit: limit4,
        remaining: 0
      };
    }
    return {
      allowed: true,
      tier,
      used,
      limit: limit4,
      remaining
    };
  } catch (error) {
    log.warn("ValyuBudget", "Budget check failed, allowing request", { tier, error });
    return {
      allowed: true,
      tier,
      used: 0,
      limit: limit4,
      remaining: limit4
    };
  }
}
async function recordValyuRetrievals(tier, retrievalCount) {
  if (retrievalCount <= 0) return;
  const monthKey = getCurrentMonthKey();
  lastCallTimeByTier.set(tier, Date.now());
  try {
    const existing = await db.select().from(valyuRetrievalCounters).where(
      and18(
        eq26(valyuRetrievalCounters.sourceTier, tier),
        eq26(valyuRetrievalCounters.monthKey, monthKey)
      )
    ).limit(1);
    if (existing.length > 0) {
      await db.update(valyuRetrievalCounters).set({
        retrievalCount: existing[0].retrievalCount + retrievalCount,
        lastUpdated: /* @__PURE__ */ new Date()
      }).where(eq26(valyuRetrievalCounters.id, existing[0].id));
    } else {
      await db.insert(valyuRetrievalCounters).values({
        sourceTier: tier,
        monthKey,
        retrievalCount
      });
    }
    log.info("ValyuBudget", "Recorded retrievals", {
      tier,
      count: retrievalCount,
      monthKey
    });
  } catch (error) {
    log.error("ValyuBudget", "Failed to record retrievals", { tier, retrievalCount, error });
  }
}
async function getValyuBudgetStatus() {
  const monthKey = getCurrentMonthKey();
  const resetDate = getNextMonthResetDate();
  const tiers = ["web", "finance", "proprietary"];
  const statuses = [];
  for (const tier of tiers) {
    const limit4 = getLimitForTier(tier);
    let used = 0;
    try {
      const counter = await getOrCreateCounter(tier, monthKey);
      used = counter.retrievalCount;
    } catch (error) {
      log.warn("ValyuBudget", "Failed to get usage for tier", { tier, error });
    }
    statuses.push({
      tier,
      used,
      limit: limit4,
      remaining: Math.max(0, limit4 - used),
      resetDate,
      lastCallTime: lastCallTimeByTier.get(tier) ?? null
    });
  }
  return statuses;
}
function getValyuBudgetConfig() {
  return { ...currentConfig };
}
function updateValyuBudgetConfig(updates) {
  if (updates.webRetrievalsPerMonth !== void 0) {
    currentConfig.webRetrievalsPerMonth = Math.max(0, updates.webRetrievalsPerMonth);
  }
  if (updates.financeRetrievalsPerMonth !== void 0) {
    currentConfig.financeRetrievalsPerMonth = Math.max(0, updates.financeRetrievalsPerMonth);
  }
  if (updates.proprietaryRetrievalsPerMonth !== void 0) {
    currentConfig.proprietaryRetrievalsPerMonth = Math.max(0, updates.proprietaryRetrievalsPerMonth);
  }
  log.info("ValyuBudget", "Config updated", currentConfig);
  return { ...currentConfig };
}
async function resetValyuBudget(tier) {
  const monthKey = getCurrentMonthKey();
  try {
    if (tier) {
      await db.update(valyuRetrievalCounters).set({ retrievalCount: 0, lastUpdated: /* @__PURE__ */ new Date() }).where(
        and18(
          eq26(valyuRetrievalCounters.sourceTier, tier),
          eq26(valyuRetrievalCounters.monthKey, monthKey)
        )
      );
      log.info("ValyuBudget", "Reset budget for tier", { tier });
    } else {
      await db.update(valyuRetrievalCounters).set({ retrievalCount: 0, lastUpdated: /* @__PURE__ */ new Date() }).where(eq26(valyuRetrievalCounters.monthKey, monthKey));
      log.info("ValyuBudget", "Reset all budgets for month", { monthKey });
    }
  } catch (error) {
    log.error("ValyuBudget", "Failed to reset budget", { tier, error });
  }
}
var DEFAULT_CONFIG4, MAX_PRICE_BY_TIER, currentConfig, lastCallTimeByTier;
var init_valyuBudget = __esm({
  "server/lib/valyuBudget.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_logger();
    DEFAULT_CONFIG4 = {
      webRetrievalsPerMonth: 2e3,
      financeRetrievalsPerMonth: 500,
      proprietaryRetrievalsPerMonth: 100
    };
    MAX_PRICE_BY_TIER = {
      web: 6,
      finance: 12,
      proprietary: 15
    };
    currentConfig = { ...DEFAULT_CONFIG4 };
    lastCallTimeByTier = /* @__PURE__ */ new Map();
  }
});

// server/ai/index.ts
var ai_exports = {};
__export(ai_exports, {
  AIMLClient: () => AIMLClient,
  GroqClient: () => GroqClient,
  OpenAIClient: () => OpenAIClient,
  OpenRouterClient: () => OpenRouterClient,
  TogetherClient: () => TogetherClient,
  aimlClient: () => aimlClient,
  createLLMError: () => createLLMError,
  getAllAvailableProviders: () => getAllAvailableProviders,
  getLLMStatus: () => getLLMStatus,
  groqClient: () => groqClient,
  llm: () => llm,
  openaiClient: () => openaiClient,
  openrouterClient: () => openrouterClient,
  togetherClient: () => togetherClient
});
function getConfiguredProvider() {
  const provider = process.env.AI_PROVIDER?.toLowerCase();
  if (provider === "openrouter") return "openrouter";
  if (provider === "groq") return "groq";
  if (provider === "together") return "together";
  if (provider === "aimlapi") return "aimlapi";
  return "openai";
}
function selectClient() {
  const provider = getConfiguredProvider();
  const clientMap = {
    openai: openaiClient,
    openrouter: openrouterClient,
    groq: groqClient,
    together: togetherClient,
    aimlapi: aimlClient
  };
  const preferredClient = clientMap[provider];
  if (preferredClient?.isAvailable()) {
    return preferredClient;
  }
  if (openaiClient.isAvailable()) return openaiClient;
  if (groqClient.isAvailable()) return groqClient;
  if (togetherClient.isAvailable()) return togetherClient;
  if (aimlClient.isAvailable()) return aimlClient;
  if (openrouterClient.isAvailable()) return openrouterClient;
  return openaiClient;
}
function getLLMStatus() {
  const client = selectClient();
  return {
    provider: client.getProviderName(),
    available: client.isAvailable(),
    providers: {
      openai: openaiClient.isAvailable(),
      openrouter: openrouterClient.isAvailable(),
      groq: groqClient.isAvailable(),
      together: togetherClient.isAvailable(),
      aimlapi: aimlClient.isAvailable()
    }
  };
}
function getAllAvailableProviders() {
  const available = [];
  if (openaiClient.isAvailable()) available.push("openai");
  if (groqClient.isAvailable()) available.push("groq");
  if (togetherClient.isAvailable()) available.push("together");
  if (aimlClient.isAvailable()) available.push("aimlapi");
  if (openrouterClient.isAvailable()) available.push("openrouter");
  return available;
}
var llm;
var init_ai = __esm({
  "server/ai/index.ts"() {
    "use strict";
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    init_llmClient();
    init_openaiClient();
    init_openrouterClient();
    init_groqClient();
    init_togetherClient();
    init_aimlClient();
    llm = selectClient();
  }
});

// server/jobs/position-reconciliation.ts
var position_reconciliation_exports = {};
__export(position_reconciliation_exports, {
  positionReconciliationJob: () => positionReconciliationJob
});
import * as cron from "node-cron";
var PositionReconciliationJob, positionReconciliationJob;
var init_position_reconciliation = __esm({
  "server/jobs/position-reconciliation.ts"() {
    "use strict";
    init_alpaca_trading_engine();
    init_orchestration();
    init_logger();
    PositionReconciliationJob = class {
      cronTask = null;
      isRunning = false;
      stats = {
        isRunning: false,
        lastRunTime: null,
        lastRunDuration: null,
        nextRunTime: null,
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        lastError: null,
        lastResult: null
      };
      /**
       * Start the position reconciliation cron job
       * Runs every 5 minutes to sync positions from Alpaca
       */
      start() {
        if (this.cronTask) {
          log.warn("PositionReconciliation", "Job already running, ignoring start request");
          return;
        }
        this.cronTask = cron.schedule("*/5 * * * *", async () => {
          await this.executeSync();
        }, {
          timezone: "America/New_York"
          // Use market timezone (NYSE)
        });
        log.info("PositionReconciliation", "Cron job started - syncing every 5 minutes");
        this.updateNextRunTime();
        setTimeout(() => {
          this.executeSync();
        }, 1e4);
      }
      /**
       * Stop the position reconciliation cron job
       */
      stop() {
        if (this.cronTask) {
          this.cronTask.stop();
          this.cronTask = null;
          log.info("PositionReconciliation", "Cron job stopped");
        }
      }
      /**
       * Execute the position sync (can be called manually or by cron)
       */
      async executeSync() {
        if (this.isRunning) {
          log.warn("PositionReconciliation", "Sync already in progress, skipping this run");
          return { created: [], updated: [], removed: [], errors: [] };
        }
        this.isRunning = true;
        this.stats.isRunning = true;
        this.stats.totalRuns++;
        const startTime = Date.now();
        const runTime = /* @__PURE__ */ new Date();
        log.info("PositionReconciliation", "Starting position sync...");
        try {
          const result = await alpacaTradingEngine.syncPositionsFromAlpaca();
          const duration = Date.now() - startTime;
          this.stats.successfulRuns++;
          this.stats.lastRunTime = runTime;
          this.stats.lastRunDuration = duration;
          this.stats.lastError = null;
          this.stats.lastResult = result;
          this.updateNextRunTime();
          log.info("PositionReconciliation", "Position sync completed", {
            created: result.created.length,
            updated: result.updated.length,
            removed: result.removed.length,
            errors: result.errors.length,
            duration: `${duration}ms`
          });
          if (result.created.length > 0) {
            log.info("PositionReconciliation", `Created ${result.created.length} new positions: ${result.created.join(", ")}`);
          }
          if (result.updated.length > 0) {
            log.info("PositionReconciliation", `Updated ${result.updated.length} existing positions: ${result.updated.join(", ")}`);
          }
          if (result.removed.length > 0) {
            log.warn("PositionReconciliation", `Removed ${result.removed.length} stale positions: ${result.removed.join(", ")}`);
          }
          if (result.errors.length > 0) {
            log.error("PositionReconciliation", `Encountered ${result.errors.length} errors during sync`, {
              errors: result.errors
            });
          }
          if (result.created.length > 0 || result.updated.length > 0 || result.removed.length > 0) {
            eventBus.emit("position:updated", {
              type: "reconciliation",
              created: result.created,
              updated: result.updated,
              removed: result.removed,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            }, "position-reconciliation-job");
          }
          return result;
        } catch (error) {
          const duration = Date.now() - startTime;
          const errorMessage = error.message;
          this.stats.failedRuns++;
          this.stats.lastRunTime = runTime;
          this.stats.lastRunDuration = duration;
          this.stats.lastError = errorMessage;
          this.updateNextRunTime();
          log.error("PositionReconciliation", "Position sync failed", {
            error: errorMessage,
            duration: `${duration}ms`
          });
          eventBus.emit("system:error", {
            message: "Position reconciliation failed",
            error: errorMessage,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }, "position-reconciliation-job");
          throw error;
        } finally {
          this.isRunning = false;
          this.stats.isRunning = false;
        }
      }
      /**
       * Get current job statistics
       */
      getStats() {
        return { ...this.stats };
      }
      /**
       * Reset job statistics (useful for testing)
       */
      resetStats() {
        this.stats = {
          isRunning: this.isRunning,
          lastRunTime: null,
          lastRunDuration: null,
          nextRunTime: this.stats.nextRunTime,
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          lastError: null,
          lastResult: null
        };
        log.info("PositionReconciliation", "Job statistics reset");
      }
      /**
       * Update the next run time based on cron schedule
       */
      updateNextRunTime() {
        if (!this.cronTask) {
          this.stats.nextRunTime = null;
          return;
        }
        const now = /* @__PURE__ */ new Date();
        const nextRun = new Date(now.getTime() + 5 * 60 * 1e3);
        nextRun.setSeconds(0, 0);
        const minutes = nextRun.getMinutes();
        const remainder = minutes % 5;
        if (remainder !== 0) {
          nextRun.setMinutes(minutes + (5 - remainder));
        }
        this.stats.nextRunTime = nextRun;
      }
      /**
       * Check if job is currently running
       */
      isJobRunning() {
        return this.isRunning;
      }
    };
    positionReconciliationJob = new PositionReconciliationJob();
  }
});

// server/index.ts
import express from "express";
import cookieParser from "cookie-parser";

// server/routes.ts
import { createServer } from "node:http";
import bcrypt2 from "bcryptjs";

// server/lib/session.ts
init_db();
init_schema();
import { randomBytes } from "node:crypto";
import { eq, lt } from "drizzle-orm";
var SESSION_DURATION = 7 * 24 * 60 * 60 * 1e3;
async function createSession(userId) {
  const sessionId = randomBytes(32).toString("hex");
  const expiresAt = new Date(Date.now() + SESSION_DURATION);
  await db.insert(sessions).values({
    id: sessionId,
    userId,
    expiresAt
  });
  return sessionId;
}
async function getSession(sessionId) {
  const [session] = await db.select().from(sessions).where(eq(sessions.id, sessionId));
  if (!session) {
    return null;
  }
  if (session.expiresAt < /* @__PURE__ */ new Date()) {
    await deleteSession(sessionId);
    return null;
  }
  return {
    userId: session.userId,
    expiresAt: session.expiresAt.getTime()
  };
}
async function deleteSession(sessionId) {
  await db.delete(sessions).where(eq(sessions.id, sessionId));
}
async function cleanupExpiredSessions() {
  const result = await db.delete(sessions).where(lt(sessions.expiresAt, /* @__PURE__ */ new Date()));
  console.log(`[SessionCleanup] Cleaned up expired sessions`);
}

// server/routes.ts
init_storage();
init_db();
init_schema();
import { sql as sql16, desc as desc19, eq as eq27 } from "drizzle-orm";

// server/lib/standard-errors.ts
function sendError(res, statusCode, error, message, details) {
  const errorResponse = {
    error,
    message,
    statusCode,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (details) {
    errorResponse.details = details;
  }
  return res.status(statusCode).json(errorResponse);
}
function badRequest(res, message = "Invalid request parameters", details) {
  return sendError(res, 400, "Bad Request", message, details);
}
function unauthorized(res, message = "Authentication required", details) {
  return sendError(res, 401, "Unauthorized", message, details);
}
function notFound(res, message = "Resource not found", details) {
  return sendError(res, 404, "Not Found", message, details);
}
function validationError(res, message = "Validation failed", details) {
  return sendError(res, 422, "Validation Error", message, details);
}
function serverError(res, message = "An internal server error occurred", details) {
  return sendError(res, 500, "Internal Server Error", message, details);
}

// server/routes.ts
init_sanitization();
init_schema();
init_coingecko();
init_finnhub();
init_alpaca();

// server/connectors/coinmarketcap.ts
init_api_cache();
init_connectorClient();
init_logger();
var CMC_BASE_URL = "https://pro-api.coinmarketcap.com";
var PROVIDER = "coinmarketcap";
var CoinMarketCapConnector = class {
  listingsCache = new ApiCache({
    freshDuration: 5 * 60 * 1e3,
    staleDuration: 60 * 60 * 1e3
  });
  quotesCache = new ApiCache({
    freshDuration: 5 * 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  globalCache = new ApiCache({
    freshDuration: 10 * 60 * 1e3,
    staleDuration: 60 * 60 * 1e3
  });
  mapCache = new ApiCache({
    freshDuration: 60 * 60 * 1e3,
    staleDuration: 24 * 60 * 60 * 1e3
  });
  getApiKey() {
    return process.env.COINMARKETCAP_API_KEY;
  }
  getAuthHeaders() {
    const apiKey = this.getApiKey();
    if (!apiKey) {
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    return {
      "X-CMC_PRO_API_KEY": apiKey,
      Accept: "application/json"
    };
  }
  async getLatestListings(start = 1, limit4 = 100, sort = "market_cap", sortDir = "desc") {
    const l1CacheKey = `listings_${start}_${limit4}_${sort}_${sortDir}`;
    const l1Cached = this.listingsCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey = this.getApiKey();
    if (!apiKey) {
      const stale = this.listingsCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/listings/latest?start=${start}&limit=${limit4}&sort=${sort}&sort_dir=${sortDir}&convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "listings", start, limit4, sort, sortDir);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "listings/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(result.data.status.error_message || "CoinMarketCap API error");
    }
    const data = result.data.data;
    this.listingsCache.set(l1CacheKey, data);
    return data;
  }
  async getQuotes(ids) {
    const idsParam = ids.join(",");
    const l1CacheKey = `quotes_${idsParam}`;
    const l1Cached = this.quotesCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey = this.getApiKey();
    if (!apiKey) {
      const stale = this.quotesCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/quotes/latest?id=${idsParam}&convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "quotes", idsParam);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "quotes/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(result.data.status.error_message || "CoinMarketCap API error");
    }
    const data = result.data.data;
    this.quotesCache.set(l1CacheKey, data);
    return data;
  }
  async getQuotesBySymbols(symbols) {
    const symbolsParam = symbols.join(",");
    const l1CacheKey = `quotes_symbols_${symbolsParam}`;
    const l1Cached = this.quotesCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey = this.getApiKey();
    if (!apiKey) {
      const stale = this.quotesCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/quotes/latest?symbol=${symbolsParam}&convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "quotes_symbols", symbolsParam);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "quotes/latest/symbols",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(result.data.status.error_message || "CoinMarketCap API error");
    }
    const data = result.data.data;
    this.quotesCache.set(l1CacheKey, data);
    return data;
  }
  async getGlobalMetrics() {
    const l1CacheKey = "global_metrics";
    const l1Cached = this.globalCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey = this.getApiKey();
    if (!apiKey) {
      const stale = this.globalCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/global-metrics/quotes/latest?convert=USD`;
    const cacheKey = buildCacheKey(PROVIDER, "global_metrics");
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "global-metrics/quotes/latest",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(result.data.status.error_message || "CoinMarketCap API error");
    }
    const data = result.data.data;
    this.globalCache.set(l1CacheKey, data);
    return data;
  }
  async getCryptoMap(start = 1, limit4 = 5e3, sort = "cmc_rank") {
    const l1CacheKey = `map_${start}_${limit4}_${sort}`;
    const l1Cached = this.mapCache.get(l1CacheKey);
    if (l1Cached?.isFresh) {
      log.debug("CMC", `L1 cache HIT for ${l1CacheKey}`);
      return l1Cached.data;
    }
    const apiKey = this.getApiKey();
    if (!apiKey) {
      const stale = this.mapCache.getStale(l1CacheKey);
      if (stale) {
        log.debug("CMC", `No API key, serving stale L1 data for ${l1CacheKey}`);
        return stale;
      }
      throw new Error("COINMARKETCAP_API_KEY is not configured");
    }
    const url = `${CMC_BASE_URL}/v1/cryptocurrency/map?start=${start}&limit=${limit4}&sort=${sort}`;
    const cacheKey = buildCacheKey(PROVIDER, "map", start, limit4, sort);
    const result = await connectorFetch(url, {
      provider: PROVIDER,
      endpoint: "cryptocurrency/map",
      cacheKey,
      headers: this.getAuthHeaders()
    });
    if (result.data.status.error_code !== 0) {
      throw new Error(result.data.status.error_message || "CoinMarketCap API error");
    }
    const data = result.data.data;
    this.mapCache.set(l1CacheKey, data);
    return data;
  }
  async searchCryptos(query, limit4 = 20) {
    const allCryptos = await this.getCryptoMap(1, 500);
    const lowerQuery = query.toLowerCase();
    return allCryptos.filter(
      (crypto4) => crypto4.symbol.toLowerCase().includes(lowerQuery) || crypto4.name.toLowerCase().includes(lowerQuery)
    ).slice(0, limit4);
  }
  getConnectionStatus() {
    const totalCacheSize = this.listingsCache.size() + this.quotesCache.size() + this.globalCache.size() + this.mapCache.size();
    return {
      connected: !!this.getApiKey(),
      hasApiKey: !!this.getApiKey(),
      cacheSize: totalCacheSize
    };
  }
  clearCache() {
    this.listingsCache.clear();
    this.quotesCache.clear();
    this.globalCache.clear();
    this.mapCache.clear();
  }
};
var coinmarketcap = new CoinMarketCapConnector();

// server/routes.ts
init_newsapi();

// server/connectors/uae-markets.ts
init_api_cache();
init_logger();
var DUBAI_PULSE_API_KEY = process.env.UAE_MARKETS_API_KEY || "";
var DUBAI_PULSE_BASE_URL = "https://api.dubaipulse.gov.ae";
var USE_DEMO_DATA = !DUBAI_PULSE_API_KEY || process.env.UAE_MARKETS_USE_DEMO === "true";
var UAE_STOCK_TEMPLATES = [
  {
    symbol: "ADNOCDIST",
    name: "ADNOC Distribution",
    exchange: "ADX",
    sector: "Energy",
    basePrice: 4.28,
    baseChange: 0.08,
    baseChangePercent: 1.9,
    baseVolume: 125e5,
    marketCap: 535e8,
    currency: "AED"
  },
  {
    symbol: "ETISALAT",
    name: "Emirates Telecommunications (Etisalat)",
    exchange: "ADX",
    sector: "Telecommunications",
    basePrice: 25.5,
    baseChange: -0.2,
    baseChangePercent: -0.78,
    baseVolume: 32e5,
    marketCap: 221e9,
    currency: "AED"
  },
  {
    symbol: "FAB",
    name: "First Abu Dhabi Bank",
    exchange: "ADX",
    sector: "Financials",
    basePrice: 13.8,
    baseChange: 0.15,
    baseChangePercent: 1.1,
    baseVolume: 85e5,
    marketCap: 152e9,
    currency: "AED"
  },
  {
    symbol: "ADCB",
    name: "Abu Dhabi Commercial Bank",
    exchange: "ADX",
    sector: "Financials",
    basePrice: 9.45,
    baseChange: 0.05,
    baseChangePercent: 0.53,
    baseVolume: 56e5,
    marketCap: 65e9,
    currency: "AED"
  },
  {
    symbol: "ALDAR",
    name: "Aldar Properties",
    exchange: "ADX",
    sector: "Real Estate",
    basePrice: 6.82,
    baseChange: 0.12,
    baseChangePercent: 1.79,
    baseVolume: 152e5,
    marketCap: 54e9,
    currency: "AED"
  },
  {
    symbol: "EMAAR",
    name: "Emaar Properties",
    exchange: "DFM",
    sector: "Real Estate",
    basePrice: 9.15,
    baseChange: 0.25,
    baseChangePercent: 2.81,
    baseVolume: 22e6,
    marketCap: 8e10,
    currency: "AED"
  },
  {
    symbol: "DIB",
    name: "Dubai Islamic Bank",
    exchange: "DFM",
    sector: "Financials",
    basePrice: 6.2,
    baseChange: -0.05,
    baseChangePercent: -0.8,
    baseVolume: 98e5,
    marketCap: 45e9,
    currency: "AED"
  },
  {
    symbol: "EMIRATESNBD",
    name: "Emirates NBD",
    exchange: "DFM",
    sector: "Financials",
    basePrice: 18.9,
    baseChange: 0.3,
    baseChangePercent: 1.61,
    baseVolume: 45e5,
    marketCap: 118e9,
    currency: "AED"
  },
  {
    symbol: "DU",
    name: "Emirates Integrated Telecommunications (du)",
    exchange: "DFM",
    sector: "Telecommunications",
    basePrice: 6.75,
    baseChange: 0.1,
    baseChangePercent: 1.5,
    baseVolume: 32e5,
    marketCap: 3e10,
    currency: "AED"
  },
  {
    symbol: "DEWA",
    name: "Dubai Electricity & Water Authority",
    exchange: "DFM",
    sector: "Utilities",
    basePrice: 2.58,
    baseChange: 0.02,
    baseChangePercent: 0.78,
    baseVolume: 185e5,
    marketCap: 13e10,
    currency: "AED"
  }
];
var UAE_SUMMARY_TEMPLATES = [
  {
    exchange: "ADX",
    indexName: "ADX General Index",
    baseIndexValue: 9856.42,
    baseChange: 45.23,
    baseChangePercent: 0.46,
    baseTradingValue: 125e7,
    baseTradingVolume: 285e6,
    advancers: 32,
    decliners: 18,
    unchanged: 8
  },
  {
    exchange: "DFM",
    indexName: "DFM General Index",
    baseIndexValue: 4285.67,
    baseChange: -12.35,
    baseChangePercent: -0.29,
    baseTradingValue: 89e7,
    baseTradingVolume: 195e6,
    advancers: 22,
    decliners: 28,
    unchanged: 12
  }
];
var UAE_MARKET_INFO = {
  exchanges: {
    ADX: {
      name: "ADX",
      fullName: "Abu Dhabi Securities Exchange",
      website: "https://www.adx.ae",
      currency: "AED",
      timezone: "GST (UTC+4)",
      tradingHours: "10:00 AM - 2:00 PM (Sun-Thu)",
      established: 2e3
    },
    DFM: {
      name: "DFM",
      fullName: "Dubai Financial Market",
      website: "https://www.dfm.ae",
      currency: "AED",
      timezone: "GST (UTC+4)",
      tradingHours: "10:00 AM - 2:00 PM (Sun-Thu)",
      established: 2e3
    }
  },
  apiProviders: [
    {
      name: "Dubai Pulse Open API",
      type: "free",
      coverage: ["DFM"],
      features: ["DFM Indices", "Market Summary", "OAuth Authentication"],
      url: "https://www.dubaipulse.gov.ae/data/dfm-general/dfm_indices-open-api"
    },
    {
      name: "DFM Native API",
      type: "free",
      coverage: ["DFM"],
      features: ["SOAP/XML Format", "Market Summary", "Real-time Prices"],
      url: "https://api.dfm.ae"
    },
    {
      name: "Twelve Data",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["REST API", "Real-time & Historical", "Analyst Ratings"],
      url: "https://twelvedata.com"
    },
    {
      name: "ICE Data Services",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["Native & Normalized Feed", "Level 1 & 2", "Historical Data"],
      url: "https://developer.ice.com"
    },
    {
      name: "LSEG (Refinitiv)",
      type: "premium",
      coverage: ["ADX", "DFM"],
      features: ["Low Latency Feed", "Market Depth", "Full Tick History"],
      url: "https://www.lseg.com"
    }
  ],
  regulatoryAuthority: "UAE Securities and Commodities Authority (SCA)",
  notes: "UAE markets operate Sunday-Thursday. First exchange globally to operate under Islamic Sharia principles (DFM)."
};
function generateDemoStocks() {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  return UAE_STOCK_TEMPLATES.map((template) => ({
    symbol: template.symbol,
    name: template.name,
    exchange: template.exchange,
    sector: template.sector,
    currentPrice: template.basePrice,
    change: template.baseChange,
    changePercent: template.baseChangePercent,
    volume: template.baseVolume,
    marketCap: template.marketCap,
    currency: template.currency,
    lastUpdated: now
  }));
}
function generateDemoSummaries() {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  return UAE_SUMMARY_TEMPLATES.map((template) => ({
    exchange: template.exchange,
    indexName: template.indexName,
    indexValue: template.baseIndexValue,
    change: template.baseChange,
    changePercent: template.baseChangePercent,
    tradingValue: template.baseTradingValue,
    tradingVolume: template.baseTradingVolume,
    advancers: template.advancers,
    decliners: template.decliners,
    unchanged: template.unchanged,
    lastUpdated: now
  }));
}
var UAEMarketsConnector = class {
  stocksCache = new ApiCache({
    freshDuration: 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  summaryCache = new ApiCache({
    freshDuration: 60 * 1e3,
    staleDuration: 30 * 60 * 1e3
  });
  apiCallCount = 0;
  lastApiCallTime = null;
  usingLiveData = false;
  /**
   * Fetch DFM index data from Dubai Pulse Open API
   */
  async fetchDubaiPulseIndices() {
    if (USE_DEMO_DATA) {
      return null;
    }
    try {
      this.apiCallCount++;
      this.lastApiCallTime = /* @__PURE__ */ new Date();
      const url = `${DUBAI_PULSE_BASE_URL}/data/dfm-general/dfm-indices`;
      const response = await fetch(url, {
        headers: {
          "Authorization": `Bearer ${DUBAI_PULSE_API_KEY}`,
          "Accept": "application/json"
        },
        signal: AbortSignal.timeout(1e4)
        // 10s timeout
      });
      if (!response.ok) {
        log.warn("UAEMarkets", `Dubai Pulse API returned ${response.status}`);
        return null;
      }
      const data = await response.json();
      const records = data?.data?.records;
      if (!records || records.length === 0) {
        log.warn("UAEMarkets", "No records in Dubai Pulse response");
        return null;
      }
      const record = records[0];
      const indexValue = parseFloat(String(record.Index_Value || 0));
      const change = parseFloat(String(record.Change || 0));
      const changePercent = parseFloat(String(record.Change_Percentage || 0));
      const volume = parseFloat(String(record.Volume || 0));
      const value = parseFloat(String(record.Value || 0));
      this.usingLiveData = true;
      return {
        exchange: "DFM",
        indexName: record.Index_Name || "DFM General Index",
        indexValue,
        change,
        changePercent,
        tradingValue: value,
        tradingVolume: volume,
        advancers: 0,
        // Not provided by this API
        decliners: 0,
        unchanged: 0,
        lastUpdated: record.Trade_Date || (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      log.error("UAEMarkets", `Failed to fetch Dubai Pulse data: ${error}`);
      this.usingLiveData = false;
      return null;
    }
  }
  /**
   * Fetch stocks with live API integration
   */
  async getTopStocks(exchange) {
    const cacheKey = `stocks_${exchange || "all"}`;
    const cached = this.stocksCache.get(cacheKey);
    if (cached?.isFresh) {
      return cached.data;
    }
    if (exchange === "DFM" && !USE_DEMO_DATA) {
      log.info("UAEMarkets", "Live stock data requires DFM Native API or premium provider");
    }
    let stocks = generateDemoStocks();
    if (exchange) {
      stocks = stocks.filter((s) => s.exchange === exchange);
    }
    this.stocksCache.set(cacheKey, stocks);
    return stocks;
  }
  /**
   * Fetch market summary with live API integration
   */
  async getMarketSummary(exchange) {
    const cacheKey = `summary_${exchange || "all"}`;
    const cached = this.summaryCache.get(cacheKey);
    if (cached?.isFresh) {
      return cached.data;
    }
    let summaries = [];
    if (!exchange || exchange === "DFM") {
      const liveDfmData = await this.fetchDubaiPulseIndices();
      if (liveDfmData) {
        summaries.push(liveDfmData);
        log.info("UAEMarkets", "Using live DFM data from Dubai Pulse API");
      }
    }
    const demoSummaries = generateDemoSummaries();
    if (summaries.length === 0) {
      summaries = demoSummaries;
    } else if (!exchange) {
      const adxDemo = demoSummaries.find((s) => s.exchange === "ADX");
      if (adxDemo) {
        summaries.push(adxDemo);
      }
    }
    if (exchange) {
      summaries = summaries.filter((s) => s.exchange === exchange);
    }
    this.summaryCache.set(cacheKey, summaries);
    return summaries;
  }
  getMarketInfo() {
    return { ...UAE_MARKET_INFO };
  }
  getConnectionStatus() {
    return {
      connected: true,
      dataSource: this.usingLiveData ? "live" : "demo",
      cacheSize: this.stocksCache.size() + this.summaryCache.size(),
      isMockData: !this.usingLiveData,
      isDemoData: !this.usingLiveData,
      apiCallCount: this.apiCallCount,
      lastApiCall: this.lastApiCallTime?.toISOString() || null,
      apiConfigured: !!DUBAI_PULSE_API_KEY
    };
  }
  clearCache() {
    this.stocksCache.clear();
    this.summaryCache.clear();
  }
};
var uaeMarkets = new UAEMarketsConnector();

// server/routes.ts
init_valyu();
init_huggingface();
init_gdelt();
init_decision_engine();
init_llmGateway();
init_data_fusion_engine();
init_alpaca_trading_engine();

// server/trading/alpaca-stream.ts
init_logger();
init_storage();
import WebSocket from "ws";

// server/trading/order-retry-handler.ts
init_alpaca();
init_storage();
init_logger();
init_trading_config();
var MAX_RETRIES_PER_ORDER = tradingConfig.orderRetry.maxRetriesPerOrder;
var RETRY_BACKOFF_BASE_MS = tradingConfig.orderRetry.retryBackoffBaseMs;
var CIRCUIT_BREAKER_THRESHOLD = tradingConfig.orderRetry.circuitBreakerThreshold;
var CIRCUIT_BREAKER_WINDOW_MS = tradingConfig.orderRetry.circuitBreakerWindowMs;
var CIRCUIT_BREAKER_RESET_MS = tradingConfig.orderRetry.circuitBreakerResetMs;
var retryTracker = /* @__PURE__ */ new Map();
var circuitBreaker = {
  failures: 0,
  lastFailureTime: null,
  isOpen: false,
  resetTime: null
};
var rejectionHandlers = [
  // Market Hours Issues
  {
    pattern: /market.*(?:closed|extended|hours)/i,
    category: "market_hours",
    description: "Market order rejected during extended hours",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.005 : 0.995;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "day",
          limit_price: limitPrice.toFixed(2),
          extended_hours: true
        },
        explanation: `Converted market order to limit order at $${limitPrice.toFixed(2)} for extended hours trading`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /day.*(?:trading|closed)/i,
    category: "market_hours",
    description: "Day order attempted when market closed",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.005 : 0.995;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "gtc",
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Converted to GTC limit order at $${limitPrice.toFixed(2)} to execute when market opens`,
        confidence: "high"
      };
    }
  },
  // Price Validation Issues
  {
    pattern: /price.*(?:aggressive|outside|collar|range)/i,
    category: "price_validation",
    description: "Limit price too aggressive or outside allowed range",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.005 : 0.995;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: order.order.time_in_force,
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Adjusted limit price to $${limitPrice.toFixed(2)} (0.5% from market) to meet broker requirements`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /notional.*(?:below|minimum|threshold)/i,
    category: "price_validation",
    description: "Order value too small",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const minNotional = 5;
      const requiredQty = Math.ceil(minNotional / currentPrice);
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: requiredQty.toString(),
          type: order.order.type,
          time_in_force: order.order.time_in_force,
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Increased quantity to ${requiredQty} shares to meet minimum order value ($${minNotional})`,
        confidence: "medium"
      };
    }
  },
  // Insufficient Funds
  {
    pattern: /insufficient.*(?:buying|funds|balance|capital)/i,
    category: "insufficient_funds",
    description: "Not enough buying power",
    fix: async (order, reason) => {
      const account = await alpaca.getAccount();
      const buyingPower = parseFloat(account.buying_power);
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice || buyingPower <= 0) return null;
      const affordableQty = Math.floor(buyingPower * 0.95 / currentPrice);
      if (affordableQty < 1) {
        return null;
      }
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: affordableQty.toString(),
          type: order.order.type,
          time_in_force: order.order.time_in_force,
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Reduced quantity to ${affordableQty} shares to fit within buying power ($${buyingPower.toFixed(2)})`,
        confidence: "high"
      };
    }
  },
  // Position Limits
  {
    pattern: /(?:max|maximum).*positions/i,
    category: "position_limits",
    description: "Maximum position count exceeded",
    fix: async (order, reason) => {
      log.warn("OrderRetry", `Max positions limit - manual intervention required for ${order.order.symbol}`);
      return null;
    }
  },
  // Fractional Shares Issues
  {
    pattern: /fractional.*(?:not.*supported|shares)/i,
    category: "order_type",
    description: "Fractional shares not allowed",
    fix: async (order, reason) => {
      const qty = parseFloat(order.order.qty);
      const wholeShares = Math.floor(qty);
      if (wholeShares < 1) {
        return null;
      }
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: wholeShares.toString(),
          type: order.order.type,
          time_in_force: order.order.time_in_force,
          limit_price: order.order.limit_price || void 0,
          extended_hours: order.order.extended_hours
        },
        explanation: `Rounded down to ${wholeShares} whole shares (fractional not supported for this symbol)`,
        confidence: "high"
      };
    }
  },
  // Order Type Issues
  {
    pattern: /(?:gtc|time.*force).*(?:not.*supported|invalid)/i,
    category: "order_type",
    description: "Time-in-force not supported",
    fix: async (order, reason) => {
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: order.order.type,
          time_in_force: "day",
          // Safest default
          limit_price: order.order.limit_price || void 0,
          stop_price: order.order.stop_price || void 0
        },
        explanation: `Changed time-in-force to 'day' (most compatible option)`,
        confidence: "high"
      };
    }
  },
  {
    pattern: /market.*order.*(?:not.*allowed|invalid)/i,
    category: "order_type",
    description: "Market orders not allowed",
    fix: async (order, reason) => {
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.01 : 0.99;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: "limit",
          time_in_force: "day",
          limit_price: limitPrice.toFixed(2)
        },
        explanation: `Converted to limit order at $${limitPrice.toFixed(2)} (1% buffer from market)`,
        confidence: "high"
      };
    }
  },
  // Bracket Order Issues
  {
    pattern: /bracket.*(?:not.*supported|invalid)/i,
    category: "order_type",
    description: "Bracket orders not supported",
    fix: async (order, reason) => {
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: order.order.type,
          time_in_force: order.order.time_in_force,
          limit_price: order.order.limit_price || void 0,
          order_class: "simple"
          // Remove bracket
        },
        explanation: `Converted to simple order (bracket orders not supported for this symbol/session)`,
        confidence: "medium"
      };
    }
  },
  // Symbol Issues
  {
    pattern: /symbol.*(?:not.*found|invalid|unknown)/i,
    category: "symbol_invalid",
    description: "Symbol not found or invalid",
    fix: async (order, reason) => {
      log.error("OrderRetry", `Invalid symbol ${order.order.symbol} - cannot retry`);
      return null;
    }
  },
  // Regulatory/Account Issues
  {
    pattern: /pattern.*day.*trad(?:er|ing)/i,
    category: "regulatory",
    description: "Pattern day trader restriction",
    fix: async (order, reason) => {
      log.warn("OrderRetry", `PDT restriction for ${order.order.symbol} - cannot retry`);
      return null;
    }
  },
  {
    pattern: /account.*(?:blocked|suspended|restricted)/i,
    category: "regulatory",
    description: "Account restricted",
    fix: async (order, reason) => {
      log.error("OrderRetry", `Account restricted - cannot retry orders`);
      return null;
    }
  },
  // Short Sale Issues
  {
    pattern: /short.*(?:not.*available|restricted|locate)/i,
    category: "position_limits",
    description: "Short selling not available",
    fix: async (order, reason) => {
      if (order.order.side === "sell") {
        log.warn("OrderRetry", `Short selling restricted for ${order.order.symbol} - cannot retry`);
        return null;
      }
      return null;
    }
  },
  // Wash Trade Prevention
  {
    pattern: /wash.*trade/i,
    category: "regulatory",
    description: "Potential wash trade detected",
    fix: async (order, reason) => {
      log.warn("OrderRetry", `Wash trade rule for ${order.order.symbol} - delaying retry`);
      await new Promise((resolve2) => setTimeout(resolve2, 3e4));
      return {
        params: {
          symbol: order.order.symbol,
          side: order.order.side,
          qty: order.order.qty,
          type: order.order.type,
          time_in_force: order.order.time_in_force,
          limit_price: order.order.limit_price || void 0
        },
        explanation: `Delayed retry by 30 seconds to avoid wash trade rule`,
        confidence: "low"
      };
    }
  },
  // Order Canceled (generic - often due to market session issues)
  {
    pattern: /order.*cancel/i,
    category: "market_hours",
    description: "Order canceled by broker (usually session-related)",
    fix: async (order, reason) => {
      const { tradingSessionManager: tradingSessionManager2 } = await Promise.resolve().then(() => (init_trading_session_manager(), trading_session_manager_exports));
      const sessionInfo = tradingSessionManager2.getCurrentSession("US_EQUITIES");
      const isRegularHours = sessionInfo.session === "regular" && sessionInfo.isOpen;
      const isExtendedHours = sessionInfo.session === "pre_market" || sessionInfo.session === "after_hours";
      if (isRegularHours) {
        if (order.order.qty) {
          return {
            params: {
              symbol: order.order.symbol,
              side: order.order.side,
              qty: order.order.qty,
              type: "market",
              time_in_force: "day"
            },
            explanation: `Retrying as MARKET order during regular hours (qty=${order.order.qty})`,
            confidence: "high"
          };
        }
        if (order.order.notional) {
          return {
            params: {
              symbol: order.order.symbol,
              side: order.order.side,
              notional: order.order.notional,
              type: "market",
              time_in_force: "day"
            },
            explanation: `Retrying as MARKET order during regular hours (notional=${order.order.notional})`,
            confidence: "high"
          };
        }
      }
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (!currentPrice) return null;
      const buffer = order.order.side === "buy" ? 1.01 : 0.99;
      const limitPrice = Math.round(currentPrice * buffer * 100) / 100;
      if (order.order.qty) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: order.order.qty,
            type: "limit",
            time_in_force: "day",
            limit_price: limitPrice.toFixed(2),
            extended_hours: isExtendedHours
          },
          explanation: `Converted to limit order at $${limitPrice.toFixed(2)} (extended_hours=${isExtendedHours}, qty=${order.order.qty})`,
          confidence: "medium"
        };
      }
      if (order.order.notional) {
        const estimatedQty = Math.floor(parseFloat(order.order.notional) / currentPrice);
        if (estimatedQty < 1) {
          log.warn("OrderRetry", `Notional ${order.order.notional} too small for whole shares at $${currentPrice}`);
          return null;
        }
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: estimatedQty.toString(),
            type: "limit",
            time_in_force: "day",
            limit_price: limitPrice.toFixed(2),
            extended_hours: isExtendedHours
          },
          explanation: `Converted notional=${order.order.notional} to qty=${estimatedQty} limit order at $${limitPrice.toFixed(2)} (extended_hours=${isExtendedHours})`,
          confidence: "medium"
        };
      }
      log.warn("OrderRetry", `Order ${order.order.symbol} has no qty or notional - cannot retry`);
      return null;
    }
  },
  // Missing qty or notional (validation error)
  {
    pattern: /qty.*(?:or|and).*notional.*required/i,
    category: "order_type",
    description: "Order missing qty or notional parameter",
    fix: async (order, reason) => {
      if (order.order.qty) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: order.order.qty,
            type: order.order.type || "limit",
            time_in_force: order.order.time_in_force || "day",
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Retried with explicit qty=${order.order.qty}`,
          confidence: "high"
        };
      }
      if (order.order.notional) {
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            notional: order.order.notional,
            type: order.order.type || "limit",
            time_in_force: order.order.time_in_force || "day",
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Retried with explicit notional=${order.order.notional}`,
          confidence: "high"
        };
      }
      if (order.order.side === "sell") {
        try {
          const positions2 = await alpaca.getPositions();
          const position = positions2.find((p) => p.symbol === order.order.symbol);
          if (position) {
            const availableQty = Math.floor(parseFloat(position.qty_available || position.qty || "0"));
            if (availableQty >= 1) {
              return {
                params: {
                  symbol: order.order.symbol,
                  side: "sell",
                  qty: availableQty.toString(),
                  type: order.order.type || "limit",
                  time_in_force: order.order.time_in_force || "day",
                  limit_price: order.order.limit_price || void 0,
                  extended_hours: order.order.extended_hours
                },
                explanation: `Sell order: Using available position qty=${availableQty}`,
                confidence: "medium"
              };
            }
          }
        } catch (e) {
          log.warn("OrderRetry", `Failed to get position for ${order.order.symbol}`);
        }
      }
      const currentPrice = await getCurrentPrice(order.order.symbol);
      if (currentPrice) {
        const minNotional = 10;
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            notional: minNotional.toString(),
            type: order.order.type || "limit",
            time_in_force: order.order.time_in_force || "day",
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Using minimum notional=$${minNotional} as fallback`,
          confidence: "low"
        };
      }
      return null;
    }
  },
  // Insufficient Quantity Available (position mismatch)
  {
    pattern: /insufficient.*qty.*available/i,
    category: "position_limits",
    description: "Requested quantity exceeds available shares",
    fix: async (order, reason) => {
      try {
        const positions2 = await alpaca.getPositions();
        const position = positions2.find((p) => p.symbol === order.order.symbol);
        if (!position) {
          log.warn("OrderRetry", `No position found for ${order.order.symbol} - cannot retry sell`);
          return null;
        }
        const availableQty = parseFloat(position.qty_available || position.qty || "0");
        const wholeQty = Math.floor(availableQty);
        if (wholeQty < 1) {
          log.warn("OrderRetry", `No whole shares available for ${order.order.symbol} (${availableQty} available)`);
          return null;
        }
        return {
          params: {
            symbol: order.order.symbol,
            side: order.order.side,
            qty: wholeQty.toString(),
            type: order.order.type,
            time_in_force: order.order.time_in_force,
            limit_price: order.order.limit_price || void 0,
            extended_hours: order.order.extended_hours
          },
          explanation: `Reduced quantity to ${wholeQty} shares (actual available from position)`,
          confidence: "high"
        };
      } catch (error) {
        log.error("OrderRetry", `Failed to get position for ${order.order.symbol}`, { error });
        return null;
      }
    }
  }
];
async function getCurrentPrice(symbol) {
  try {
    const snapshot = await alpaca.getSnapshots([symbol]);
    const data = snapshot[symbol];
    if (!data) return null;
    return data.latestTrade?.p || data.latestQuote?.ap || data.dailyBar?.c || null;
  } catch (error) {
    log.error("OrderRetry", `Failed to get price for ${symbol}`, { error });
    return null;
  }
}
function extractRejectionReason(update) {
  if (update.order.status === "rejected" || update.order.failed_at) {
    const reasons = [];
    if (update.order.extended_hours && update.order.type === "market") {
      reasons.push("market orders not allowed during extended hours");
    }
    if (update.order.order_class === "bracket" && update.order.extended_hours) {
      reasons.push("bracket orders not supported during extended hours");
    }
    if (reasons.length === 0) {
      reasons.push("order rejected by broker");
    }
    return reasons.join("; ");
  }
  if (update.order.status === "canceled" || update.order.canceled_at) {
    return "order canceled";
  }
  return "unknown rejection reason";
}
function findHandler(reason) {
  for (const handler of rejectionHandlers) {
    if (handler.pattern.test(reason)) {
      return handler;
    }
  }
  return null;
}
function checkCircuitBreaker() {
  const now = Date.now();
  if (circuitBreaker.resetTime && now >= circuitBreaker.resetTime.getTime()) {
    circuitBreaker.failures = 0;
    circuitBreaker.isOpen = false;
    circuitBreaker.resetTime = null;
    circuitBreaker.lastFailureTime = null;
    log.info("OrderRetry", "Circuit breaker reset");
  }
  if (circuitBreaker.lastFailureTime) {
    const timeSinceLastFailure = now - circuitBreaker.lastFailureTime.getTime();
    if (timeSinceLastFailure > CIRCUIT_BREAKER_WINDOW_MS) {
      circuitBreaker.failures = 0;
    }
  }
  return circuitBreaker.isOpen;
}
function recordFailure() {
  circuitBreaker.failures++;
  circuitBreaker.lastFailureTime = /* @__PURE__ */ new Date();
  if (circuitBreaker.failures >= CIRCUIT_BREAKER_THRESHOLD) {
    circuitBreaker.isOpen = true;
    circuitBreaker.resetTime = new Date(Date.now() + CIRCUIT_BREAKER_RESET_MS);
    log.error("OrderRetry", `Circuit breaker OPENED after ${circuitBreaker.failures} failures. Will reset at ${circuitBreaker.resetTime.toISOString()}`);
  }
}
function calculateBackoff(attemptNumber) {
  return RETRY_BACKOFF_BASE_MS * Math.pow(2, attemptNumber - 1);
}
async function handleOrderRejection(update, reason) {
  const orderId = update.order.id;
  const symbol = update.order.symbol;
  const rejectionReason = reason || extractRejectionReason(update);
  log.warn("OrderRetry", `Order ${orderId} for ${symbol} ${update.order.status}`, {
    reason: rejectionReason,
    orderType: update.order.type,
    timeInForce: update.order.time_in_force
  });
  if (!retryTracker.has(orderId)) {
    retryTracker.set(orderId, []);
  }
  const attempts = retryTracker.get(orderId);
  if (attempts.length >= MAX_RETRIES_PER_ORDER) {
    log.error("OrderRetry", `Max retries (${MAX_RETRIES_PER_ORDER}) exceeded for order ${orderId}`);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "max_retries_exceeded",
      error: `Exceeded maximum retry attempts (${MAX_RETRIES_PER_ORDER})`
    };
  }
  if (checkCircuitBreaker()) {
    log.error("OrderRetry", `Circuit breaker is OPEN - rejecting retry for ${orderId}`);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "permanent_failure",
      error: "Circuit breaker is open - too many failures recently"
    };
  }
  const handler = findHandler(rejectionReason);
  if (!handler) {
    log.warn("OrderRetry", `No handler found for rejection reason: ${rejectionReason}`);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "no_fix_available",
      error: `No automated fix available for: ${rejectionReason}`
    };
  }
  log.info("OrderRetry", `Found handler: ${handler.description} (${handler.category})`);
  let fixedParams;
  try {
    fixedParams = await handler.fix(update, rejectionReason);
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log.error("OrderRetry", `Fix function failed for ${orderId}`, { error: errorMsg });
    recordFailure();
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: handler.description,
      success: false,
      error: `Fix function error: ${errorMsg}`
    };
    attempts.push(attempt);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "permanent_failure",
      error: errorMsg
    };
  }
  if (!fixedParams) {
    log.warn("OrderRetry", `Handler could not generate fix for ${orderId}`);
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "no_fix_available",
      error: `Handler could not generate fix: ${handler.description}`
    };
  }
  const backoffMs = calculateBackoff(attempts.length + 1);
  log.info("OrderRetry", `Waiting ${backoffMs}ms before retry (attempt ${attempts.length + 1}/${MAX_RETRIES_PER_ORDER})`);
  await new Promise((resolve2) => setTimeout(resolve2, backoffMs));
  const newClientOrderId = `retry-${orderId}-${attempts.length + 1}-${Date.now()}`;
  fixedParams.params.client_order_id = newClientOrderId;
  log.info("OrderRetry", `Retrying order ${orderId} with fix: ${fixedParams.explanation}`);
  try {
    const newOrder = await alpaca.createOrder(fixedParams.params);
    log.info("OrderRetry", `Retry successful! New order ${newOrder.id} created for ${symbol}`, {
      status: newOrder.status,
      fix: fixedParams.explanation
    });
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: fixedParams.explanation,
      success: true
    };
    attempts.push(attempt);
    await storage.upsertOrderByBrokerOrderId(newOrder.id, {
      broker: "alpaca",
      brokerOrderId: newOrder.id,
      clientOrderId: newClientOrderId,
      symbol: newOrder.symbol,
      side: newOrder.side,
      type: newOrder.type,
      timeInForce: newOrder.time_in_force,
      qty: newOrder.qty,
      notional: newOrder.notional,
      limitPrice: newOrder.limit_price,
      stopPrice: newOrder.stop_price,
      status: newOrder.status,
      submittedAt: new Date(newOrder.submitted_at || Date.now()),
      updatedAt: /* @__PURE__ */ new Date(),
      filledQty: newOrder.filled_qty,
      filledAvgPrice: newOrder.filled_avg_price,
      traceId: `retry-${orderId}`,
      rawJson: {
        ...newOrder,
        retryMetadata: {
          originalOrderId: orderId,
          attemptNumber: attempts.length,
          rejectionReason,
          fix: fixedParams.explanation
        }
      }
    });
    return {
      success: true,
      originalOrderId: orderId,
      newOrderId: newOrder.id,
      attempts,
      finalStatus: "retried_successfully"
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log.error("OrderRetry", `Retry failed for ${orderId}`, { error: errorMsg });
    recordFailure();
    const attempt = {
      attemptNumber: attempts.length + 1,
      timestamp: /* @__PURE__ */ new Date(),
      reason: rejectionReason,
      fix: fixedParams.explanation,
      success: false,
      error: errorMsg
    };
    attempts.push(attempt);
    if (attempts.length < MAX_RETRIES_PER_ORDER) {
      log.info("OrderRetry", `Retry failed, will attempt again (${attempts.length}/${MAX_RETRIES_PER_ORDER})`);
      return handleOrderRejection(update, errorMsg);
    }
    return {
      success: false,
      originalOrderId: orderId,
      attempts,
      finalStatus: "max_retries_exceeded",
      error: errorMsg
    };
  }
}
function hookIntoTradeUpdates(update) {
  const status = update.order.status;
  if (status === "rejected" || status === "canceled") {
    handleOrderRejection(update).catch((error) => {
      log.error("OrderRetry", "Unhandled error in rejection handler", { error });
    });
  }
}
log.info("OrderRetry", `Order Retry Handler initialized with ${rejectionHandlers.length} handlers`);

// server/trading/alpaca-stream.ts
var ALPACA_STREAM_URL2 = "wss://paper-api.alpaca.markets/stream";
function mapAlpacaStatusToOrderStatus(alpacaStatus) {
  const statusMap = {
    new: "new",
    accepted: "accepted",
    pending_new: "pending_new",
    accepted_for_bidding: "accepted",
    stopped: "stopped",
    rejected: "rejected",
    suspended: "suspended",
    calculated: "calculated",
    partially_filled: "partially_filled",
    filled: "filled",
    done_for_day: "done_for_day",
    canceled: "canceled",
    expired: "expired",
    replaced: "replaced",
    pending_cancel: "pending_cancel",
    pending_replace: "pending_replace"
  };
  return statusMap[alpacaStatus.toLowerCase()] || "new";
}
var AlpacaStreamManager = class {
  ws = null;
  reconnectAttempts = 0;
  maxReconnectAttempts = 10;
  reconnectDelay = 1e3;
  isConnecting = false;
  isAuthenticated = false;
  heartbeatInterval = null;
  lastPongTime = Date.now();
  getCredentials() {
    const apiKey = process.env.ALPACA_API_KEY;
    const secretKey = process.env.ALPACA_SECRET_KEY;
    if (!apiKey || !secretKey) return null;
    return { apiKey, secretKey };
  }
  async connect() {
    if (this.isConnecting || this.ws && this.ws.readyState === WebSocket.OPEN) {
      log.debug("AlpacaStream", "Already connected or connecting");
      return;
    }
    const credentials2 = this.getCredentials();
    if (!credentials2) {
      log.warn("AlpacaStream", "Alpaca credentials not configured, skipping stream connection");
      return;
    }
    this.isConnecting = true;
    log.info("AlpacaStream", "Connecting to Alpaca trade updates stream...");
    try {
      this.ws = new WebSocket(ALPACA_STREAM_URL2);
      this.ws.on("open", () => {
        log.info("AlpacaStream", "WebSocket connected, authenticating...");
        this.authenticate(credentials2);
      });
      this.ws.on("message", (data) => {
        this.handleMessage(data);
      });
      this.ws.on("close", (code, reason) => {
        log.warn("AlpacaStream", `WebSocket closed: ${code} - ${reason.toString()}`);
        this.isAuthenticated = false;
        this.isConnecting = false;
        this.stopHeartbeat();
        this.scheduleReconnect();
      });
      this.ws.on("error", (error) => {
        log.error("AlpacaStream", `WebSocket error: ${error.message}`);
        this.isConnecting = false;
      });
      this.ws.on("pong", () => {
        this.lastPongTime = Date.now();
      });
    } catch (error) {
      log.error("AlpacaStream", `Failed to connect: ${error}`);
      this.isConnecting = false;
      this.scheduleReconnect();
    }
  }
  authenticate(credentials2) {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    const authMessage = {
      action: "auth",
      key: credentials2.apiKey,
      secret: credentials2.secretKey
    };
    this.ws.send(JSON.stringify(authMessage));
  }
  subscribeToTradeUpdates() {
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;
    const subscribeMessage = {
      action: "listen",
      data: {
        streams: ["trade_updates"]
      }
    };
    this.ws.send(JSON.stringify(subscribeMessage));
    log.info("AlpacaStream", "Subscribed to trade_updates stream");
    this.startHeartbeat();
  }
  startHeartbeat() {
    this.stopHeartbeat();
    this.heartbeatInterval = setInterval(() => {
      if (this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.ws.ping();
        if (Date.now() - this.lastPongTime > 6e4) {
          log.warn("AlpacaStream", "No pong received in 60s, reconnecting...");
          this.ws.terminate();
        }
      }
    }, 3e4);
  }
  stopHeartbeat() {
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
  async handleMessage(data) {
    try {
      const message = JSON.parse(data.toString());
      if (message.stream === "authorization") {
        if (message.data?.status === "authorized") {
          log.info("AlpacaStream", "Authentication successful");
          this.isAuthenticated = true;
          this.isConnecting = false;
          this.reconnectAttempts = 0;
          this.subscribeToTradeUpdates();
        } else {
          log.error("AlpacaStream", `Authentication failed: ${JSON.stringify(message.data)}`);
          this.isConnecting = false;
        }
        return;
      }
      if (message.stream === "listening") {
        log.info("AlpacaStream", `Now listening to: ${message.data?.streams?.join(", ")}`);
        return;
      }
      if (message.stream === "trade_updates") {
        await this.handleTradeUpdate(message.data);
      }
    } catch (error) {
      log.error("AlpacaStream", `Failed to parse message: ${error}`);
    }
  }
  async handleTradeUpdate(update) {
    const { event, order, timestamp: timestamp3, price, qty, execution_id } = update;
    const brokerOrderId = order.id;
    log.info("AlpacaStream", `Trade update: ${event} for order ${brokerOrderId} (${order.symbol})`);
    try {
      const existingOrder = await storage.getOrderByBrokerOrderId(brokerOrderId);
      const traceId = existingOrder?.traceId || `stream-${Date.now()}`;
      let userId = existingOrder?.userId;
      if (!userId) {
        const adminUser = await storage.getAdminUser();
        userId = adminUser?.id;
        if (!userId) {
          log.error("AlpacaStream", `No userId available for order ${brokerOrderId}, skipping update`);
          return;
        }
      }
      const newStatus = mapAlpacaStatusToOrderStatus(order.status);
      await storage.upsertOrderByBrokerOrderId(brokerOrderId, {
        userId,
        broker: "alpaca",
        brokerOrderId,
        clientOrderId: order.client_order_id,
        symbol: order.symbol,
        side: order.side,
        type: order.type,
        timeInForce: order.time_in_force,
        qty: order.qty,
        notional: order.notional,
        limitPrice: order.limit_price,
        stopPrice: order.stop_price,
        status: newStatus,
        submittedAt: order.submitted_at ? new Date(order.submitted_at) : /* @__PURE__ */ new Date(),
        updatedAt: new Date(order.updated_at),
        filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
        filledQty: order.filled_qty,
        filledAvgPrice: order.filled_avg_price,
        traceId,
        rawJson: order
      });
      if ((event === "fill" || event === "partial_fill") && price && qty) {
        const fillId = execution_id || `${brokerOrderId}-${qty}-${price}-${Math.floor(new Date(timestamp3).getTime() / 1e3)}`;
        try {
          await storage.createFill({
            broker: "alpaca",
            brokerOrderId,
            brokerFillId: fillId,
            orderId: existingOrder?.id,
            symbol: order.symbol,
            side: order.side,
            qty,
            price,
            occurredAt: new Date(timestamp3),
            traceId,
            rawJson: update
          });
          log.info("AlpacaStream", `Created fill record: ${fillId} for ${qty} @ ${price}`);
          if (event === "fill" && existingOrder?.id) {
            try {
              let pnl = null;
              const positions2 = await storage.getPositions(userId);
              const position = positions2.find((p) => p.symbol === order.symbol);
              if (position && order.side !== position.side) {
                const entryPrice = parseFloat(position.entryPrice);
                const exitPrice = parseFloat(price);
                const quantity = parseFloat(qty);
                if (order.side === "sell") {
                  pnl = ((exitPrice - entryPrice) * quantity).toFixed(2);
                } else {
                  pnl = ((entryPrice - exitPrice) * quantity).toFixed(2);
                }
              }
              await storage.createTrade({
                userId,
                orderId: existingOrder.id,
                symbol: order.symbol,
                side: order.side,
                quantity: qty,
                price,
                pnl,
                status: "completed",
                traceId,
                notes: `Auto-created from fill ${fillId}`
              });
              log.info("AlpacaStream", `Auto-created trade record for filled order ${brokerOrderId}, symbol: ${order.symbol}, qty: ${qty}, price: ${price}${pnl ? `, pnl: ${pnl}` : ""}`);
            } catch (tradeError) {
              log.error("AlpacaStream", `Failed to auto-create trade record: ${tradeError.message}`);
            }
          }
        } catch (fillError) {
          if (fillError.message?.includes("duplicate") || fillError.code === "23505") {
            log.debug("AlpacaStream", `Fill already exists: ${fillId}`);
          } else {
            throw fillError;
          }
        }
      }
      log.debug("AlpacaStream", `Order ${brokerOrderId} updated to status: ${newStatus}`);
      try {
        const { emitOrderUpdate: emitOrderUpdate2, emitOrderFill: emitOrderFill2 } = (init_sse_emitter(), __toCommonJS(sse_emitter_exports));
        emitOrderUpdate2(brokerOrderId, {
          status: newStatus,
          symbol: order.symbol,
          side: order.side,
          qty: order.qty,
          filledQty: order.filled_qty,
          filledAvgPrice: order.filled_avg_price,
          type: order.type,
          timeInForce: order.time_in_force
        });
        if (event === "fill" || event === "partial_fill") {
          emitOrderFill2(brokerOrderId, {
            symbol: order.symbol,
            side: order.side,
            qty,
            price,
            filledQty: order.filled_qty,
            filledAvgPrice: order.filled_avg_price,
            partial: event === "partial_fill"
          });
        }
      } catch (sseError) {
        log.error("AlpacaStream", `Failed to emit SSE event: ${sseError}`);
      }
      if (newStatus === "rejected" || newStatus === "canceled") {
        hookIntoTradeUpdates(update);
      }
    } catch (error) {
      log.error("AlpacaStream", `Failed to process trade update: ${error}`);
    }
  }
  scheduleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      log.error("AlpacaStream", "Max reconnection attempts reached, giving up");
      return;
    }
    const delay = Math.min(this.reconnectDelay * Math.pow(2, this.reconnectAttempts), 6e4);
    this.reconnectAttempts++;
    log.info("AlpacaStream", `Scheduling reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    setTimeout(() => {
      this.connect();
    }, delay);
  }
  disconnect() {
    this.stopHeartbeat();
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
    this.isAuthenticated = false;
    this.isConnecting = false;
    log.info("AlpacaStream", "Disconnected from Alpaca stream");
  }
  isConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN && this.isAuthenticated;
  }
  getStatus() {
    return {
      connected: this.ws?.readyState === WebSocket.OPEN,
      authenticated: this.isAuthenticated,
      reconnectAttempts: this.reconnectAttempts
    };
  }
};
var alpacaStream = new AlpacaStreamManager();

// server/routes.ts
init_trading_session_manager();

// server/trading/order-execution-flow.ts
init_alpaca();
init_storage();
init_numeric();
init_performance_metrics();
init_order_execution_cache();
import { randomUUID as randomUUID2 } from "crypto";

// server/lib/webhook-emitter.ts
import pLimit2 from "p-limit";
var webhooks = /* @__PURE__ */ new Map();
var deliveryHistory = [];
var MAX_HISTORY = 100;
var limit2 = pLimit2(5);
function registerWebhook(config) {
  webhooks.set(config.id, config);
  console.log(`[Webhook] Registered: ${config.name} (${config.id}) -> ${config.url}`);
}
function unregisterWebhook(id) {
  const result = webhooks.delete(id);
  if (result) {
    console.log(`[Webhook] Unregistered: ${id}`);
  }
  return result;
}
function getWebhooks() {
  return Array.from(webhooks.values());
}
function getWebhook(id) {
  return webhooks.get(id);
}
function updateWebhook(id, updates) {
  const existing = webhooks.get(id);
  if (!existing) return void 0;
  const updated = { ...existing, ...updates };
  webhooks.set(id, updated);
  return updated;
}
async function deliverWebhook(webhook, event) {
  const startTime = Date.now();
  const attempt = {
    webhookId: webhook.id,
    eventId: event.id,
    eventType: event.type,
    status: "pending",
    timestamp: /* @__PURE__ */ new Date(),
    durationMs: 0
  };
  try {
    const headers = {
      "Content-Type": "application/json",
      "X-Webhook-Event": event.type,
      "X-Webhook-Id": event.id,
      "X-Webhook-Timestamp": event.timestamp,
      ...webhook.headers
    };
    if (webhook.secret) {
      const crypto4 = await import("crypto");
      const signature = crypto4.createHmac("sha256", webhook.secret).update(JSON.stringify(event)).digest("hex");
      headers["X-Webhook-Signature"] = `sha256=${signature}`;
    }
    const response = await fetch(webhook.url, {
      method: "POST",
      headers,
      body: JSON.stringify(event),
      signal: AbortSignal.timeout(1e4)
    });
    attempt.durationMs = Date.now() - startTime;
    attempt.statusCode = response.status;
    if (response.ok) {
      attempt.status = "success";
    } else {
      attempt.status = "failed";
      attempt.error = `HTTP ${response.status}: ${response.statusText}`;
    }
  } catch (error) {
    attempt.durationMs = Date.now() - startTime;
    attempt.status = "failed";
    attempt.error = error instanceof Error ? error.message : "Unknown error";
  }
  deliveryHistory.push(attempt);
  if (deliveryHistory.length > MAX_HISTORY) {
    deliveryHistory.shift();
  }
  return attempt;
}
async function emitEvent(type, payload) {
  const event = {
    id: `evt_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
    type,
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    source: "ai-active-trader",
    payload
  };
  const matchingWebhooks = Array.from(webhooks.values()).filter(
    (w) => w.enabled && (w.eventTypes.includes(type) || w.eventTypes.includes("*"))
  );
  if (matchingWebhooks.length === 0) {
    return [];
  }
  console.log(`[Webhook] Emitting ${type} to ${matchingWebhooks.length} webhooks`);
  const results = await Promise.all(
    matchingWebhooks.map((webhook) => limit2(() => deliverWebhook(webhook, event)))
  );
  const successes = results.filter((r) => r.status === "success").length;
  const failures = results.filter((r) => r.status === "failed").length;
  if (failures > 0) {
    console.warn(`[Webhook] ${type}: ${successes} success, ${failures} failed`);
  }
  return results;
}
function getDeliveryHistory(limit4) {
  const count3 = limit4 || MAX_HISTORY;
  return deliveryHistory.slice(-count3);
}
function getWebhookStats() {
  const recent = deliveryHistory.slice(-50);
  const successes = recent.filter((d) => d.status === "success").length;
  return {
    totalWebhooks: webhooks.size,
    enabledWebhooks: Array.from(webhooks.values()).filter((w) => w.enabled).length,
    recentDeliveries: recent.length,
    successRate: recent.length > 0 ? successes / recent.length : 1
  };
}
var SUPPORTED_EVENTS = [
  "trade.order.submitted",
  "trade.order.filled",
  "trade.order.canceled",
  "trade.order.rejected",
  "trade.position.opened",
  "trade.position.closed",
  "trade.position.updated",
  "ai.decision.generated",
  "ai.decision.executed",
  "market.data.update",
  "market.news.alert",
  "analytics.pnl.daily",
  "analytics.metrics.update",
  "system.error",
  "system.health.changed"
];

// server/trading/order-execution-flow.ts
init_notification_service();
init_tradability_service();

// server/trading/order-types-matrix.ts
import { z as z3 } from "zod";
var OrderTypeEnum = z3.enum([
  "market",
  "limit",
  "stop",
  "stop_limit",
  "trailing_stop"
]);
var OrderClassEnum = z3.enum([
  "simple",
  "bracket",
  "oco",
  "oto"
]);
var TimeInForceEnum = z3.enum([
  "day",
  "gtc",
  "opg",
  "cls",
  "ioc",
  "fok"
]);
var OrderSideEnum = z3.enum(["buy", "sell"]);
var ORDER_TYPE_MATRIX = [
  {
    orderType: "market",
    validTimeInForce: ["day", "opg", "cls", "ioc", "fok"],
    supportsExtendedHours: false,
    requiredFields: ["symbol", "side", "qty|notional"],
    optionalFields: ["client_order_id"],
    description: "Execute immediately at best available price"
  },
  {
    orderType: "limit",
    validTimeInForce: ["day", "gtc", "opg", "cls", "ioc", "fok"],
    supportsExtendedHours: true,
    requiredFields: ["symbol", "side", "qty|notional", "limit_price"],
    optionalFields: ["client_order_id", "extended_hours"],
    description: "Execute at specified price or better"
  },
  {
    orderType: "stop",
    validTimeInForce: ["day", "gtc"],
    supportsExtendedHours: false,
    requiredFields: ["symbol", "side", "qty", "stop_price"],
    optionalFields: ["client_order_id"],
    description: "Trigger market order when stop price is reached"
  },
  {
    orderType: "stop_limit",
    validTimeInForce: ["day", "gtc"],
    supportsExtendedHours: true,
    requiredFields: ["symbol", "side", "qty", "stop_price", "limit_price"],
    optionalFields: ["client_order_id", "extended_hours"],
    description: "Trigger limit order when stop price is reached"
  },
  {
    orderType: "trailing_stop",
    validTimeInForce: ["day", "gtc"],
    supportsExtendedHours: false,
    requiredFields: ["symbol", "side", "qty", "trail_percent|trail_price"],
    optionalFields: ["client_order_id"],
    description: "Dynamic stop that follows price movement"
  }
];
var BaseOrderSchema = z3.object({
  symbol: z3.string().min(1).max(10).toUpperCase(),
  side: OrderSideEnum,
  client_order_id: z3.string().uuid().optional()
});
var QuantitySchema = z3.union([
  z3.object({ qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number") }),
  z3.object({ notional: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive dollar amount") })
]);
var MarketOrderSchema = BaseOrderSchema.extend({
  type: z3.literal("market"),
  time_in_force: z3.enum(["day", "opg", "cls", "ioc", "fok"]),
  extended_hours: z3.literal(false).optional()
}).and(QuantitySchema);
var LimitOrderSchema = BaseOrderSchema.extend({
  type: z3.literal("limit"),
  time_in_force: TimeInForceEnum,
  limit_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
  extended_hours: z3.boolean().optional()
}).and(QuantitySchema);
var StopOrderSchema = BaseOrderSchema.extend({
  type: z3.literal("stop"),
  time_in_force: z3.enum(["day", "gtc"]),
  stop_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  extended_hours: z3.literal(false).optional()
});
var StopLimitOrderSchema = BaseOrderSchema.extend({
  type: z3.literal("stop_limit"),
  time_in_force: z3.enum(["day", "gtc"]),
  stop_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
  limit_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  extended_hours: z3.boolean().optional()
});
var TrailingStopOrderSchema = BaseOrderSchema.extend({
  type: z3.literal("trailing_stop"),
  time_in_force: z3.enum(["day", "gtc"]),
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  extended_hours: z3.literal(false).optional()
}).and(
  z3.union([
    z3.object({ trail_percent: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive percent") }),
    z3.object({ trail_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive dollar amount") })
  ])
);
var BracketOrderSchema = BaseOrderSchema.extend({
  order_class: z3.literal("bracket"),
  type: z3.enum(["market", "limit"]),
  time_in_force: z3.literal("day"),
  // FIXED: Must be "day" only - "gtc" causes 422 rejection
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  limit_price: z3.string().regex(/^\d+(\.\d+)?$/).optional(),
  take_profit: z3.object({
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
  }),
  stop_loss: z3.object({
    stop_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/).optional()
  })
});
var OCOOrderSchema = BaseOrderSchema.extend({
  order_class: z3.literal("oco"),
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  time_in_force: z3.enum(["day", "gtc"]),
  take_profit: z3.object({
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
  }),
  stop_loss: z3.object({
    stop_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/).optional()
  })
});
var OTOOrderSchema = BaseOrderSchema.extend({
  order_class: z3.literal("oto"),
  type: z3.enum(["market", "limit"]),
  time_in_force: z3.enum(["day", "gtc"]),
  qty: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive number"),
  limit_price: z3.string().regex(/^\d+(\.\d+)?$/).optional(),
  stop_loss: z3.object({
    stop_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price"),
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/).optional()
  }).optional(),
  take_profit: z3.object({
    limit_price: z3.string().regex(/^\d+(\.\d+)?$/, "Must be a positive price")
  }).optional()
});
var SimpleOrderSchema = z3.union([
  MarketOrderSchema,
  LimitOrderSchema,
  StopOrderSchema,
  StopLimitOrderSchema,
  TrailingStopOrderSchema
]);
var ComplexOrderSchema = z3.union([
  BracketOrderSchema,
  OCOOrderSchema,
  OTOOrderSchema
]);
var CreateOrderSchema = z3.union([
  SimpleOrderSchema,
  ComplexOrderSchema
]);
var OrderStatusEnum = z3.enum([
  "new",
  // Order has been received but not yet accepted
  "pending_new",
  // Order is being processed
  "accepted",
  // Order is accepted and live in the market
  "partially_filled",
  // Order has been partially filled
  "filled",
  // Order has been completely filled
  "done_for_day",
  // Order is done for the day
  "canceled",
  // Order has been canceled
  "expired",
  // Order has expired
  "replaced",
  // Order has been replaced
  "pending_cancel",
  // Order cancel request is pending
  "pending_replace",
  // Order replace request is pending
  "stopped",
  // Order has been stopped
  "rejected",
  // Order has been rejected
  "suspended",
  // Order has been suspended
  "calculated"
  // Order is being calculated
]);
var TERMINAL_STATUSES = [
  "filled",
  "canceled",
  "expired",
  "replaced",
  "rejected"
];
var ACTIVE_STATUSES = [
  "new",
  "pending_new",
  "accepted",
  "partially_filled",
  "pending_cancel",
  "pending_replace"
];
var FAILED_STATUSES = [
  "canceled",
  "expired",
  "rejected"
];
function validateOrderTypeCombination(orderType, timeInForce, extendedHours = false) {
  const result = { valid: true, errors: [], warnings: [] };
  const typeConfig = ORDER_TYPE_MATRIX.find((t) => t.orderType === orderType);
  if (!typeConfig) {
    result.valid = false;
    result.errors.push(`Invalid order type: ${orderType}`);
    return result;
  }
  if (!typeConfig.validTimeInForce.includes(timeInForce)) {
    result.valid = false;
    result.errors.push(
      `Invalid time_in_force '${timeInForce}' for ${orderType} order. Valid options: ${typeConfig.validTimeInForce.join(", ")}`
    );
  }
  if (extendedHours && !typeConfig.supportsExtendedHours) {
    result.valid = false;
    result.errors.push(
      `Extended hours trading not supported for ${orderType} orders. Use limit or stop_limit orders for extended hours.`
    );
  }
  return result;
}
function validateStopPrice(side, currentPrice, stopPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy" && stopPrice <= currentPrice) {
    result.warnings.push(
      `Buy stop at $${stopPrice} is below current price $${currentPrice}. This order will trigger immediately as a market order.`
    );
  }
  if (side === "sell" && stopPrice >= currentPrice) {
    result.warnings.push(
      `Sell stop at $${stopPrice} is above current price $${currentPrice}. This order will trigger immediately as a market order.`
    );
  }
  return result;
}
function validateLimitPrice(side, currentPrice, limitPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy" && limitPrice > currentPrice * 1.1) {
    result.warnings.push(
      `Buy limit at $${limitPrice} is significantly above current price $${currentPrice}. This order will likely fill immediately at a worse price.`
    );
  }
  if (side === "sell" && limitPrice < currentPrice * 0.9) {
    result.warnings.push(
      `Sell limit at $${limitPrice} is significantly below current price $${currentPrice}. This order will likely fill immediately at a worse price.`
    );
  }
  return result;
}
function validateBracketOrder(side, entryPrice, takeProfitPrice, stopLossPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (side === "buy") {
    if (takeProfitPrice <= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Take profit price ($${takeProfitPrice}) must be above entry price ($${entryPrice}) for buy orders`
      );
    }
    if (stopLossPrice >= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Stop loss price ($${stopLossPrice}) must be below entry price ($${entryPrice}) for buy orders`
      );
    }
  } else {
    if (takeProfitPrice >= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Take profit price ($${takeProfitPrice}) must be below entry price ($${entryPrice}) for sell orders`
      );
    }
    if (stopLossPrice <= entryPrice) {
      result.valid = false;
      result.errors.push(
        `Stop loss price ($${stopLossPrice}) must be above entry price ($${entryPrice}) for sell orders`
      );
    }
  }
  return result;
}
function validateTrailingStop(trailPercent, trailPrice) {
  const result = { valid: true, errors: [], warnings: [] };
  if (trailPercent !== void 0 && trailPrice !== void 0) {
    result.valid = false;
    result.errors.push("Cannot specify both trail_percent and trail_price. Choose one.");
  }
  if (trailPercent === void 0 && trailPrice === void 0) {
    result.valid = false;
    result.errors.push("Must specify either trail_percent or trail_price for trailing stop orders.");
  }
  if (trailPercent !== void 0) {
    if (trailPercent <= 0 || trailPercent > 100) {
      result.valid = false;
      result.errors.push(`Trail percent must be between 0 and 100, got ${trailPercent}`);
    }
    if (trailPercent < 0.5) {
      result.warnings.push("Trail percent below 0.5% may trigger too frequently");
    }
    if (trailPercent > 10) {
      result.warnings.push("Trail percent above 10% may not provide adequate protection");
    }
  }
  if (trailPrice !== void 0 && trailPrice <= 0) {
    result.valid = false;
    result.errors.push(`Trail price must be positive, got ${trailPrice}`);
  }
  return result;
}

// server/trading/order-execution-flow.ts
init_trading_config();
function classifyError(error, context) {
  const message = error.message.toLowerCase();
  if (message.includes("insufficient") || message.includes("buying power")) {
    return {
      type: "INSUFFICIENT_FUNDS" /* INSUFFICIENT_FUNDS */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */
    };
  }
  if (message.includes("symbol") && (message.includes("not found") || message.includes("invalid"))) {
    return {
      type: "INVALID_SYMBOL" /* INVALID_SYMBOL */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "MANUAL_INTERVENTION" /* MANUAL_INTERVENTION */
    };
  }
  if (message.includes("market") && (message.includes("closed") || message.includes("not open"))) {
    return {
      type: "MARKET_CLOSED" /* MARKET_CLOSED */,
      message: error.message,
      retryable: true,
      suggestedDelay: 6e4,
      recoveryStrategy: "WAIT_FOR_MARKET_OPEN" /* WAIT_FOR_MARKET_OPEN */
    };
  }
  if (message.includes("429") || message.includes("rate limit")) {
    return {
      type: "RATE_LIMITED" /* RATE_LIMITED */,
      message: error.message,
      retryable: true,
      suggestedDelay: 5e3,
      recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */
    };
  }
  if (message.includes("network") || message.includes("fetch") || message.includes("econnrefused")) {
    return {
      type: "NETWORK_ERROR" /* NETWORK_ERROR */,
      message: error.message,
      retryable: true,
      suggestedDelay: 2e3,
      recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */
    };
  }
  if (message.includes("timeout")) {
    return {
      type: "TIMEOUT" /* TIMEOUT */,
      message: error.message,
      retryable: true,
      suggestedDelay: 1e3,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  if (message.includes("rejected") || message.includes("refused")) {
    return {
      type: "BROKER_REJECTION" /* BROKER_REJECTION */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */
    };
  }
  if (message.includes("position") && message.includes("not found")) {
    return {
      type: "POSITION_NOT_FOUND" /* POSITION_NOT_FOUND */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  if (message.includes("order") && message.includes("not found")) {
    return {
      type: "ORDER_NOT_FOUND" /* ORDER_NOT_FOUND */,
      message: error.message,
      retryable: false,
      suggestedDelay: 0,
      recoveryStrategy: "CHECK_AND_SYNC" /* CHECK_AND_SYNC */
    };
  }
  return {
    type: "UNKNOWN" /* UNKNOWN */,
    message: error.message,
    retryable: true,
    suggestedDelay: 3e3,
    recoveryStrategy: "RETRY_WITH_BACKOFF" /* RETRY_WITH_BACKOFF */,
    originalError: error
  };
}
var DEFAULT_OPTIONS = {
  maxRetries: 3,
  retryDelayMs: 1e3,
  timeoutMs: 3e4,
  validateBeforeSubmit: true,
  trackExpectedOutcome: true,
  autoRecover: true
};
var OrderExecutionEngine = class {
  activeExecutions = /* @__PURE__ */ new Map();
  /**
   * Execute order with full validation, retry, and recovery
   */
  async executeOrder(params, options = {}) {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const clientOrderId = params.client_order_id || randomUUID2();
    const state = {
      orderId: null,
      clientOrderId,
      status: "pending",
      symbol: params.symbol,
      side: params.side,
      orderType: params.type,
      requestedQty: params.qty || params.notional || "0",
      filledQty: "0",
      requestedPrice: params.limit_price || params.stop_price || null,
      filledPrice: null,
      attempts: 0,
      maxAttempts: opts.maxRetries,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      errors: [],
      validationResult: null,
      expectedOutcome: null,
      actualOutcome: null
    };
    this.activeExecutions.set(clientOrderId, state);
    const warnings = [];
    try {
      state.status = "validating";
      state.updatedAt = /* @__PURE__ */ new Date();
      if (opts.validateBeforeSubmit) {
        const validation = await this.validateOrderParams(params);
        state.validationResult = validation;
        if (!validation.valid) {
          const error = classifyError(new Error(validation.errors.join("; ")));
          error.type = "VALIDATION_ERROR" /* VALIDATION_ERROR */;
          state.errors.push(error);
          state.status = "failed";
          return {
            success: false,
            state,
            error,
            validationWarnings: validation.warnings
          };
        }
        warnings.push(...validation.warnings);
      }
      if (opts.trackExpectedOutcome) {
        state.expectedOutcome = await this.calculateExpectedOutcome(params);
      }
      state.status = "submitting";
      let order = null;
      while (state.attempts < opts.maxRetries) {
        state.attempts++;
        state.updatedAt = /* @__PURE__ */ new Date();
        try {
          const orderWithClientId = {
            ...params,
            client_order_id: clientOrderId
          };
          order = await this.submitOrderWithTimeout(orderWithClientId, opts.timeoutMs);
          state.orderId = order.id;
          state.status = "submitted";
          emitEvent("trade.order.submitted", {
            orderId: order.id,
            clientOrderId,
            symbol: params.symbol,
            side: params.side,
            type: params.type,
            qty: params.qty,
            limitPrice: params.limit_price,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          }).catch((err) => console.error("[Webhook] Order submitted event failed:", err));
          sendNotification("trade.order.submitted", {
            orderId: order.id,
            symbol: params.symbol,
            side: params.side,
            qty: params.qty,
            price: params.limit_price || "market"
          }).catch((err) => console.error("[Notification] Order submitted failed:", err));
          break;
        } catch (error) {
          const classifiedError = classifyError(error, `Attempt ${state.attempts}`);
          state.errors.push(classifiedError);
          if (!classifiedError.retryable || state.attempts >= opts.maxRetries) {
            if (opts.autoRecover && classifiedError.recoveryStrategy !== "NONE" /* NONE */) {
              const recovered = await this.attemptRecovery(state, classifiedError, params);
              if (recovered) {
                order = recovered;
                break;
              }
            }
            state.status = "failed";
            sendNotification("trade.order.rejected", {
              symbol: params.symbol,
              side: params.side,
              qty: params.qty,
              reason: classifiedError.message
            }).catch((err) => console.error("[Notification] Order rejected failed:", err));
            return {
              success: false,
              state,
              error: classifiedError,
              validationWarnings: warnings
            };
          }
          const delay = classifiedError.suggestedDelay * Math.pow(2, state.attempts - 1);
          await this.sleep(delay);
        }
      }
      if (!order) {
        state.status = "failed";
        return {
          success: false,
          state,
          error: state.errors[state.errors.length - 1],
          validationWarnings: warnings
        };
      }
      state.status = "monitoring";
      const monitoredOrder = await this.monitorOrderUntilTerminal(order.id, opts.timeoutMs);
      state.actualOutcome = this.recordActualOutcome(monitoredOrder, state);
      if (FAILED_STATUSES.includes(monitoredOrder.status)) {
        state.status = monitoredOrder.status;
        return {
          success: false,
          state,
          order: monitoredOrder,
          validationWarnings: warnings,
          outcomeAnalysis: this.analyzeOutcome(state)
        };
      }
      state.status = "filled";
      state.filledQty = monitoredOrder.filled_qty;
      state.filledPrice = monitoredOrder.filled_avg_price;
      emitEvent("trade.order.filled", {
        orderId: monitoredOrder.id,
        clientOrderId,
        symbol: monitoredOrder.symbol,
        side: monitoredOrder.side,
        filledQty: monitoredOrder.filled_qty,
        filledPrice: monitoredOrder.filled_avg_price,
        status: monitoredOrder.status,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }).catch((err) => console.error("[Webhook] Order filled event failed:", err));
      sendNotification("trade.order.filled", {
        orderId: monitoredOrder.id,
        symbol: monitoredOrder.symbol,
        side: monitoredOrder.side,
        qty: monitoredOrder.filled_qty,
        price: monitoredOrder.filled_avg_price
      }).catch((err) => console.error("[Notification] Order filled failed:", err));
      return {
        success: true,
        state,
        order: monitoredOrder,
        validationWarnings: warnings,
        outcomeAnalysis: this.analyzeOutcome(state)
      };
    } finally {
      this.activeExecutions.delete(clientOrderId);
    }
  }
  /**
   * Validate order parameters before submission
   */
  async validateOrderParams(params) {
    const result = { valid: true, errors: [], warnings: [] };
    try {
      CreateOrderSchema.parse(params);
    } catch (e) {
      result.valid = false;
      result.errors.push(`Schema validation failed: ${e.message}`);
      return result;
    }
    const tradabilityCheck = await tradabilityService.validateSymbolTradable(params.symbol);
    if (!tradabilityCheck.tradable) {
      result.valid = false;
      result.errors.push(`Symbol ${params.symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}`);
      return result;
    }
    if (!tradabilityCheck.fractionable && params.notional) {
      result.warnings.push(`${params.symbol} does not support fractional trading; use qty instead of notional`);
    }
    if (!tradabilityCheck.marginable) {
      result.warnings.push(`${params.symbol} is not marginable`);
    }
    const typeTifValidation = validateOrderTypeCombination(
      params.type,
      params.time_in_force,
      params.extended_hours
    );
    result.errors.push(...typeTifValidation.errors);
    result.warnings.push(...typeTifValidation.warnings);
    if (!typeTifValidation.valid) result.valid = false;
    let currentPrice = null;
    const cachedQuote = getQuickQuote(params.symbol);
    if (cachedQuote) {
      currentPrice = cachedQuote.price;
    } else {
      try {
        const operationId = `quote_${params.symbol}_${Date.now()}`;
        performanceTracker.startTimer(operationId);
        const snapshots = await alpaca.getSnapshots([params.symbol]);
        const latency = performanceTracker.endTimer(operationId, "quoteRetrieval");
        currentPrice = snapshots[params.symbol]?.latestTrade?.p || null;
        if (currentPrice) {
          const trade = snapshots[params.symbol]?.latestTrade;
          cacheQuickQuote({
            symbol: params.symbol,
            price: currentPrice,
            bid: snapshots[params.symbol]?.latestQuote?.bp || currentPrice,
            ask: snapshots[params.symbol]?.latestQuote?.ap || currentPrice,
            spread: 0,
            timestamp: Date.now()
          });
        }
        if (latency > 10) {
          console.log(`[OrderExecution] Slow quote retrieval: ${latency}ms for ${params.symbol}`);
        }
      } catch {
        result.warnings.push(`Could not fetch current price for ${params.symbol}`);
      }
    }
    if (currentPrice) {
      if (params.stop_price) {
        const stopValidation = validateStopPrice(
          params.side,
          currentPrice,
          parseFloat(params.stop_price)
        );
        result.errors.push(...stopValidation.errors);
        result.warnings.push(...stopValidation.warnings);
        if (!stopValidation.valid) result.valid = false;
      }
      if (params.limit_price) {
        const limitValidation = validateLimitPrice(
          params.side,
          currentPrice,
          parseFloat(params.limit_price)
        );
        result.errors.push(...limitValidation.errors);
        result.warnings.push(...limitValidation.warnings);
        if (!limitValidation.valid) result.valid = false;
      }
      if (params.order_class === "bracket" && params.take_profit && params.stop_loss) {
        const entryPrice = params.limit_price ? parseFloat(params.limit_price) : currentPrice;
        const bracketValidation = validateBracketOrder(
          params.side,
          entryPrice,
          parseFloat(params.take_profit.limit_price),
          parseFloat(params.stop_loss.stop_price)
        );
        result.errors.push(...bracketValidation.errors);
        result.warnings.push(...bracketValidation.warnings);
        if (!bracketValidation.valid) result.valid = false;
      }
    }
    if (params.type === "trailing_stop") {
      const trailValidation = validateTrailingStop(
        params.trail_percent ? parseFloat(params.trail_percent) : void 0,
        params.trail_price ? parseFloat(params.trail_price) : void 0
      );
      result.errors.push(...trailValidation.errors);
      result.warnings.push(...trailValidation.warnings);
      if (!trailValidation.valid) result.valid = false;
    }
    if (!params.extended_hours) {
      try {
        const marketStatus = await alpaca.getMarketStatus();
        if (!marketStatus.isOpen && params.time_in_force === "day") {
          result.warnings.push(
            `Market is currently ${marketStatus.session}. Day orders will queue until market open.`
          );
        }
      } catch {
        result.warnings.push("Could not verify market status");
      }
    }
    return result;
  }
  /**
   * Calculate expected outcome based on order parameters
   */
  async calculateExpectedOutcome(params) {
    const qty = parseFloat(params.qty || "0");
    const notional = parseFloat(params.notional || "0");
    let currentPrice = 0;
    try {
      const snapshots = await alpaca.getSnapshots([params.symbol]);
      currentPrice = snapshots[params.symbol]?.latestTrade?.p || 0;
    } catch {
      currentPrice = params.limit_price ? parseFloat(params.limit_price) : 0;
    }
    const expectedQty = qty > 0 ? qty : notional / currentPrice;
    const risks = [];
    let fillPriceMin = currentPrice;
    let fillPriceMax = currentPrice;
    let shouldFillImmediately = false;
    let fillTimeEstimate = 0;
    switch (params.type) {
      case "market":
        fillPriceMin = currentPrice * 0.995;
        fillPriceMax = currentPrice * 1.005;
        shouldFillImmediately = true;
        fillTimeEstimate = 500;
        risks.push("Slippage possible in fast-moving markets");
        break;
      case "limit":
        const limitPrice = parseFloat(params.limit_price || "0");
        fillPriceMin = limitPrice;
        fillPriceMax = limitPrice;
        shouldFillImmediately = params.side === "buy" ? limitPrice >= currentPrice : limitPrice <= currentPrice;
        fillTimeEstimate = shouldFillImmediately ? 1e3 : 3e5;
        if (!shouldFillImmediately) {
          risks.push("Order may not fill if price doesn't reach limit");
        }
        break;
      case "stop":
        fillPriceMin = parseFloat(params.stop_price || "0") * 0.99;
        fillPriceMax = parseFloat(params.stop_price || "0") * 1.01;
        shouldFillImmediately = false;
        fillTimeEstimate = 6e5;
        risks.push("Stop orders trigger as market orders - slippage possible");
        break;
      case "stop_limit":
        fillPriceMin = parseFloat(params.limit_price || "0");
        fillPriceMax = parseFloat(params.limit_price || "0");
        shouldFillImmediately = false;
        fillTimeEstimate = 6e5;
        risks.push("Order may not fill if gap occurs past limit price");
        break;
      case "trailing_stop":
        fillPriceMin = currentPrice * 0.9;
        fillPriceMax = currentPrice * 1.1;
        shouldFillImmediately = false;
        fillTimeEstimate = 36e5;
        risks.push("Trailing stop may trigger during normal volatility");
        break;
    }
    return {
      fillPrice: { min: fillPriceMin, max: fillPriceMax },
      fillQty: expectedQty,
      estimatedCost: expectedQty * ((fillPriceMin + fillPriceMax) / 2),
      shouldFillImmediately,
      fillTimeEstimateMs: fillTimeEstimate,
      risksIdentified: risks
    };
  }
  /**
   * Submit order with timeout and performance tracking
   */
  async submitOrderWithTimeout(params, timeoutMs) {
    const operationId = `order_${params.symbol}_${Date.now()}`;
    performanceTracker.startTimer(operationId);
    return new Promise((resolve2, reject) => {
      const timeout = setTimeout(() => {
        performanceTracker.endTimer(operationId, "orderExecution");
        reject(new Error(`Order submission timed out after ${timeoutMs}ms`));
      }, timeoutMs);
      alpaca.createOrder(params).then((order) => {
        clearTimeout(timeout);
        const latency = performanceTracker.endTimer(operationId, "orderExecution");
        if (latency > 50) {
          console.log(`[OrderExecution] Slow order submission: ${latency}ms for ${params.symbol}`);
        }
        resolve2(order);
      }).catch((error) => {
        clearTimeout(timeout);
        performanceTracker.endTimer(operationId, "orderExecution");
        reject(error);
      });
    });
  }
  /**
   * Monitor order until it reaches a terminal state
   */
  async monitorOrderUntilTerminal(orderId, timeoutMs) {
    const startTime = Date.now();
    const pollInterval = 1e3;
    while (Date.now() - startTime < timeoutMs) {
      try {
        const order = await alpaca.getOrder(orderId);
        if (TERMINAL_STATUSES.includes(order.status)) {
          return order;
        }
        await this.sleep(pollInterval);
      } catch (error) {
        console.error(`Error polling order ${orderId}:`, error);
        await this.sleep(pollInterval);
      }
    }
    return await alpaca.getOrder(orderId);
  }
  /**
   * Record actual outcome from filled order
   */
  recordActualOutcome(order, state) {
    const fillPrice = safeParseFloat(order.filled_avg_price, 0);
    const fillQty = safeParseFloat(order.filled_qty, 0);
    const fillTimeMs = order.filled_at ? new Date(order.filled_at).getTime() - state.createdAt.getTime() : Date.now() - state.createdAt.getTime();
    const requestedPrice = state.requestedPrice ? parseFloat(state.requestedPrice) : null;
    const slippage = requestedPrice && fillPrice ? (fillPrice - requestedPrice) / requestedPrice * 100 : null;
    const unexpectedEvents = [];
    if (order.status === "partially_filled") {
      unexpectedEvents.push(`Only partially filled: ${fillQty} of ${order.qty}`);
    }
    if (slippage !== null && Math.abs(slippage) > 1) {
      unexpectedEvents.push(`Significant slippage: ${slippage.toFixed(2)}%`);
    }
    return {
      filled: order.status === "filled",
      fillPrice,
      fillQty,
      totalCost: fillPrice * fillQty,
      fillTimeMs,
      slippage,
      status: order.status,
      unexpectedEvents
    };
  }
  /**
   * Analyze outcome vs expected
   */
  analyzeOutcome(state) {
    const expected = state.expectedOutcome;
    const actual = state.actualOutcome;
    if (!expected || !actual) {
      return {
        matchesExpected: true,
        slippagePercent: null,
        fillTimeDeviation: null,
        unexpectedIssues: [],
        recommendations: []
      };
    }
    const issues = [];
    const recommendations = [];
    let matchesExpected = true;
    if (actual.fillPrice !== null) {
      if (actual.fillPrice < expected.fillPrice.min || actual.fillPrice > expected.fillPrice.max) {
        matchesExpected = false;
        issues.push(
          `Fill price $${actual.fillPrice.toFixed(2)} outside expected range $${expected.fillPrice.min.toFixed(2)}-$${expected.fillPrice.max.toFixed(2)}`
        );
        recommendations.push("Consider using limit orders for better price control");
      }
    }
    if (actual.fillQty < expected.fillQty * 0.99) {
      matchesExpected = false;
      issues.push(`Partial fill: ${actual.fillQty} of ${expected.fillQty} requested`);
      recommendations.push("Check liquidity before placing large orders");
    }
    const fillTimeDeviation = actual.fillTimeMs - expected.fillTimeEstimateMs;
    if (expected.shouldFillImmediately && actual.fillTimeMs > 5e3) {
      issues.push(`Expected immediate fill but took ${actual.fillTimeMs}ms`);
    }
    issues.push(...actual.unexpectedEvents);
    return {
      matchesExpected,
      slippagePercent: actual.slippage,
      fillTimeDeviation,
      unexpectedIssues: issues,
      recommendations
    };
  }
  /**
   * Attempt recovery based on error type
   */
  async attemptRecovery(state, error, originalParams) {
    state.status = "recovering";
    console.log(`[OrderExecution] Attempting recovery: ${error.recoveryStrategy}`);
    switch (error.recoveryStrategy) {
      case "CHECK_AND_SYNC" /* CHECK_AND_SYNC */:
        try {
          const orders2 = await alpaca.getOrders("all", 10);
          const existingOrder = orders2.find((o) => o.client_order_id === state.clientOrderId);
          if (existingOrder) {
            console.log(`[OrderExecution] Found existing order via sync: ${existingOrder.id}`);
            return existingOrder;
          }
        } catch {
          console.error("[OrderExecution] Sync check failed");
        }
        return null;
      case "ADJUST_AND_RETRY" /* ADJUST_AND_RETRY */:
        if (error.type === "INSUFFICIENT_FUNDS" /* INSUFFICIENT_FUNDS */) {
          const reducedParams = { ...originalParams };
          if (reducedParams.qty) {
            reducedParams.qty = (parseFloat(reducedParams.qty) * 0.5).toString();
          } else if (reducedParams.notional) {
            reducedParams.notional = (parseFloat(reducedParams.notional) * 0.5).toString();
          }
          try {
            return await alpaca.createOrder(reducedParams);
          } catch {
            return null;
          }
        }
        return null;
      case "WAIT_FOR_MARKET_OPEN" /* WAIT_FOR_MARKET_OPEN */:
        const marketStatus = await alpaca.getMarketStatus();
        if (marketStatus.isOpen || marketStatus.isExtendedHours) {
          try {
            return await alpaca.createOrder(originalParams);
          } catch {
            return null;
          }
        }
        return null;
      default:
        return null;
    }
  }
  sleep(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  /**
   * Get active execution states for monitoring
   */
  getActiveExecutions() {
    return new Map(this.activeExecutions);
  }
};
var orderExecutionEngine = new OrderExecutionEngine();
async function identifyUnrealOrders() {
  const unrealOrders = [];
  try {
    const allOrders = await alpaca.getOrders("all", 500);
    const staleThresholdMs = 24 * 60 * 60 * 1e3;
    const now = Date.now();
    for (const order of allOrders) {
      let isUnreal = false;
      let reason = "";
      const filledQty = safeParseFloat(order.filled_qty, 0);
      const notionalValue = order.notional ? safeParseFloat(order.notional, 0) : 0;
      const orderCreatedAt = new Date(order.created_at).getTime();
      const orderAgeMs = now - orderCreatedAt;
      if (order.status === "rejected") {
        isUnreal = true;
        reason = "Order was rejected by broker";
      } else if (order.status === "canceled" && filledQty === 0) {
        isUnreal = true;
        reason = "Order was canceled with no fills";
      } else if (order.status === "expired" && filledQty === 0) {
        isUnreal = true;
        reason = "Order expired with no fills";
      } else if (filledQty === 0 && notionalValue === 0 && order.qty === "0") {
        isUnreal = true;
        reason = "Order has zero quantity and zero notional";
      } else if (ACTIVE_STATUSES.includes(order.status) && orderAgeMs >= staleThresholdMs && filledQty === 0) {
        isUnreal = true;
        reason = "Stale active order with no fills (>24 hours old)";
      }
      if (isUnreal) {
        unrealOrders.push({
          orderId: order.id,
          symbol: order.symbol,
          status: order.status,
          reason,
          createdAt: order.created_at,
          filledQty: order.filled_qty,
          qty: order.qty,
          notional: order.notional
        });
      }
    }
  } catch (error) {
    console.error("[OrderCleanup] Failed to identify unreal orders:", error);
  }
  return unrealOrders;
}
async function cleanupUnrealOrders() {
  const result = {
    identified: 0,
    canceled: 0,
    errors: []
  };
  try {
    const unrealOrders = await identifyUnrealOrders();
    result.identified = unrealOrders.length;
    for (const order of unrealOrders) {
      if (ACTIVE_STATUSES.includes(order.status)) {
        try {
          await alpaca.cancelOrder(order.orderId);
          console.log(`[OrderCleanup] Canceled unreal order ${order.orderId}: ${order.reason}`);
          result.canceled++;
        } catch (error) {
          const errorMsg = `Failed to cancel ${order.orderId}: ${error.message}`;
          result.errors.push(errorMsg);
          console.warn(`[OrderCleanup] ${errorMsg}`);
        }
      }
    }
    console.log(`[OrderCleanup] Identified ${result.identified} unreal orders, canceled ${result.canceled}`);
  } catch (error) {
    result.errors.push(`Cleanup failed: ${error.message}`);
  }
  return result;
}
async function reconcileOrderBook() {
  const result = {
    alpacaOrders: 0,
    localTrades: 0,
    missingLocal: [],
    orphanedLocal: [],
    synced: 0
  };
  try {
    const alpacaOrders = await alpaca.getOrders("all", 100);
    result.alpacaOrders = alpacaOrders.length;
    const localTrades = await storage.getTrades(100);
    result.localTrades = localTrades.length;
    const alpacaOrderIds = new Set(alpacaOrders.map((o) => o.id));
    const alpacaClientIds = new Set(alpacaOrders.map((o) => o.client_order_id));
    for (const order of alpacaOrders) {
      if (order.status === "filled") {
        const hasLocal = localTrades.some(
          (t) => t.notes?.includes(order.id) || t.notes?.includes(order.client_order_id)
        );
        if (!hasLocal) {
          result.missingLocal.push(order.id);
          await storage.createTrade({
            symbol: order.symbol,
            side: order.side,
            quantity: order.filled_qty,
            price: order.filled_avg_price || "0",
            status: "completed",
            notes: `Synced from Alpaca: ${order.id}`,
            pnl: null,
            strategyId: null
          });
          result.synced++;
        }
      }
    }
    console.log(`[Reconciliation] Orders: Alpaca=${result.alpacaOrders}, Local=${result.localTrades}, Synced=${result.synced}`);
  } catch (error) {
    console.error("[Reconciliation] Failed:", error);
  }
  return result;
}
var ORDER_FILL_POLL_INTERVAL_MS = tradingConfig.orderExecution.orderFillPollIntervalMs;
var ORDER_FILL_TIMEOUT_MS = tradingConfig.orderExecution.orderFillTimeoutMs;
var STALE_ORDER_TIMEOUT_MS = tradingConfig.orderExecution.staleOrderTimeoutMs;
async function waitForAlpacaOrderFill(orderId, timeoutMs = ORDER_FILL_TIMEOUT_MS) {
  const startTime = Date.now();
  while (Date.now() - startTime < timeoutMs) {
    try {
      const order = await alpaca.getOrder(orderId);
      const filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      const hasFillData = filledPrice > 0 && filledQty > 0;
      if (order.status === "filled" && hasFillData) {
        return { order, timedOut: false, hasFillData: true, isFullyFilled: true };
      }
      if (TERMINAL_STATUSES.includes(order.status)) {
        console.log(`[OrderFlow] Order ${orderId} ended with status: ${order.status}`);
        return { order, timedOut: false, hasFillData, isFullyFilled: false };
      }
      await new Promise((resolve2) => setTimeout(resolve2, ORDER_FILL_POLL_INTERVAL_MS));
    } catch (error) {
      console.error(`[OrderFlow] Error polling order ${orderId}:`, error);
      await new Promise((resolve2) => setTimeout(resolve2, ORDER_FILL_POLL_INTERVAL_MS));
    }
  }
  console.log(`[OrderFlow] Order ${orderId} fill timeout after ${timeoutMs}ms`);
  try {
    const finalOrder = await alpaca.getOrder(orderId);
    const filledPrice = safeParseFloat(finalOrder.filled_avg_price, 0);
    const filledQty = safeParseFloat(finalOrder.filled_qty, 0);
    const hasFillData = filledPrice > 0 && filledQty > 0;
    const isFullyFilled = finalOrder.status === "filled" && hasFillData;
    return { order: finalOrder, timedOut: true, hasFillData, isFullyFilled };
  } catch {
    return { order: null, timedOut: true, hasFillData: false, isFullyFilled: false };
  }
}
async function cancelExpiredOrders(maxAgeMs = STALE_ORDER_TIMEOUT_MS) {
  let canceledCount = 0;
  try {
    const openOrders = await alpaca.getOrders("open", 100);
    const now = Date.now();
    for (const order of openOrders) {
      const createdAt = new Date(order.created_at).getTime();
      const orderAge = now - createdAt;
      if (orderAge > maxAgeMs) {
        try {
          await alpaca.cancelOrder(order.id);
          canceledCount++;
          console.log(`[OrderFlow] Canceled expired order ${order.id} for ${order.symbol} (age: ${Math.floor(orderAge / 1e3)}s)`);
        } catch (error) {
          console.warn(`[OrderFlow] Failed to cancel expired order ${order.id}:`, error);
        }
      }
    }
    if (canceledCount > 0) {
      console.log(`[OrderFlow] Canceled ${canceledCount} expired pending orders`);
    }
  } catch (error) {
    console.error("[OrderFlow] Error checking for expired orders:", error);
  }
  return canceledCount;
}

// server/autonomous/orchestrator.ts
init_alpaca();
init_decision_engine();
init_finnhub();
init_coingecko();
init_storage();
init_numeric();

// server/ai/market-condition-analyzer.ts
init_storage();
init_finnhub();
init_coingecko();
init_alpaca();
init_numeric();
init_llmGateway();

// server/universe/candidatesService.ts
init_db();
init_schema();
import { eq as eq8, desc as desc4, inArray } from "drizzle-orm";

// server/universe/fundamentalsService.ts
init_db();
init_schema();
init_finnhub();
import { eq as eq5, and as and4 } from "drizzle-orm";
var DEFAULT_SCORE_WEIGHTS = {
  revenueGrowth: 0.35,
  margins: 0.3,
  leverage: 0.2,
  dilution: 0.15
};
function safeParseNumeric(value) {
  if (value === null || value === void 0) return null;
  const num = typeof value === "string" ? parseFloat(value) : value;
  return isNaN(num) ? null : num;
}
function normalizeScore(value, min, max, invert = false) {
  if (value === null) return 0.5;
  const clamped = Math.max(min, Math.min(max, value));
  const normalized = (clamped - min) / (max - min);
  return invert ? 1 - normalized : normalized;
}
var FundamentalsService = class {
  calculateQualityGrowthScore(fundamentals) {
    const revenueCagr = safeParseNumeric(fundamentals.revenueCagr3y);
    const grossMargin = safeParseNumeric(fundamentals.grossMargin);
    const operatingMargin = safeParseNumeric(fundamentals.operatingMargin);
    const netMargin = safeParseNumeric(fundamentals.netMargin);
    const freeCashFlowMargin = safeParseNumeric(fundamentals.freeCashFlowMargin);
    const debtToEquity = safeParseNumeric(fundamentals.debtToEquity);
    const sharesDilution = safeParseNumeric(fundamentals.sharesDilution1y);
    const revenueGrowthScore = normalizeScore(revenueCagr, -0.1, 0.5);
    const avgMargin = [grossMargin, operatingMargin, netMargin, freeCashFlowMargin].filter((m) => m !== null).reduce((sum, m, _, arr) => sum + m / arr.length, 0);
    const marginScore = normalizeScore(avgMargin, -0.1, 0.4);
    const leverageScore = normalizeScore(debtToEquity, 0, 3, true);
    const dilutionScore = normalizeScore(sharesDilution, -0.1, 0.15, true);
    const qualityScore = (marginScore + leverageScore) / 2;
    const growthScore = (revenueGrowthScore + (1 - dilutionScore)) / 2;
    const weights = DEFAULT_SCORE_WEIGHTS;
    const finalScore = revenueGrowthScore * weights.revenueGrowth + marginScore * weights.margins + leverageScore * weights.leverage + dilutionScore * weights.dilution;
    return {
      qualityScore: Math.round(qualityScore * 100) / 100,
      growthScore: Math.round(growthScore * 100) / 100,
      finalScore: Math.round(finalScore * 100) / 100,
      breakdown: {
        revenueGrowthScore: Math.round(revenueGrowthScore * 100) / 100,
        marginScore: Math.round(marginScore * 100) / 100,
        leverageScore: Math.round(leverageScore * 100) / 100,
        dilutionScore: Math.round(dilutionScore * 100) / 100
      }
    };
  }
  async fetchAndStoreFundamentals(options = {}) {
    const startTime = Date.now();
    const { symbols, batchSize = 10, traceId } = options;
    console.log(`[FUNDAMENTALS] Starting fundamentals fetch, traceId=${traceId}`);
    let targetSymbols;
    if (symbols && symbols.length > 0) {
      targetSymbols = symbols;
    } else {
      const assets = await db.select({ symbol: universeAssets.symbol }).from(universeAssets).where(and4(
        eq5(universeAssets.tradable, true),
        eq5(universeAssets.excluded, false)
      ));
      targetSymbols = assets.map((a) => a.symbol);
    }
    console.log(`[FUNDAMENTALS] Fetching fundamentals for ${targetSymbols.length} symbols`);
    let computed = 0;
    let failed = 0;
    for (let i = 0; i < targetSymbols.length; i += batchSize) {
      const batch = targetSymbols.slice(i, i + batchSize);
      for (const symbol of batch) {
        try {
          const [profile, basicFinancials] = await Promise.all([
            finnhub.getCompanyProfile(symbol),
            finnhub.getBasicFinancials(symbol)
          ]);
          const metric = basicFinancials?.metric || {};
          const fundamentalsData = {
            symbol,
            marketCap: profile?.marketCapitalization?.toString() || null,
            sector: profile?.finnhubIndustry || null,
            industry: profile?.finnhubIndustry || null,
            revenueTtm: metric.revenuePerShareTTM ? (metric.revenuePerShareTTM * (metric.sharesOutstanding || 1)).toString() : null,
            revenueCagr3y: metric.revenueGrowthTTMYoy ? (metric.revenueGrowthTTMYoy / 100).toString() : null,
            grossMargin: metric.grossMarginTTM ? (metric.grossMarginTTM / 100).toString() : null,
            operatingMargin: metric.operatingMarginTTM ? (metric.operatingMarginTTM / 100).toString() : null,
            netMargin: metric.netProfitMarginTTM ? (metric.netProfitMarginTTM / 100).toString() : null,
            freeCashFlowMargin: metric.freeCashFlowMarginTTM ? (metric.freeCashFlowMarginTTM / 100).toString() : null,
            debtToEquity: metric.totalDebtToEquity?.toString() || null,
            sharesDilution1y: null,
            source: "finnhub",
            rawJson: { profile, metric }
          };
          await this.upsertFundamentals(fundamentalsData);
          computed++;
        } catch (error) {
          console.error(`[FUNDAMENTALS] Failed to fetch fundamentals for ${symbol}:`, error);
          failed++;
        }
      }
      if (i + batchSize < targetSymbols.length) {
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
    const duration = Date.now() - startTime;
    console.log(`[FUNDAMENTALS] Fetch complete: computed=${computed}, failed=${failed}, duration=${duration}ms`);
    return {
      success: true,
      computed,
      failed,
      duration,
      traceId
    };
  }
  async upsertFundamentals(data) {
    const existing = await db.select({ id: universeFundamentals.id }).from(universeFundamentals).where(eq5(universeFundamentals.symbol, data.symbol)).limit(1);
    if (existing.length > 0) {
      await db.update(universeFundamentals).set({
        ...data,
        lastUpdatedAt: /* @__PURE__ */ new Date()
      }).where(eq5(universeFundamentals.symbol, data.symbol));
    } else {
      await db.insert(universeFundamentals).values(data);
    }
  }
  async getFundamentalsBySymbol(symbol) {
    const result = await db.select().from(universeFundamentals).where(eq5(universeFundamentals.symbol, symbol.toUpperCase())).limit(1);
    return result[0] || null;
  }
  async getFundamentalsWithScores(limit4 = 100) {
    const fundamentals = await db.select().from(universeFundamentals).limit(limit4);
    return fundamentals.map((f) => ({
      ...f,
      ...this.calculateQualityGrowthScore(f)
    }));
  }
  async getTopByScore(limit4 = 50) {
    const fundamentals = await db.select().from(universeFundamentals).limit(500);
    const scored = fundamentals.map((f) => ({
      ...f,
      ...this.calculateQualityGrowthScore(f)
    }));
    return scored.sort((a, b) => b.finalScore - a.finalScore).slice(0, limit4);
  }
  async getStats() {
    const all = await db.select().from(universeFundamentals);
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
    const bySector = {};
    let stale = 0;
    let lastUpdatedAt = null;
    for (const f of all) {
      if (f.sector) {
        bySector[f.sector] = (bySector[f.sector] || 0) + 1;
      }
      if (f.lastUpdatedAt < oneDayAgo) stale++;
      if (!lastUpdatedAt || f.lastUpdatedAt > lastUpdatedAt) {
        lastUpdatedAt = f.lastUpdatedAt;
      }
    }
    return {
      total: all.length,
      bySector,
      stale,
      lastUpdatedAt
    };
  }
};
var fundamentalsService = new FundamentalsService();

// server/universe/liquidityService.ts
init_db();
init_schema();
init_alpaca();
import { eq as eq7, and as and6, desc as desc3 } from "drizzle-orm";

// server/admin/settings.ts
init_db();
init_schema();
import { eq as eq6, and as and5 } from "drizzle-orm";
async function getSetting(namespace, key) {
  const [result] = await db.select().from(adminSettings).where(and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))).limit(1);
  if (!result) return void 0;
  return result.value;
}
async function getSettingFull(namespace, key) {
  const [result] = await db.select().from(adminSettings).where(and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))).limit(1);
  return result || void 0;
}
async function setSetting(namespace, key, value, options) {
  const existing = await db.select().from(adminSettings).where(and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))).limit(1);
  if (existing.length > 0) {
    if (existing[0].isReadOnly) {
      throw new Error(`Setting ${namespace}:${key} is read-only`);
    }
    const [updated] = await db.update(adminSettings).set({
      value,
      description: options?.description ?? existing[0].description,
      updatedBy: options?.userId,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq6(adminSettings.id, existing[0].id)).returning();
    return updated;
  }
  const [created] = await db.insert(adminSettings).values({
    namespace,
    key,
    value,
    description: options?.description,
    isSecret: options?.isSecret ?? false,
    isReadOnly: options?.isReadOnly ?? false,
    updatedBy: options?.userId
  }).returning();
  return created;
}
async function deleteSetting(namespace, key) {
  const existing = await db.select().from(adminSettings).where(and5(eq6(adminSettings.namespace, namespace), eq6(adminSettings.key, key))).limit(1);
  if (existing.length === 0) return false;
  if (existing[0].isReadOnly) {
    throw new Error(`Setting ${namespace}:${key} is read-only`);
  }
  await db.delete(adminSettings).where(eq6(adminSettings.id, existing[0].id));
  return true;
}
async function listSettings(namespace) {
  if (namespace) {
    return db.select().from(adminSettings).where(eq6(adminSettings.namespace, namespace));
  }
  return db.select().from(adminSettings);
}
function sanitizeSettingForResponse(setting) {
  if (setting.isSecret) {
    return { ...setting, value: "[REDACTED]" };
  }
  return setting;
}

// server/universe/liquidityService.ts
var PENNY_STOCK_THRESHOLD = 5;
var DEFAULT_THRESHOLDS = {
  tierA: {
    minAdtvUsd: 5e7,
    maxSpreadPct: 0.25,
    minPrice: 5
  },
  tierB: {
    minAdtvUsd: 2e7,
    maxSpreadPct: 0.75,
    minPrice: 3
  }
};
var LiquidityService = class {
  async getThresholds() {
    try {
      const setting = await getSetting("universe", "liquidity_thresholds");
      if (setting) {
        return setting;
      }
    } catch {
    }
    return DEFAULT_THRESHOLDS;
  }
  calculateLiquidityTier(adtvUsd, spreadPct, price, thresholds) {
    if (!adtvUsd || !price) return "C";
    const effectiveSpread = spreadPct ?? 0.5;
    if (adtvUsd >= thresholds.tierA.minAdtvUsd && effectiveSpread <= thresholds.tierA.maxSpreadPct && price >= thresholds.tierA.minPrice) {
      return "A";
    }
    if (adtvUsd >= thresholds.tierB.minAdtvUsd && effectiveSpread <= thresholds.tierB.maxSpreadPct && price >= thresholds.tierB.minPrice) {
      return "B";
    }
    return "C";
  }
  async computeLiquidityMetrics(options = {}) {
    const startTime = Date.now();
    const { symbols, batchSize = 50, traceId } = options;
    console.log(`[LIQUIDITY] Starting liquidity computation, traceId=${traceId}`);
    const thresholds = await this.getThresholds();
    let targetSymbols;
    if (symbols && symbols.length > 0) {
      targetSymbols = symbols;
    } else {
      const assets = await db.select({ symbol: universeAssets.symbol }).from(universeAssets).where(and6(
        eq7(universeAssets.tradable, true),
        eq7(universeAssets.excluded, false)
      ));
      targetSymbols = assets.map((a) => a.symbol);
    }
    console.log(`[LIQUIDITY] Computing metrics for ${targetSymbols.length} symbols`);
    let computed = 0;
    let tierACount = 0;
    let tierBCount = 0;
    let tierCCount = 0;
    const now = /* @__PURE__ */ new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    const startDate = thirtyDaysAgo.toISOString().split("T")[0];
    const endDate = now.toISOString().split("T")[0];
    for (let i = 0; i < targetSymbols.length; i += batchSize) {
      const batch = targetSymbols.slice(i, i + batchSize);
      try {
        const barsResponse = await alpaca.getBars(
          batch,
          "1Day",
          startDate,
          endDate,
          1e3
        );
        for (const symbol of batch) {
          const bars = barsResponse.bars?.[symbol] || [];
          if (bars.length === 0) {
            const metrics2 = {
              symbol,
              avgDailyVolumeShares: null,
              avgDailyTradedValueUsd: null,
              avgBidAskSpreadPct: null,
              latestPrice: null,
              priceDataDays: 0,
              liquidityTier: "C",
              source: "alpaca",
              rawJson: { noData: true }
            };
            await this.upsertLiquidityMetrics(metrics2);
            tierCCount++;
            computed++;
            continue;
          }
          let totalVolume = 0;
          let totalValue = 0;
          const latestPrice = bars[bars.length - 1]?.c || 0;
          for (const bar of bars) {
            totalVolume += bar.v;
            totalValue += bar.v * ((bar.h + bar.l) / 2);
          }
          const avgVolume = bars.length > 0 ? totalVolume / bars.length : 0;
          const avgTradedValue = bars.length > 0 ? totalValue / bars.length : 0;
          const tier = this.calculateLiquidityTier(
            avgTradedValue,
            null,
            latestPrice,
            thresholds
          );
          const metrics = {
            symbol,
            avgDailyVolumeShares: avgVolume.toString(),
            avgDailyTradedValueUsd: avgTradedValue.toString(),
            avgBidAskSpreadPct: null,
            latestPrice: latestPrice.toString(),
            priceDataDays: bars.length,
            liquidityTier: tier,
            source: "alpaca",
            rawJson: { barCount: bars.length, computed: now.toISOString() }
          };
          await this.upsertLiquidityMetrics(metrics);
          const isPennyStock = latestPrice < PENNY_STOCK_THRESHOLD && latestPrice > 0;
          await this.updatePennyStockFlag(symbol, isPennyStock, latestPrice);
          if (tier === "A") tierACount++;
          else if (tier === "B") tierBCount++;
          else tierCCount++;
          computed++;
        }
      } catch (error) {
        console.error(`[LIQUIDITY] Failed to process batch starting at ${i}:`, error);
      }
      if (i + batchSize < targetSymbols.length) {
        await new Promise((r) => setTimeout(r, 500));
      }
    }
    const duration = Date.now() - startTime;
    console.log(`[LIQUIDITY] Computation complete: computed=${computed}, tierA=${tierACount}, tierB=${tierBCount}, tierC=${tierCCount}, duration=${duration}ms`);
    return {
      success: true,
      computed,
      tierA: tierACount,
      tierB: tierBCount,
      tierC: tierCCount,
      duration,
      traceId
    };
  }
  async upsertLiquidityMetrics(metrics) {
    const existing = await db.select({ id: universeLiquidityMetrics.id }).from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.symbol, metrics.symbol)).limit(1);
    if (existing.length > 0) {
      await db.update(universeLiquidityMetrics).set({
        ...metrics,
        lastUpdatedAt: /* @__PURE__ */ new Date()
      }).where(eq7(universeLiquidityMetrics.symbol, metrics.symbol));
    } else {
      await db.insert(universeLiquidityMetrics).values(metrics);
    }
  }
  async getMetricsBySymbol(symbol) {
    const result = await db.select().from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.symbol, symbol.toUpperCase())).limit(1);
    return result[0] || null;
  }
  async getMetricsByTier(tier, limit4 = 100) {
    return db.select().from(universeLiquidityMetrics).where(eq7(universeLiquidityMetrics.liquidityTier, tier)).orderBy(desc3(universeLiquidityMetrics.avgDailyTradedValueUsd)).limit(limit4);
  }
  async getTierStats() {
    const all = await db.select().from(universeLiquidityMetrics);
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
    let tierA = 0, tierB = 0, tierC = 0, stale = 0;
    for (const m of all) {
      if (m.liquidityTier === "A") tierA++;
      else if (m.liquidityTier === "B") tierB++;
      else tierC++;
      if (m.lastUpdatedAt < oneDayAgo) stale++;
    }
    return { tierA, tierB, tierC, stale, total: all.length };
  }
  async getTopLiquid(limit4 = 50) {
    return db.select().from(universeLiquidityMetrics).orderBy(desc3(universeLiquidityMetrics.avgDailyTradedValueUsd)).limit(limit4);
  }
  async getThresholdsForAdmin() {
    return this.getThresholds();
  }
  async updatePennyStockFlag(symbol, isPennyStock, latestPrice) {
    try {
      await db.update(universeAssets).set({
        isPennyStock,
        excluded: isPennyStock ? true : void 0,
        excludeReason: isPennyStock ? `Penny stock (price $${latestPrice.toFixed(2)} < $${PENNY_STOCK_THRESHOLD})` : void 0
      }).where(eq7(universeAssets.symbol, symbol));
    } catch (error) {
      console.error(`[LIQUIDITY] Failed to update penny stock flag for ${symbol}:`, error);
    }
  }
};
var liquidityService = new LiquidityService();

// server/universe/candidatesService.ts
var CandidatesService = class {
  async generateCandidates(options = {}) {
    const startTime = Date.now();
    const {
      minLiquidityTier = "B",
      minScore = 0.4,
      limit: limit4 = 100,
      traceId
    } = options;
    console.log(`[CANDIDATES] Generating candidates, minTier=${minLiquidityTier}, minScore=${minScore}, traceId=${traceId}`);
    const eligibleSymbols = await db.select({
      symbol: universeLiquidityMetrics.symbol,
      tier: universeLiquidityMetrics.liquidityTier
    }).from(universeLiquidityMetrics).where(
      inArray(
        universeLiquidityMetrics.liquidityTier,
        minLiquidityTier === "A" ? ["A"] : ["A", "B"]
      )
    ).limit(limit4 * 2);
    console.log(`[CANDIDATES] Found ${eligibleSymbols.length} symbols meeting liquidity criteria`);
    let generated = 0;
    let updated = 0;
    for (const { symbol, tier } of eligibleSymbols) {
      const fundamentals = await fundamentalsService.getFundamentalsBySymbol(symbol);
      const liquidity = await liquidityService.getMetricsBySymbol(symbol);
      let qualityScore = 0.5;
      let growthScore = 0.5;
      let finalScore = 0.5;
      let rationale = "Insufficient data for scoring";
      if (fundamentals) {
        const scores = fundamentalsService.calculateQualityGrowthScore(fundamentals);
        qualityScore = scores.qualityScore;
        growthScore = scores.growthScore;
        finalScore = scores.finalScore;
        rationale = `Quality: ${(qualityScore * 100).toFixed(1)}%, Growth: ${(growthScore * 100).toFixed(1)}%`;
      }
      if (finalScore < minScore) {
        continue;
      }
      const liquidityScore = tier === "A" ? 1 : tier === "B" ? 0.7 : 0.4;
      const candidateData = {
        symbol,
        tier: tier || "C",
        liquidityScore: liquidityScore.toString(),
        qualityScore: qualityScore.toString(),
        growthScore: growthScore.toString(),
        finalScore: finalScore.toString(),
        rationale,
        traceId
      };
      const existing = await db.select({ id: universeCandidates.id, status: universeCandidates.status }).from(universeCandidates).where(eq8(universeCandidates.symbol, symbol)).limit(1);
      if (existing.length > 0) {
        if (existing[0].status === "NEW" || existing[0].status === "WATCHLIST") {
          await db.update(universeCandidates).set({
            ...candidateData,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq8(universeCandidates.symbol, symbol));
          updated++;
        }
      } else {
        await db.insert(universeCandidates).values({
          ...candidateData,
          status: "NEW"
        });
        generated++;
      }
      if (generated + updated >= limit4) break;
    }
    const duration = Date.now() - startTime;
    console.log(`[CANDIDATES] Generation complete: generated=${generated}, updated=${updated}, duration=${duration}ms`);
    return {
      success: true,
      generated,
      updated,
      duration,
      traceId
    };
  }
  async approveCandidate(symbol, userId) {
    return this.updateCandidateStatus(symbol, "APPROVED", userId);
  }
  async rejectCandidate(symbol) {
    return this.updateCandidateStatus(symbol, "REJECTED");
  }
  async watchlistCandidate(symbol) {
    return this.updateCandidateStatus(symbol, "WATCHLIST");
  }
  async updateCandidateStatus(symbol, newStatus, userId) {
    const existing = await db.select().from(universeCandidates).where(eq8(universeCandidates.symbol, symbol.toUpperCase())).limit(1);
    if (existing.length === 0) {
      throw new Error(`Candidate not found: ${symbol}`);
    }
    const previousStatus = existing[0].status;
    await db.update(universeCandidates).set({
      status: newStatus,
      approvedBy: newStatus === "APPROVED" ? userId : null,
      approvedAt: newStatus === "APPROVED" ? /* @__PURE__ */ new Date() : null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq8(universeCandidates.symbol, symbol.toUpperCase()));
    console.log(`[CANDIDATES] ${symbol}: ${previousStatus} -> ${newStatus}`);
    return {
      success: true,
      symbol: symbol.toUpperCase(),
      previousStatus,
      newStatus
    };
  }
  async getCandidateBySymbol(symbol) {
    const result = await db.select().from(universeCandidates).where(eq8(universeCandidates.symbol, symbol.toUpperCase())).limit(1);
    return result[0] || null;
  }
  async getCandidatesByStatus(status, limit4 = 100) {
    return db.select().from(universeCandidates).where(eq8(universeCandidates.status, status)).orderBy(desc4(universeCandidates.finalScore)).limit(limit4);
  }
  async getApprovedSymbols() {
    const approved = await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates).where(eq8(universeCandidates.status, "APPROVED"));
    return approved.map((c) => c.symbol);
  }
  async getWatchlistSymbols() {
    const symbols = await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates).where(inArray(universeCandidates.status, ["APPROVED", "WATCHLIST"]));
    const stocks = [];
    const crypto4 = [];
    for (const { symbol } of symbols) {
      if (symbol.includes("/USD") || ["BTC", "ETH", "SOL", "DOGE", "SHIB", "AVAX", "ADA", "XRP", "DOT", "MATIC"].includes(symbol.toUpperCase())) {
        crypto4.push(symbol.replace("/USD", "").toUpperCase());
      } else {
        stocks.push(symbol.toUpperCase());
      }
    }
    return { stocks, crypto: crypto4 };
  }
  async isSymbolApproved(symbol) {
    const candidate = await this.getCandidateBySymbol(symbol);
    return candidate?.status === "APPROVED";
  }
  async getStats() {
    const all = await db.select().from(universeCandidates);
    let newCount = 0;
    let watchlistCount = 0;
    let approvedCount = 0;
    let rejectedCount = 0;
    let totalScore = 0;
    for (const c of all) {
      if (c.status === "NEW") newCount++;
      else if (c.status === "WATCHLIST") watchlistCount++;
      else if (c.status === "APPROVED") approvedCount++;
      else if (c.status === "REJECTED") rejectedCount++;
      const score = parseFloat(c.finalScore || "0");
      totalScore += isNaN(score) ? 0 : score;
    }
    return {
      total: all.length,
      new: newCount,
      watchlist: watchlistCount,
      approved: approvedCount,
      rejected: rejectedCount,
      avgScore: all.length > 0 ? Math.round(totalScore / all.length * 100) / 100 : 0
    };
  }
  async getTopCandidates(limit4 = 50) {
    return db.select().from(universeCandidates).where(inArray(universeCandidates.status, ["NEW", "WATCHLIST", "APPROVED"])).orderBy(desc4(universeCandidates.finalScore)).limit(limit4);
  }
  async bootstrapFromWatchlist(watchlist, traceId) {
    console.log(`[CANDIDATES] Bootstrapping ${watchlist.length} symbols from watchlist, traceId=${traceId}`);
    let added = 0;
    let existing = 0;
    let errors = 0;
    for (const symbol of watchlist) {
      try {
        const upperSymbol = symbol.toUpperCase();
        const exists = await db.select({ id: universeCandidates.id }).from(universeCandidates).where(eq8(universeCandidates.symbol, upperSymbol)).limit(1);
        if (exists.length > 0) {
          existing++;
          continue;
        }
        await db.insert(universeCandidates).values({
          symbol: upperSymbol,
          tier: "B",
          liquidityScore: "0.7",
          qualityScore: "0.6",
          growthScore: "0.6",
          finalScore: "0.65",
          rationale: "Auto-bootstrapped from orchestrator watchlist",
          status: "APPROVED",
          approvedAt: /* @__PURE__ */ new Date(),
          approvedBy: null,
          traceId
        });
        added++;
      } catch (error) {
        console.error(`[CANDIDATES] Error bootstrapping ${symbol}:`, error);
        errors++;
      }
    }
    console.log(`[CANDIDATES] Bootstrap complete: added=${added}, existing=${existing}, errors=${errors}`);
    return { added, existing, errors };
  }
  async ensureWatchlistApproved(watchlist, traceId) {
    const existingSymbols = new Set(
      (await db.select({ symbol: universeCandidates.symbol }).from(universeCandidates)).map((r) => r.symbol.toUpperCase())
    );
    const missingSymbols = watchlist.map((s) => s.toUpperCase()).filter((s) => !existingSymbols.has(s));
    if (missingSymbols.length === 0) {
      console.log(`[CANDIDATES] All ${watchlist.length} watchlist symbols already in universe_candidates`);
      return;
    }
    console.log(`[CANDIDATES] Found ${missingSymbols.length} missing symbols, bootstrapping...`);
    const result = await this.bootstrapFromWatchlist(missingSymbols, traceId);
    if (result.errors > 0) {
      console.warn(`[CANDIDATES] Bootstrap completed with ${result.errors} errors out of ${missingSymbols.length} symbols`);
    }
  }
};
var candidatesService = new CandidatesService();

// server/ai/market-condition-analyzer.ts
var MIN_ORDER_LIMIT = 10;
var MAX_ORDER_LIMIT = 50;
var ANALYSIS_INTERVAL_MS = 5 * 60 * 1e3;
var MarketConditionAnalyzer = class {
  lastAnalysis = null;
  lastAnalysisTime = null;
  isAnalyzing = false;
  analysisTimer = null;
  async initialize() {
    console.log("[MarketAnalyzer] Initializing market condition analyzer...");
    this.runAnalysis().catch((err) => {
      console.error("[MarketAnalyzer] Initial analysis failed:", err);
    });
    this.startPeriodicAnalysis();
  }
  startPeriodicAnalysis() {
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
    }
    this.analysisTimer = setInterval(() => {
      this.runAnalysis().catch((err) => {
        console.error("[MarketAnalyzer] Periodic analysis error:", err);
      });
    }, ANALYSIS_INTERVAL_MS);
    console.log(`[MarketAnalyzer] Periodic analysis started (every ${ANALYSIS_INTERVAL_MS / 1e3}s)`);
  }
  stop() {
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
      this.analysisTimer = null;
    }
  }
  async runAnalysis() {
    if (this.isAnalyzing) {
      return this.lastAnalysis || this.getDefaultAnalysis();
    }
    this.isAnalyzing = true;
    try {
      console.log("[MarketAnalyzer] Running market condition analysis...");
      const snapshot = await this.fetchMarketSnapshot();
      const analysis = await this.analyzeWithAI(snapshot);
      this.lastAnalysis = analysis;
      this.lastAnalysisTime = /* @__PURE__ */ new Date();
      await this.updateAgentOrderLimit(analysis);
      console.log(`[MarketAnalyzer] Analysis complete: ${analysis.condition}, order limit: ${analysis.recommendedOrderLimit}`);
      return analysis;
    } catch (error) {
      console.error("[MarketAnalyzer] Analysis failed:", error);
      return this.lastAnalysis || this.getDefaultAnalysis();
    } finally {
      this.isAnalyzing = false;
    }
  }
  async fetchMarketSnapshot() {
    const snapshot = {
      stocks: /* @__PURE__ */ new Map(),
      crypto: /* @__PURE__ */ new Map(),
      portfolioValue: 0,
      // Will be fetched from Alpaca
      openPositions: 0,
      dailyPnl: 0
    };
    let watchlistStocks = ["SPY", "QQQ", "AAPL", "MSFT", "NVDA"];
    let watchlistCrypto = ["btc", "eth", "sol"];
    try {
      const dynamicWatchlist = await candidatesService.getWatchlistSymbols();
      if (dynamicWatchlist.stocks.length > 0) {
        watchlistStocks = dynamicWatchlist.stocks.slice(0, 15);
      }
      if (dynamicWatchlist.crypto.length > 0) {
        watchlistCrypto = dynamicWatchlist.crypto.map((c) => c.toLowerCase());
      }
    } catch (error) {
      console.warn("[MarketAnalyzer] Failed to load watchlist from database, using fallback:", error);
    }
    try {
      const stockQuotes = await finnhub.getMultipleQuotes(watchlistStocks);
      for (const [symbol, quote] of stockQuotes.entries()) {
        if (quote.c > 0) {
          snapshot.stocks.set(symbol, {
            price: quote.c,
            change: quote.d,
            changePercent: quote.dp
          });
        }
      }
    } catch (error) {
      console.error("[MarketAnalyzer] Failed to fetch stock data:", error);
    }
    try {
      const cryptoMarkets = await coingecko.getMarkets();
      const watchedCrypto = cryptoMarkets.filter(
        (c) => watchlistCrypto.includes(c.symbol.toLowerCase())
      );
      for (const coin of watchedCrypto) {
        snapshot.crypto.set(coin.symbol.toUpperCase(), {
          price: coin.current_price,
          change: coin.price_change_24h || 0,
          changePercent: coin.price_change_percentage_24h || 0
        });
      }
    } catch (error) {
      console.error("[MarketAnalyzer] Failed to fetch crypto data:", error);
    }
    try {
      const account = await alpaca.getAccount();
      snapshot.portfolioValue = safeParseFloat(account.portfolio_value);
      const positions2 = await alpaca.getPositions();
      snapshot.openPositions = positions2.length;
      let totalPnl = 0;
      for (const pos of positions2) {
        totalPnl += safeParseFloat(pos.unrealized_pl);
      }
      snapshot.dailyPnl = totalPnl;
    } catch (error) {
      console.error("[MarketAnalyzer] Failed to fetch portfolio data:", error);
    }
    return snapshot;
  }
  async analyzeWithAI(snapshot) {
    const stockSummary = Array.from(snapshot.stocks.entries()).map(([symbol, data]) => `${symbol}: $${data.price.toFixed(2)} (${data.changePercent >= 0 ? "+" : ""}${data.changePercent.toFixed(2)}%)`).join(", ");
    const cryptoSummary = Array.from(snapshot.crypto.entries()).map(([symbol, data]) => `${symbol}: $${data.price.toFixed(2)} (${data.changePercent >= 0 ? "+" : ""}${data.changePercent.toFixed(2)}%)`).join(", ");
    const avgStockChange = this.calculateAverageChange(snapshot.stocks);
    const avgCryptoChange = this.calculateAverageChange(snapshot.crypto);
    const volatility = this.calculateVolatility(snapshot.stocks, snapshot.crypto);
    const prompt = `You are an expert market analyst AI. Analyze the following market snapshot and determine the optimal trading aggressiveness.

CURRENT MARKET DATA:
Stocks: ${stockSummary || "No data"}
Crypto: ${cryptoSummary || "No data"}

MARKET METRICS:
- Average stock change: ${avgStockChange.toFixed(2)}%
- Average crypto change: ${avgCryptoChange.toFixed(2)}%
- Volatility indicator: ${volatility.toFixed(2)}

PORTFOLIO STATUS:
- Portfolio value: $${snapshot.portfolioValue.toFixed(2)}
- Open positions: ${snapshot.openPositions}
- Unrealized P&L: $${snapshot.dailyPnl.toFixed(2)}

TASK:
Determine the optimal number of active orders (between ${MIN_ORDER_LIMIT} and ${MAX_ORDER_LIMIT}) based on:
1. Market conditions - bullish markets allow more orders, bearish markets require caution
2. Volatility - high volatility means higher risk, reduce orders
3. Portfolio health - significant losses mean reduce exposure
4. Opportunity assessment - more opportunities = more orders

RESPOND WITH VALID JSON ONLY:
{
  "condition": "bullish" | "bearish" | "neutral" | "volatile" | "uncertain",
  "confidenceScore": 0.0-1.0,
  "recommendedOrderLimit": ${MIN_ORDER_LIMIT}-${MAX_ORDER_LIMIT},
  "reasoning": "brief explanation",
  "riskLevel": "low" | "medium" | "high",
  "marketIndicators": {
    "overallTrend": "up/down/sideways",
    "volatilityLevel": "low/medium/high",
    "sentimentScore": -1.0 to 1.0,
    "majorMovers": ["symbol1", "symbol2"]
  }
}`;
    try {
      const response = await callLLM({
        role: "risk_manager",
        criticality: "medium",
        purpose: "market_condition_analysis",
        traceId: generateTraceId(),
        system: "You are a market analyst AI. Respond only with valid JSON. No markdown, no explanations outside the JSON.",
        messages: [{ role: "user", content: prompt }],
        responseFormat: { type: "json_object" },
        temperature: 0.3,
        maxTokens: 500
      });
      const content = response.text;
      if (!content) {
        throw new Error("Empty AI response");
      }
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      if (!jsonMatch) {
        throw new Error("No JSON found in response");
      }
      const parsed = JSON.parse(jsonMatch[0]);
      parsed.recommendedOrderLimit = Math.max(
        MIN_ORDER_LIMIT,
        Math.min(MAX_ORDER_LIMIT, parsed.recommendedOrderLimit)
      );
      return parsed;
    } catch (error) {
      console.error("[MarketAnalyzer] AI analysis failed:", error);
      return this.calculateFallbackAnalysis(snapshot, avgStockChange, avgCryptoChange, volatility);
    }
  }
  calculateAverageChange(data) {
    if (data.size === 0) return 0;
    let total = 0;
    for (const item of data.values()) {
      total += item.changePercent;
    }
    return total / data.size;
  }
  calculateVolatility(stocks, crypto4) {
    const allChanges = [];
    for (const item of stocks.values()) {
      allChanges.push(Math.abs(item.changePercent));
    }
    for (const item of crypto4.values()) {
      allChanges.push(Math.abs(item.changePercent));
    }
    if (allChanges.length === 0) return 0;
    const avg = allChanges.reduce((a, b) => a + b, 0) / allChanges.length;
    const variance = allChanges.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / allChanges.length;
    return Math.sqrt(variance);
  }
  calculateFallbackAnalysis(snapshot, avgStockChange, avgCryptoChange, volatility) {
    const overallChange = (avgStockChange + avgCryptoChange) / 2;
    let condition = "neutral";
    let riskLevel = "medium";
    let recommendedOrderLimit = 20;
    if (volatility > 3) {
      condition = "volatile";
      riskLevel = "high";
      recommendedOrderLimit = MIN_ORDER_LIMIT;
    } else if (overallChange > 1) {
      condition = "bullish";
      riskLevel = "low";
      recommendedOrderLimit = Math.min(MAX_ORDER_LIMIT, 35);
    } else if (overallChange < -1) {
      condition = "bearish";
      riskLevel = "high";
      recommendedOrderLimit = Math.min(15, MIN_ORDER_LIMIT + 5);
    } else {
      condition = "neutral";
      riskLevel = "medium";
      recommendedOrderLimit = 20;
    }
    if (snapshot.dailyPnl < -snapshot.portfolioValue * 0.02) {
      recommendedOrderLimit = Math.max(MIN_ORDER_LIMIT, recommendedOrderLimit - 10);
      riskLevel = "high";
    }
    const majorMovers = this.identifyMajorMovers(snapshot);
    return {
      condition,
      confidenceScore: 0.6,
      recommendedOrderLimit,
      reasoning: `Fallback analysis: ${condition} market with ${volatility.toFixed(1)}% volatility`,
      riskLevel,
      marketIndicators: {
        overallTrend: overallChange > 0.5 ? "up" : overallChange < -0.5 ? "down" : "sideways",
        volatilityLevel: volatility > 3 ? "high" : volatility > 1.5 ? "medium" : "low",
        sentimentScore: Math.max(-1, Math.min(1, overallChange / 5)),
        majorMovers
      }
    };
  }
  identifyMajorMovers(snapshot) {
    const allAssets = [];
    for (const [symbol, data] of snapshot.stocks.entries()) {
      allAssets.push({ symbol, change: Math.abs(data.changePercent) });
    }
    for (const [symbol, data] of snapshot.crypto.entries()) {
      allAssets.push({ symbol, change: Math.abs(data.changePercent) });
    }
    return allAssets.sort((a, b) => b.change - a.change).slice(0, 3).map((a) => a.symbol);
  }
  async updateAgentOrderLimit(analysis) {
    try {
      await storage.updateAgentStatus({
        dynamicOrderLimit: analysis.recommendedOrderLimit,
        marketCondition: analysis.condition,
        aiConfidenceScore: analysis.confidenceScore.toString(),
        lastMarketAnalysis: /* @__PURE__ */ new Date(),
        maxPositionsCount: analysis.recommendedOrderLimit
      });
    } catch (error) {
      console.error("[MarketAnalyzer] Failed to update agent status:", error);
    }
  }
  getDefaultAnalysis() {
    return {
      condition: "neutral",
      confidenceScore: 0.5,
      recommendedOrderLimit: 15,
      reasoning: "Default conservative analysis - no market data available",
      riskLevel: "medium",
      marketIndicators: {
        overallTrend: "sideways",
        volatilityLevel: "medium",
        sentimentScore: 0,
        majorMovers: []
      }
    };
  }
  getLastAnalysis() {
    return this.lastAnalysis;
  }
  getLastAnalysisTime() {
    return this.lastAnalysisTime;
  }
  getCurrentOrderLimit() {
    return this.lastAnalysis?.recommendedOrderLimit || 15;
  }
  getStatus() {
    return {
      isRunning: !!this.analysisTimer,
      lastAnalysis: this.lastAnalysis,
      lastAnalysisTime: this.lastAnalysisTime,
      currentOrderLimit: this.getCurrentOrderLimit()
    };
  }
};
var marketConditionAnalyzer = new MarketConditionAnalyzer();

// server/autonomous/orchestrator.ts
init_logger();

// server/ai/learning-service.ts
init_db();
init_schema();
init_logger();
import { eq as eq9, desc as desc5, and as and8, gte as gte4, sql as sql7 } from "drizzle-orm";
async function recordDecisionFeatures(decisionId, symbol, features) {
  try {
    const featureVectorJson = JSON.stringify(features);
    await db.insert(aiDecisionFeatures).values({
      decisionId,
      symbol,
      volatility: features.volatility?.toString(),
      trendStrength: features.trendStrength?.toString(),
      signalAgreement: features.signalAgreement?.toString(),
      sentimentScore: features.sentimentScore?.toString(),
      peRatio: features.peRatio?.toString(),
      pbRatio: features.pbRatio?.toString(),
      rsi: features.rsi?.toString(),
      macdSignal: features.macdSignal,
      volumeRatio: features.volumeRatio?.toString(),
      priceChangePercent: features.priceChangePercent?.toString(),
      marketCondition: features.marketCondition,
      dataQuality: features.dataQuality?.toString(),
      activeSources: features.activeSources,
      featureVector: featureVectorJson
    });
    log.debug("AILearning", `Recorded features for decision ${decisionId}`);
  } catch (error) {
    log.error("AILearning", `Failed to record features: ${error}`);
  }
}
async function recordTradeOutcome(input) {
  try {
    await db.insert(aiTradeOutcomes).values({
      decisionId: input.decisionId,
      tradeId: input.tradeId,
      symbol: input.symbol,
      action: input.action,
      predictionConfidence: input.predictionConfidence?.toString(),
      entryPrice: input.entryPrice?.toString(),
      exitPrice: input.exitPrice?.toString(),
      quantity: input.quantity?.toString(),
      realizedPnl: input.realizedPnl?.toString(),
      realizedPnlPercent: input.realizedPnlPercent?.toString(),
      holdingTimeMs: input.holdingTimeMs,
      isWin: input.isWin,
      slippagePercent: input.slippagePercent?.toString(),
      targetPriceHit: input.targetPriceHit,
      stopLossHit: input.stopLossHit,
      maxDrawdown: input.maxDrawdown?.toString(),
      maxGain: input.maxGain?.toString(),
      marketSessionAtEntry: input.marketSessionAtEntry,
      marketSessionAtExit: input.marketSessionAtExit,
      strategyId: input.strategyId,
      exitReason: input.exitReason,
      closedAt: input.exitPrice ? /* @__PURE__ */ new Date() : null
    });
    log.debug("AILearning", `Recorded outcome for decision ${input.decisionId}`);
  } catch (error) {
    log.error("AILearning", `Failed to record outcome: ${error}`);
  }
}
async function updateTradeOutcomeOnClose(decisionId, exitPrice, exitReason, marketSession) {
  try {
    const existingOutcome = await db.select().from(aiTradeOutcomes).where(eq9(aiTradeOutcomes.decisionId, decisionId)).limit(1);
    if (existingOutcome.length === 0) {
      log.warn("AILearning", `No outcome record found for decision ${decisionId}`);
      return;
    }
    const outcome = existingOutcome[0];
    const entryPrice = parseFloat(outcome.entryPrice || "0");
    const quantity = parseFloat(outcome.quantity || "0");
    const realizedPnl = (exitPrice - entryPrice) * quantity;
    const realizedPnlPercent = entryPrice > 0 ? (exitPrice - entryPrice) / entryPrice * 100 : 0;
    const isWin = realizedPnl > 0;
    const holdingTimeMs = outcome.createdAt ? Date.now() - outcome.createdAt.getTime() : 0;
    await db.update(aiTradeOutcomes).set({
      exitPrice: exitPrice.toString(),
      realizedPnl: realizedPnl.toString(),
      realizedPnlPercent: realizedPnlPercent.toString(),
      isWin,
      holdingTimeMs,
      exitReason,
      marketSessionAtExit: marketSession,
      closedAt: /* @__PURE__ */ new Date()
    }).where(eq9(aiTradeOutcomes.decisionId, decisionId));
    log.info("AILearning", `Updated outcome for ${decisionId}: PnL=$${realizedPnl.toFixed(2)} (${isWin ? "WIN" : "LOSS"})`);
  } catch (error) {
    log.error("AILearning", `Failed to update outcome: ${error}`);
  }
}
async function runCalibrationAnalysis(windowDays = 30) {
  try {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - windowDays);
    const outcomes = await db.select().from(aiTradeOutcomes).where(and8(
      gte4(aiTradeOutcomes.createdAt, startDate),
      sql7`${aiTradeOutcomes.isWin} IS NOT NULL`
    ));
    if (outcomes.length === 0) {
      log.info("AILearning", "No closed trades in window for calibration");
      return;
    }
    const wins = outcomes.filter((o) => o.isWin === true);
    const losses = outcomes.filter((o) => o.isWin === false);
    const avgConfidenceWins = wins.length > 0 ? wins.reduce((sum, o) => sum + parseFloat(o.predictionConfidence || "0"), 0) / wins.length : 0;
    const avgConfidenceLosses = losses.length > 0 ? losses.reduce((sum, o) => sum + parseFloat(o.predictionConfidence || "0"), 0) / losses.length : 0;
    const avgHoldingTimeWins = wins.length > 0 ? Math.round(wins.reduce((sum, o) => sum + (o.holdingTimeMs || 0), 0) / wins.length) : 0;
    const avgHoldingTimeLosses = losses.length > 0 ? Math.round(losses.reduce((sum, o) => sum + (o.holdingTimeMs || 0), 0) / losses.length) : 0;
    const symbolWins = {};
    const symbolLosses = {};
    for (const o of outcomes) {
      if (o.isWin) {
        symbolWins[o.symbol] = (symbolWins[o.symbol] || 0) + 1;
      } else {
        symbolLosses[o.symbol] = (symbolLosses[o.symbol] || 0) + 1;
      }
    }
    const topWinningSymbols = Object.entries(symbolWins).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([s, c]) => `${s}:${c}`).join(",");
    const topLosingSymbols = Object.entries(symbolLosses).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([s, c]) => `${s}:${c}`).join(",");
    const adjustments = [];
    if (avgConfidenceLosses > 0.6) {
      adjustments.push("High confidence losses detected - consider raising confidence threshold");
    }
    if (avgHoldingTimeLosses < avgHoldingTimeWins / 2) {
      adjustments.push("Losses happen quickly - consider tighter stop losses");
    }
    if (losses.length > wins.length * 2) {
      adjustments.push("Low win rate - consider more conservative position sizing");
    }
    await db.insert(aiCalibrationLog).values({
      calibrationType: "periodic",
      dataWindowDays: windowDays,
      totalDecisions: outcomes.length,
      winCount: wins.length,
      lossCount: losses.length,
      avgConfidenceOnWins: avgConfidenceWins.toString(),
      avgConfidenceOnLosses: avgConfidenceLosses.toString(),
      avgHoldingTimeWins,
      avgHoldingTimeLosses,
      topWinningSymbols,
      topLosingSymbols,
      recommendedAdjustments: adjustments.join("; "),
      modelVersion: "v1.0"
    });
    log.info("AILearning", `Calibration complete: ${wins.length} wins, ${losses.length} losses, win rate ${(wins.length / outcomes.length * 100).toFixed(1)}%`);
  } catch (error) {
    log.error("AILearning", `Calibration analysis failed: ${error}`);
  }
}

// server/autonomous/orchestrator.ts
init_tradability_service();

// server/lib/work-queue.ts
init_storage();
init_alpaca();
init_logger();
init_tradability_service();

// server/universe/alpacaUniverse.ts
init_db();
init_schema();
init_alpaca();
import { eq as eq10, and as and9 } from "drizzle-orm";
var OTC_EXCHANGES = ["OTC", "OTCBB", "OTCQB", "OTCQX", "PINK"];
var PENNY_STOCK_THRESHOLD2 = 5;
function isOtcExchange(exchange) {
  return OTC_EXCHANGES.includes(exchange.toUpperCase());
}
function isSpacName(name) {
  const spacPatterns = [
    /acquisition corp/i,
    /SPAC/i,
    /blank check/i,
    /special purpose/i
  ];
  return spacPatterns.some((pattern) => pattern.test(name));
}
var AlpacaUniverseService = class {
  async refreshAssets(options = {}) {
    const startTime = Date.now();
    const {
      status = "active",
      assetClass = "us_equity",
      includeOtc = false,
      includeSpac = false,
      includePennyStocks = false,
      traceId
    } = options;
    console.log(`[UNIVERSE] Starting asset refresh for ${assetClass} (status=${status}), traceId=${traceId}`);
    let alpacaAssets;
    try {
      alpacaAssets = await alpaca.getAssets(status, assetClass);
    } catch (error) {
      console.error("[UNIVERSE] Failed to fetch Alpaca assets:", error);
      throw new Error(`Failed to fetch Alpaca assets: ${error}`);
    }
    console.log(`[UNIVERSE] Fetched ${alpacaAssets.length} assets from Alpaca`);
    let added = 0;
    let updated = 0;
    let excluded = 0;
    const existingSymbols = new Set(
      (await db.select({ symbol: universeAssets.symbol }).from(universeAssets)).map((a) => a.symbol)
    );
    for (const asset of alpacaAssets) {
      const isOtc = isOtcExchange(asset.exchange);
      const isSpac = isSpacName(asset.name);
      let shouldExclude = false;
      let excludeReason = null;
      if (isOtc && !includeOtc) {
        shouldExclude = true;
        excludeReason = "OTC excluded by policy";
      } else if (isSpac && !includeSpac) {
        shouldExclude = true;
        excludeReason = "SPAC excluded by policy";
      }
      const assetData = {
        symbol: asset.symbol,
        name: asset.name,
        exchange: asset.exchange,
        assetClass: asset.class,
        status: asset.status,
        tradable: asset.tradable,
        marginable: asset.marginable,
        shortable: asset.shortable,
        fractionable: asset.fractionable,
        easyToBorrow: asset.easy_to_borrow,
        isOtc,
        isSpac,
        isPennyStock: false,
        excluded: shouldExclude,
        excludeReason,
        rawJson: asset
      };
      try {
        if (existingSymbols.has(asset.symbol)) {
          await db.update(universeAssets).set({
            ...assetData,
            lastRefreshedAt: /* @__PURE__ */ new Date()
          }).where(eq10(universeAssets.symbol, asset.symbol));
          updated++;
        } else {
          await db.insert(universeAssets).values(assetData);
          added++;
        }
        if (shouldExclude) {
          excluded++;
        }
      } catch (error) {
        console.error(`[UNIVERSE] Failed to upsert asset ${asset.symbol}:`, error);
      }
    }
    const fetchedSymbols = new Set(alpacaAssets.map((a) => a.symbol));
    const symbolsToRemove = [...existingSymbols].filter((s) => !fetchedSymbols.has(s));
    for (const symbol of symbolsToRemove) {
      await db.update(universeAssets).set({
        tradable: false,
        status: "delisted",
        excluded: true,
        excludeReason: "No longer in Alpaca assets",
        lastRefreshedAt: /* @__PURE__ */ new Date()
      }).where(eq10(universeAssets.symbol, symbol));
      await db.delete(universeLiquidityMetrics).where(eq10(universeLiquidityMetrics.symbol, symbol));
    }
    console.log(`[UNIVERSE] Cleaned up ${symbolsToRemove.length} delisted symbols from liquidity metrics`);
    const duration = Date.now() - startTime;
    console.log(`[UNIVERSE] Refresh complete: added=${added}, updated=${updated}, removed=${symbolsToRemove.length}, excluded=${excluded}, duration=${duration}ms`);
    return {
      success: true,
      added,
      updated,
      removed: symbolsToRemove.length,
      excluded,
      duration,
      traceId
    };
  }
  async getStats() {
    const allAssets = await db.select().from(universeAssets);
    const byExchange = {};
    const byAssetClass = {};
    let activeTradable = 0;
    let excluded = 0;
    let otcCount = 0;
    let spacCount = 0;
    let pennyStockCount = 0;
    let lastRefreshedAt = null;
    for (const asset of allAssets) {
      byExchange[asset.exchange] = (byExchange[asset.exchange] || 0) + 1;
      byAssetClass[asset.assetClass] = (byAssetClass[asset.assetClass] || 0) + 1;
      if (asset.tradable && !asset.excluded) {
        activeTradable++;
      }
      if (asset.excluded) {
        excluded++;
      }
      if (asset.isOtc) {
        otcCount++;
      }
      if (asset.isSpac) {
        spacCount++;
      }
      if (asset.isPennyStock) {
        pennyStockCount++;
      }
      if (!lastRefreshedAt || asset.lastRefreshedAt > lastRefreshedAt) {
        lastRefreshedAt = asset.lastRefreshedAt;
      }
    }
    return {
      totalAssets: allAssets.length,
      activeTradable,
      excluded,
      byExchange,
      byAssetClass,
      otcCount,
      spacCount,
      pennyStockCount,
      lastRefreshedAt
    };
  }
  async getAssets(options = {}) {
    const {
      tradableOnly = true,
      excludeOtc = true,
      excludeSpac = true,
      excludePennyStocks = true,
      exchange,
      limit: limit4 = 1e3,
      offset = 0
    } = options;
    let query = db.select().from(universeAssets);
    const conditions = [];
    if (tradableOnly) {
      conditions.push(eq10(universeAssets.tradable, true));
      conditions.push(eq10(universeAssets.excluded, false));
    }
    if (excludeOtc) {
      conditions.push(eq10(universeAssets.isOtc, false));
    }
    if (excludeSpac) {
      conditions.push(eq10(universeAssets.isSpac, false));
    }
    if (excludePennyStocks) {
      conditions.push(eq10(universeAssets.isPennyStock, false));
    }
    if (exchange) {
      conditions.push(eq10(universeAssets.exchange, exchange));
    }
    if (conditions.length > 0) {
      query = query.where(and9(...conditions));
    }
    return query.limit(limit4).offset(offset);
  }
  async getAssetBySymbol(symbol) {
    const result = await db.select().from(universeAssets).where(eq10(universeAssets.symbol, symbol.toUpperCase())).limit(1);
    return result[0] || null;
  }
  async setExcluded(symbol, excluded, reason) {
    const result = await db.update(universeAssets).set({
      excluded,
      excludeReason: reason || null,
      lastRefreshedAt: /* @__PURE__ */ new Date()
    }).where(eq10(universeAssets.symbol, symbol.toUpperCase()));
    return true;
  }
  async markPennyStock(symbol, isPennyStock) {
    await db.update(universeAssets).set({
      isPennyStock,
      excluded: isPennyStock,
      excludeReason: isPennyStock ? "Penny stock (price < $5)" : null,
      lastRefreshedAt: /* @__PURE__ */ new Date()
    }).where(eq10(universeAssets.symbol, symbol.toUpperCase()));
    return true;
  }
  async updatePennyStockFlags(prices) {
    let updated = 0;
    for (const [symbol, price] of Object.entries(prices)) {
      const isPenny = price < PENNY_STOCK_THRESHOLD2;
      await this.markPennyStock(symbol, isPenny);
      if (isPenny) updated++;
    }
    return updated;
  }
  async getTradableSymbols() {
    const assets = await this.getAssets({ tradableOnly: true });
    return assets.map((a) => a.symbol);
  }
  async isSymbolTradable(symbol) {
    const asset = await this.getAssetBySymbol(symbol);
    if (!asset) return false;
    return asset.tradable && !asset.excluded;
  }
};
var alpacaUniverseService = new AlpacaUniverseService();

// server/universe/tradingEnforcement.ts
init_db();
init_schema();
import { eq as eq11 } from "drizzle-orm";
var TradingEnforcementService = class {
  rejectedAttempts = 0;
  lastCheckedAt = null;
  async canTradeSymbol(symbol, traceId) {
    this.lastCheckedAt = /* @__PURE__ */ new Date();
    const upperSymbol = symbol.toUpperCase();
    try {
      const candidate = await db.query.universeCandidates.findFirst({
        where: eq11(universeCandidates.symbol, upperSymbol)
      });
      if (!candidate) {
        this.rejectedAttempts++;
        console.log(`[ENFORCEMENT] ${traceId || "?"} Symbol ${upperSymbol} NOT in candidates - trade BLOCKED`);
        return {
          symbol: upperSymbol,
          eligible: false,
          reason: "Symbol not in approved candidates list",
          details: { status: "MISSING" }
        };
      }
      if (candidate.status !== "APPROVED") {
        this.rejectedAttempts++;
        console.log(`[ENFORCEMENT] ${traceId || "?"} Symbol ${upperSymbol} status=${candidate.status} - trade BLOCKED`);
        return {
          symbol: upperSymbol,
          eligible: false,
          reason: `Symbol status is ${candidate.status}, not APPROVED`,
          details: {
            status: candidate.status,
            liquidityTier: candidate.tier || void 0,
            approvedAt: null,
            approvedBy: null
          }
        };
      }
      const asset = await db.query.universeAssets.findFirst({
        where: eq11(universeAssets.symbol, upperSymbol)
      });
      if (asset && !asset.tradable) {
        this.rejectedAttempts++;
        console.log(`[ENFORCEMENT] ${traceId || "?"} Symbol ${upperSymbol} marked non-tradable by Alpaca - trade BLOCKED`);
        return {
          symbol: upperSymbol,
          eligible: false,
          reason: "Symbol is marked non-tradable by Alpaca",
          details: { status: candidate.status }
        };
      }
      const liquidity = await db.query.universeLiquidityMetrics.findFirst({
        where: eq11(universeLiquidityMetrics.symbol, upperSymbol)
      });
      const isPennyStock = liquidity?.latestPrice && parseFloat(liquidity.latestPrice) < 5;
      if (isPennyStock) {
        this.rejectedAttempts++;
        console.log(`[ENFORCEMENT] ${traceId || "?"} Symbol ${upperSymbol} is a penny stock ($${liquidity?.latestPrice}) - trade BLOCKED`);
        return {
          symbol: upperSymbol,
          eligible: false,
          reason: "Penny stocks (price < $5) are not tradable",
          details: {
            status: candidate.status,
            isPennyStock: true,
            liquidityTier: liquidity?.liquidityTier || void 0
          }
        };
      }
      console.log(`[ENFORCEMENT] ${traceId || "?"} Symbol ${upperSymbol} APPROVED - trade ALLOWED`);
      return {
        symbol: upperSymbol,
        eligible: true,
        reason: "Symbol is approved for trading",
        details: {
          status: candidate.status,
          liquidityTier: candidate.tier || void 0,
          approvedAt: candidate.approvedAt,
          approvedBy: candidate.approvedBy
        }
      };
    } catch (error) {
      console.error(`[ENFORCEMENT] ${traceId || "?"} Error checking ${upperSymbol}:`, error);
      this.rejectedAttempts++;
      return {
        symbol: upperSymbol,
        eligible: false,
        reason: "Error checking trading eligibility"
      };
    }
  }
  async canTradeMultiple(symbols, traceId) {
    const results = /* @__PURE__ */ new Map();
    for (const symbol of symbols) {
      const result = await this.canTradeSymbol(symbol, traceId);
      results.set(symbol.toUpperCase(), result);
    }
    return results;
  }
  async getApprovedSymbolsSet(traceId) {
    try {
      const approved = await db.query.universeCandidates.findMany({
        where: eq11(universeCandidates.status, "APPROVED"),
        columns: { symbol: true }
      });
      console.log(`[ENFORCEMENT] ${traceId || "?"} Retrieved ${approved.length} approved symbols`);
      return new Set(approved.map((c) => c.symbol));
    } catch (error) {
      console.error(`[ENFORCEMENT] ${traceId || "?"} Error getting approved symbols:`, error);
      return /* @__PURE__ */ new Set();
    }
  }
  async filterToApproved(symbols, traceId) {
    const approvedSet = await this.getApprovedSymbolsSet(traceId);
    return symbols.filter((s) => approvedSet.has(s.toUpperCase()));
  }
  async getStats() {
    const approved = await db.query.universeCandidates.findMany({
      where: eq11(universeCandidates.status, "APPROVED"),
      columns: { symbol: true }
    });
    return {
      approvedCount: approved.length,
      rejectedAttempts: this.rejectedAttempts,
      lastCheckedAt: this.lastCheckedAt
    };
  }
  resetStats() {
    this.rejectedAttempts = 0;
    this.lastCheckedAt = null;
  }
};
var tradingEnforcementService = new TradingEnforcementService();

// server/universe/allocationService.ts
init_db();
init_schema();
init_alpaca();
import { eq as eq12, and as and11, desc as desc7, sql as sql9 } from "drizzle-orm";
var AllocationService = class {
  async getActivePolicy() {
    const policy = await db.query.allocationPolicies.findFirst({
      where: eq12(allocationPolicies.isActive, true)
    });
    return policy ?? null;
  }
  async getPolicyById(id) {
    const policy = await db.query.allocationPolicies.findFirst({
      where: eq12(allocationPolicies.id, id)
    });
    return policy ?? null;
  }
  async listPolicies() {
    return db.query.allocationPolicies.findMany({
      orderBy: [desc7(allocationPolicies.createdAt)]
    });
  }
  async createPolicy(data) {
    if (data.isActive) {
      await db.update(allocationPolicies).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(allocationPolicies.isActive, true));
    }
    const [policy] = await db.insert(allocationPolicies).values(data).returning();
    return policy;
  }
  async updatePolicy(id, data) {
    if (data.isActive === true) {
      await db.update(allocationPolicies).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(and11(
        eq12(allocationPolicies.isActive, true),
        sql9`${allocationPolicies.id} != ${id}`
      ));
    }
    const [updated] = await db.update(allocationPolicies).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).returning().where(eq12(allocationPolicies.id, id));
    return updated || null;
  }
  async activatePolicy(id) {
    return this.updatePolicy(id, { isActive: true });
  }
  async deactivatePolicy(id) {
    return this.updatePolicy(id, { isActive: false });
  }
  async analyzeRebalance(traceId) {
    const policy = await this.getActivePolicy();
    if (!policy) {
      console.log(`[ALLOCATION] ${traceId} No active policy found`);
      return null;
    }
    const [account, positions2] = await Promise.all([
      alpaca.getAccount(),
      alpaca.getPositions()
    ]);
    const portfolioValue = parseFloat(account.equity);
    console.log(`[ALLOCATION] ${traceId} Portfolio value: $${portfolioValue.toFixed(2)}`);
    const currentPositions = /* @__PURE__ */ new Map();
    for (const pos of positions2) {
      const marketValue = parseFloat(pos.market_value);
      currentPositions.set(pos.symbol, {
        qty: parseFloat(pos.qty),
        marketValue,
        weightPct: marketValue / portfolioValue * 100
      });
    }
    const approved = await db.query.universeCandidates.findMany({
      where: eq12(universeCandidates.status, "APPROVED")
    });
    const approvedSymbols = approved.map((c) => c.symbol);
    const minTier = policy.minLiquidityTier || "B";
    const tierOrder = ["A", "B", "C"];
    const eligibleSymbols = [];
    for (const candidate of approved) {
      if (!candidate.tier) continue;
      const candidateTierIdx = tierOrder.indexOf(candidate.tier);
      const minTierIdx = tierOrder.indexOf(minTier);
      if (candidateTierIdx <= minTierIdx) {
        eligibleSymbols.push(candidate.symbol);
      }
    }
    const maxWeight = parseFloat(policy.maxPositionWeightPct || "8");
    const rotationTopN = policy.rotationTopN || 10;
    const profitThreshold = parseFloat(policy.profitTakingThresholdPct || "20") / 100;
    const overweightThreshold = parseFloat(policy.overweightThresholdPct || "50") / 100;
    const profitTakingCandidates = [];
    const overweightPositions = [];
    for (const [symbol, pos] of currentPositions) {
      if (pos.weightPct > maxWeight * (1 + overweightThreshold)) {
        overweightPositions.push(symbol);
      }
    }
    const targetPositions = [];
    const numPositions = Math.min(eligibleSymbols.length, rotationTopN);
    const equalWeight = numPositions > 0 ? Math.min(100 / numPositions, maxWeight) : 0;
    for (const symbol of eligibleSymbols.slice(0, rotationTopN)) {
      const current = currentPositions.get(symbol);
      targetPositions.push({
        symbol,
        targetWeightPct: equalWeight,
        currentWeightPct: current?.weightPct || 0,
        reason: "Approved high-quality candidate"
      });
    }
    const intents = [];
    for (const target of targetPositions) {
      const delta = target.targetWeightPct - target.currentWeightPct;
      const notionalDelta = delta / 100 * portfolioValue;
      if (Math.abs(delta) < 0.5) {
        intents.push({
          symbol: target.symbol,
          action: "HOLD",
          targetWeightPct: target.targetWeightPct,
          currentWeightPct: target.currentWeightPct,
          notionalDelta: 0,
          reason: "Within tolerance"
        });
      } else if (delta > 0) {
        intents.push({
          symbol: target.symbol,
          action: "BUY",
          targetWeightPct: target.targetWeightPct,
          currentWeightPct: target.currentWeightPct,
          notionalDelta,
          reason: "Underweight vs target"
        });
      } else {
        intents.push({
          symbol: target.symbol,
          action: "TRIM",
          targetWeightPct: target.targetWeightPct,
          currentWeightPct: target.currentWeightPct,
          notionalDelta,
          reason: "Overweight vs target"
        });
      }
    }
    for (const [symbol, pos] of currentPositions) {
      if (!approvedSymbols.includes(symbol)) {
        intents.push({
          symbol,
          action: "SELL",
          targetWeightPct: 0,
          currentWeightPct: pos.weightPct,
          notionalDelta: -pos.marketValue,
          reason: "Position not in approved list - sell to exit"
        });
      }
    }
    console.log(`[ALLOCATION] ${traceId} Analysis complete: ${intents.length} intents generated`);
    return {
      policy,
      portfolioValue,
      approvedSymbols,
      currentPositions,
      targetPositions,
      intents,
      profitTakingCandidates,
      rotationCandidates: eligibleSymbols.slice(0, rotationTopN)
    };
  }
  async createRebalanceRun(data) {
    const [run] = await db.insert(rebalanceRuns).values(data).returning();
    return run;
  }
  async getRebalanceRuns(limit4 = 20) {
    return db.query.rebalanceRuns.findMany({
      orderBy: [desc7(rebalanceRuns.startedAt)],
      limit: limit4
    });
  }
  async getRebalanceRunById(id) {
    const run = await db.query.rebalanceRuns.findFirst({
      where: eq12(rebalanceRuns.id, id)
    });
    return run ?? null;
  }
  async updateRebalanceRun(id, data) {
    const [updated] = await db.update(rebalanceRuns).set(data).returning().where(eq12(rebalanceRuns.id, id));
    return updated || null;
  }
  async getStats() {
    const [policies, activePolicy, runs] = await Promise.all([
      db.query.allocationPolicies.findMany(),
      this.getActivePolicy(),
      db.query.rebalanceRuns.findMany({
        orderBy: [desc7(rebalanceRuns.startedAt)],
        limit: 10
      })
    ]);
    return {
      totalPolicies: policies.length,
      activePolicyId: activePolicy?.id || null,
      activePolicyName: activePolicy?.name || null,
      recentRuns: runs.length,
      lastRunAt: runs[0]?.startedAt || null
    };
  }
};
var allocationService = new AllocationService();

// server/universe/rebalancerService.ts
init_db();
init_schema();
import { desc as desc8 } from "drizzle-orm";
init_alpaca();
var RebalancerService = class {
  async executeDryRun(traceId) {
    console.log(`[REBALANCER] ${traceId} Starting dry run analysis`);
    const analysis = await allocationService.analyzeRebalance(traceId);
    if (!analysis) {
      console.log(`[REBALANCER] ${traceId} No active policy - cannot analyze`);
      return null;
    }
    const profitTaking = await this.analyzeProfitTaking(analysis.policy, traceId);
    let wouldSubmit = 0;
    let wouldSkip = 0;
    for (const intent of analysis.intents) {
      if (intent.action === "HOLD") {
        wouldSkip++;
        continue;
      }
      const enforcement = await tradingEnforcementService.canTradeSymbol(intent.symbol, traceId);
      if (intent.action === "SELL" || enforcement.eligible) {
        wouldSubmit++;
      } else {
        wouldSkip++;
      }
    }
    console.log(`[REBALANCER] ${traceId} Dry run complete: would submit ${wouldSubmit}, would skip ${wouldSkip}`);
    return {
      analysis,
      profitTaking,
      wouldSubmit,
      wouldSkip
    };
  }
  async executeRebalance(traceId, dryRun = false) {
    const startTime = Date.now();
    console.log(`[REBALANCER] ${traceId} Starting rebalance execution (dryRun=${dryRun})`);
    const analysis = await allocationService.analyzeRebalance(traceId);
    if (!analysis) {
      return {
        runId: "",
        traceId,
        success: false,
        intentsGenerated: 0,
        ordersSubmitted: 0,
        ordersSkipped: 0,
        errors: ["No active allocation policy configured"],
        duration: Date.now() - startTime
      };
    }
    const run = await allocationService.createRebalanceRun({
      policyId: analysis.policy.id,
      traceId,
      status: "pending",
      triggerType: dryRun ? "manual_dry_run" : "manual",
      inputSnapshot: {
        portfolioValue: analysis.portfolioValue,
        approvedSymbolCount: analysis.approvedSymbols.length,
        currentPositionCount: analysis.currentPositions.size
      },
      orderIntents: analysis.intents
    });
    if (dryRun) {
      await allocationService.updateRebalanceRun(run.id, {
        status: "dry_run_complete",
        completedAt: /* @__PURE__ */ new Date(),
        rationale: `Dry run: ${analysis.intents.length} intents generated, no orders submitted`
      });
      return {
        runId: run.id,
        traceId,
        success: true,
        intentsGenerated: analysis.intents.length,
        ordersSubmitted: 0,
        ordersSkipped: analysis.intents.length,
        errors: [],
        duration: Date.now() - startTime
      };
    }
    await allocationService.updateRebalanceRun(run.id, { status: "executing" });
    const errors = [];
    let ordersSubmitted = 0;
    let ordersSkipped = 0;
    const executedOrders = [];
    const sellIntents = analysis.intents.filter((i) => i.action === "SELL" || i.action === "TRIM");
    const buyIntents = analysis.intents.filter((i) => i.action === "BUY");
    for (const intent of sellIntents) {
      if (Math.abs(intent.notionalDelta) < 10) {
        ordersSkipped++;
        continue;
      }
      try {
        const enforcement = await tradingEnforcementService.canTradeSymbol(intent.symbol, traceId);
        if (intent.action === "SELL" || enforcement.eligible) {
          const currentPos = analysis.currentPositions.get(intent.symbol);
          if (!currentPos) {
            ordersSkipped++;
            continue;
          }
          const sellValue = Math.abs(intent.notionalDelta);
          let price = 0;
          try {
            const snapshots = await alpaca.getSnapshots([intent.symbol]);
            const snapshot = snapshots?.[intent.symbol];
            price = snapshot?.latestTrade?.p || snapshot?.latestQuote?.ap || 0;
          } catch (e) {
            console.warn(`[REBALANCER] ${traceId} Failed to get snapshot for ${intent.symbol}`);
          }
          if (!price || price <= 0 || !isFinite(price)) {
            errors.push(`${intent.symbol}: Could not get valid price`);
            ordersSkipped++;
            continue;
          }
          const rawQtyToSell = Math.floor(sellValue / price);
          const qtyToSell = Math.min(rawQtyToSell, currentPos.qty);
          if (qtyToSell < 1) {
            ordersSkipped++;
            continue;
          }
          const idempotencyKey = generateIdempotencyKey({
            strategyId: `rebalance-${run.id}`,
            symbol: intent.symbol,
            side: "sell"
          });
          const workItem = await workQueue.enqueue({
            type: "ORDER_SUBMIT",
            symbol: intent.symbol,
            idempotencyKey,
            payload: JSON.stringify({
              symbol: intent.symbol,
              side: "sell",
              qty: qtyToSell.toString(),
              type: "market",
              time_in_force: "day",
              traceId
            }),
            maxAttempts: 3
          });
          executedOrders.push({ symbol: intent.symbol, workItemId: workItem.id, side: "sell" });
          ordersSubmitted++;
        } else {
          ordersSkipped++;
        }
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        errors.push(`${intent.symbol}: ${msg}`);
        ordersSkipped++;
      }
    }
    for (const intent of buyIntents) {
      if (!intent.notionalDelta || !isFinite(intent.notionalDelta) || intent.notionalDelta < 10) {
        ordersSkipped++;
        continue;
      }
      try {
        const enforcement = await tradingEnforcementService.canTradeSymbol(intent.symbol, traceId);
        if (!enforcement.eligible) {
          console.log(`[REBALANCER] ${traceId} Skipping BUY ${intent.symbol}: ${enforcement.reason}`);
          ordersSkipped++;
          continue;
        }
        const idempotencyKey = generateIdempotencyKey({
          strategyId: `rebalance-${run.id}`,
          symbol: intent.symbol,
          side: "buy"
        });
        const workItem = await workQueue.enqueue({
          type: "ORDER_SUBMIT",
          symbol: intent.symbol,
          idempotencyKey,
          payload: JSON.stringify({
            symbol: intent.symbol,
            side: "buy",
            notional: intent.notionalDelta.toFixed(2),
            type: "market",
            time_in_force: "day",
            traceId
          }),
          maxAttempts: 3
        });
        executedOrders.push({ symbol: intent.symbol, workItemId: workItem.id, side: "buy" });
        ordersSubmitted++;
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        errors.push(`${intent.symbol}: ${msg}`);
        ordersSkipped++;
      }
    }
    const holdIntents = analysis.intents.filter((i) => i.action === "HOLD").length;
    ordersSkipped += holdIntents;
    const finalStatus = errors.length > 0 ? "completed_with_errors" : "completed";
    await allocationService.updateRebalanceRun(run.id, {
      status: finalStatus,
      completedAt: /* @__PURE__ */ new Date(),
      executedOrders,
      rationale: `Submitted ${ordersSubmitted} orders, skipped ${ordersSkipped}. ${errors.length} errors.`
    });
    console.log(`[REBALANCER] ${traceId} Execution complete: ${ordersSubmitted} orders, ${errors.length} errors`);
    return {
      runId: run.id,
      traceId,
      success: errors.length === 0,
      intentsGenerated: analysis.intents.length,
      ordersSubmitted,
      ordersSkipped,
      errors,
      duration: Date.now() - startTime
    };
  }
  async analyzeProfitTaking(policy, traceId) {
    if (!policy) return [];
    const profitThreshold = parseFloat(policy.profitTakingThresholdPct || "20") / 100;
    const positions2 = await alpaca.getPositions();
    const results = [];
    for (const pos of positions2) {
      const costBasis = parseFloat(pos.cost_basis);
      const currentValue = parseFloat(pos.market_value);
      const unrealizedPnlPct = (currentValue - costBasis) / costBasis;
      if (unrealizedPnlPct >= profitThreshold) {
        const excessGain = unrealizedPnlPct - profitThreshold;
        const recommendedTrimPct = Math.min(excessGain * 50, 25);
        results.push({
          symbol: pos.symbol,
          costBasis,
          currentValue,
          unrealizedPnlPct: unrealizedPnlPct * 100,
          recommendedTrimPct,
          reason: `Gain of ${(unrealizedPnlPct * 100).toFixed(1)}% exceeds ${(profitThreshold * 100).toFixed(0)}% threshold`
        });
      }
    }
    console.log(`[REBALANCER] ${traceId} Profit-taking analysis: ${results.length} candidates`);
    return results;
  }
  async getStats() {
    const runs = await db.query.rebalanceRuns.findMany({
      orderBy: [desc8(rebalanceRuns.startedAt)],
      limit: 20
    });
    const successfulRuns = runs.filter((r) => r.status === "completed").length;
    const totalOrders = runs.reduce((sum, r) => {
      const orders2 = r.executedOrders;
      return sum + (Array.isArray(orders2) ? orders2.length : 0);
    }, 0);
    return {
      recentRuns: runs.length,
      successfulRuns,
      totalOrdersSubmitted: totalOrders,
      lastRunAt: runs[0]?.startedAt || null,
      lastRunStatus: runs[0]?.status || null
    };
  }
};
var rebalancerService = new RebalancerService();

// server/trading/smart-order-router.ts
init_logger();
init_trading_session_manager();
var DEFAULT_CONFIG = {
  buyBufferPercent: 0.3,
  sellBufferPercent: 0.3,
  aggressiveLimitBufferPercent: 0.5,
  autoUpgradeMarketToLimit: true,
  forceExtendedHoursDayTIF: true,
  enablePriceValidation: true
};
var SmartOrderRouter = class {
  config;
  constructor(config) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }
  /**
   * Main transformation function - ensures order will not be rejected
   */
  transformOrderForExecution(order, currentPrice, sessionOverride) {
    const transformations = [];
    const warnings = [];
    const isCrypto = this.isCryptoSymbol(order.symbol);
    const session = sessionOverride || this.detectMarketSession(order.symbol);
    log.debug("SmartOrderRouter", "Transforming order", {
      symbol: order.symbol,
      side: order.side,
      type: order.type,
      session,
      isCrypto
    });
    let transformedOrder = { ...order };
    const isExtendedHours = this.isExtendedHoursSession(session);
    const needsExtendedHours = isExtendedHours && !isCrypto;
    const orderType = this.selectOrderType(
      order,
      session,
      isCrypto,
      transformations
    );
    transformedOrder.type = orderType;
    if (this.needsLimitPrice(orderType, needsExtendedHours)) {
      const limitPrice = this.calculateLimitPrice(
        order,
        currentPrice,
        session,
        transformations,
        warnings
      );
      if (limitPrice) {
        transformedOrder.limitPrice = limitPrice;
      }
    }
    const timeInForce = this.selectTimeInForce(
      { ...transformedOrder, type: orderType },
      session,
      isCrypto,
      needsExtendedHours,
      transformations
    );
    transformedOrder.timeInForce = timeInForce;
    transformedOrder.extendedHours = needsExtendedHours;
    if (needsExtendedHours && !order.extendedHours) {
      transformations.push(`Set extended_hours=true for ${session} session`);
    }
    if (this.config.enablePriceValidation && transformedOrder.limitPrice) {
      this.validateLimitPrice(
        { ...transformedOrder, type: orderType, limitPrice: transformedOrder.limitPrice },
        currentPrice,
        warnings
      );
    }
    if (transformedOrder.orderClass === "bracket") {
      if (transformedOrder.timeInForce !== "day") {
        transformedOrder.timeInForce = "day";
        transformations.push("Forced bracket order TIF to 'day' (Alpaca requirement)");
      }
      if (session !== "regular" && !isCrypto) {
        warnings.push("Bracket orders only recommended during regular hours");
      }
    }
    this.finalValidation(
      { ...transformedOrder, type: orderType, timeInForce },
      session,
      isCrypto,
      warnings
    );
    return {
      ...transformedOrder,
      type: transformedOrder.type,
      timeInForce: transformedOrder.timeInForce,
      extendedHours: transformedOrder.extendedHours || false,
      transformations,
      warnings,
      session,
      isCrypto
    };
  }
  /**
   * Detect if symbol is cryptocurrency
   */
  isCryptoSymbol(symbol) {
    const upperSymbol = symbol.toUpperCase();
    const cryptoPatterns = [
      /BTC/,
      /ETH/,
      /DOGE/,
      /SOL/,
      /ADA/,
      /MATIC/,
      /AVAX/,
      /LTC/,
      /BCH/,
      /XRP/,
      /DOT/,
      /LINK/,
      /UNI/,
      /AAVE/,
      /\/USD$/,
      /\/USDT$/,
      /\/USDC$/
      // Trading pairs
    ];
    return cryptoPatterns.some((pattern) => pattern.test(upperSymbol));
  }
  /**
   * Detect current market session for a symbol
   */
  detectMarketSession(symbol) {
    const isCrypto = this.isCryptoSymbol(symbol);
    if (isCrypto) {
      return "regular";
    }
    const exchange = tradingSessionManager.detectExchange(symbol);
    const sessionInfo = tradingSessionManager.getCurrentSession(exchange);
    return sessionInfo.session;
  }
  /**
   * Check if session is extended hours
   */
  isExtendedHoursSession(session) {
    return session === "pre_market" || session === "after_hours";
  }
  /**
   * Auto-select the correct order type based on session and conditions
   */
  selectOrderType(order, session, isCrypto, transformations) {
    const requestedType = order.type || "market";
    if (session === "closed" && !isCrypto) {
      if (requestedType === "market") {
        transformations.push("Upgraded market order to limit (market closed)");
        return "limit";
      }
      return requestedType;
    }
    if (this.isExtendedHoursSession(session) && !isCrypto) {
      if (requestedType === "market" && this.config.autoUpgradeMarketToLimit) {
        transformations.push(`Upgraded market to limit order (${session})`);
        return "limit";
      }
      if (requestedType === "stop") {
        transformations.push(`Upgraded stop to stop_limit (${session})`);
        return "stop_limit";
      }
      if (requestedType === "trailing_stop") {
        transformations.push(`Changed trailing_stop to limit (not supported in ${session})`);
        return "limit";
      }
      if (!["limit", "stop_limit"].includes(requestedType)) {
        transformations.push(`Forced to limit order (${session} restriction)`);
        return "limit";
      }
    }
    return requestedType;
  }
  /**
   * Check if order needs a limit price
   */
  needsLimitPrice(orderType, needsExtendedHours) {
    if (orderType === "limit" || orderType === "stop_limit") {
      return true;
    }
    if (needsExtendedHours) {
      return true;
    }
    return false;
  }
  /**
   * Calculate appropriate limit price based on side and session
   */
  calculateLimitPrice(order, currentPrice, session, transformations, warnings) {
    if (order.limitPrice) {
      return order.limitPrice;
    }
    const { side } = order;
    const isExtendedHours = this.isExtendedHoursSession(session);
    let bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.buyBufferPercent;
    let calculatedPrice;
    let priceSource;
    if (side === "buy") {
      const basePrice = currentPrice.ask || currentPrice.last;
      bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.buyBufferPercent;
      calculatedPrice = basePrice * (1 + bufferPercent / 100);
      priceSource = currentPrice.ask ? "ask" : "last";
      transformations.push(
        `Auto-calculated buy limit: $${calculatedPrice.toFixed(2)} (${priceSource} + ${bufferPercent}% buffer)`
      );
    } else {
      const basePrice = currentPrice.bid || currentPrice.last;
      bufferPercent = isExtendedHours ? this.config.aggressiveLimitBufferPercent : this.config.sellBufferPercent;
      calculatedPrice = basePrice * (1 - bufferPercent / 100);
      priceSource = currentPrice.bid ? "bid" : "last";
      transformations.push(
        `Auto-calculated sell limit: $${calculatedPrice.toFixed(2)} (${priceSource} - ${bufferPercent}% buffer)`
      );
    }
    if (currentPrice.spread && currentPrice.spread > 0.02) {
      warnings.push(
        `Wide spread detected (${(currentPrice.spread * 100).toFixed(2)}%) - limit price may result in poor fill`
      );
    }
    const decimals = calculatedPrice < 1 ? 4 : 2;
    return calculatedPrice.toFixed(decimals);
  }
  /**
   * Select appropriate time-in-force
   */
  selectTimeInForce(order, session, isCrypto, needsExtendedHours, transformations) {
    const requestedTIF = order.timeInForce || "day";
    const orderType = order.type;
    if (orderType === "market" && requestedTIF === "gtc") {
      transformations.push("Changed market order TIF from 'gtc' to 'day' (not allowed)");
      return "day";
    }
    if (needsExtendedHours && this.config.forceExtendedHoursDayTIF) {
      if (requestedTIF !== "day") {
        transformations.push(`Forced TIF to 'day' for extended hours (${session})`);
      }
      return "day";
    }
    if (order.orderClass === "bracket" && requestedTIF !== "day") {
      transformations.push("Forced bracket order TIF to 'day' (Alpaca requirement)");
      return "day";
    }
    if (session === "closed" && !isCrypto) {
      if (requestedTIF === "ioc" || requestedTIF === "fok") {
        transformations.push("Changed TIF from 'ioc'/'fok' to 'day' (market closed)");
        return "day";
      }
    }
    if (isCrypto && orderType === "market") {
      if (requestedTIF === "gtc") {
        transformations.push("Changed crypto market order TIF from 'gtc' to 'ioc'");
        return "ioc";
      }
    }
    if ((orderType === "stop" || orderType === "trailing_stop") && !["day", "gtc"].includes(requestedTIF)) {
      transformations.push(`Changed ${orderType} TIF to 'day' (only day/gtc allowed)`);
      return "day";
    }
    return requestedTIF;
  }
  /**
   * Validate limit price to warn on potentially bad prices
   */
  validateLimitPrice(order, currentPrice, warnings) {
    const limitPrice = parseFloat(order.limitPrice);
    const marketPrice = currentPrice.last;
    const { side, type } = order;
    if (currentPrice.spread && currentPrice.spread > 0.02) {
      warnings.push(
        `Wide spread detected (${(currentPrice.spread * 100).toFixed(2)}%) - limit price may result in poor fill`
      );
    }
    if (type === "limit") {
      if (side === "buy") {
        if (limitPrice > marketPrice * 1.05) {
          warnings.push(
            `Buy limit $${limitPrice.toFixed(2)} is ${((limitPrice / marketPrice - 1) * 100).toFixed(1)}% above market $${marketPrice.toFixed(2)} - may fill at worse price`
          );
        }
        if (limitPrice < marketPrice * 0.95) {
          warnings.push(
            `Buy limit $${limitPrice.toFixed(2)} is ${((1 - limitPrice / marketPrice) * 100).toFixed(1)}% below market $${marketPrice.toFixed(2)} - may not fill`
          );
        }
      } else {
        if (limitPrice < marketPrice * 0.95) {
          warnings.push(
            `Sell limit $${limitPrice.toFixed(2)} is ${((1 - limitPrice / marketPrice) * 100).toFixed(1)}% below market $${marketPrice.toFixed(2)} - may fill at worse price`
          );
        }
        if (limitPrice > marketPrice * 1.05) {
          warnings.push(
            `Sell limit $${limitPrice.toFixed(2)} is ${((limitPrice / marketPrice - 1) * 100).toFixed(1)}% above market $${marketPrice.toFixed(2)} - may not fill`
          );
        }
      }
    }
  }
  /**
   * Final validation before returning
   */
  finalValidation(order, session, isCrypto, warnings) {
    if (session !== "regular" && !isCrypto && order.qty) {
      const qty = parseFloat(order.qty);
      if (qty < 1 || qty % 1 !== 0) {
        warnings.push(
          "Fractional shares not allowed in extended hours - order may be rejected"
        );
      }
    }
    if (session !== "regular" && !isCrypto && order.notional) {
      warnings.push(
        "Notional orders may not work in extended hours - consider using qty instead"
      );
    }
    if ((order.type === "stop" || order.type === "trailing_stop") && session !== "regular" && !isCrypto) {
      warnings.push(
        `${order.type} orders may not trigger in extended hours`
      );
    }
  }
  /**
   * Update configuration
   */
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    log.info("SmartOrderRouter", "Configuration updated", config);
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return { ...this.config };
  }
};
var smartOrderRouter = new SmartOrderRouter();
function transformOrderForExecution(order, currentPrice, sessionOverride) {
  return smartOrderRouter.transformOrderForExecution(order, currentPrice, sessionOverride);
}
function createPriceData(quote) {
  const bid = quote.bid || quote.last || 0;
  const ask = quote.ask || quote.last || 0;
  const last = quote.last || (bid + ask) / 2;
  const spread = ask && bid ? (ask - bid) / last : 0;
  return {
    bid,
    ask,
    last,
    spread
  };
}

// server/lib/work-queue.ts
import crypto2 from "crypto";
var RETRY_DELAYS_MS = {
  ORDER_SUBMIT: [1e3, 5e3, 15e3],
  ORDER_CANCEL: [1e3, 3e3, 1e4],
  ORDER_SYNC: [5e3, 15e3, 6e4],
  POSITION_CLOSE: [1e3, 5e3, 15e3],
  KILL_SWITCH: [500, 2e3, 5e3],
  DECISION_EVALUATION: [2e3, 1e4, 3e4],
  ASSET_UNIVERSE_SYNC: [6e4, 3e5, 6e5]
};
var TRANSIENT_ERROR_PATTERNS = [
  /timeout/i,
  /network/i,
  /ECONNREFUSED/i,
  /ETIMEDOUT/i,
  /rate.?limit/i,
  /429/,
  /5\d\d/,
  /temporary/i,
  /unavailable/i
];
var PERMANENT_ERROR_PATTERNS = [
  /invalid.*symbol/i,
  /insufficient.*buying/i,
  /account.*blocked/i,
  /not.*tradable/i,
  /market.*closed/i,
  /invalid.*quantity/i,
  /rejected/i,
  /4[0-3]\d/
];
function generateIdempotencyKey(params) {
  const bucket = params.timeframeBucket || Math.floor(Date.now() / 6e4).toString();
  const data = `${params.strategyId}:${params.symbol}:${params.side}:${params.signalHash || ""}:${bucket}`;
  return crypto2.createHash("sha256").update(data).digest("hex").substring(0, 32);
}
function classifyError2(error) {
  const errorStr = error instanceof Error ? error.message : String(error);
  if (PERMANENT_ERROR_PATTERNS.some((p) => p.test(errorStr))) {
    return "permanent";
  }
  if (TRANSIENT_ERROR_PATTERNS.some((p) => p.test(errorStr))) {
    return "transient";
  }
  return "unknown";
}
function calculateNextRunAt(type, attempts) {
  const delays = RETRY_DELAYS_MS[type] || [5e3, 15e3, 6e4];
  const delayIndex = Math.min(attempts, delays.length - 1);
  const baseDelay = delays[delayIndex];
  const jitter = Math.random() * baseDelay * 0.2;
  return new Date(Date.now() + baseDelay + jitter);
}
var WorkQueueServiceImpl = class {
  workerInterval = null;
  processing = false;
  async enqueue(item) {
    if (item.idempotencyKey) {
      const existing = await this.getByIdempotencyKey(item.idempotencyKey);
      if (existing) {
        log.info("work-queue", `Duplicate work item detected: ${item.idempotencyKey}`);
        return existing;
      }
    }
    return storage.createWorkItem(item);
  }
  async claimNext(types) {
    return storage.claimNextWorkItem(types);
  }
  async markSucceeded(id, result) {
    await storage.updateWorkItem(id, {
      status: "SUCCEEDED",
      result: result || null,
      updatedAt: /* @__PURE__ */ new Date()
    });
  }
  async markFailed(id, error, retryable = true) {
    const item = await storage.getWorkItem(id);
    if (!item) return;
    const newAttempts = item.attempts + 1;
    const maxAttempts = item.maxAttempts || 3;
    if (!retryable || newAttempts >= maxAttempts) {
      await storage.updateWorkItem(id, {
        status: "DEAD_LETTER",
        lastError: error,
        attempts: newAttempts,
        updatedAt: /* @__PURE__ */ new Date()
      });
    } else {
      const nextRunAt = calculateNextRunAt(item.type, newAttempts);
      await storage.updateWorkItem(id, {
        status: "PENDING",
        lastError: error,
        attempts: newAttempts,
        nextRunAt,
        updatedAt: /* @__PURE__ */ new Date()
      });
    }
  }
  async markDeadLetter(id, reason) {
    await storage.updateWorkItem(id, {
      status: "DEAD_LETTER",
      lastError: reason,
      updatedAt: /* @__PURE__ */ new Date()
    });
  }
  async invalidateWorkItem(id, reason) {
    const item = await storage.getWorkItem(id);
    if (!item) {
      log.warn("work-queue", `Cannot invalidate work item ${id}: not found`);
      return;
    }
    log.info("work-queue", `Invalidating work item ${id}: ${reason}`, {
      originalStatus: item.status,
      symbol: item.symbol,
      idempotencyKey: item.idempotencyKey
    });
    await storage.updateWorkItem(id, {
      status: "DEAD_LETTER",
      lastError: `INVALIDATED: ${reason}`,
      idempotencyKey: `invalidated-${id}-${Date.now()}`,
      // Change the key so new orders don't match
      updatedAt: /* @__PURE__ */ new Date()
    });
  }
  async getById(id) {
    const item = await storage.getWorkItem(id);
    return item || null;
  }
  async getByIdempotencyKey(key) {
    return storage.getWorkItemByIdempotencyKey(key);
  }
  async getPendingCount(type) {
    return storage.getWorkItemCount("PENDING", type);
  }
  async getRecentItems(limit4 = 50, status) {
    return storage.getWorkItems(limit4, status);
  }
  async retryDeadLetter(id) {
    const item = await storage.getWorkItem(id);
    if (!item || item.status !== "DEAD_LETTER") return null;
    await storage.updateWorkItem(id, {
      status: "PENDING",
      attempts: 0,
      nextRunAt: /* @__PURE__ */ new Date(),
      lastError: null,
      updatedAt: /* @__PURE__ */ new Date()
    });
    const updated = await storage.getWorkItem(id);
    return updated || null;
  }
  async processOrderSubmit(item) {
    const payload = JSON.parse(item.payload || "{}");
    const {
      symbol,
      side,
      qty,
      notional,
      type,
      time_in_force,
      limit_price,
      stop_price,
      extended_hours,
      order_class,
      take_profit_limit_price,
      stop_loss_stop_price,
      // Also extract nested objects for bracket orders (orchestrator sends nested format)
      take_profit,
      stop_loss,
      traceId
    } = payload;
    const effectiveTakeProfitLimitPrice = take_profit_limit_price || take_profit?.limit_price;
    const effectiveStopLossStopPrice = stop_loss_stop_price || stop_loss?.stop_price;
    log.info("work-queue", `Processing ORDER_SUBMIT for ${symbol} ${side}`, {
      traceId,
      workItemId: item.id,
      symbol,
      side
    });
    if (side !== "sell") {
      const enforcementCheck = await tradingEnforcementService.canTradeSymbol(symbol, traceId);
      if (!enforcementCheck.eligible) {
        log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - Trading enforcement rejected`, {
          traceId,
          workItemId: item.id,
          symbol,
          side,
          qty,
          notional,
          orderType: type,
          reason: "TRADING_ENFORCEMENT_BLOCKED",
          enforcementReason: enforcementCheck.reason,
          blockCategory: "SYMBOL_NOT_APPROVED",
          suggestion: "Add symbol to approved candidates list or ensure it passes universe eligibility"
        });
        await this.markFailed(
          item.id,
          `Symbol ${symbol} blocked by trading enforcement: ${enforcementCheck.reason}`,
          false
        );
        return;
      }
    } else {
      log.info("work-queue", `Bypassing enforcement check for SELL order on ${symbol}`, { traceId });
    }
    const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
    if (!tradabilityCheck.tradable) {
      log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - Symbol not tradable`, {
        traceId,
        workItemId: item.id,
        symbol,
        side,
        qty,
        notional,
        orderType: type,
        reason: "SYMBOL_NOT_TRADABLE",
        tradabilityReason: tradabilityCheck.reason,
        blockCategory: "BROKER_UNIVERSE",
        suggestion: "Symbol may not be in Alpaca universe or may be a penny stock (<$5)"
      });
      await this.markFailed(
        item.id,
        `Symbol ${symbol} is not tradable: ${tradabilityCheck.reason || "Not found in broker universe"}`,
        false
      );
      return;
    }
    const isCrypto = symbol.includes("/") || ["BTC", "ETH", "SOL", "DOGE", "SHIB", "AVAX"].some((c) => symbol.toUpperCase().startsWith(c));
    let currentPriceData = { bid: 0, ask: 0, last: 0, spread: 0 };
    try {
      if (!isCrypto) {
        const snapshots = await alpaca.getSnapshots([symbol]);
        const snapshot = snapshots[symbol];
        if (snapshot?.latestTrade?.p) {
          const lastPrice = snapshot.latestTrade.p;
          const bidPrice = snapshot.latestQuote?.bp || lastPrice * 0.999;
          const askPrice = snapshot.latestQuote?.ap || lastPrice * 1.001;
          currentPriceData = createPriceData({ bid: bidPrice, ask: askPrice, last: lastPrice });
        }
      } else {
        const cryptoSnapshots = await alpaca.getCryptoSnapshots([symbol]);
        const snapshot = cryptoSnapshots[symbol];
        if (snapshot?.latestTrade?.p) {
          const lastPrice = snapshot.latestTrade.p;
          currentPriceData = createPriceData({ bid: lastPrice * 0.999, ask: lastPrice * 1.001, last: lastPrice });
        }
      }
    } catch (priceError) {
      log.warn("work-queue", `Failed to fetch price for ${symbol}, using market order if possible`, { traceId, error: String(priceError) });
    }
    const orderInput = {
      symbol,
      side,
      qty,
      notional,
      type: type || "market",
      timeInForce: time_in_force || "day",
      limitPrice: limit_price?.toString(),
      stopPrice: stop_price?.toString(),
      extendedHours: extended_hours,
      orderClass: order_class,
      takeProfitLimitPrice: effectiveTakeProfitLimitPrice?.toString(),
      stopLossStopPrice: effectiveStopLossStopPrice?.toString()
    };
    const transformedOrder = transformOrderForExecution(orderInput, currentPriceData);
    if (transformedOrder.transformations.length > 0) {
      log.info("work-queue", `ORDER_TRANSFORMED: ${symbol} - ${transformedOrder.transformations.length} changes applied`, {
        traceId,
        workItemId: item.id,
        symbol,
        side,
        originalType: type || "market",
        newType: transformedOrder.type,
        originalTIF: time_in_force || "day",
        newTIF: transformedOrder.timeInForce,
        limitPrice: transformedOrder.limitPrice,
        extendedHours: transformedOrder.extendedHours,
        session: transformedOrder.session,
        transformations: transformedOrder.transformations
      });
    }
    if (transformedOrder.warnings.length > 0) {
      log.warn("work-queue", `ORDER_WARNINGS: ${symbol} - ${transformedOrder.warnings.length} warnings`, {
        traceId,
        workItemId: item.id,
        symbol,
        warnings: transformedOrder.warnings
      });
    }
    const baseClientOrderId = item.idempotencyKey || item.id;
    const clientOrderId = `${baseClientOrderId.substring(0, 20)}-${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 6)}`;
    const existingOrders = await alpaca.getOrders("open", 100);
    const existingOrder = existingOrders.find((o) => o.client_order_id === clientOrderId || o.client_order_id === baseClientOrderId);
    if (existingOrder) {
      log.info("work-queue", `Order already exists for client_order_id ${clientOrderId}: ${existingOrder.id}`, { traceId });
      await storage.updateWorkItem(item.id, {
        brokerOrderId: existingOrder.id,
        result: JSON.stringify({ orderId: existingOrder.id, status: existingOrder.status })
      });
      await this.markSucceeded(item.id, JSON.stringify({ orderId: existingOrder.id, deduplicated: true }));
      return;
    }
    let validatedQty = transformedOrder.qty;
    let validatedNotional = transformedOrder.notional;
    if (side === "sell" && validatedQty) {
      try {
        const positions2 = await alpaca.getPositions();
        const position = positions2.find((p) => p.symbol === symbol);
        if (!position) {
          log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - No position found to sell`, {
            traceId,
            workItemId: item.id,
            requestedQty: validatedQty
          });
          await this.markFailed(item.id, `No position found for ${symbol} - cannot sell`, false);
          return;
        }
        const availableQty = parseFloat(position.qty_available || position.qty || "0");
        const requestedQty = parseFloat(validatedQty);
        const heldForOrders = parseFloat(position.qty) - availableQty;
        log.info("work-queue", `Position validation for ${symbol}`, {
          traceId,
          requestedQty,
          availableQty,
          totalQty: position.qty,
          heldForOrders: heldForOrders.toString()
        });
        if (availableQty <= 0) {
          log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - No available shares (all held for other orders)`, {
            traceId,
            workItemId: item.id,
            availableQty,
            heldForOrders: heldForOrders.toString()
          });
          await this.markFailed(item.id, `No available shares for ${symbol} (${availableQty} available, rest held for orders)`, false);
          return;
        }
        if (requestedQty > availableQty) {
          log.warn("work-queue", `ORDER_QTY_ADJUSTED: ${symbol} - Clamping qty from ${requestedQty} to ${availableQty}`, {
            traceId,
            workItemId: item.id,
            originalQty: requestedQty,
            clampedQty: availableQty
          });
        }
        let finalQty = Math.min(requestedQty, availableQty);
        if (transformedOrder.extendedHours) {
          const wholeQty = Math.floor(finalQty);
          if (wholeQty <= 0) {
            log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - Fractional shares cannot trade in extended hours`, {
              traceId,
              workItemId: item.id,
              availableQty: finalQty,
              session: transformedOrder.session
            });
            await this.markFailed(item.id, `Cannot sell fractional shares (${finalQty}) during extended hours`, false);
            return;
          }
          if (wholeQty < finalQty) {
            log.info("work-queue", `ORDER_QTY_ROUNDED: ${symbol} - Rounding down from ${finalQty} to ${wholeQty} for extended hours`, {
              traceId,
              workItemId: item.id
            });
          }
          finalQty = wholeQty;
        }
        validatedQty = finalQty.toString();
      } catch (posError) {
        log.error("work-queue", `Position validation failed for ${symbol}: ${posError.message}`, { traceId });
      }
    }
    if (side === "buy" && validatedNotional && transformedOrder.extendedHours && currentPriceData.last > 0) {
      try {
        const requestedNotional = parseFloat(validatedNotional);
        const estimatedShares = requestedNotional / currentPriceData.last;
        if (estimatedShares < 1) {
          log.warn("work-queue", `ORDER_BLOCKED: ${symbol} - Notional too small for whole share in extended hours`, {
            traceId,
            workItemId: item.id,
            notional: requestedNotional,
            estimatedShares,
            price: currentPriceData.last
          });
          await this.markFailed(item.id, `Notional $${requestedNotional} too small for 1 share at $${currentPriceData.last}`, false);
          return;
        }
      } catch (validationError4) {
        log.warn("work-queue", `Extended hours validation failed: ${validationError4.message}`, { traceId });
      }
    }
    const orderParams = {
      symbol,
      side,
      type: transformedOrder.type,
      time_in_force: transformedOrder.timeInForce,
      client_order_id: clientOrderId
    };
    if (validatedQty) orderParams.qty = validatedQty;
    if (validatedNotional) orderParams.notional = validatedNotional;
    if (transformedOrder.limitPrice) orderParams.limit_price = transformedOrder.limitPrice;
    if (stop_price) orderParams.stop_price = stop_price;
    if (transformedOrder.extendedHours) orderParams.extended_hours = transformedOrder.extendedHours;
    if (transformedOrder.orderClass) {
      orderParams.order_class = transformedOrder.orderClass;
      if (transformedOrder.orderClass === "bracket") {
        if (transformedOrder.takeProfitLimitPrice) {
          orderParams.take_profit = { limit_price: transformedOrder.takeProfitLimitPrice };
        }
        if (transformedOrder.stopLossStopPrice) {
          orderParams.stop_loss = { stop_price: transformedOrder.stopLossStopPrice };
        }
      }
    }
    log.info("work-queue", `Submitting order to Alpaca`, {
      traceId,
      workItemId: item.id,
      symbol,
      type: orderParams.type,
      timeInForce: orderParams.time_in_force,
      limitPrice: orderParams.limit_price,
      extendedHours: orderParams.extended_hours,
      session: transformedOrder.session
    });
    const order = await alpaca.createOrder(orderParams);
    log.info("work-queue", `ORDER_SUBMIT succeeded: ${order.id}`, {
      traceId,
      workItemId: item.id,
      orderId: order.id,
      status: order.status
    });
    const orderData = {
      broker: "alpaca",
      brokerOrderId: order.id,
      clientOrderId,
      symbol,
      side,
      // Use VALIDATED values that were actually submitted
      type: transformedOrder.type,
      timeInForce: transformedOrder.timeInForce,
      qty: validatedQty?.toString(),
      notional: validatedNotional?.toString(),
      limitPrice: transformedOrder.limitPrice?.toString(),
      stopPrice: stop_price?.toString(),
      status: order.status,
      // Capture extended_hours and order_class from Alpaca response
      extendedHours: order.extended_hours || transformedOrder.extendedHours || false,
      orderClass: order.order_class || transformedOrder.orderClass || "simple",
      submittedAt: new Date(order.submitted_at || Date.now()),
      updatedAt: /* @__PURE__ */ new Date(),
      filledAt: order.filled_at ? new Date(order.filled_at) : void 0,
      expiredAt: order.expired_at ? new Date(order.expired_at) : void 0,
      canceledAt: order.canceled_at ? new Date(order.canceled_at) : void 0,
      failedAt: order.failed_at ? new Date(order.failed_at) : void 0,
      filledQty: order.filled_qty?.toString(),
      filledAvgPrice: order.filled_avg_price?.toString(),
      traceId,
      workItemId: item.id,
      rawJson: order
    };
    await storage.upsertOrderByBrokerOrderId(order.id, orderData);
    await storage.updateWorkItem(item.id, { brokerOrderId: order.id });
    await this.markSucceeded(item.id, JSON.stringify({ orderId: order.id, status: order.status }));
  }
  async processOrderCancel(item) {
    const payload = JSON.parse(item.payload || "{}");
    const { orderId } = payload;
    if (!orderId) {
      await this.markFailed(item.id, "Missing orderId in payload", false);
      return;
    }
    await alpaca.cancelOrder(orderId);
    await this.markSucceeded(item.id, JSON.stringify({ canceledOrderId: orderId }));
  }
  async processOrderSync(item) {
    const payload = JSON.parse(item.payload || "{}");
    const traceId = payload.traceId || `sync-${Date.now()}`;
    log.info("work-queue", "Starting order sync", { traceId, workItemId: item.id });
    const [openOrders, recentOrders] = await Promise.all([
      alpaca.getOrders("open", 100),
      alpaca.getOrders("closed", 50)
    ]);
    const allOrders = [...openOrders, ...recentOrders];
    let ordersUpserted = 0;
    let fillsCreated = 0;
    for (const alpacaOrder of allOrders) {
      try {
        const orderData = {
          broker: "alpaca",
          brokerOrderId: alpacaOrder.id,
          clientOrderId: alpacaOrder.client_order_id || void 0,
          symbol: alpacaOrder.symbol,
          side: alpacaOrder.side,
          type: alpacaOrder.type || alpacaOrder.order_type || "market",
          timeInForce: alpacaOrder.time_in_force,
          qty: alpacaOrder.qty,
          notional: alpacaOrder.notional || void 0,
          limitPrice: alpacaOrder.limit_price || void 0,
          stopPrice: alpacaOrder.stop_price || void 0,
          status: alpacaOrder.status,
          // ADDED: Capture all Alpaca order metadata for complete tracking
          extendedHours: alpacaOrder.extended_hours || false,
          orderClass: alpacaOrder.order_class || "simple",
          submittedAt: new Date(alpacaOrder.submitted_at),
          updatedAt: new Date(alpacaOrder.updated_at || Date.now()),
          filledAt: alpacaOrder.filled_at ? new Date(alpacaOrder.filled_at) : void 0,
          expiredAt: alpacaOrder.expired_at ? new Date(alpacaOrder.expired_at) : void 0,
          canceledAt: alpacaOrder.canceled_at ? new Date(alpacaOrder.canceled_at) : void 0,
          failedAt: alpacaOrder.failed_at ? new Date(alpacaOrder.failed_at) : void 0,
          filledQty: alpacaOrder.filled_qty,
          filledAvgPrice: alpacaOrder.filled_avg_price || void 0,
          traceId,
          rawJson: alpacaOrder
        };
        if (alpacaOrder.client_order_id) {
          const workItem = await storage.getWorkItemByIdempotencyKey(alpacaOrder.client_order_id);
          if (workItem) {
            orderData.workItemId = workItem.id;
          }
        }
        await storage.upsertOrderByBrokerOrderId(alpacaOrder.id, orderData);
        ordersUpserted++;
        if (alpacaOrder.filled_at && parseFloat(alpacaOrder.filled_qty) > 0) {
          const existingFills = await storage.getFillsByBrokerOrderId(alpacaOrder.id);
          if (existingFills.length === 0) {
            const dbOrder = await storage.getOrderByBrokerOrderId(alpacaOrder.id);
            const fillData = {
              broker: "alpaca",
              brokerOrderId: alpacaOrder.id,
              orderId: dbOrder?.id,
              symbol: alpacaOrder.symbol,
              side: alpacaOrder.side,
              qty: alpacaOrder.filled_qty,
              price: alpacaOrder.filled_avg_price || "0",
              occurredAt: new Date(alpacaOrder.filled_at),
              traceId,
              rawJson: {
                filled_qty: alpacaOrder.filled_qty,
                filled_avg_price: alpacaOrder.filled_avg_price,
                filled_at: alpacaOrder.filled_at
              }
            };
            await storage.createFill(fillData);
            fillsCreated++;
          }
        }
      } catch (error) {
        log.warn("work-queue", `Failed to sync order ${alpacaOrder.id}: ${error}`, { traceId });
      }
    }
    log.info("work-queue", `Order sync completed`, {
      traceId,
      ordersUpserted,
      fillsCreated,
      openOrders: openOrders.length,
      recentOrders: recentOrders.length
    });
    await this.markSucceeded(item.id, JSON.stringify({
      ordersUpserted,
      fillsCreated,
      openOrders: openOrders.length,
      recentOrders: recentOrders.length,
      syncedAt: (/* @__PURE__ */ new Date()).toISOString()
    }));
  }
  async processKillSwitch(item) {
    await alpaca.cancelAllOrders();
    const payload = JSON.parse(item.payload || "{}");
    if (payload.closePositions) {
      const positions2 = await alpaca.getPositions();
      for (const pos of positions2) {
        try {
          await alpaca.closePosition(pos.symbol);
        } catch (e) {
          log.warn("work-queue", `Failed to close position ${pos.symbol}: ${e}`);
        }
      }
    }
    await storage.updateAgentStatus({
      killSwitchActive: true,
      updatedAt: /* @__PURE__ */ new Date()
    });
    await this.markSucceeded(item.id, JSON.stringify({
      canceledOrders: true,
      closedPositions: payload.closePositions || false,
      executedAt: (/* @__PURE__ */ new Date()).toISOString()
    }));
  }
  async processAssetUniverseSync(item) {
    const payload = JSON.parse(item.payload || "{}");
    const assetClass = payload.assetClass || "us_equity";
    log.info("work-queue", `Starting asset universe sync for ${assetClass}`);
    const result = await tradabilityService.syncAssetUniverse(assetClass);
    if (result.errors.length > 0) {
      throw new Error(result.errors.join("; "));
    }
    tradabilityService.clearMemoryCache();
    await this.markSucceeded(item.id, JSON.stringify({
      assetClass,
      synced: result.synced,
      tradable: result.tradable,
      syncedAt: (/* @__PURE__ */ new Date()).toISOString()
    }));
  }
  async processItem(item) {
    const startTime = Date.now();
    await storage.createWorkItemRun({
      workItemId: item.id,
      attemptNumber: item.attempts + 1,
      status: "RUNNING"
    });
    try {
      switch (item.type) {
        case "ORDER_SUBMIT":
          await this.processOrderSubmit(item);
          break;
        case "ORDER_CANCEL":
          await this.processOrderCancel(item);
          break;
        case "ORDER_SYNC":
          await this.processOrderSync(item);
          break;
        case "KILL_SWITCH":
          await this.processKillSwitch(item);
          break;
        case "ASSET_UNIVERSE_SYNC":
          await this.processAssetUniverseSync(item);
          break;
        default:
          log.warn("work-queue", `Unknown work item type: ${item.type}`);
          await this.markFailed(item.id, `Unknown type: ${item.type}`, false);
      }
    } catch (error) {
      const errorClass = classifyError2(error);
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("work-queue", `Work item ${item.id} failed (${errorClass}): ${errorMsg}`);
      await this.markFailed(item.id, errorMsg, errorClass === "transient");
    }
  }
  async runWorkerCycle() {
    if (this.processing) return;
    this.processing = true;
    try {
      const item = await this.claimNext();
      if (item) {
        await this.processItem(item);
      }
    } catch (error) {
      log.error("work-queue", `Worker cycle error: ${error}`);
    } finally {
      this.processing = false;
    }
  }
  startWorker(intervalMs = 5e3) {
    if (this.workerInterval) return;
    log.info("work-queue", `Starting work queue worker with ${intervalMs}ms interval`);
    this.workerInterval = setInterval(() => this.runWorkerCycle(), intervalMs);
  }
  stopWorker() {
    if (this.workerInterval) {
      clearInterval(this.workerInterval);
      this.workerInterval = null;
      log.info("work-queue", "Work queue worker stopped");
    }
  }
};
var workQueue = new WorkQueueServiceImpl();

// server/autonomous/orchestrator.ts
init_alpaca_trading_engine();
init_trading_session_manager();
init_trading_config();

// server/services/advanced-rebalancing-service.ts
init_db();
init_schema();
init_logger();
var DEFAULT_PARTIAL_TAKE_PROFITS = [
  { profitPercent: 10, closePercent: 25, executed: false },
  { profitPercent: 20, closePercent: 25, executed: false },
  { profitPercent: 35, closePercent: 25, executed: false },
  { profitPercent: 50, closePercent: 25, executed: false }
];
var DEFAULT_TRAILING_STOP = {
  enabled: true,
  trailPercent: 5,
  breakEvenTriggerPercent: 8,
  activationProfitPercent: 5,
  highWaterMark: 0
};
var DEFAULT_MARKET_REGIME_CONFIG = {
  bullishMultiplier: 1.25,
  bearishMultiplier: 0.5,
  sidewaysStrategy: "reduce",
  volatileMultiplier: 0.6
};
var positionProfitRules = /* @__PURE__ */ new Map();
var AdvancedRebalancingService = class {
  marketRegimeConfig = DEFAULT_MARKET_REGIME_CONFIG;
  lastRegimeAnalysis = null;
  kellyFraction = 0.25;
  registerPosition(symbol, entryPrice, customRules) {
    const rules = {
      symbol,
      entryPrice,
      partialTakeProfits: customRules?.partialTakeProfits || JSON.parse(JSON.stringify(DEFAULT_PARTIAL_TAKE_PROFITS)),
      trailingStop: customRules?.trailingStop || { ...DEFAULT_TRAILING_STOP, highWaterMark: entryPrice },
      maxHoldingPeriodHours: customRules?.maxHoldingPeriodHours || 168,
      createdAt: /* @__PURE__ */ new Date()
    };
    positionProfitRules.set(symbol, rules);
    log.info("AdvancedRebalancing", `Registered profit rules for ${symbol}`, {
      entryPrice,
      takeProfitLevels: rules.partialTakeProfits.length
    });
    return rules;
  }
  getPositionRules(symbol) {
    return positionProfitRules.get(symbol);
  }
  removePositionRules(symbol) {
    positionProfitRules.delete(symbol);
  }
  checkPartialTakeProfits(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules) return null;
    const currentProfitPercent = position.unrealizedPnlPercent;
    for (const level of rules.partialTakeProfits) {
      if (!level.executed && currentProfitPercent >= level.profitPercent) {
        level.executed = true;
        level.executedAt = /* @__PURE__ */ new Date();
        log.info("AdvancedRebalancing", `Partial take-profit triggered for ${position.symbol}`, {
          profitLevel: level.profitPercent,
          closePercent: level.closePercent,
          currentProfit: currentProfitPercent.toFixed(2)
        });
        return {
          shouldClose: true,
          closePercent: level.closePercent,
          reason: `Partial take-profit at ${level.profitPercent}% gain`
        };
      }
    }
    return null;
  }
  updateTrailingStop(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules || !rules.trailingStop.enabled) return null;
    const config = rules.trailingStop;
    const currentProfitPercent = position.unrealizedPnlPercent;
    if (currentProfitPercent < config.activationProfitPercent) {
      return null;
    }
    if (position.currentPrice > config.highWaterMark) {
      config.highWaterMark = position.currentPrice;
    }
    let newStopLoss;
    let reason;
    if (currentProfitPercent >= config.breakEvenTriggerPercent) {
      const breakEvenStop = rules.entryPrice * 1.005;
      const trailingStop = config.highWaterMark * (1 - config.trailPercent / 100);
      newStopLoss = Math.max(breakEvenStop, trailingStop);
      reason = currentProfitPercent >= config.breakEvenTriggerPercent * 1.5 ? `Trailing stop at ${config.trailPercent}% below high water mark ($${config.highWaterMark.toFixed(2)})` : `Moved stop to breakeven + 0.5%`;
    } else {
      newStopLoss = config.highWaterMark * (1 - config.trailPercent / 100);
      reason = `Initial trailing stop at ${config.trailPercent}% below current price`;
    }
    if (!position.stopLossPrice || newStopLoss > position.stopLossPrice) {
      log.info("AdvancedRebalancing", `Trailing stop update for ${position.symbol}`, {
        oldStop: position.stopLossPrice?.toFixed(2),
        newStop: newStopLoss.toFixed(2),
        reason
      });
      return { newStopLoss, reason };
    }
    return null;
  }
  async detectMarketRegime() {
    try {
      const indicators = await db.select().from(macroIndicators);
      if (indicators.length === 0) {
        return "unknown";
      }
      const vix = indicators.find((i) => i.indicatorId === "VIXCLS");
      const yieldSpread = indicators.find((i) => i.indicatorId === "T10Y2Y");
      const fedFundsRate = indicators.find((i) => i.indicatorId === "FEDFUNDS");
      const unemployment = indicators.find((i) => i.indicatorId === "UNRATE");
      const vixValue = vix?.latestValue ? parseFloat(vix.latestValue) : 20;
      const spreadValue = yieldSpread?.latestValue ? parseFloat(yieldSpread.latestValue) : 0;
      const unemploymentChange = unemployment?.changePercent ? parseFloat(unemployment.changePercent) : 0;
      let regime;
      if (vixValue > 30) {
        regime = "volatile";
      } else if (spreadValue < 0) {
        regime = "bearish";
      } else if (vixValue < 15 && spreadValue > 0.5 && unemploymentChange <= 0) {
        regime = "bullish";
      } else {
        regime = "sideways";
      }
      this.lastRegimeAnalysis = { regime, analyzedAt: /* @__PURE__ */ new Date() };
      log.info("AdvancedRebalancing", `Market regime detected: ${regime}`, {
        vix: vixValue,
        yieldSpread: spreadValue,
        unemploymentChange
      });
      return regime;
    } catch (error) {
      log.error("AdvancedRebalancing", "Failed to detect market regime", { error: String(error) });
      return "unknown";
    }
  }
  getRegimeAdjustedPositionSize(basePositionSizePercent, regime) {
    const currentRegime = regime || this.lastRegimeAnalysis?.regime || "unknown";
    let multiplier;
    switch (currentRegime) {
      case "bullish":
        multiplier = this.marketRegimeConfig.bullishMultiplier;
        break;
      case "bearish":
        multiplier = this.marketRegimeConfig.bearishMultiplier;
        break;
      case "volatile":
        multiplier = this.marketRegimeConfig.volatileMultiplier;
        break;
      case "sideways":
        multiplier = this.marketRegimeConfig.sidewaysStrategy === "reduce" ? 0.75 : 1;
        break;
      default:
        multiplier = 1;
    }
    const adjustedSize = basePositionSizePercent * multiplier;
    log.debug("AdvancedRebalancing", `Regime-adjusted position size`, {
      regime: currentRegime,
      base: basePositionSizePercent,
      multiplier,
      adjusted: adjustedSize
    });
    return adjustedSize;
  }
  calculateKellyPositionSize(params) {
    const { confidence, targetProfit, stopLoss, entryPrice, portfolioValue, maxPositionSizePercent } = params;
    const winRate = confidence / 100;
    const lossRate = 1 - winRate;
    const avgWin = targetProfit - entryPrice;
    const avgLoss = entryPrice - stopLoss;
    if (avgLoss <= 0 || avgWin <= 0) {
      return {
        symbol: "",
        rawKellyPercent: 0,
        adjustedKellyPercent: 0,
        suggestedPositionSize: 0,
        confidence,
        expectedReturn: 0,
        riskRatio: 0
      };
    }
    const winLossRatio = avgWin / avgLoss;
    const rawKelly = (winLossRatio * winRate - lossRate) / winLossRatio;
    const adjustedKelly = Math.max(0, rawKelly * this.kellyFraction);
    const cappedKelly = Math.min(adjustedKelly * 100, maxPositionSizePercent);
    const suggestedSize = cappedKelly / 100 * portfolioValue;
    const expectedReturn = winRate * avgWin - lossRate * avgLoss;
    log.debug("AdvancedRebalancing", `Kelly position size calculated`, {
      winRate: winRate.toFixed(3),
      winLossRatio: winLossRatio.toFixed(2),
      rawKelly: (rawKelly * 100).toFixed(2) + "%",
      adjustedKelly: (adjustedKelly * 100).toFixed(2) + "%",
      cappedKelly: cappedKelly.toFixed(2) + "%",
      suggestedSize: suggestedSize.toFixed(2)
    });
    return {
      symbol: "",
      rawKellyPercent: rawKelly * 100,
      adjustedKellyPercent: adjustedKelly * 100,
      suggestedPositionSize: suggestedSize,
      confidence,
      expectedReturn,
      riskRatio: winLossRatio
    };
  }
  setKellyFraction(fraction) {
    if (fraction < 0.1 || fraction > 1) {
      throw new Error("Kelly fraction must be between 0.1 and 1.0");
    }
    this.kellyFraction = fraction;
    log.info("AdvancedRebalancing", `Kelly fraction set to ${fraction}`);
  }
  setMarketRegimeConfig(config) {
    this.marketRegimeConfig = { ...this.marketRegimeConfig, ...config };
    log.info("AdvancedRebalancing", "Market regime config updated", {
      bullishMultiplier: this.marketRegimeConfig.bullishMultiplier,
      bearishMultiplier: this.marketRegimeConfig.bearishMultiplier,
      sidewaysStrategy: this.marketRegimeConfig.sidewaysStrategy,
      volatileMultiplier: this.marketRegimeConfig.volatileMultiplier
    });
  }
  getMarketRegimeConfig() {
    return { ...this.marketRegimeConfig };
  }
  getLastRegimeAnalysis() {
    return this.lastRegimeAnalysis;
  }
  checkHoldingPeriod(position) {
    const rules = positionProfitRules.get(position.symbol);
    if (!rules) return null;
    const holdingMs = Date.now() - position.openedAt.getTime();
    const holdingHours = holdingMs / (1e3 * 60 * 60);
    return {
      exceeded: holdingHours > rules.maxHoldingPeriodHours,
      holdingHours,
      maxHours: rules.maxHoldingPeriodHours
    };
  }
  getAllPositionRules() {
    return new Map(positionProfitRules);
  }
  getStatus() {
    return {
      registeredPositions: positionProfitRules.size,
      lastRegime: this.lastRegimeAnalysis?.regime || null,
      lastRegimeAnalyzedAt: this.lastRegimeAnalysis?.analyzedAt || null,
      kellyFraction: this.kellyFraction,
      regimeConfig: this.marketRegimeConfig
    };
  }
};
var advancedRebalancingService = new AdvancedRebalancingService();

// server/services/sector-exposure-service.ts
init_db();
init_schema();
init_logger();
import { eq as eq14 } from "drizzle-orm";
var DEFAULT_MAX_SECTOR_WEIGHT_PCT = 25;
var KNOWN_SECTOR_MAP = {
  // ETFs
  "SPY": "ETF",
  "QQQM": "ETF",
  "QQQ": "ETF",
  "IWM": "ETF",
  "DIA": "ETF",
  // Technology
  "AAPL": "Technology",
  "MSFT": "Technology",
  "GOOGL": "Technology",
  "GOOG": "Technology",
  "AMZN": "Technology",
  "NVDA": "Technology",
  "META": "Technology",
  "TSLA": "Technology",
  "AVGO": "Technology",
  "ORCL": "Technology",
  "CRM": "Technology",
  "AMD": "Technology",
  "INTC": "Technology",
  "IBM": "Technology",
  "CSCO": "Technology",
  "ADBE": "Technology",
  "NFLX": "Technology",
  "PYPL": "Technology",
  "NOW": "Technology",
  "UBER": "Technology",
  // Financials
  "JPM": "Financials",
  "V": "Financials",
  "MA": "Financials",
  "BAC": "Financials",
  "WFC": "Financials",
  "GS": "Financials",
  "MS": "Financials",
  "BLK": "Financials",
  "SCHW": "Financials",
  "AXP": "Financials",
  // Healthcare
  "UNH": "Healthcare",
  "JNJ": "Healthcare",
  "LLY": "Healthcare",
  "PFE": "Healthcare",
  "ABBV": "Healthcare",
  "MRK": "Healthcare",
  "TMO": "Healthcare",
  "ABT": "Healthcare",
  // Consumer Discretionary
  "HD": "Consumer Discretionary",
  "NKE": "Consumer Discretionary",
  "MCD": "Consumer Discretionary",
  "SBUX": "Consumer Discretionary",
  "LOW": "Consumer Discretionary",
  // Consumer Staples
  "WMT": "Consumer Staples",
  "PG": "Consumer Staples",
  "KO": "Consumer Staples",
  "PEP": "Consumer Staples",
  "COST": "Consumer Staples",
  // Energy
  "CVX": "Energy",
  "XOM": "Energy",
  "COP": "Energy",
  "SLB": "Energy",
  // Industrials
  "UPS": "Industrials",
  "RTX": "Industrials",
  "HON": "Industrials",
  "BA": "Industrials",
  "CAT": "Industrials",
  "GE": "Industrials",
  "DE": "Industrials",
  // Materials
  "LIN": "Materials",
  "APD": "Materials",
  "SHW": "Materials",
  // Utilities
  "NEE": "Utilities",
  "DUK": "Utilities",
  "SO": "Utilities",
  // Real Estate
  "AMT": "Real Estate",
  "PLD": "Real Estate",
  "CCI": "Real Estate",
  // Communication Services
  "DIS": "Communication Services",
  "CMCSA": "Communication Services",
  "VZ": "Communication Services",
  "T": "Communication Services",
  "TMUS": "Communication Services",
  // Crypto
  "BTC/USD": "Crypto",
  "ETH/USD": "Crypto",
  "SOL/USD": "Crypto",
  "DOGE/USD": "Crypto",
  "SHIB/USD": "Crypto",
  "AVAX/USD": "Crypto"
};
var SectorExposureService = class {
  sectorCache = /* @__PURE__ */ new Map();
  maxSectorWeightPct = DEFAULT_MAX_SECTOR_WEIGHT_PCT;
  lastConfigRefresh = null;
  configRefreshIntervalMs = 3e5;
  // 5 minutes
  /**
   * Get the sector for a symbol, using cache, database, or fallback mapping
   */
  async getSector(symbol) {
    const cached = this.sectorCache.get(symbol.toUpperCase());
    if (cached) return cached;
    try {
      const [fundamentals] = await db.select({ sector: universeFundamentals.sector }).from(universeFundamentals).where(eq14(universeFundamentals.symbol, symbol.toUpperCase())).limit(1);
      if (fundamentals?.sector) {
        this.sectorCache.set(symbol.toUpperCase(), fundamentals.sector);
        return fundamentals.sector;
      }
    } catch (error) {
      log.warn("SectorExposure", `Failed to fetch sector for ${symbol}`, { error: String(error) });
    }
    const fallback = KNOWN_SECTOR_MAP[symbol.toUpperCase()] || "Unknown";
    this.sectorCache.set(symbol.toUpperCase(), fallback);
    return fallback;
  }
  /**
   * Refresh max sector weight (uses default for now, can be extended to read from DB)
   */
  async refreshConfig() {
    const now = /* @__PURE__ */ new Date();
    if (this.lastConfigRefresh && now.getTime() - this.lastConfigRefresh.getTime() < this.configRefreshIntervalMs) {
      return;
    }
    const envValue = process.env.MAX_SECTOR_WEIGHT_PCT;
    if (envValue) {
      const parsed = parseFloat(envValue);
      if (!isNaN(parsed) && parsed >= 5 && parsed <= 100) {
        this.maxSectorWeightPct = parsed;
      }
    }
    this.lastConfigRefresh = now;
    log.debug("SectorExposure", `Max sector weight: ${this.maxSectorWeightPct}%`);
  }
  /**
   * Calculate current sector exposure from active positions
   */
  async calculateExposure(positions2, portfolioValue) {
    await this.refreshConfig();
    const sectorMap = /* @__PURE__ */ new Map();
    let totalExposure = 0;
    const warnings = [];
    for (const [symbol, position] of positions2.entries()) {
      const sector = await this.getSector(symbol);
      const positionValue = position.currentPrice * position.quantity;
      totalExposure += positionValue;
      const existing = sectorMap.get(sector) || {
        sector,
        totalValue: 0,
        positionCount: 0,
        percentOfPortfolio: 0,
        symbols: []
      };
      existing.totalValue += positionValue;
      existing.positionCount++;
      existing.symbols.push(symbol);
      sectorMap.set(sector, existing);
    }
    let mostConcentrated = null;
    let maxConcentration = 0;
    for (const [sector, exposure] of sectorMap.entries()) {
      exposure.percentOfPortfolio = portfolioValue > 0 ? exposure.totalValue / portfolioValue * 100 : 0;
      if (exposure.percentOfPortfolio > maxConcentration) {
        maxConcentration = exposure.percentOfPortfolio;
        mostConcentrated = sector;
      }
      if (exposure.percentOfPortfolio > this.maxSectorWeightPct) {
        warnings.push(
          `${sector} exposure (${exposure.percentOfPortfolio.toFixed(1)}%) exceeds limit (${this.maxSectorWeightPct}%)`
        );
      }
    }
    const exposureBySector = Array.from(sectorMap.values()).sort((a, b) => b.percentOfPortfolio - a.percentOfPortfolio);
    return {
      exposureBySector,
      totalExposure,
      portfolioValue,
      maxSectorWeight: this.maxSectorWeightPct,
      mostConcentratedSector: mostConcentrated,
      warnings
    };
  }
  /**
   * Check if adding a position would exceed sector limits
   */
  async checkExposure(symbol, proposedValue, positions2, portfolioValue) {
    await this.refreshConfig();
    const sector = await this.getSector(symbol);
    let currentSectorValue = 0;
    for (const [posSymbol, position] of positions2.entries()) {
      const posSector = await this.getSector(posSymbol);
      if (posSector === sector) {
        currentSectorValue += position.currentPrice * position.quantity;
      }
    }
    const currentExposure = portfolioValue > 0 ? currentSectorValue / portfolioValue * 100 : 0;
    const newExposure = portfolioValue > 0 ? (currentSectorValue + proposedValue) / portfolioValue * 100 : 0;
    if (newExposure > this.maxSectorWeightPct) {
      log.warn("SectorExposure", `Trade blocked: ${symbol} would exceed ${sector} limit`, {
        symbol,
        sector,
        currentExposure: currentExposure.toFixed(1),
        newExposure: newExposure.toFixed(1),
        maxAllowed: this.maxSectorWeightPct
      });
      return {
        canTrade: false,
        reason: `Would exceed ${sector} sector limit: ${newExposure.toFixed(1)}% > ${this.maxSectorWeightPct}%`,
        currentExposure,
        maxExposure: this.maxSectorWeightPct,
        sector
      };
    }
    return {
      canTrade: true,
      currentExposure,
      maxExposure: this.maxSectorWeightPct,
      sector
    };
  }
  /**
   * Set max sector weight (for runtime configuration)
   */
  setMaxSectorWeight(percent) {
    if (percent < 5 || percent > 100) {
      throw new Error("Max sector weight must be between 5% and 100%");
    }
    this.maxSectorWeightPct = percent;
    log.info("SectorExposure", `Max sector weight set to ${percent}%`);
  }
  /**
   * Clear the sector cache
   */
  clearCache() {
    this.sectorCache.clear();
    log.info("SectorExposure", "Sector cache cleared");
  }
  /**
   * Get current configuration
   */
  getConfig() {
    return {
      maxSectorWeightPct: this.maxSectorWeightPct,
      cachedSymbols: this.sectorCache.size
    };
  }
};
var sectorExposureService = new SectorExposureService();

// server/autonomous/orchestrator.ts
var DEFAULT_HARD_STOP_LOSS_PERCENT = tradingConfig.riskManagement.defaultHardStopLossPercent;
var DEFAULT_TAKE_PROFIT_PERCENT = tradingConfig.riskManagement.defaultTakeProfitPercent;
var MAX_STOCK_SYMBOLS_PER_CYCLE = tradingConfig.universe.maxStockSymbolsPerCycle;
var MAX_CRYPTO_SYMBOLS_PER_CYCLE = tradingConfig.universe.maxCryptoSymbolsPerCycle;
var ALPACA_SNAPSHOT_CHUNK_SIZE = tradingConfig.universe.alpacaSnapshotChunkSize;
var RECENT_DECISIONS_LOOKBACK = 500;
var MIN_CONFIDENCE_FOR_UNIVERSE = tradingConfig.universe.minConfidenceForUniverse;
var universeRotationState = {
  stockRotationOffset: 0,
  cryptoRotationOffset: 0,
  lastRotationTime: /* @__PURE__ */ new Date()
};
var DEFAULT_CONFIG2 = {
  analysisIntervalMs: 6e4,
  positionCheckIntervalMs: 3e4,
  enabled: true
};
var DEFAULT_RISK_LIMITS = {
  maxPositionSizePercent: tradingConfig.riskManagement.defaultMaxPositionSizePercent,
  maxTotalExposurePercent: tradingConfig.riskManagement.defaultMaxExposurePercent,
  maxPositionsCount: 100,
  // AGGRESSIVE: Increased from 10 to enterprise-level 100 positions
  dailyLossLimitPercent: 5,
  // Keep same for safety
  killSwitchActive: false
};
var FALLBACK_WATCHLIST = {
  stocks: ["SPY", "QQQ", "AAPL", "MSFT", "GOOGL", "AMZN", "NVDA", "META", "TSLA", "JPM"],
  crypto: ["BTC", "ETH", "SOL"]
};
var cachedWatchlist = null;
var watchlistCacheTime = 0;
var WATCHLIST_CACHE_TTL_MS = 5 * 60 * 1e3;
async function getWatchlist() {
  const now = Date.now();
  if (cachedWatchlist && now - watchlistCacheTime < WATCHLIST_CACHE_TTL_MS) {
    return cachedWatchlist;
  }
  try {
    const dynamicWatchlist = await candidatesService.getWatchlistSymbols();
    if (dynamicWatchlist.stocks.length > 0 || dynamicWatchlist.crypto.length > 0) {
      cachedWatchlist = dynamicWatchlist;
      watchlistCacheTime = now;
      log.info("Orchestrator", `Loaded ${dynamicWatchlist.stocks.length} stocks and ${dynamicWatchlist.crypto.length} crypto from database`);
      return dynamicWatchlist;
    }
  } catch (error) {
    log.warn("Orchestrator", "Failed to load watchlist from database, using fallback", { error: String(error) });
  }
  cachedWatchlist = FALLBACK_WATCHLIST;
  watchlistCacheTime = now;
  return FALLBACK_WATCHLIST;
}
function getWatchlistSync() {
  return cachedWatchlist || FALLBACK_WATCHLIST;
}
function isCryptoSymbol(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const watchlist = getWatchlistSync();
  if (watchlist.crypto.includes(upperSymbol)) return true;
  const cryptoPairs = watchlist.crypto.flatMap((c) => [`${c}/USD`, `${c}USD`]);
  return cryptoPairs.includes(upperSymbol) || symbol.includes("/") && upperSymbol.endsWith("USD");
}
function normalizeCryptoSymbol(symbol) {
  const upperSymbol = symbol.toUpperCase();
  const watchlist = getWatchlistSync();
  if (upperSymbol.includes("/")) return upperSymbol;
  if (watchlist.crypto.includes(upperSymbol)) return `${upperSymbol}/USD`;
  if (upperSymbol.endsWith("USD") && upperSymbol.length > 3) {
    const base = upperSymbol.slice(0, -3);
    return `${base}/USD`;
  }
  return upperSymbol;
}
var QUEUE_POLL_INTERVAL_MS = 2e3;
var QUEUE_POLL_TIMEOUT_MS = 6e4;
async function queueOrderExecution(params) {
  const { orderParams, traceId, strategyId, symbol, side, decisionId } = params;
  const timestampBucket = Math.floor(Date.now() / 3e5).toString();
  const idempotencyKey = generateIdempotencyKey({
    strategyId: strategyId || "autonomous",
    symbol,
    side,
    timeframeBucket: timestampBucket
  });
  log.info("Orchestrator", `Queuing ORDER_SUBMIT for ${symbol} ${side}`, {
    traceId,
    idempotencyKey,
    symbol,
    side
  });
  const normalizedOrderParams = {
    symbol: orderParams.symbol,
    side: orderParams.side,
    type: orderParams.type || "market",
    time_in_force: orderParams.time_in_force || "day",
    ...orderParams.qty && { qty: orderParams.qty },
    ...orderParams.notional && { notional: orderParams.notional },
    ...orderParams.limit_price && { limit_price: orderParams.limit_price },
    ...orderParams.stop_price && { stop_price: orderParams.stop_price },
    ...orderParams.extended_hours !== void 0 && { extended_hours: orderParams.extended_hours },
    ...orderParams.order_class && { order_class: orderParams.order_class },
    // Include both nested and flat formats for bracket order params
    // Work queue expects flat fields, direct API calls may use nested
    ...orderParams.take_profit && { take_profit: orderParams.take_profit },
    ...orderParams.stop_loss && { stop_loss: orderParams.stop_loss },
    ...orderParams.take_profit_limit_price && { take_profit_limit_price: orderParams.take_profit_limit_price },
    ...orderParams.stop_loss_stop_price && { stop_loss_stop_price: orderParams.stop_loss_stop_price }
  };
  const workItem = await workQueue.enqueue({
    type: "ORDER_SUBMIT",
    symbol,
    idempotencyKey,
    decisionId: decisionId || null,
    payload: JSON.stringify({
      ...normalizedOrderParams,
      traceId,
      strategyId
    }),
    maxAttempts: 3
  });
  log.info("Orchestrator", `Work item created: ${workItem.id}`, {
    traceId,
    workItemId: workItem.id,
    status: workItem.status
  });
  if (workItem.status === "SUCCEEDED" && workItem.result) {
    const result = JSON.parse(workItem.result);
    if (result.orderId) {
      try {
        const alpacaOrder = await alpaca.getOrder(result.orderId);
        const actualStatus = alpacaOrder.status?.toLowerCase() || "unknown";
        const terminalFailedStates = ["canceled", "rejected", "expired", "suspended"];
        if (terminalFailedStates.includes(actualStatus)) {
          log.warn("Orchestrator", `Duplicate order ${result.orderId} has terminal failed status: ${actualStatus}, invalidating work item`, { traceId });
          await workQueue.invalidateWorkItem(workItem.id, `Order ${actualStatus} by broker`);
          throw new Error(`Previous order was ${actualStatus}, retry with new parameters`);
        }
        log.info("Orchestrator", `Order already succeeded (duplicate): ${result.orderId}, current status: ${actualStatus}`, { traceId });
      } catch (orderCheckError) {
        if (orderCheckError.message?.includes("not found") || orderCheckError.status === 404) {
          log.warn("Orchestrator", `Duplicate order ${result.orderId} not found in Alpaca, invalidating work item`, { traceId });
          await workQueue.invalidateWorkItem(workItem.id, "Order not found in broker");
          throw new Error("Previous order not found, retry with new parameters");
        }
        if (orderCheckError.message?.includes("retry with new parameters")) {
          throw orderCheckError;
        }
        log.warn("Orchestrator", `Could not verify duplicate order status: ${orderCheckError.message}`, { traceId });
      }
    }
    return {
      orderId: result.orderId,
      status: result.status || "filled",
      workItemId: workItem.id
    };
  }
  const startTime = Date.now();
  while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS) {
    await new Promise((resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS));
    const updatedItem = await workQueue.getById(workItem.id);
    if (!updatedItem) {
      throw new Error(`Work item ${workItem.id} not found during polling`);
    }
    if (updatedItem.status === "SUCCEEDED") {
      const result = updatedItem.result ? JSON.parse(updatedItem.result) : {};
      const orderStatus = result.status || "accepted";
      const validSuccessStates = ["filled", "accepted", "new", "pending_new", "partially_filled", "queued"];
      if (validSuccessStates.includes(orderStatus.toLowerCase()) || result.orderId || updatedItem.brokerOrderId) {
        log.info("Orchestrator", `ORDER_SUBMIT succeeded: ${result.orderId || updatedItem.brokerOrderId}`, {
          traceId,
          workItemId: workItem.id,
          orderId: result.orderId,
          orderStatus
        });
        return {
          orderId: result.orderId || updatedItem.brokerOrderId || "",
          status: orderStatus,
          workItemId: workItem.id
        };
      }
    }
    if (updatedItem.brokerOrderId && !updatedItem.result) {
      log.info("Orchestrator", `ORDER_SUBMIT has broker order ID: ${updatedItem.brokerOrderId}`, {
        traceId,
        workItemId: workItem.id
      });
      return {
        orderId: updatedItem.brokerOrderId,
        status: "accepted",
        workItemId: workItem.id
      };
    }
    if (updatedItem.status === "DEAD_LETTER") {
      log.error("Orchestrator", `ORDER_SUBMIT failed permanently: ${updatedItem.lastError}`, {
        traceId,
        workItemId: workItem.id
      });
      throw new Error(`Order submission failed: ${updatedItem.lastError || "Unknown error"}`);
    }
    log.info("Orchestrator", `Polling work item ${workItem.id}: ${updatedItem.status}`, {
      traceId,
      attempts: updatedItem.attempts
    });
  }
  throw new Error(`Order submission timed out after ${QUEUE_POLL_TIMEOUT_MS}ms`);
}
async function queueOrderCancellation(params) {
  const { orderId, traceId, symbol, strategyId } = params;
  const timestampBucket = Math.floor(Date.now() / 6e4).toString();
  const idempotencyKey = generateIdempotencyKey({
    strategyId: strategyId || "autonomous",
    symbol,
    side: `cancel-${orderId}`,
    timeframeBucket: timestampBucket
  });
  log.info("Orchestrator", `Queuing ORDER_CANCEL for order ${orderId}`, {
    traceId,
    orderId,
    symbol,
    idempotencyKey
  });
  const workItem = await workQueue.enqueue({
    type: "ORDER_CANCEL",
    symbol,
    idempotencyKey,
    payload: JSON.stringify({ orderId, traceId }),
    maxAttempts: 3
  });
  if (workItem.status === "SUCCEEDED") {
    log.info("Orchestrator", `Order cancellation already succeeded (duplicate)`, { traceId, orderId });
    return;
  }
  const startTime = Date.now();
  while (Date.now() - startTime < QUEUE_POLL_TIMEOUT_MS) {
    await new Promise((resolve2) => setTimeout(resolve2, QUEUE_POLL_INTERVAL_MS));
    const updatedItem = await workQueue.getById(workItem.id);
    if (!updatedItem) {
      throw new Error(`Cancel work item ${workItem.id} not found during polling`);
    }
    if (updatedItem.status === "SUCCEEDED") {
      log.info("Orchestrator", `ORDER_CANCEL succeeded for order ${orderId}`, { traceId });
      return;
    }
    if (updatedItem.status === "CANCELLED") {
      log.info("Orchestrator", `ORDER_CANCEL completed with CANCELLED status for order ${orderId}`, { traceId });
      return;
    }
    if (updatedItem.status === "DEAD_LETTER") {
      const errorLower = (updatedItem.lastError || "").toLowerCase();
      if (errorLower.includes("already") || errorLower.includes("cancel") || errorLower.includes("not found")) {
        log.info("Orchestrator", `ORDER_CANCEL completed (order already cancelled or not found): ${orderId}`, { traceId });
        return;
      }
      log.warn("Orchestrator", `ORDER_CANCEL failed: ${updatedItem.lastError}`, {
        traceId,
        orderId
      });
      return;
    }
  }
  log.warn("Orchestrator", `Order cancellation timed out for ${orderId}`, { traceId });
}
var HEARTBEAT_INTERVAL_MS = 3e4;
var STALE_HEARTBEAT_THRESHOLD_MS = 12e4;
var AUTO_RESTART_DELAY_MS = 5e3;
var MAX_CONSECUTIVE_ERRORS = 5;
async function preTradeGuard(symbol, side, orderValue, isCrypto) {
  try {
    const account = await alpaca.getAccount();
    const availableBuyingPower = safeParseFloat(account.buying_power);
    const exchange = isCrypto ? "CRYPTO" : "US_EQUITIES";
    const sessionInfo = tradingSessionManager.getCurrentSession(exchange);
    const marketStatus = await alpaca.getMarketStatus();
    const result = {
      canTrade: false,
      marketSession: sessionInfo.session,
      availableBuyingPower,
      requiredBuyingPower: orderValue,
      useExtendedHours: false,
      useLimitOrder: false
    };
    if (side === "buy" && orderValue > availableBuyingPower) {
      result.reason = `Insufficient buying power ($${availableBuyingPower.toFixed(2)} available < $${orderValue.toFixed(2)} required)`;
      return result;
    }
    if (isCrypto) {
      result.canTrade = true;
      log.info("Orchestrator", `Crypto market 24/7 - trading enabled for ${symbol}`);
      return result;
    }
    if (tradingSessionManager.isHoliday(exchange, /* @__PURE__ */ new Date())) {
      result.canTrade = false;
      result.reason = `Market is closed for holiday (next open: ${sessionInfo.nextOpen?.toISOString()})`;
      return result;
    }
    if (sessionInfo.session === "regular") {
      result.canTrade = true;
      log.info("Orchestrator", `Regular hours - trading enabled for ${symbol}`);
      return result;
    }
    if (sessionInfo.isExtendedHours && (sessionInfo.session === "pre_market" || sessionInfo.session === "after_hours")) {
      result.useExtendedHours = true;
      result.useLimitOrder = true;
      try {
        const snapshots = await alpaca.getSnapshots([symbol]);
        const snapshot = snapshots[symbol];
        if (snapshot?.latestTrade?.p) {
          const basePrice = snapshot.latestTrade.p;
          const volatilityMultiplier = sessionInfo.volatilityMultiplier;
          result.limitPrice = Math.round(basePrice * 100) / 100;
          result.canTrade = true;
          log.info("Orchestrator", `Extended hours (${sessionInfo.session}) trading enabled for ${symbol} at $${result.limitPrice} (volatility: ${volatilityMultiplier}x)`);
          return result;
        } else {
          result.reason = `Cannot get current price for ${symbol} during ${sessionInfo.session}`;
          return result;
        }
      } catch (error) {
        result.reason = `Failed to get market price for extended hours order: ${error}`;
        return result;
      }
    }
    if (sessionInfo.session === "closed") {
      result.canTrade = false;
      const nextOpenStr = sessionInfo.nextOpen ? sessionInfo.nextOpen.toLocaleString() : "unknown";
      result.reason = `Market is closed (next open: ${nextOpenStr})`;
      log.info("Orchestrator", `Market closed for ${symbol} - next open: ${nextOpenStr}`);
      return result;
    }
    return result;
  } catch (error) {
    return {
      canTrade: false,
      reason: `Pre-trade check failed: ${error}`,
      marketSession: "closed",
      availableBuyingPower: 0,
      requiredBuyingPower: orderValue,
      useExtendedHours: false,
      useLimitOrder: false
    };
  }
}
async function isSymbolTradable(symbol, isCrypto) {
  try {
    if (isCrypto) {
      const normalizedSymbol = normalizeCryptoSymbol(symbol);
      const assets = await alpaca.getAssets("active", "crypto");
      const found = assets.find((a) => a.symbol === normalizedSymbol && a.tradable);
      if (!found) {
        return { tradable: false, reason: `Crypto ${normalizedSymbol} is not tradable on Alpaca` };
      }
      return { tradable: true };
    } else {
      const asset = await alpaca.getAsset(symbol);
      if (!asset.tradable) {
        return { tradable: false, reason: `Stock ${symbol} is not tradable` };
      }
      return { tradable: true };
    }
  } catch (error) {
    return { tradable: false, reason: `Symbol validation failed: ${error}` };
  }
}
var AutonomousOrchestrator = class {
  state;
  config;
  riskLimits;
  analysisTimer = null;
  positionTimer = null;
  heartbeatTimer = null;
  isProcessing = false;
  consecutiveErrors = 0;
  lastHeartbeat = null;
  autoStartEnabled = true;
  isAutoStarting = false;
  lastCalibrationDate = null;
  currentTraceId = null;
  // Cooldown tracking for failed orders to prevent infinite retry loops
  orderCooldowns = /* @__PURE__ */ new Map();
  ORDER_COOLDOWN_MS = 3e5;
  // 5 minute cooldown after failed order
  constructor() {
    this.config = { ...DEFAULT_CONFIG2 };
    this.riskLimits = { ...DEFAULT_RISK_LIMITS };
    this.state = {
      isRunning: false,
      mode: "autonomous",
      lastAnalysisTime: null,
      lastPositionCheckTime: null,
      activePositions: /* @__PURE__ */ new Map(),
      pendingSignals: /* @__PURE__ */ new Map(),
      executionHistory: [],
      dailyPnl: 0,
      dailyTradeCount: 0,
      errors: []
    };
  }
  async autoStart() {
    if (this.isAutoStarting) {
      log.info("Orchestrator", "Auto-start already in progress");
      return;
    }
    this.isAutoStarting = true;
    try {
      log.info("Orchestrator", "Auto-start initializing...");
      const agentStatus2 = await storage.getAgentStatus();
      this.autoStartEnabled = agentStatus2?.autoStartEnabled ?? true;
      if (!this.autoStartEnabled) {
        log.info("Orchestrator", "Auto-start is disabled in settings");
        this.isAutoStarting = false;
        return;
      }
      if (agentStatus2?.killSwitchActive) {
        log.warn("Orchestrator", "Auto-start blocked: Kill switch is active");
        this.isAutoStarting = false;
        return;
      }
      await marketConditionAnalyzer.initialize();
      await this.start();
      this.startHeartbeat();
      log.info("Orchestrator", "Auto-start complete - Agent is now running persistently");
    } catch (error) {
      log.error("Orchestrator", "Auto-start failed", { error: String(error) });
      this.state.errors.push(`Auto-start failed: ${error}`);
      setTimeout(() => {
        this.isAutoStarting = false;
        this.autoStart().catch((err) => {
          log.error("Orchestrator", "Auto-restart retry failed", { error: String(err) });
        });
      }, AUTO_RESTART_DELAY_MS);
    } finally {
      this.isAutoStarting = false;
    }
  }
  startHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
    this.lastHeartbeat = /* @__PURE__ */ new Date();
    this.heartbeatTimer = setInterval(async () => {
      await this.performHeartbeat();
    }, HEARTBEAT_INTERVAL_MS);
    log.info("Orchestrator", "Heartbeat started");
  }
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
  }
  async performHeartbeat() {
    try {
      const now = /* @__PURE__ */ new Date();
      this.lastHeartbeat = now;
      await storage.updateAgentStatus({
        lastHeartbeat: now
      });
      await this.checkAndRecoverIfStale();
      if (this.consecutiveErrors > 0) {
        this.consecutiveErrors = Math.max(0, this.consecutiveErrors - 1);
      }
    } catch (error) {
      log.error("Orchestrator", "Heartbeat error", { error: String(error) });
      this.consecutiveErrors++;
      if (this.consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
        log.warn("Orchestrator", "Too many consecutive errors, triggering self-healing");
        await this.selfHeal();
      }
    }
  }
  async checkAndRecoverIfStale() {
    if (!this.state.isRunning) return;
    const now = Date.now();
    const lastAnalysis = this.state.lastAnalysisTime?.getTime() || 0;
    const timeSinceAnalysis = now - lastAnalysis;
    if (timeSinceAnalysis > STALE_HEARTBEAT_THRESHOLD_MS && lastAnalysis > 0) {
      log.warn("Orchestrator", `Stale state detected (${Math.round(timeSinceAnalysis / 1e3)}s since last analysis)`);
      await this.selfHeal();
    }
  }
  async selfHeal() {
    log.info("Orchestrator", "Initiating self-healing...");
    const wasAutoStartEnabled = this.autoStartEnabled;
    try {
      await this.stop(true);
      await new Promise((resolve2) => setTimeout(resolve2, AUTO_RESTART_DELAY_MS));
      this.consecutiveErrors = 0;
      this.state.errors = [];
      if (wasAutoStartEnabled) {
        await this.start();
        this.startHeartbeat();
        log.info("Orchestrator", "Self-healing complete - Agent restarted");
      }
    } catch (error) {
      log.error("Orchestrator", "Self-healing failed", { error: String(error) });
      this.state.errors.push(`Self-healing failed: ${error}`);
    }
  }
  async setAutoStartEnabled(enabled) {
    this.autoStartEnabled = enabled;
    await storage.updateAgentStatus({ autoStartEnabled: enabled });
    log.info("Orchestrator", `Auto-start ${enabled ? "enabled" : "disabled"}`);
  }
  isAutoStartEnabledFlag() {
    return this.autoStartEnabled;
  }
  getHealthStatus() {
    const analyzerStatus = marketConditionAnalyzer.getStatus();
    return {
      isHealthy: this.consecutiveErrors < MAX_CONSECUTIVE_ERRORS && this.state.isRunning,
      lastHeartbeat: this.lastHeartbeat,
      consecutiveErrors: this.consecutiveErrors,
      autoStartEnabled: this.autoStartEnabled,
      marketCondition: analyzerStatus.lastAnalysis?.condition || null,
      dynamicOrderLimit: analyzerStatus.currentOrderLimit
    };
  }
  async initialize() {
    await this.loadRiskLimitsFromDB();
    await this.syncPositionsFromBroker();
    const watchlist = await getWatchlist();
    const allSymbols = [...watchlist.stocks, ...watchlist.crypto.map((c) => `${c}/USD`)];
    await candidatesService.ensureWatchlistApproved(allSymbols, "orchestrator-init");
    log.info("Orchestrator", "Initialized with risk limits", { ...this.riskLimits });
  }
  /**
   * Auto-approve a symbol for trading when it receives a high-confidence buy signal.
   * This makes the watchlist dynamic - symbols are automatically approved based on AI analysis.
   */
  async autoApproveSymbol(symbol) {
    try {
      const upperSymbol = symbol.toUpperCase();
      const existing = await candidatesService.getCandidateBySymbol(upperSymbol);
      if (existing?.status === "APPROVED") {
        return;
      }
      if (existing) {
        await candidatesService.approveCandidate(upperSymbol, "ai-auto-approve");
        log.info("Orchestrator", `AUTO-APPROVED: ${upperSymbol} (was ${existing.status})`);
      } else {
        await candidatesService.ensureWatchlistApproved([upperSymbol], "ai-signal");
        await candidatesService.approveCandidate(upperSymbol, "ai-auto-approve");
        log.info("Orchestrator", `AUTO-APPROVED: ${upperSymbol} (new candidate)`);
      }
    } catch (error) {
      log.warn("Orchestrator", `Failed to auto-approve ${symbol}`, { error: String(error) });
    }
  }
  async loadRiskLimitsFromDB() {
    try {
      const agentStatus2 = await storage.getAgentStatus();
      const dynamicLimit = marketConditionAnalyzer.getCurrentOrderLimit();
      if (agentStatus2) {
        this.riskLimits = {
          maxPositionSizePercent: Number(agentStatus2.maxPositionSizePercent) || 10,
          maxTotalExposurePercent: Number(agentStatus2.maxTotalExposurePercent) || 50,
          maxPositionsCount: Number(agentStatus2.maxPositionsCount) || agentStatus2.dynamicOrderLimit || dynamicLimit || 10,
          dailyLossLimitPercent: Number(agentStatus2.dailyLossLimitPercent) || 5,
          killSwitchActive: agentStatus2.killSwitchActive || false
        };
        log.info("Orchestrator", "Loaded risk limits from DB", {
          maxPositionSizePercent: this.riskLimits.maxPositionSizePercent,
          maxTotalExposurePercent: this.riskLimits.maxTotalExposurePercent,
          maxPositionsCount: this.riskLimits.maxPositionsCount,
          dailyLossLimitPercent: this.riskLimits.dailyLossLimitPercent
        });
      }
    } catch (error) {
      log.error("Orchestrator", "Failed to load risk limits", { error: String(error) });
    }
  }
  async syncPositionsFromBroker() {
    try {
      const positions2 = await alpaca.getPositions();
      const existingPositions = new Map(this.state.activePositions);
      this.state.activePositions.clear();
      try {
        await storage.syncPositionsFromAlpaca(positions2);
        log.info("Orchestrator", `Synced ${positions2.length} positions to database`);
      } catch (dbError) {
        log.error("Orchestrator", "Failed to sync positions to database", { error: String(dbError) });
      }
      for (const pos of positions2) {
        const entryPrice = safeParseFloat(pos.avg_entry_price);
        const currentPrice = safeParseFloat(pos.current_price);
        const existingPos = existingPositions.get(pos.symbol);
        let stopLossPrice = existingPos?.stopLossPrice;
        let takeProfitPrice = existingPos?.takeProfitPrice;
        let trailingStopPercent = existingPos?.trailingStopPercent;
        const hardStopLoss = entryPrice * (1 - DEFAULT_HARD_STOP_LOSS_PERCENT / 100);
        const defaultTakeProfit = entryPrice * (1 + DEFAULT_TAKE_PROFIT_PERCENT / 100);
        if (!stopLossPrice && entryPrice > 0) {
          stopLossPrice = hardStopLoss;
        }
        if (!takeProfitPrice && entryPrice > 0) {
          takeProfitPrice = defaultTakeProfit;
        }
        if (stopLossPrice && stopLossPrice < hardStopLoss && entryPrice > 0) {
          log.info("Orchestrator", `Enforcing hard stop-loss for ${pos.symbol}: $${stopLossPrice.toFixed(2)} -> $${hardStopLoss.toFixed(2)}`);
          stopLossPrice = hardStopLoss;
        }
        if (existingPos?.trailingStopPercent && currentPrice > entryPrice) {
          const profitPercent = (currentPrice - entryPrice) / entryPrice * 100;
          if (profitPercent > 5) {
            const newStopLoss = currentPrice * (1 - existingPos.trailingStopPercent / 100);
            if (!stopLossPrice || newStopLoss > stopLossPrice) {
              stopLossPrice = newStopLoss;
              log.info("Orchestrator", `Trailing stop updated for ${pos.symbol}: $${stopLossPrice.toFixed(2)}`);
            }
          }
        }
        const totalQty = safeParseFloat(pos.qty);
        const availableQty = safeParseFloat(pos.qty_available);
        const positionWithRules = {
          symbol: pos.symbol,
          quantity: totalQty,
          availableQuantity: availableQty,
          entryPrice,
          currentPrice,
          unrealizedPnl: safeParseFloat(pos.unrealized_pl),
          unrealizedPnlPercent: safeParseFloat(pos.unrealized_plpc) * 100,
          openedAt: existingPos?.openedAt || /* @__PURE__ */ new Date(),
          stopLossPrice,
          takeProfitPrice,
          trailingStopPercent,
          strategyId: existingPos?.strategyId
        };
        this.state.activePositions.set(pos.symbol, positionWithRules);
      }
      log.info("Orchestrator", `Synced ${positions2.length} positions from broker`);
    } catch (error) {
      log.error("Orchestrator", "Failed to sync positions", { error: String(error) });
      this.state.errors.push(`Position sync failed: ${error}`);
    }
  }
  async fetchCurrentPrice(symbol) {
    try {
      const isCrypto = isCryptoSymbol(symbol);
      if (isCrypto) {
        const normSymbol = normalizeCryptoSymbol(symbol);
        const snapshots = await alpaca.getCryptoSnapshots([normSymbol]);
        const snapshot = snapshots[normSymbol];
        return snapshot?.latestTrade?.p || 0;
      } else {
        const snapshots = await alpaca.getSnapshots([symbol]);
        const snapshot = snapshots[symbol];
        return snapshot?.latestTrade?.p || 0;
      }
    } catch (error) {
      log.warn("Orchestrator", `Failed to fetch current price for ${symbol}`, { error: String(error) });
      return 0;
    }
  }
  async start() {
    if (this.state.isRunning) {
      log.info("Orchestrator", "Already running");
      return;
    }
    await this.initialize();
    if (this.riskLimits.killSwitchActive) {
      log.warn("Orchestrator", "Kill switch is active - cannot start");
      throw new Error("Kill switch is active. Disable it to start autonomous trading.");
    }
    alpacaTradingEngine.enableOrchestratorControl();
    log.info("Orchestrator", "Enabled orchestrator control over AlpacaTradingEngine");
    this.state.isRunning = true;
    this.state.mode = "autonomous";
    this.state.errors = [];
    await storage.updateAgentStatus({ isRunning: true });
    this.analysisTimer = setInterval(() => {
      this.runAnalysisCycle().catch((err) => {
        log.error("Orchestrator", "Analysis cycle error", { error: String(err) });
        this.state.errors.push(`Analysis error: ${err.message}`);
      });
    }, this.config.analysisIntervalMs);
    this.positionTimer = setInterval(() => {
      this.runPositionManagementCycle().catch((err) => {
        log.error("Orchestrator", "Position management error", { error: String(err) });
        this.state.errors.push(`Position mgmt error: ${err.message}`);
      });
    }, this.config.positionCheckIntervalMs);
    await this.runAnalysisCycle();
    await this.runPositionManagementCycle();
    log.info("Orchestrator", "Started autonomous trading mode");
  }
  async stop(preserveAutoStart = false) {
    if (!this.state.isRunning) {
      log.info("Orchestrator", "Not running");
      return;
    }
    this.state.isRunning = false;
    this.state.mode = "manual";
    if (this.analysisTimer) {
      clearInterval(this.analysisTimer);
      this.analysisTimer = null;
    }
    if (this.positionTimer) {
      clearInterval(this.positionTimer);
      this.positionTimer = null;
    }
    this.stopHeartbeat();
    marketConditionAnalyzer.stop();
    alpacaTradingEngine.disableOrchestratorControl();
    log.info("Orchestrator", "Disabled orchestrator control - AlpacaTradingEngine can now trade autonomously");
    await storage.updateAgentStatus({ isRunning: false });
    log.info("Orchestrator", "Stopped autonomous trading mode");
  }
  async activateKillSwitch(reason) {
    log.warn("Orchestrator", `KILL SWITCH ACTIVATED: ${reason}`);
    this.riskLimits.killSwitchActive = true;
    await this.stop();
    await storage.updateAgentStatus({ killSwitchActive: true });
    this.state.errors.push(`Kill switch activated: ${reason}`);
  }
  async deactivateKillSwitch() {
    this.riskLimits.killSwitchActive = false;
    await storage.updateAgentStatus({ killSwitchActive: false });
    log.info("Orchestrator", "Kill switch deactivated");
  }
  async runAnalysisCycle() {
    if (this.isProcessing || !this.state.isRunning) return;
    this.isProcessing = true;
    const cycleId = log.generateCycleId();
    log.setCycleId(cycleId);
    this.currentTraceId = cycleId;
    try {
      const allSessions = tradingSessionManager.getAllSessionInfo();
      log.info("Orchestrator", "Running analysis cycle...", {
        cycleId,
        traceId: cycleId,
        marketSessions: {
          usEquities: allSessions.US_EQUITIES.session,
          crypto: allSessions.CRYPTO.session,
          usEquitiesOpen: allSessions.US_EQUITIES.isOpen,
          nextOpen: allSessions.US_EQUITIES.nextOpen?.toISOString()
        }
      });
      this.state.lastAnalysisTime = /* @__PURE__ */ new Date();
      await this.loadRiskLimitsFromDB();
      if (this.riskLimits.killSwitchActive) {
        log.info("Orchestrator", "Kill switch active - skipping analysis");
        return;
      }
      const canceledOrderCount = await cancelExpiredOrders();
      if (canceledOrderCount > 0) {
        log.info("Orchestrator", `Analysis cycle: cleaned up ${canceledOrderCount} stale pending orders`);
      }
      const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      if (this.lastCalibrationDate !== today) {
        this.lastCalibrationDate = today;
        runCalibrationAnalysis(30).catch(
          (err) => log.error("Orchestrator", `Calibration failed: ${err}`)
        );
        log.info("Orchestrator", "Daily AI calibration triggered");
      }
      if (this.checkDailyLossLimit()) {
        await this.activateKillSwitch("Daily loss limit exceeded");
        return;
      }
      const marketData = await this.fetchMarketData();
      const allStrategies = await storage.getStrategies();
      const activeStrategies = allStrategies.filter((s) => s.isActive);
      for (const [symbol, data] of marketData.entries()) {
        const strategy = activeStrategies.find(
          (s) => s.assets?.includes(symbol)
        ) || activeStrategies[0];
        try {
          const decision = await aiDecisionEngine.analyzeOpportunity(
            symbol,
            data,
            void 0,
            strategy ? {
              id: strategy.id,
              name: strategy.name,
              type: strategy.type,
              parameters: strategy.parameters ? JSON.parse(strategy.parameters) : void 0
            } : void 0,
            { traceId: this.currentTraceId || void 0 }
          );
          if (decision.confidence >= 0.7 && decision.action !== "hold") {
            const aiDecision = await storage.createAiDecision({
              strategyId: strategy?.id || null,
              symbol,
              action: decision.action,
              confidence: decision.confidence.toString(),
              reasoning: decision.reasoning,
              marketContext: JSON.stringify(data),
              status: "pending",
              traceId: this.currentTraceId
            });
            recordDecisionFeatures(aiDecision.id, symbol, {
              volatility: data.priceChangePercent24h ? Math.abs(data.priceChangePercent24h) / 10 : void 0,
              priceChangePercent: data.priceChangePercent24h,
              marketCondition: this.state.mode
            }).catch((err) => log.error("Orchestrator", `Failed to record features: ${err}`));
            if (decision.action === "buy" && decision.confidence >= 0.7) {
              this.autoApproveSymbol(symbol).catch(
                (err) => log.warn("Orchestrator", `Auto-approve failed for ${symbol}: ${err}`)
              );
            }
            this.state.pendingSignals.set(symbol, { ...decision, aiDecisionId: aiDecision.id });
          }
        } catch (error) {
          log.error("Orchestrator", `Analysis failed for ${symbol}`, { error: String(error) });
        }
      }
      await this.processSignals();
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Get the dynamic analysis universe by merging multiple sources:
   * - Base watchlist stocks/crypto
   * - APPROVED candidates from candidatesService
   * - Symbols from recent high-confidence AI decisions
   * - Symbols from recently executed trades (with boost priority)
   */
  async getAnalysisUniverseSymbols() {
    const sources = { watchlist: 0, candidates: 0, recentDecisions: 0, executedTrades: 0 };
    const watchlist = await getWatchlist();
    const stockSet = new Set(watchlist.stocks.map((s) => s.toUpperCase()));
    const cryptoSet = new Set(watchlist.crypto.map((c) => c.toUpperCase()));
    sources.watchlist = stockSet.size + cryptoSet.size;
    try {
      const approvedSymbols = await candidatesService.getApprovedSymbols();
      for (const symbol of approvedSymbols) {
        const upper = symbol.toUpperCase();
        if (isCryptoSymbol(upper)) {
          cryptoSet.add(upper.replace("/USD", ""));
        } else {
          stockSet.add(upper);
        }
      }
      sources.candidates = approvedSymbols.length;
    } catch (error) {
      log.warn("Orchestrator", "Failed to get approved candidates", { error: String(error) });
    }
    try {
      const recentDecisions = await storage.getAiDecisions(RECENT_DECISIONS_LOOKBACK);
      const highConfDecisions = recentDecisions.filter((d) => {
        const confidence = parseFloat(d.confidence || "0");
        return confidence >= MIN_CONFIDENCE_FOR_UNIVERSE && d.action !== "hold";
      });
      for (const decision of highConfDecisions) {
        const upper = decision.symbol.toUpperCase();
        if (isCryptoSymbol(upper)) {
          cryptoSet.add(upper.replace("/USD", ""));
        } else {
          stockSet.add(upper);
        }
        if (decision.executedTradeId) {
          sources.executedTrades++;
        }
      }
      sources.recentDecisions = highConfDecisions.length;
    } catch (error) {
      log.warn("Orchestrator", "Failed to get recent AI decisions for universe", { error: String(error) });
    }
    let stocks = Array.from(stockSet);
    let crypto4 = Array.from(cryptoSet);
    if (stocks.length > MAX_STOCK_SYMBOLS_PER_CYCLE) {
      const now = Date.now();
      const hoursSinceLastRotation = (now - universeRotationState.lastRotationTime.getTime()) / (1e3 * 60 * 60);
      if (hoursSinceLastRotation >= 1) {
        universeRotationState.stockRotationOffset = (universeRotationState.stockRotationOffset + MAX_STOCK_SYMBOLS_PER_CYCLE / 2) % stocks.length;
        universeRotationState.lastRotationTime = /* @__PURE__ */ new Date();
      }
      const offset = universeRotationState.stockRotationOffset;
      const rotated = [...stocks.slice(offset), ...stocks.slice(0, offset)];
      stocks = rotated.slice(0, MAX_STOCK_SYMBOLS_PER_CYCLE);
    }
    if (crypto4.length > MAX_CRYPTO_SYMBOLS_PER_CYCLE) {
      const offset = universeRotationState.cryptoRotationOffset;
      const rotated = [...crypto4.slice(offset), ...crypto4.slice(0, offset)];
      crypto4 = rotated.slice(0, MAX_CRYPTO_SYMBOLS_PER_CYCLE);
    }
    log.info("Orchestrator", `Universe built: ${stocks.length} stocks, ${crypto4.length} crypto`, {
      sources,
      totalStockPool: stockSet.size,
      totalCryptoPool: cryptoSet.size
    });
    return { stocks, crypto: crypto4, sources };
  }
  async fetchMarketData() {
    const marketData = /* @__PURE__ */ new Map();
    const universe = await this.getAnalysisUniverseSymbols();
    try {
      const fetchedFromAlpaca = /* @__PURE__ */ new Set();
      for (let i = 0; i < universe.stocks.length; i += ALPACA_SNAPSHOT_CHUNK_SIZE) {
        const chunk = universe.stocks.slice(i, i + ALPACA_SNAPSHOT_CHUNK_SIZE);
        try {
          const snapshots = await alpaca.getSnapshots(chunk);
          for (const [symbol, snapshot] of Object.entries(snapshots)) {
            if (snapshot?.latestTrade?.p || snapshot?.dailyBar?.c) {
              const price = snapshot.latestTrade?.p || snapshot.dailyBar?.c || 0;
              const prevClose = snapshot.prevDailyBar?.c || price;
              const change = price - prevClose;
              const changePercent = prevClose > 0 ? change / prevClose * 100 : 0;
              marketData.set(symbol, {
                symbol,
                currentPrice: price,
                priceChange24h: change,
                priceChangePercent24h: changePercent,
                high24h: snapshot.dailyBar?.h,
                low24h: snapshot.dailyBar?.l,
                volume: snapshot.dailyBar?.v
              });
              fetchedFromAlpaca.add(symbol);
            }
          }
        } catch (chunkError) {
          log.warn("Orchestrator", `Alpaca snapshot chunk failed, will use Finnhub fallback`, {
            chunkStart: i,
            error: String(chunkError)
          });
        }
      }
      const missingSymbols = universe.stocks.filter((s) => !fetchedFromAlpaca.has(s));
      if (missingSymbols.length > 0 && missingSymbols.length <= 30) {
        try {
          const finnhubPrices = await finnhub.getMultipleQuotes(missingSymbols);
          for (const [symbol, quote] of finnhubPrices.entries()) {
            if (quote.c > 0) {
              marketData.set(symbol, {
                symbol,
                currentPrice: quote.c,
                priceChange24h: quote.d,
                priceChangePercent24h: quote.dp,
                high24h: quote.h,
                low24h: quote.l
              });
            }
          }
          log.info("Orchestrator", `Finnhub fallback fetched ${finnhubPrices.size}/${missingSymbols.length} symbols`);
        } catch (finnhubError) {
          log.warn("Orchestrator", `Finnhub fallback also failed`, { error: String(finnhubError) });
        }
      }
      log.info("Orchestrator", `Stock data fetched: ${marketData.size}/${universe.stocks.length} symbols via Alpaca+Finnhub`);
    } catch (error) {
      log.error("Orchestrator", "Failed to fetch stock data", { error: String(error) });
    }
    try {
      const cryptoSymbols = universe.crypto.map((c) => normalizeCryptoSymbol(c));
      if (cryptoSymbols.length > 0) {
        try {
          const cryptoSnapshots = await alpaca.getCryptoSnapshots(cryptoSymbols);
          for (const [symbol, snapshot] of Object.entries(cryptoSnapshots)) {
            if (snapshot?.latestTrade?.p) {
              const price = snapshot.latestTrade.p;
              const prevClose = snapshot.prevDailyBar?.c || price;
              const change = price - prevClose;
              const changePercent = prevClose > 0 ? change / prevClose * 100 : 0;
              const bareSymbol = symbol.replace("/USD", "").toUpperCase();
              marketData.set(bareSymbol, {
                symbol: bareSymbol,
                currentPrice: price,
                priceChange24h: change,
                priceChangePercent24h: changePercent,
                high24h: snapshot.dailyBar?.h,
                low24h: snapshot.dailyBar?.l,
                volume: snapshot.dailyBar?.v
              });
            }
          }
          log.info("Orchestrator", `Crypto data fetched via Alpaca: ${Object.keys(cryptoSnapshots).length} symbols`);
        } catch (alpacaCryptoError) {
          log.warn("Orchestrator", "Alpaca crypto failed, falling back to CoinGecko", { error: String(alpacaCryptoError) });
          const cryptoPrices = await coingecko.getMarkets();
          const watchedCrypto = cryptoPrices.filter(
            (c) => universe.crypto.includes(c.symbol.toUpperCase())
          );
          for (const price of watchedCrypto) {
            marketData.set(price.symbol.toUpperCase(), {
              symbol: price.symbol.toUpperCase(),
              currentPrice: price.current_price,
              priceChange24h: price.price_change_24h || 0,
              priceChangePercent24h: price.price_change_percentage_24h || 0,
              high24h: price.high_24h,
              low24h: price.low_24h,
              volume: price.total_volume,
              marketCap: price.market_cap
            });
          }
        }
      }
    } catch (error) {
      log.error("Orchestrator", "Failed to fetch crypto data", { error: String(error) });
    }
    return marketData;
  }
  async processSignals() {
    for (const [symbol, decision] of this.state.pendingSignals.entries()) {
      let result;
      try {
        result = await this.executeSignal(symbol, decision);
      } catch (error) {
        result = {
          success: false,
          action: "skip",
          reason: `Execution error: ${String(error)}`,
          symbol
        };
        log.error("Orchestrator", `Error executing signal for ${symbol}`, { error: String(error) });
      }
      this.state.executionHistory.push(result);
      if (decision.aiDecisionId) {
        try {
          if (result.success && result.action !== "hold" && result.action !== "skip") {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "executed",
              filledPrice: result.price?.toString(),
              filledAt: /* @__PURE__ */ new Date()
            });
          } else if (result.action === "hold") {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "skipped",
              skipReason: "Hold action - no trade executed"
            });
          } else {
            await storage.updateAiDecision(decision.aiDecisionId, {
              status: "skipped",
              skipReason: result.reason || "Trade not executed"
            });
          }
        } catch (e) {
          log.error("Orchestrator", `Failed to update AI decision status for ${decision.aiDecisionId}`, { error: String(e) });
        }
      }
      if (this.state.executionHistory.length > 100) {
        this.state.executionHistory = this.state.executionHistory.slice(-100);
      }
    }
    this.state.pendingSignals.clear();
  }
  async executeSignal(symbol, decision) {
    const positionCount = this.state.activePositions.size;
    if (decision.action === "buy" && positionCount >= this.riskLimits.maxPositionsCount) {
      return {
        success: false,
        action: "skip",
        reason: `Max positions limit reached (${positionCount}/${this.riskLimits.maxPositionsCount})`,
        symbol
      };
    }
    const existingPosition = this.state.activePositions.get(symbol);
    if (decision.action === "buy" && existingPosition) {
      if (decision.confidence >= 0.5) {
        log.info("Orchestrator", `Reinforcing position: ${symbol} (confidence: ${(decision.confidence * 100).toFixed(1)}%)`);
        return await this.reinforcePosition(symbol, decision, existingPosition);
      }
      return {
        success: false,
        action: "skip",
        reason: `Already have position, confidence ${(decision.confidence * 100).toFixed(1)}% below 50% threshold`,
        symbol
      };
    }
    if (decision.action === "sell" && !existingPosition) {
      return {
        success: false,
        action: "skip",
        reason: "No position to sell",
        symbol
      };
    }
    if (decision.action === "buy") {
      return await this.openPosition(symbol, decision);
    }
    if (decision.action === "sell" && existingPosition) {
      return await this.closePosition(symbol, decision, existingPosition);
    }
    return {
      success: true,
      action: "hold",
      reason: decision.reasoning,
      symbol
    };
  }
  async openPosition(symbol, decision) {
    try {
      const account = await alpaca.getAccount();
      const portfolioValue = safeParseFloat(account.portfolio_value);
      const positionSizePercent = Math.min(
        (decision.suggestedQuantity || 0.05) * 100,
        this.riskLimits.maxPositionSizePercent
      );
      const positionValue = portfolioValue * (positionSizePercent / 100);
      const totalExposure = this.calculateTotalExposure(portfolioValue);
      if (totalExposure + positionSizePercent > this.riskLimits.maxTotalExposurePercent) {
        return {
          success: false,
          action: "skip",
          reason: `Would exceed max exposure (${totalExposure.toFixed(1)}% + ${positionSizePercent.toFixed(1)}% > ${this.riskLimits.maxTotalExposurePercent}%)`,
          symbol
        };
      }
      const sectorCheck = await sectorExposureService.checkExposure(
        symbol,
        positionValue,
        this.state.activePositions,
        portfolioValue
      );
      if (!sectorCheck.canTrade) {
        log.warn("Orchestrator", `Sector exposure check failed for ${symbol}`, {
          sector: sectorCheck.sector,
          currentExposure: sectorCheck.currentExposure.toFixed(1),
          maxExposure: sectorCheck.maxExposure
        });
        return {
          success: false,
          action: "skip",
          reason: sectorCheck.reason || `Sector exposure limit exceeded for ${sectorCheck.sector}`,
          symbol
        };
      }
      const isCrypto = isCryptoSymbol(symbol);
      const brokerSymbol = isCrypto ? normalizeCryptoSymbol(symbol) : symbol;
      const tradableCheck = await isSymbolTradable(symbol, isCrypto);
      if (!tradableCheck.tradable) {
        log.warn("Orchestrator", `Symbol ${symbol} not tradable: ${tradableCheck.reason}`);
        return {
          success: false,
          action: "skip",
          reason: tradableCheck.reason || "Symbol not tradable",
          symbol
        };
      }
      const preCheck = await preTradeGuard(symbol, "buy", positionValue, isCrypto);
      if (!preCheck.canTrade) {
        log.warn("Orchestrator", `Pre-trade check failed for ${symbol}: ${preCheck.reason}`);
        return {
          success: false,
          action: "skip",
          reason: preCheck.reason || "Pre-trade check failed",
          symbol
        };
      }
      const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
      if (!tradabilityCheck.tradable) {
        log.warn("Orchestrator", `Symbol ${symbol} not tradable: ${tradabilityCheck.reason}`);
        return {
          success: false,
          action: "skip",
          reason: `Symbol not tradable: ${tradabilityCheck.reason || "Not in broker universe"}`,
          symbol
        };
      }
      let queuedResult;
      const hasBracketParams = false;
      if (preCheck.useExtendedHours && preCheck.useLimitOrder && preCheck.limitPrice) {
        log.info("Orchestrator", `Extended hours limit order for ${symbol} @ $${preCheck.limitPrice}`);
        const estimatedQty = Math.floor(positionValue / preCheck.limitPrice);
        if (estimatedQty < 1) {
          return {
            success: false,
            action: "skip",
            reason: `Position value too small for whole share order ($${positionValue.toFixed(2)} at $${preCheck.limitPrice})`,
            symbol
          };
        }
        const orderParams = {
          symbol: brokerSymbol,
          qty: estimatedQty.toString(),
          side: "buy",
          type: "limit",
          time_in_force: "day",
          limit_price: preCheck.limitPrice.toFixed(2),
          extended_hours: true
        };
        queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "buy",
          decisionId: decision.aiDecisionId
        });
      } else if (hasBracketParams && decision.targetPrice && decision.stopLoss) {
        log.info("Orchestrator", `Bracket order for ${symbol}: TP=$${decision.targetPrice.toFixed(2)}, SL=$${decision.stopLoss.toFixed(2)}`);
        const currentPrice = await this.fetchCurrentPrice(symbol);
        if (currentPrice > 0 && positionValue > 0) {
          const estimatedQty = (positionValue / currentPrice).toFixed(6);
          const orderParams = {
            symbol: brokerSymbol,
            qty: estimatedQty,
            side: "buy",
            type: "market",
            time_in_force: "day",
            // FIXED: Was "gtc" which causes 422 rejection
            order_class: "bracket",
            // Flat fields for work-queue compatibility
            take_profit_limit_price: decision.targetPrice.toFixed(2),
            stop_loss_stop_price: decision.stopLoss.toFixed(2),
            // Also include nested format for direct API calls
            take_profit: { limit_price: decision.targetPrice.toFixed(2) },
            stop_loss: { stop_price: decision.stopLoss.toFixed(2) }
          };
          queuedResult = await queueOrderExecution({
            orderParams,
            traceId: this.currentTraceId,
            symbol,
            side: "buy",
            decisionId: decision.aiDecisionId
          });
        } else {
          log.warn("Orchestrator", `Bracket order fallback - invalid price/value for ${symbol}`);
          const orderParams = {
            symbol: brokerSymbol,
            notional: positionValue.toFixed(2),
            side: "buy",
            type: "market",
            time_in_force: "day"
          };
          queuedResult = await queueOrderExecution({
            orderParams,
            traceId: this.currentTraceId,
            symbol,
            side: "buy",
            decisionId: decision.aiDecisionId
          });
        }
      } else {
        const orderParams = {
          symbol: brokerSymbol,
          notional: positionValue.toFixed(2),
          side: "buy",
          type: "market",
          time_in_force: "day"
          // FIXED: Market orders cannot use GTC (was causing 422 rejections for crypto)
        };
        queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "buy",
          decisionId: decision.aiDecisionId
        });
      }
      const fillResult = await waitForAlpacaOrderFill(queuedResult.orderId);
      if (!fillResult.order) {
        log.error("Orchestrator", `Order ${queuedResult.orderId} - no order data received`);
        await this.syncPositionsFromBroker();
        return {
          success: false,
          action: "buy",
          reason: "Order failed - no response from broker",
          symbol,
          orderId: queuedResult.orderId
        };
      }
      if (!fillResult.hasFillData) {
        log.error("Orchestrator", `Order ${queuedResult.orderId} has no fill data, syncing positions`);
        await this.syncPositionsFromBroker();
        return {
          success: false,
          action: "buy",
          reason: fillResult.timedOut ? "Order fill timed out - position sync triggered" : "Order rejected or no fill data",
          symbol,
          orderId: queuedResult.orderId
        };
      }
      if (fillResult.timedOut && !fillResult.isFullyFilled) {
        log.warn("Orchestrator", `Order ${queuedResult.orderId} timed out with partial fill, using available data`);
      }
      const order = fillResult.order;
      let filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      if (filledPrice === 0) {
        try {
          const isCrypto2 = isCryptoSymbol(symbol);
          if (isCrypto2) {
            const normSymbol = normalizeCryptoSymbol(symbol);
            const snapshots = await alpaca.getCryptoSnapshots([normSymbol]);
            const snapshot = snapshots[normSymbol];
            filledPrice = snapshot?.latestTrade?.p || 0;
          } else {
            const snapshots = await alpaca.getSnapshots([symbol]);
            const snapshot = snapshots[symbol];
            filledPrice = snapshot?.latestTrade?.p || 0;
          }
          if (filledPrice > 0) {
            log.info("Orchestrator", `Using market price ${filledPrice} for ${symbol}`);
          }
        } catch (error) {
          log.warn("Orchestrator", `Failed to fetch market price for ${symbol}`, { error: String(error) });
        }
      }
      const trade = await storage.createTrade({
        symbol,
        side: "buy",
        quantity: filledQty.toString(),
        price: filledPrice.toString(),
        status: "completed",
        notes: `AI autonomous: ${decision.reasoning}`,
        traceId: this.currentTraceId
      });
      if (decision.aiDecisionId) {
        const marketStatus = await alpaca.getMarketStatus();
        recordTradeOutcome({
          decisionId: decision.aiDecisionId,
          tradeId: trade.id,
          symbol,
          action: "buy",
          predictionConfidence: decision.confidence,
          entryPrice: filledPrice,
          quantity: filledQty,
          marketSessionAtEntry: marketStatus.session,
          strategyId: void 0
        }).catch((err) => log.error("Orchestrator", `Failed to record trade outcome: ${err}`));
      }
      this.state.dailyTradeCount++;
      const positionWithRules = {
        symbol,
        quantity: filledQty,
        availableQuantity: filledQty,
        entryPrice: filledPrice,
        currentPrice: filledPrice,
        unrealizedPnl: 0,
        unrealizedPnlPercent: 0,
        openedAt: /* @__PURE__ */ new Date(),
        stopLossPrice: decision.stopLoss,
        takeProfitPrice: decision.targetPrice,
        trailingStopPercent: decision.trailingStopPercent
      };
      this.state.activePositions.set(symbol, positionWithRules);
      advancedRebalancingService.registerPosition(symbol, filledPrice);
      log.info("Orchestrator", `Registered ${symbol} with advanced rebalancing (4-tier take-profits, trailing stops)`);
      log.trade(`Opened position: ${symbol} $${positionValue.toFixed(2)}`, { symbol, value: positionValue });
      return {
        success: true,
        orderId: order.id,
        action: "buy",
        reason: decision.reasoning,
        symbol,
        quantity: positionWithRules.quantity,
        price: positionWithRules.entryPrice
      };
    } catch (error) {
      log.error("Orchestrator", `Failed to open position ${symbol}`, { error: String(error) });
      return {
        success: false,
        action: "buy",
        reason: `Order failed: ${error}`,
        symbol,
        error: String(error)
      };
    }
  }
  async closePosition(symbol, decision, position, partialPercent = 100, options = {}) {
    try {
      const isCrypto = isCryptoSymbol(symbol);
      const brokerSymbol = isCrypto ? normalizeCryptoSymbol(symbol) : symbol;
      const isAtLoss = position.currentPrice < position.entryPrice;
      const isProtectedClose = options.isStopLossTriggered || options.isEmergencyStop;
      if (isAtLoss && !isProtectedClose) {
        const lossPercent = ((position.entryPrice - position.currentPrice) / position.entryPrice * 100).toFixed(2);
        log.info("Orchestrator", `Blocking close of ${symbol} at ${lossPercent}% loss - stop loss not triggered`, {
          symbol,
          entryPrice: position.entryPrice,
          currentPrice: position.currentPrice,
          lossPercent
        });
        return {
          success: false,
          action: "hold",
          reason: `Position at ${lossPercent}% loss - holding until stop-loss triggers or price recovers`,
          symbol
        };
      }
      try {
        const openOrders = await alpaca.getOrders("open");
        const symbolOrders = openOrders.filter((o) => o.symbol === brokerSymbol);
        for (const order2 of symbolOrders) {
          try {
            await queueOrderCancellation({
              orderId: order2.id,
              traceId: this.currentTraceId,
              symbol
            });
            log.info("Orchestrator", `Queued cancellation for pending order ${order2.id} for ${symbol} before closing`);
          } catch {
          }
        }
        if (symbolOrders.length > 0) {
          await new Promise((resolve2) => setTimeout(resolve2, 500));
        }
      } catch (err) {
        log.warn("Orchestrator", `Failed to cancel orders for ${symbol}: ${err}`);
      }
      let orderId;
      if (partialPercent >= 100) {
        const initialOrder = await alpaca.closePosition(brokerSymbol);
        orderId = initialOrder.id;
      } else {
        const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
        if (!tradabilityCheck.tradable) {
          log.warn("Orchestrator", `Cannot partial close ${symbol}: not tradable`);
          return {
            success: false,
            action: "sell",
            reason: `Symbol not tradable: ${tradabilityCheck.reason || "Not in broker universe"}`,
            symbol
          };
        }
        const closeQty = position.quantity * partialPercent / 100;
        const orderParams = {
          symbol: brokerSymbol,
          qty: closeQty.toString(),
          side: "sell",
          type: "market",
          time_in_force: "day"
          // FIXED: Market orders cannot use GTC (even for crypto)
        };
        const queuedResult = await queueOrderExecution({
          orderParams,
          traceId: this.currentTraceId,
          symbol,
          side: "sell",
          decisionId: decision.aiDecisionId
        });
        orderId = queuedResult.orderId;
      }
      const fillResult = await waitForAlpacaOrderFill(orderId);
      if (!fillResult.order) {
        log.error("Orchestrator", `Close order ${orderId} - no order data received`);
        await this.syncPositionsFromBroker();
        return {
          success: false,
          action: "sell",
          reason: "Close order failed - no response from broker",
          symbol,
          orderId
        };
      }
      if (!fillResult.hasFillData) {
        log.error("Orchestrator", `Close order ${orderId} has no fill data, syncing positions`);
        await this.syncPositionsFromBroker();
        return {
          success: false,
          action: "sell",
          reason: fillResult.timedOut ? "Close order fill timed out - position sync triggered" : "Close order rejected or no fill data",
          symbol,
          orderId
        };
      }
      if (fillResult.timedOut && !fillResult.isFullyFilled) {
        log.warn("Orchestrator", `Close order ${orderId} timed out with partial fill, using available data`);
      }
      const order = fillResult.order;
      let filledPrice = safeParseFloat(order.filled_avg_price, 0);
      const filledQty = safeParseFloat(order.filled_qty, 0);
      if (filledPrice === 0) {
        try {
          const isCrypto2 = isCryptoSymbol(symbol);
          if (isCrypto2) {
            const normSymbol = normalizeCryptoSymbol(symbol);
            const snapshots = await alpaca.getCryptoSnapshots([normSymbol]);
            const snapshot = snapshots[normSymbol];
            filledPrice = snapshot?.latestTrade?.p || 0;
          } else {
            const snapshots = await alpaca.getSnapshots([symbol]);
            const snapshot = snapshots[symbol];
            filledPrice = snapshot?.latestTrade?.p || 0;
          }
          if (filledPrice > 0) {
            log.info("Orchestrator", `Using market price ${filledPrice} for ${symbol}`);
          }
        } catch (error) {
          log.warn("Orchestrator", `Failed to fetch market price for ${symbol}`, { error: String(error) });
        }
      }
      const pnl = (filledPrice - position.entryPrice) * filledQty;
      const exitReason = decision.reasoning || (pnl > 0 ? "take_profit" : "stop_loss");
      await storage.createTrade({
        symbol,
        side: "sell",
        quantity: filledQty.toString(),
        price: filledPrice.toString(),
        pnl: pnl.toString(),
        status: "completed",
        notes: `AI autonomous: ${decision.reasoning}`,
        traceId: this.currentTraceId
      });
      if (decision.aiDecisionId) {
        const marketStatus = await alpaca.getMarketStatus();
        updateTradeOutcomeOnClose(
          decision.aiDecisionId,
          filledPrice,
          exitReason,
          marketStatus.session
        ).catch((err) => log.error("Orchestrator", `Failed to update trade outcome: ${err}`));
      }
      this.state.dailyPnl += pnl;
      this.state.dailyTradeCount++;
      if (partialPercent >= 100) {
        this.state.activePositions.delete(symbol);
        advancedRebalancingService.removePositionRules(symbol);
      } else {
        const remaining = position.quantity * (1 - partialPercent / 100);
        position.quantity = remaining;
        this.state.activePositions.set(symbol, position);
      }
      log.trade(`Closed ${partialPercent}% of ${symbol}, P&L: $${pnl.toFixed(2)}`, { symbol, pnl, partialPercent });
      return {
        success: true,
        orderId: order.id,
        action: "sell",
        reason: decision.reasoning,
        symbol,
        quantity: filledQty,
        price: filledPrice
      };
    } catch (error) {
      log.error("Orchestrator", `Failed to close position ${symbol}`, { error: String(error) });
      return {
        success: false,
        action: "sell",
        reason: `Close failed: ${error}`,
        symbol,
        error: String(error)
      };
    }
  }
  async reinforcePosition(symbol, decision, existingPosition) {
    log.info("Orchestrator", `Reinforcing position: ${symbol}`);
    const reinforceDecision = {
      ...decision,
      suggestedQuantity: (decision.suggestedQuantity || 0.05) * 0.5
    };
    return await this.openPosition(symbol, reinforceDecision);
  }
  async runPositionManagementCycle() {
    if (!this.state.isRunning) return;
    try {
      this.state.lastPositionCheckTime = /* @__PURE__ */ new Date();
      await this.syncPositionsFromBroker();
      for (const [symbol, position] of this.state.activePositions.entries()) {
        await this.checkPositionRules(symbol, position);
      }
      await this.rebalancePositions();
    } catch (error) {
      log.error("Orchestrator", "Position management cycle error", { error: String(error) });
    }
  }
  async checkPositionRules(symbol, position) {
    if (position.stopLossPrice && position.currentPrice <= position.stopLossPrice) {
      log.warn("Orchestrator", `Stop-loss triggered for ${symbol}`);
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 1,
          reasoning: `Stop-loss triggered at $${position.stopLossPrice}`,
          riskLevel: "high"
        },
        position,
        100,
        { isStopLossTriggered: true }
      );
      return;
    }
    if (position.unrealizedPnlPercent <= -8) {
      log.warn("Orchestrator", `Emergency stop for ${symbol} at ${position.unrealizedPnlPercent.toFixed(1)}% loss`);
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 1,
          reasoning: `Emergency stop: ${position.unrealizedPnlPercent.toFixed(1)}% loss`,
          riskLevel: "high"
        },
        position,
        100,
        { isEmergencyStop: true }
      );
      return;
    }
    const partialTakeProfit = advancedRebalancingService.checkPartialTakeProfits(position);
    if (partialTakeProfit && partialTakeProfit.shouldClose) {
      log.info("Orchestrator", `Graduated take-profit for ${symbol}: ${partialTakeProfit.reason}`);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 0.95,
          reasoning: partialTakeProfit.reason,
          riskLevel: "low"
        },
        position,
        partialTakeProfit.closePercent
      );
      return;
    }
    const trailingUpdate = advancedRebalancingService.updateTrailingStop(position);
    if (trailingUpdate) {
      log.info("Orchestrator", `Trailing stop update for ${symbol}: ${trailingUpdate.reason}`);
      position.stopLossPrice = trailingUpdate.newStopLoss;
      this.state.activePositions.set(symbol, position);
    }
    const holdingCheck = advancedRebalancingService.checkHoldingPeriod(position);
    if (holdingCheck && holdingCheck.exceeded) {
      log.warn("Orchestrator", `Max holding period exceeded for ${symbol}: ${holdingCheck.holdingHours.toFixed(1)}h > ${holdingCheck.maxHours}h`);
      advancedRebalancingService.removePositionRules(symbol);
      await this.closePosition(
        symbol,
        {
          action: "sell",
          confidence: 0.8,
          reasoning: `Max holding period exceeded (${holdingCheck.holdingHours.toFixed(1)} hours)`,
          riskLevel: "medium"
        },
        position,
        100
      );
      return;
    }
    if (position.takeProfitPrice && position.currentPrice >= position.takeProfitPrice) {
      log.info("Orchestrator", `Legacy take-profit triggered for ${symbol}`);
      const pnlPercent = position.unrealizedPnlPercent;
      if (pnlPercent > 15) {
        await this.closePosition(
          symbol,
          {
            action: "sell",
            confidence: 1,
            reasoning: `Take-profit fully triggered at $${position.takeProfitPrice}`,
            riskLevel: "low"
          },
          position,
          100
        );
      } else if (pnlPercent > 10) {
        await this.closePosition(
          symbol,
          {
            action: "sell",
            confidence: 0.9,
            reasoning: `Partial take-profit at $${position.currentPrice}`,
            riskLevel: "low"
          },
          position,
          50
        );
      }
    }
  }
  calculateTotalExposure(portfolioValue) {
    let totalValue = 0;
    for (const position of this.state.activePositions.values()) {
      totalValue += position.currentPrice * position.quantity;
    }
    return totalValue / portfolioValue * 100;
  }
  checkDailyLossLimit() {
    const portfolioValue = this.state.portfolioValue || 1e5;
    const lossPercent = Math.abs(
      Math.min(0, this.state.dailyPnl) / portfolioValue
    ) * 100;
    return lossPercent >= this.riskLimits.dailyLossLimitPercent;
  }
  getState() {
    return { ...this.state };
  }
  getPendingAnalysis() {
    const pending = [];
    for (const [symbol, signal] of this.state.pendingSignals.entries()) {
      pending.push({
        symbol,
        startedAt: /* @__PURE__ */ new Date(),
        status: "pending_execution"
      });
    }
    return pending;
  }
  getRiskLimits() {
    return { ...this.riskLimits };
  }
  async updateRiskLimits(limits) {
    this.riskLimits = { ...this.riskLimits, ...limits };
    await storage.updateAgentStatus({
      maxPositionSizePercent: limits.maxPositionSizePercent?.toString(),
      maxTotalExposurePercent: limits.maxTotalExposurePercent?.toString(),
      maxPositionsCount: limits.maxPositionsCount,
      dailyLossLimitPercent: limits.dailyLossLimitPercent?.toString(),
      killSwitchActive: limits.killSwitchActive
    });
    log.info("Orchestrator", "Updated risk limits", { ...this.riskLimits });
  }
  async setMode(mode) {
    if (mode === "autonomous" && !this.state.isRunning) {
      await this.start();
    } else if (mode === "manual" && this.state.isRunning) {
      await this.stop();
    }
    this.state.mode = mode;
  }
  getMode() {
    return this.state.mode;
  }
  resetDailyStats() {
    this.state.dailyPnl = 0;
    this.state.dailyTradeCount = 0;
    log.info("Orchestrator", "Reset daily stats");
  }
  async rebalancePositions() {
    try {
      await this.syncPositionsFromBroker();
      const account = await alpaca.getAccount();
      const portfolioValue = parseFloat(account.portfolio_value);
      const buyingPower = safeParseFloat(account.buying_power);
      const availableCash = safeParseFloat(account.cash);
      if (portfolioValue <= 0) {
        log.warn("Orchestrator", "Cannot rebalance: invalid portfolio value");
        return;
      }
      const targetAllocationPercent = this.riskLimits.maxPositionSizePercent;
      const rebalanceThresholdPercent = 2;
      const buyTheDipThresholdPercent = 3;
      const minCashReservePercent = 10;
      log.debug("Orchestrator", `Account status: cash=${availableCash.toFixed(2)}, buyingPower=${buyingPower.toFixed(2)}, portfolioValue=${portfolioValue.toFixed(2)}`);
      const approvedSymbols = await candidatesService.getApprovedSymbols();
      const approvedSet = new Set(approvedSymbols.map((s) => s.toUpperCase()));
      for (const [symbol, position] of this.state.activePositions.entries()) {
        const positionValue = position.currentPrice * position.quantity;
        const currentAllocationPercent = positionValue / portfolioValue * 100;
        const drift = currentAllocationPercent - targetAllocationPercent;
        if (Math.abs(drift) > rebalanceThresholdPercent) {
          log.info("Orchestrator", `Position ${symbol} drifted by ${drift.toFixed(2)}%`);
          const cooldownUntil = this.orderCooldowns.get(symbol);
          if (cooldownUntil && Date.now() < cooldownUntil) {
            const remainingMs = cooldownUntil - Date.now();
            log.info("Orchestrator", `Skipping ${symbol}: on cooldown for ${Math.round(remainingMs / 1e3)}s after failed order`);
            continue;
          }
          if (drift > rebalanceThresholdPercent) {
            const excessValue = positionValue - portfolioValue * targetAllocationPercent / 100;
            let sharesToSell = Math.floor(excessValue / position.currentPrice);
            const availableShares = Math.floor(position.availableQuantity);
            if (availableShares <= 0) {
              log.warn("Orchestrator", `Skipping rebalance for ${symbol}: no available shares (${position.availableQuantity} available, ${position.quantity - position.availableQuantity} held for orders)`);
              continue;
            }
            if (sharesToSell > availableShares) {
              log.info("Orchestrator", `Limiting rebalance for ${symbol}: requested ${sharesToSell} but only ${availableShares} available`);
              sharesToSell = availableShares;
            }
            if (sharesToSell > 0 && sharesToSell < position.quantity) {
              log.info("Orchestrator", `Rebalancing: Selling ${sharesToSell} shares of ${symbol} (${availableShares} available)`);
              try {
                const result = await this.closePosition(
                  symbol,
                  {
                    action: "sell",
                    confidence: 0.8,
                    reasoning: `Rebalancing: Position overweight by ${drift.toFixed(1)}%`,
                    riskLevel: "low"
                  },
                  position,
                  sharesToSell / position.quantity * 100
                );
                if (!result.success) {
                  log.warn("Orchestrator", `Setting ${this.ORDER_COOLDOWN_MS / 1e3}s cooldown for ${symbol} after failed order: ${result.reason}`);
                  this.orderCooldowns.set(symbol, Date.now() + this.ORDER_COOLDOWN_MS);
                } else {
                  this.orderCooldowns.delete(symbol);
                }
              } catch (error) {
                log.error("Orchestrator", `Rebalance sell failed for ${symbol}: ${error.message}`);
                this.orderCooldowns.set(symbol, Date.now() + this.ORDER_COOLDOWN_MS);
              }
            }
          } else if (drift < -buyTheDipThresholdPercent) {
            if (!approvedSet.has(symbol.toUpperCase())) {
              log.info("Orchestrator", `Skipping buy-the-dip for ${symbol}: not in approved candidates`);
              continue;
            }
            const buyingPowerReserve = buyingPower * (minCashReservePercent / 100);
            const availableForBuying = Math.max(0, buyingPower - buyingPowerReserve);
            if (availableForBuying <= 0 && buyingPower <= 0) {
              log.info("Orchestrator", `Skipping buy-the-dip for ${symbol}: no buying power (${buyingPower.toFixed(2)} available)`);
              continue;
            }
            const deficitValue = portfolioValue * targetAllocationPercent / 100 - positionValue;
            const buyValue = Math.min(deficitValue, Math.max(availableForBuying, buyingPower * 0.1), portfolioValue * 0.02);
            if (buyValue >= 50 && position.unrealizedPnlPercent <= 0) {
              log.info("Orchestrator", `Buy-the-dip: Adding $${buyValue.toFixed(2)} to underweight ${symbol} (at ${position.unrealizedPnlPercent.toFixed(1)}% loss)`);
              const isCrypto = isCryptoSymbol(symbol);
              const brokerSymbol = isCrypto ? normalizeCryptoSymbol(symbol) : symbol;
              try {
                const preCheck = await preTradeGuard(symbol, "buy", buyValue, isCrypto);
                if (!preCheck.canTrade) {
                  log.warn("Orchestrator", `Buy-the-dip blocked for ${symbol}: ${preCheck.reason}`);
                  continue;
                }
                await queueOrderExecution({
                  orderParams: {
                    symbol: brokerSymbol,
                    side: "buy",
                    type: preCheck.useLimitOrder ? "limit" : "market",
                    notional: buyValue.toFixed(2),
                    time_in_force: "day",
                    extended_hours: preCheck.useExtendedHours,
                    ...preCheck.limitPrice && { limit_price: preCheck.limitPrice.toString() }
                  },
                  traceId: this.currentTraceId,
                  symbol,
                  side: "buy"
                });
                log.trade(`Buy-the-dip: ${symbol} $${buyValue.toFixed(2)}`, { symbol, value: buyValue });
              } catch (error) {
                log.error("Orchestrator", `Buy-the-dip failed for ${symbol}`, { error: String(error) });
              }
            }
          }
        }
      }
      const pyramidedThisCycle = /* @__PURE__ */ new Set();
      const pyramidMinProfitPercent = 5;
      const pyramidMaxProfitPercent = 20;
      for (const [symbol, position] of this.state.activePositions.entries()) {
        if (pyramidedThisCycle.has(symbol) || !approvedSet.has(symbol.toUpperCase())) {
          continue;
        }
        if (position.unrealizedPnlPercent >= pyramidMinProfitPercent && position.unrealizedPnlPercent <= pyramidMaxProfitPercent) {
          const cashReserve = portfolioValue * (minCashReservePercent / 100);
          const availableForBuying = Math.max(0, availableCash - cashReserve);
          if (availableForBuying <= 50) {
            continue;
          }
          const originalPositionValue = position.quantity * position.entryPrice;
          const pyramidValue = Math.min(
            originalPositionValue * 0.5,
            // 50% of original position
            availableForBuying,
            portfolioValue * 0.05
            // Max 5% of portfolio per pyramid
          );
          if (pyramidValue >= 50) {
            log.info("Orchestrator", `Pyramid-up: Adding $${pyramidValue.toFixed(2)} (50% of original) to winning ${symbol} (at +${position.unrealizedPnlPercent.toFixed(1)}%)`);
            const isCrypto = isCryptoSymbol(symbol);
            const brokerSymbol = isCrypto ? normalizeCryptoSymbol(symbol) : symbol;
            try {
              const preCheck = await preTradeGuard(symbol, "buy", pyramidValue, isCrypto);
              if (!preCheck.canTrade) {
                log.warn("Orchestrator", `Pyramid-up blocked for ${symbol}: ${preCheck.reason}`);
                continue;
              }
              await queueOrderExecution({
                orderParams: {
                  symbol: brokerSymbol,
                  side: "buy",
                  type: preCheck.useLimitOrder ? "limit" : "market",
                  notional: pyramidValue.toFixed(2),
                  time_in_force: "day",
                  extended_hours: preCheck.useExtendedHours,
                  ...preCheck.limitPrice && { limit_price: preCheck.limitPrice.toString() }
                },
                traceId: this.currentTraceId,
                symbol,
                side: "buy"
              });
              pyramidedThisCycle.add(symbol);
              log.trade(`Pyramid-up: ${symbol} $${pyramidValue.toFixed(2)} (+${position.unrealizedPnlPercent.toFixed(1)}%)`, {
                symbol,
                value: pyramidValue,
                profitPercent: position.unrealizedPnlPercent
              });
            } catch (error) {
              log.error("Orchestrator", `Pyramid-up failed for ${symbol}`, { error: String(error) });
            }
          }
        }
      }
    } catch (error) {
      log.error("Orchestrator", "Rebalancing error", { error: String(error) });
      this.state.errors.push(`Rebalancing failed: ${error}`);
    }
  }
  async adjustStopLossTakeProfit(symbol, newStopLoss, newTakeProfit, trailingStopPercent) {
    const position = this.state.activePositions.get(symbol);
    if (!position) {
      log.warn("Orchestrator", `Cannot adjust SL/TP: Position ${symbol} not found`);
      return false;
    }
    if (newStopLoss !== void 0) {
      if (newStopLoss >= position.currentPrice) {
        log.warn("Orchestrator", `Invalid stop loss: $${newStopLoss} >= current price $${position.currentPrice}`);
        return false;
      }
      position.stopLossPrice = newStopLoss;
    }
    if (newTakeProfit !== void 0) {
      if (newTakeProfit <= position.currentPrice) {
        log.warn("Orchestrator", `Invalid take profit: $${newTakeProfit} <= current price $${position.currentPrice}`);
        return false;
      }
      position.takeProfitPrice = newTakeProfit;
    }
    if (trailingStopPercent !== void 0) {
      if (trailingStopPercent <= 0 || trailingStopPercent >= 100) {
        log.warn("Orchestrator", `Invalid trailing stop percent: ${trailingStopPercent}`);
        return false;
      }
      position.trailingStopPercent = trailingStopPercent;
    }
    this.state.activePositions.set(symbol, position);
    log.info("Orchestrator", `Updated ${symbol} - SL: $${position.stopLossPrice?.toFixed(2)}, TP: $${position.takeProfitPrice?.toFixed(2)}, Trail: ${position.trailingStopPercent || "N/A"}%`);
    return true;
  }
  async applyTrailingStopToAllPositions(trailPercent = 5) {
    for (const [symbol, position] of this.state.activePositions.entries()) {
      if (position.unrealizedPnlPercent > 0) {
        position.trailingStopPercent = trailPercent;
        this.state.activePositions.set(symbol, position);
        log.info("Orchestrator", `Applied ${trailPercent}% trailing stop to ${symbol}`);
      }
    }
  }
};
var orchestrator = new AutonomousOrchestrator();

// server/routes.ts
init_orchestration();
init_numeric();

// shared/position-mapper.ts
function safeParseFloat2(value, fallback = 0) {
  if (value === null || value === void 0) return fallback;
  const parsed = typeof value === "number" ? value : parseFloat(value);
  return isNaN(parsed) ? fallback : parsed;
}
function mapAlpacaPositionToEnriched(position, fetchedAt = /* @__PURE__ */ new Date()) {
  const qty = safeParseFloat2(position.qty);
  return {
    id: position.asset_id,
    symbol: position.symbol,
    quantity: qty,
    entryPrice: safeParseFloat2(position.avg_entry_price),
    currentPrice: safeParseFloat2(position.current_price),
    unrealizedPnl: safeParseFloat2(position.unrealized_pl),
    unrealizedPnlPercent: safeParseFloat2(position.unrealized_plpc) * 100,
    side: qty > 0 ? "long" : "short",
    marketValue: safeParseFloat2(position.market_value),
    costBasis: safeParseFloat2(position.cost_basis),
    changeToday: safeParseFloat2(position.change_today) * 100,
    assetClass: position.asset_class,
    exchange: position.exchange,
    _source: {
      source: "alpaca_live",
      fetchedAt: fetchedAt.toISOString(),
      isStale: false
    }
  };
}
function mapAlpacaOrderToEnriched(order, fetchedAt = /* @__PURE__ */ new Date()) {
  return {
    id: order.id,
    clientOrderId: order.client_order_id,
    symbol: order.symbol,
    quantity: safeParseFloat2(order.qty),
    filledQuantity: safeParseFloat2(order.filled_qty),
    side: order.side,
    type: order.type,
    status: order.status,
    limitPrice: order.limit_price ? safeParseFloat2(order.limit_price) : null,
    stopPrice: order.stop_price ? safeParseFloat2(order.stop_price) : null,
    filledAvgPrice: order.filled_avg_price ? safeParseFloat2(order.filled_avg_price) : null,
    createdAt: order.created_at,
    filledAt: order.filled_at,
    timeInForce: order.time_in_force,
    extendedHours: order.extended_hours,
    _source: {
      source: "alpaca_live",
      fetchedAt: fetchedAt.toISOString(),
      isStale: false
    }
  };
}
function createUnavailableSourceMetadata(error) {
  return {
    source: "unavailable",
    fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
    isStale: true
  };
}
function createLiveSourceMetadata() {
  return {
    source: "alpaca_live",
    fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
    isStale: false
  };
}

// server/routes.ts
init_apiBudget();
init_persistentApiCache();
init_apiPolicy();

// server/ai/roleBasedRouter.ts
init_logger();
init_openaiClient();
init_groqClient();
init_togetherClient();
init_aimlClient();
init_openrouterClient();
init_db();
init_schema();
import { eq as eq15, desc as desc9 } from "drizzle-orm";
var PROVIDER_CLIENTS2 = {
  openai: { client: openaiClient, isAvailable: () => openaiClient.isAvailable() },
  groq: { client: groqClient, isAvailable: () => groqClient.isAvailable() },
  together: { client: togetherClient, isAvailable: () => togetherClient.isAvailable() },
  aimlapi: { client: aimlClient, isAvailable: () => aimlClient.isAvailable() },
  openrouter: { client: openrouterClient, isAvailable: () => openrouterClient.isAvailable() }
};
var DEFAULT_ROLE_CONFIGS = {
  market_news_summarizer: {
    role: "market_news_summarizer",
    description: "Cheap + fast model for summarizing market news",
    fallbackChain: [
      { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
      { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 500,
    temperature: 0.3
  },
  technical_analyst: {
    role: "technical_analyst",
    description: "Strong reasoning model for technical analysis",
    fallbackChain: [
      { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
      { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 2e3,
    temperature: 0.2
  },
  risk_manager: {
    role: "risk_manager",
    description: "Conservative, instruction-following model for risk assessment",
    fallbackChain: [
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
      { provider: "openrouter", model: "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 },
      { provider: "openrouter", model: "google/gemini-pro-1.5", costPer1kTokens: 125e-5 }
    ],
    maxTokens: 1500,
    temperature: 0.1,
    enableCitations: true
  },
  execution_planner: {
    role: "execution_planner",
    description: "Deterministic, tool-use friendly model for trade execution",
    fallbackChain: [
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 },
      { provider: "groq", model: "llama-3.1-70b-versatile", costPer1kTokens: 59e-5 },
      { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 }
    ],
    maxTokens: 1e3,
    temperature: 0
  },
  post_trade_reporter: {
    role: "post_trade_reporter",
    description: "Cheap summarizer for post-trade reports",
    fallbackChain: [
      { provider: "groq", model: "llama-3.1-8b-instant", costPer1kTokens: 5e-5 },
      { provider: "together", model: "meta-llama/Llama-3.2-3B-Instruct-Turbo", costPer1kTokens: 1e-4 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 800,
    temperature: 0.4
  },
  // New roles added for enhanced trading capabilities
  position_sizer: {
    role: "position_sizer",
    description: "Optimal position sizing based on risk and market conditions",
    fallbackChain: [
      { provider: "openrouter", model: "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 },
      { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 1500,
    temperature: 0.2
  },
  sentiment_analyst: {
    role: "sentiment_analyst",
    description: "Dedicated sentiment analysis from news and social sources",
    fallbackChain: [
      { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 },
      { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 1200,
    temperature: 0.3
  },
  post_trade_analyzer: {
    role: "post_trade_analyzer",
    description: "Detailed trade performance analysis and learning",
    fallbackChain: [
      { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
      { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 },
      { provider: "openai", model: "gpt-4o-mini", costPer1kTokens: 15e-5 }
    ],
    maxTokens: 2e3,
    temperature: 0.3
  },
  futures_analyst: {
    role: "futures_analyst",
    description: "Specialized futures market analysis and recommendations",
    fallbackChain: [
      { provider: "openrouter", model: "anthropic/claude-3.5-sonnet", costPer1kTokens: 3e-3 },
      { provider: "openrouter", model: "deepseek/deepseek-r1", costPer1kTokens: 55e-5 },
      { provider: "groq", model: "llama-3.3-70b-versatile", costPer1kTokens: 59e-5 }
    ],
    maxTokens: 2500,
    temperature: 0.2
  }
};
function estimateCost2(tokens, costPer1kTokens) {
  return tokens / 1e3 * costPer1kTokens;
}
function parseFallbackChain(chainJson) {
  try {
    return JSON.parse(chainJson);
  } catch {
    return [];
  }
}
async function getRoleConfig(role) {
  try {
    const [dbConfig] = await db.select().from(llmRoleConfigs).where(eq15(llmRoleConfigs.role, role)).limit(1);
    if (dbConfig && dbConfig.isActive) {
      return {
        role,
        description: dbConfig.description || DEFAULT_ROLE_CONFIGS[role].description,
        fallbackChain: parseFallbackChain(dbConfig.fallbackChain),
        maxTokens: dbConfig.maxTokens || DEFAULT_ROLE_CONFIGS[role].maxTokens,
        temperature: parseFloat(dbConfig.temperature || "0.3"),
        enableCitations: dbConfig.enableCitations
      };
    }
  } catch (error) {
    log.warn("RoleBasedRouter", `Failed to load config for ${role}, using defaults`, { error: String(error) });
  }
  return DEFAULT_ROLE_CONFIGS[role];
}
async function logCall2(callData) {
  try {
    await db.insert(llmCalls).values(callData);
  } catch (error) {
    log.warn("RoleBasedRouter", "Failed to log LLM call", { error: String(error) });
  }
}
async function roleBasedLLMCall(req) {
  const startTime = Date.now();
  const config = await getRoleConfig(req.role);
  let fallbackUsed = false;
  let fallbackReason;
  let lastError;
  for (let i = 0; i < config.fallbackChain.length; i++) {
    const modelConfig = config.fallbackChain[i];
    const providerEntry = PROVIDER_CLIENTS2[modelConfig.provider];
    if (!providerEntry || !providerEntry.isAvailable()) {
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = `Primary provider ${modelConfig.provider} not available`;
      }
      continue;
    }
    try {
      const llmRequest = {
        ...req,
        model: modelConfig.model,
        maxTokens: req.maxTokens || config.maxTokens,
        temperature: req.temperature ?? config.temperature
      };
      if (config.enableCitations && llmRequest.system) {
        llmRequest.system = `${llmRequest.system}

IMPORTANT: Always cite your sources. Reference internal data (market data, news feeds, analysis) rather than external knowledge. Format citations as [Source: X].`;
      }
      const response = await providerEntry.client.call(llmRequest);
      const latencyMs2 = Date.now() - startTime;
      const totalTokens = response.tokensUsed?.total || 0;
      const estimatedCost = estimateCost2(totalTokens, modelConfig.costPer1kTokens || 1e-4);
      await logCall2({
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        promptTokens: response.tokensUsed?.prompt || null,
        completionTokens: response.tokensUsed?.completion || null,
        totalTokens: totalTokens || null,
        estimatedCost: estimatedCost.toFixed(6),
        latencyMs: latencyMs2,
        status: "success",
        systemPrompt: req.system || null,
        userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
        response: response.content?.slice(0, 2e3) || null,
        cacheHit: false,
        fallbackUsed,
        fallbackReason: fallbackReason || null
      });
      log.ai(`RoleBasedRouter: ${req.role} succeeded`, {
        role: req.role,
        provider: modelConfig.provider,
        model: modelConfig.model,
        tokensUsed: totalTokens,
        estimatedCost,
        latencyMs: latencyMs2,
        fallbackUsed
      });
      return {
        ...response,
        role: req.role,
        provider: modelConfig.provider,
        estimatedCost,
        fallbackUsed,
        fallbackReason
      };
    } catch (error) {
      lastError = error;
      const llmError = error;
      log.warn("RoleBasedRouter", `${modelConfig.provider}/${modelConfig.model} failed for ${req.role}`, {
        isRateLimit: llmError?.isRateLimit,
        isAuthError: llmError?.isAuthError,
        error: String(error)
      });
      if (i === 0) {
        fallbackUsed = true;
        fallbackReason = llmError?.isRateLimit ? "Rate limit exceeded" : llmError?.isAuthError ? "Auth error" : "Provider error";
      }
      if (llmError?.isRateLimit) {
        await new Promise((r) => setTimeout(r, 1e3));
      }
    }
  }
  const latencyMs = Date.now() - startTime;
  await logCall2({
    role: req.role,
    provider: "none",
    model: "none",
    status: "error",
    errorMessage: String(lastError),
    latencyMs,
    systemPrompt: req.system || null,
    userPrompt: req.messages.map((m) => m.content).join("\n").slice(0, 2e3),
    fallbackUsed: true,
    fallbackReason: "All providers failed"
  });
  log.error("RoleBasedRouter", `All providers failed for ${req.role}`, {
    role: req.role,
    triedProviders: config.fallbackChain.map((c) => c.provider),
    lastError: String(lastError)
  });
  throw lastError || new Error(`All LLM providers failed for role: ${req.role}`);
}
async function getAllRoleConfigs() {
  const configs = [];
  for (const role of Object.keys(DEFAULT_ROLE_CONFIGS)) {
    const config = await getRoleConfig(role);
    configs.push(config);
  }
  return configs;
}
async function updateRoleConfig(role, updates) {
  const fallbackChainJson = updates.fallbackChain ? JSON.stringify(updates.fallbackChain) : JSON.stringify(DEFAULT_ROLE_CONFIGS[role].fallbackChain);
  const existing = await db.select().from(llmRoleConfigs).where(eq15(llmRoleConfigs.role, role)).limit(1);
  if (existing.length > 0) {
    const [updated] = await db.update(llmRoleConfigs).set({
      description: updates.description,
      fallbackChain: fallbackChainJson,
      maxTokens: updates.maxTokens,
      temperature: updates.temperature?.toString(),
      enableCitations: updates.enableCitations,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq15(llmRoleConfigs.role, role)).returning();
    return updated;
  }
  const [inserted] = await db.insert(llmRoleConfigs).values({
    role,
    description: updates.description || DEFAULT_ROLE_CONFIGS[role].description,
    fallbackChain: fallbackChainJson,
    maxTokens: updates.maxTokens || DEFAULT_ROLE_CONFIGS[role].maxTokens,
    temperature: (updates.temperature ?? DEFAULT_ROLE_CONFIGS[role].temperature)?.toString(),
    enableCitations: updates.enableCitations ?? DEFAULT_ROLE_CONFIGS[role].enableCitations ?? false,
    isActive: true
  }).returning();
  return inserted;
}
async function getRecentCalls(limit4 = 20, role) {
  if (role) {
    return db.select().from(llmCalls).where(eq15(llmCalls.role, role)).orderBy(desc9(llmCalls.createdAt)).limit(limit4);
  }
  return db.select().from(llmCalls).orderBy(desc9(llmCalls.createdAt)).limit(limit4);
}
async function getCallStats() {
  const calls = await db.select().from(llmCalls).orderBy(desc9(llmCalls.createdAt)).limit(1e3);
  const stats = {
    total: calls.length,
    byRole: {},
    byProvider: {},
    totalCost: 0
  };
  for (const call of calls) {
    const cost = parseFloat(call.estimatedCost || "0");
    stats.totalCost += cost;
    if (!stats.byRole[call.role]) {
      stats.byRole[call.role] = { count: 0, totalCost: 0, avgLatency: 0 };
    }
    stats.byRole[call.role].count++;
    stats.byRole[call.role].totalCost += cost;
    stats.byRole[call.role].avgLatency += call.latencyMs || 0;
    if (!stats.byProvider[call.provider]) {
      stats.byProvider[call.provider] = { count: 0, totalCost: 0, successRate: 0 };
    }
    stats.byProvider[call.provider].count++;
    stats.byProvider[call.provider].totalCost += cost;
    if (call.status === "success") {
      stats.byProvider[call.provider].successRate++;
    }
  }
  for (const role of Object.keys(stats.byRole)) {
    stats.byRole[role].avgLatency /= stats.byRole[role].count;
  }
  for (const provider of Object.keys(stats.byProvider)) {
    stats.byProvider[provider].successRate = stats.byProvider[provider].successRate / stats.byProvider[provider].count * 100;
  }
  return stats;
}
var roleBasedRouter = {
  call: roleBasedLLMCall,
  getAllConfigs: getAllRoleConfigs,
  updateConfig: updateRoleConfig,
  getRecentCalls,
  getCallStats,
  getAvailableProviders: () => {
    return Object.entries(PROVIDER_CLIENTS2).filter(([_, v]) => v.isAvailable()).map(([name]) => name);
  }
};

// server/routes.ts
init_tradability_service();

// server/routes/backtests.ts
init_db();
init_schema();
import { Router } from "express";

// server/services/backtesting/historical-data-service.ts
init_callExternal();
init_alpaca();
init_logger();
function transformAlpacaBar(bar, symbol) {
  return {
    ts: bar.t,
    open: bar.o,
    high: bar.h,
    low: bar.l,
    close: bar.c,
    volume: bar.v,
    vwap: bar.vw,
    symbol
  };
}
async function fetchBarsPage(symbol, timeframe, startDate, endDate, limit4, cacheKeySuffix, pageToken) {
  const cacheKeyStr = `bars:${symbol}:${timeframe}:${startDate}:${endDate}:${cacheKeySuffix}`;
  const endpoint = `bars/${symbol}/${timeframe}/${startDate}/${endDate}`;
  return callExternal(
    () => alpaca.getBars([symbol], timeframe, startDate, endDate, limit4, pageToken),
    {
      provider: "alpaca",
      endpoint,
      cacheKey: cacheKeyStr,
      budgetPolicy: {
        countAsMultiple: 1
      }
    }
  );
}
async function fetchHistoricalBars(options) {
  const { symbols, timeframe, startDate, endDate, maxBarsPerSymbol = 5e3 } = options;
  const BATCH_LIMIT = 5e3;
  log.info("HistoricalData", `Fetching bars for ${symbols.length} symbols from ${startDate} to ${endDate}`);
  const allBars = {};
  const barsCountBySymbol = {};
  let totalCacheHits = 0;
  let totalRequests = 0;
  let nextPageTokensUsed = 0;
  for (const symbol of symbols) {
    allBars[symbol] = [];
    let currentPageToken = null;
    let totalBarsForSymbol = 0;
    let hasMorePages = true;
    while (hasMorePages) {
      const tokenSuffix = currentPageToken || "first";
      try {
        const fetchResult = await fetchBarsPage(
          symbol,
          timeframe,
          startDate,
          endDate,
          BATCH_LIMIT,
          tokenSuffix,
          currentPageToken ?? void 0
        );
        totalRequests++;
        if (fetchResult.provenance.cacheStatus === "fresh") {
          totalCacheHits++;
        }
        const symbolBars = fetchResult.data.bars?.[symbol] || [];
        const transformedBars = symbolBars.map((bar) => transformAlpacaBar(bar, symbol));
        allBars[symbol].push(...transformedBars);
        totalBarsForSymbol += transformedBars.length;
        const nextToken = fetchResult.data.next_page_token ?? null;
        if (nextToken) {
          currentPageToken = nextToken;
          nextPageTokensUsed++;
        } else {
          hasMorePages = false;
        }
        if (totalBarsForSymbol >= maxBarsPerSymbol) {
          log.debug("HistoricalData", `Reached max bars limit for ${symbol}: ${totalBarsForSymbol}`);
          hasMorePages = false;
        }
      } catch (error) {
        log.error("HistoricalData", `Failed to fetch bars for ${symbol}: ${error}`);
        hasMorePages = false;
      }
    }
    barsCountBySymbol[symbol] = allBars[symbol].length;
    log.debug("HistoricalData", `Fetched ${allBars[symbol].length} bars for ${symbol}`);
  }
  for (const symbol of symbols) {
    allBars[symbol].sort((a, b) => new Date(a.ts).getTime() - new Date(b.ts).getTime());
  }
  const cacheHitRate = totalRequests > 0 ? totalCacheHits / totalRequests : 0;
  const provenance = {
    provider: "alpaca",
    cacheHitRate,
    dataPulledAt: (/* @__PURE__ */ new Date()).toISOString(),
    barsCountBySymbol,
    timeframe,
    dateRange: { start: startDate, end: endDate },
    nextPageTokensUsed
  };
  log.info("HistoricalData", `Completed fetching bars. Cache hit rate: ${(cacheHitRate * 100).toFixed(1)}%`);
  return { bars: allBars, provenance };
}

// server/services/backtesting/execution-engine.ts
function calculateSlippage(price, model, side) {
  const direction = side === "buy" ? 1 : -1;
  if (model.type === "bps") {
    return price * (model.value / 1e4) * direction;
  } else if (model.type === "spread_proxy") {
    const estimatedSpread = price * 1e-3;
    return estimatedSpread * model.value * direction;
  }
  return 0;
}
function calculateFees(notional, model) {
  if (model.type === "fixed") {
    return model.value;
  } else if (model.type === "percentage") {
    return notional * (model.value / 100);
  }
  return 0;
}
function getExecutionPrice(bar, rule, slippageModel, side) {
  const basePrice = rule === "NEXT_OPEN" ? bar.open : bar.close;
  const slippage = calculateSlippage(basePrice, slippageModel, side);
  return basePrice + slippage;
}
function calculateEquity(cash, positions2, prices) {
  let equity = cash;
  for (const [symbol, position] of Object.entries(positions2)) {
    const price = prices[symbol] || position.avgPrice;
    equity += position.qty * price;
  }
  return equity;
}
function calculateExposure(positions2, prices) {
  let totalValue = 0;
  for (const [symbol, position] of Object.entries(positions2)) {
    const price = prices[symbol] || position.avgPrice;
    totalValue += Math.abs(position.qty * price);
  }
  return totalValue;
}
function mergeAndSortBars(bars) {
  const allEntries = [];
  for (const [symbol, symbolBars] of Object.entries(bars)) {
    symbolBars.forEach((bar, index2) => {
      allEntries.push({
        symbol,
        bar,
        symbolBarIndex: index2,
        time: new Date(bar.ts).getTime()
      });
    });
  }
  allEntries.sort((a, b) => a.time - b.time);
  return allEntries.map(({ symbol, bar, symbolBarIndex }) => ({ symbol, bar, symbolBarIndex }));
}
function runSimulation(bars, signalGenerator, config) {
  const { runId, initialCash, feesModel, slippageModel, executionPriceRule } = config;
  const positions2 = {};
  let cash = initialCash;
  const trades3 = [];
  const equityCurve = [];
  const tradePnLs = [];
  const equityHistory = [];
  const pendingSignals = {};
  const processedBarsBySymbol = {};
  const lastProcessedBarIndex = {};
  const currentPrices = {};
  for (const symbol of Object.keys(bars)) {
    pendingSignals[symbol] = [];
    processedBarsBySymbol[symbol] = [];
    lastProcessedBarIndex[symbol] = -1;
  }
  const sortedBars = mergeAndSortBars(bars);
  for (const { symbol, bar, symbolBarIndex } of sortedBars) {
    currentPrices[symbol] = bar.close;
    const symbolPendingSignals = pendingSignals[symbol] || [];
    const signalsToExecute = [];
    const signalsToKeep = [];
    for (const ps of symbolPendingSignals) {
      if (ps.signal.symbol === symbol && ps.signalBarIndex < symbolBarIndex) {
        signalsToExecute.push(ps);
      } else {
        signalsToKeep.push(ps);
      }
    }
    pendingSignals[symbol] = signalsToKeep;
    for (const { signal } of signalsToExecute) {
      const executionPrice = getExecutionPrice(bar, executionPriceRule, slippageModel, signal.side);
      const slippageAmount = calculateSlippage(
        executionPriceRule === "NEXT_OPEN" ? bar.open : bar.close,
        slippageModel,
        signal.side
      );
      const notional = signal.qty * executionPrice;
      const fees = calculateFees(notional, feesModel);
      const currentPosition = positions2[symbol] || { qty: 0, avgPrice: 0 };
      let pnl = 0;
      let executedQty = 0;
      if (signal.side === "buy") {
        const totalCost = notional + fees;
        if (cash >= totalCost) {
          cash -= totalCost;
          executedQty = signal.qty;
          const newQty = currentPosition.qty + signal.qty;
          const newAvgPrice = currentPosition.qty > 0 ? (currentPosition.avgPrice * currentPosition.qty + executionPrice * signal.qty) / newQty : executionPrice;
          positions2[symbol] = { qty: newQty, avgPrice: newAvgPrice };
        } else {
          continue;
        }
      } else {
        executedQty = Math.min(signal.qty, currentPosition.qty);
        if (executedQty > 0) {
          const proceeds = executedQty * executionPrice - fees;
          pnl = (executionPrice - currentPosition.avgPrice) * executedQty - fees;
          cash += proceeds;
          tradePnLs.push(pnl);
          const remainingQty = currentPosition.qty - executedQty;
          if (remainingQty > 0) {
            positions2[symbol] = { qty: remainingQty, avgPrice: currentPosition.avgPrice };
          } else {
            delete positions2[symbol];
          }
        } else {
          continue;
        }
      }
      const tradeEvent = {
        id: `${runId}-${trades3.length}`,
        runId,
        ts: bar.ts,
        symbol,
        side: signal.side,
        qty: executedQty,
        price: executionPrice,
        reason: signal.reason,
        orderType: "market",
        fees,
        slippage: Math.abs(slippageAmount),
        positionAfter: positions2[symbol]?.qty || 0,
        cashAfter: cash
      };
      trades3.push(tradeEvent);
    }
    processedBarsBySymbol[symbol].push(bar);
    lastProcessedBarIndex[symbol] = symbolBarIndex;
    const newSignals = signalGenerator.onBar(bar, symbolBarIndex, [...processedBarsBySymbol[symbol]]);
    for (const signal of newSignals) {
      const targetSymbol = signal.symbol;
      if (targetSymbol === symbol) {
        pendingSignals[targetSymbol] = pendingSignals[targetSymbol] || [];
        pendingSignals[targetSymbol].push({ signal, signalBarIndex: symbolBarIndex });
      }
    }
    const equity = calculateEquity(cash, positions2, currentPrices);
    const exposure = calculateExposure(positions2, currentPrices);
    equityHistory.push(equity);
    equityCurve.push({
      runId,
      ts: bar.ts,
      equity,
      cash,
      exposure
    });
  }
  const metrics = calculateMetrics(initialCash, equityHistory, tradePnLs, trades3, equityCurve);
  return { trades: trades3, equityCurve, metrics };
}
function calculateMetrics(initialCash, equityHistory, tradePnLs, trades3, equityCurve) {
  if (equityHistory.length === 0) {
    return {
      cagr: null,
      totalReturnPct: 0,
      maxDrawdownPct: 0,
      sharpeRatio: null,
      sortinoRatio: null,
      calmarRatio: null,
      winRatePct: 0,
      totalTrades: 0,
      profitFactor: null,
      avgWinPct: 0,
      avgLossPct: 0,
      expectancy: null,
      tradesPerMonth: null,
      avgHoldingPeriodDays: null
    };
  }
  const finalEquity = equityHistory[equityHistory.length - 1];
  if (!Number.isFinite(finalEquity) || initialCash <= 0) {
    return {
      cagr: null,
      totalReturnPct: 0,
      maxDrawdownPct: 0,
      sharpeRatio: null,
      sortinoRatio: null,
      calmarRatio: null,
      winRatePct: 0,
      totalTrades: tradePnLs.length,
      profitFactor: null,
      avgWinPct: 0,
      avgLossPct: 0,
      expectancy: null,
      tradesPerMonth: null,
      avgHoldingPeriodDays: null
    };
  }
  const totalReturnPct = (finalEquity - initialCash) / initialCash * 100;
  let maxDrawdownPct = 0;
  let peak = initialCash;
  for (const equity of equityHistory) {
    if (equity > peak) {
      peak = equity;
    }
    if (peak > 0) {
      const drawdown = (peak - equity) / peak * 100;
      if (drawdown > maxDrawdownPct) {
        maxDrawdownPct = drawdown;
      }
    }
  }
  const returns = [];
  for (let i = 1; i < equityHistory.length; i++) {
    const prevEquity = equityHistory[i - 1];
    if (prevEquity > 0 && Number.isFinite(prevEquity)) {
      const ret = (equityHistory[i] - prevEquity) / prevEquity;
      if (Number.isFinite(ret)) {
        returns.push(ret);
      }
    }
  }
  let sharpeRatio = null;
  let sortinoRatio = null;
  if (returns.length > 1) {
    const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
    const variance = returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length;
    const stdDev = Math.sqrt(variance);
    if (stdDev > 1e-10 && Number.isFinite(stdDev)) {
      const annualizedMean = meanReturn * 252;
      const annualizedStd = stdDev * Math.sqrt(252);
      if (annualizedStd > 0 && Number.isFinite(annualizedStd)) {
        sharpeRatio = annualizedMean / annualizedStd;
        if (!Number.isFinite(sharpeRatio)) {
          sharpeRatio = null;
        }
      }
    }
    const negativeReturns = returns.filter((r) => r < 0);
    if (negativeReturns.length > 0) {
      const downVariance = negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length;
      const downStdDev = Math.sqrt(downVariance);
      if (downStdDev > 1e-10 && Number.isFinite(downStdDev)) {
        const annualizedMean = meanReturn * 252;
        const annualizedDownStd = downStdDev * Math.sqrt(252);
        if (annualizedDownStd > 0 && Number.isFinite(annualizedDownStd)) {
          sortinoRatio = annualizedMean / annualizedDownStd;
          if (!Number.isFinite(sortinoRatio)) {
            sortinoRatio = null;
          }
        }
      }
    }
  }
  const totalTrades = tradePnLs.length;
  const winningTrades = tradePnLs.filter((pnl) => pnl > 0);
  const losingTrades = tradePnLs.filter((pnl) => pnl < 0);
  const winRatePct = totalTrades > 0 ? winningTrades.length / totalTrades * 100 : 0;
  const grossProfit = winningTrades.reduce((sum, pnl) => sum + pnl, 0);
  const grossLoss = Math.abs(losingTrades.reduce((sum, pnl) => sum + pnl, 0));
  let profitFactor = null;
  if (grossLoss > 0) {
    profitFactor = grossProfit / grossLoss;
  } else if (grossProfit > 0) {
    profitFactor = null;
  } else {
    profitFactor = null;
  }
  if (profitFactor !== null && !Number.isFinite(profitFactor)) {
    profitFactor = null;
  }
  const avgWinPct = winningTrades.length > 0 && initialCash > 0 ? grossProfit / winningTrades.length / initialCash * 100 : 0;
  const avgLossPct = losingTrades.length > 0 && initialCash > 0 ? grossLoss / losingTrades.length / initialCash * 100 : 0;
  let cagr = null;
  if (equityHistory.length >= 252 && finalEquity > 0 && initialCash > 0) {
    const years = equityHistory.length / 252;
    const ratio = finalEquity / initialCash;
    if (ratio > 0 && years > 0) {
      cagr = (Math.pow(ratio, 1 / years) - 1) * 100;
      if (!Number.isFinite(cagr)) {
        cagr = null;
      }
    }
  }
  let calmarRatio = null;
  if (cagr !== null && maxDrawdownPct > 0) {
    calmarRatio = cagr / maxDrawdownPct;
    if (!Number.isFinite(calmarRatio)) {
      calmarRatio = null;
    }
  }
  let expectancy = null;
  if (totalTrades > 0) {
    const winRate = winRatePct / 100;
    const lossRate = 1 - winRate;
    expectancy = winRate * avgWinPct - lossRate * avgLossPct;
    if (!Number.isFinite(expectancy)) {
      expectancy = null;
    }
  }
  let tradesPerMonth = null;
  if (equityCurve.length >= 2 && totalTrades > 0) {
    const firstTs = new Date(equityCurve[0].ts).getTime();
    const lastTs = new Date(equityCurve[equityCurve.length - 1].ts).getTime();
    const elapsedMs = lastTs - firstTs;
    const elapsedDays = elapsedMs / (1e3 * 60 * 60 * 24);
    const months = elapsedDays / 30;
    if (months > 0) {
      tradesPerMonth = totalTrades / months;
      if (!Number.isFinite(tradesPerMonth)) {
        tradesPerMonth = null;
      }
    }
  }
  let avgHoldingPeriodDays = null;
  if (trades3.length > 0) {
    const positionEntries = {};
    const holdingPeriods = [];
    for (const trade of trades3) {
      const tradeTs = new Date(trade.ts).getTime();
      if (trade.side === "buy") {
        if (!positionEntries[trade.symbol]) {
          positionEntries[trade.symbol] = [];
        }
        positionEntries[trade.symbol].push({ ts: tradeTs, qty: trade.qty });
      } else if (trade.side === "sell") {
        const entries = positionEntries[trade.symbol] || [];
        let remainingToSell = trade.qty;
        while (remainingToSell > 0 && entries.length > 0) {
          const entry = entries[0];
          const qtyToMatch = Math.min(remainingToSell, entry.qty);
          const holdingMs = tradeTs - entry.ts;
          const holdingDays = holdingMs / (1e3 * 60 * 60 * 24);
          if (holdingDays >= 0) {
            holdingPeriods.push({ days: holdingDays, qty: qtyToMatch });
          }
          entry.qty -= qtyToMatch;
          remainingToSell -= qtyToMatch;
          if (entry.qty <= 0) {
            entries.shift();
          }
        }
      }
    }
    if (holdingPeriods.length > 0) {
      const totalQty = holdingPeriods.reduce((sum, hp) => sum + hp.qty, 0);
      const weightedDays = holdingPeriods.reduce((sum, hp) => sum + hp.days * hp.qty, 0);
      avgHoldingPeriodDays = totalQty > 0 ? weightedDays / totalQty : null;
      if (avgHoldingPeriodDays !== null && !Number.isFinite(avgHoldingPeriodDays)) {
        avgHoldingPeriodDays = null;
      }
    }
  }
  return {
    cagr,
    totalReturnPct: Number.isFinite(totalReturnPct) ? totalReturnPct : 0,
    maxDrawdownPct: Number.isFinite(maxDrawdownPct) ? maxDrawdownPct : 0,
    sharpeRatio,
    sortinoRatio,
    calmarRatio,
    winRatePct: Number.isFinite(winRatePct) ? winRatePct : 0,
    totalTrades,
    profitFactor,
    avgWinPct: Number.isFinite(avgWinPct) ? avgWinPct : 0,
    avgLossPct: Number.isFinite(avgLossPct) ? avgLossPct : 0,
    expectancy,
    tradesPerMonth,
    avgHoldingPeriodDays
  };
}

// server/services/backtesting/backtest-runner.ts
init_db();
init_schema();

// server/services/backtesting/strategies.ts
function createMovingAverageCrossoverStrategy(universe, initialCash, fastPeriod = 10, slowPeriod = 20, allocationPct = 10) {
  const state = /* @__PURE__ */ new Map();
  for (const symbol of universe) {
    state.set(symbol, { prices: [], position: "none", positionQty: 0 });
  }
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const signals = [];
      const symbol = bar.symbol;
      let symbolState = state.get(symbol);
      if (!symbolState) {
        symbolState = { prices: [], position: "none", positionQty: 0 };
        state.set(symbol, symbolState);
      }
      symbolState.prices.push(bar.close);
      if (symbolState.prices.length < slowPeriod) return signals;
      const recentPrices = symbolState.prices.slice(-slowPeriod);
      const fastMA = recentPrices.slice(-fastPeriod).reduce((a, b) => a + b, 0) / fastPeriod;
      const slowMA = recentPrices.reduce((a, b) => a + b, 0) / slowPeriod;
      if (symbolState.prices.length > slowPeriod) {
        const prevPrices = symbolState.prices.slice(-slowPeriod - 1, -1);
        const prevFastMA = prevPrices.slice(-fastPeriod).reduce((a, b) => a + b, 0) / fastPeriod;
        const prevSlowMA = prevPrices.reduce((a, b) => a + b, 0) / slowPeriod;
        if (prevFastMA <= prevSlowMA && fastMA > slowMA && symbolState.position === "none") {
          const allocationAmount = initialCash * (allocationPct / 100);
          const qty = Math.floor(allocationAmount / bar.close);
          if (qty > 0) {
            signals.push({
              symbol,
              side: "buy",
              qty,
              reason: `Bullish crossover: Fast MA (${fastMA.toFixed(2)}) crossed above Slow MA (${slowMA.toFixed(2)})`
            });
            symbolState.position = "long";
            symbolState.positionQty = qty;
          }
        } else if (prevFastMA >= prevSlowMA && fastMA < slowMA && symbolState.position === "long") {
          signals.push({
            symbol,
            side: "sell",
            qty: symbolState.positionQty,
            reason: `Bearish crossover: Fast MA (${fastMA.toFixed(2)}) crossed below Slow MA (${slowMA.toFixed(2)})`
          });
          symbolState.position = "none";
          symbolState.positionQty = 0;
        }
      }
      return signals;
    }
  };
}
function createRSIStrategy(universe, initialCash, period = 14, oversoldThreshold = 30, overboughtThreshold = 70, allocationPct = 10) {
  const state = /* @__PURE__ */ new Map();
  for (const symbol of universe) {
    state.set(symbol, { prices: [], position: "none", positionQty: 0, gains: [], losses: [] });
  }
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const signals = [];
      const symbol = bar.symbol;
      let symbolState = state.get(symbol);
      if (!symbolState) {
        symbolState = { prices: [], position: "none", positionQty: 0, gains: [], losses: [] };
        state.set(symbol, symbolState);
      }
      const prevPrice = symbolState.prices[symbolState.prices.length - 1];
      symbolState.prices.push(bar.close);
      if (prevPrice !== void 0) {
        const change = bar.close - prevPrice;
        symbolState.gains.push(change > 0 ? change : 0);
        symbolState.losses.push(change < 0 ? Math.abs(change) : 0);
      }
      if (symbolState.gains.length < period) return signals;
      const recentGains = symbolState.gains.slice(-period);
      const recentLosses = symbolState.losses.slice(-period);
      const avgGain = recentGains.reduce((a, b) => a + b, 0) / period;
      const avgLoss = recentLosses.reduce((a, b) => a + b, 0) / period;
      const rs = avgLoss > 0 ? avgGain / avgLoss : 100;
      const rsi = 100 - 100 / (1 + rs);
      if (rsi < oversoldThreshold && symbolState.position === "none") {
        const allocationAmount = initialCash * (allocationPct / 100);
        const qty = Math.floor(allocationAmount / bar.close);
        if (qty > 0) {
          signals.push({
            symbol,
            side: "buy",
            qty,
            reason: `RSI oversold: RSI (${rsi.toFixed(2)}) < ${oversoldThreshold}`
          });
          symbolState.position = "long";
          symbolState.positionQty = qty;
        }
      } else if (rsi > overboughtThreshold && symbolState.position === "long") {
        signals.push({
          symbol,
          side: "sell",
          qty: symbolState.positionQty,
          reason: `RSI overbought: RSI (${rsi.toFixed(2)}) > ${overboughtThreshold}`
        });
        symbolState.position = "none";
        symbolState.positionQty = 0;
      }
      return signals;
    }
  };
}
function createBuyAndHoldStrategy(universe, initialCash, allocationPct = 10) {
  const bought = /* @__PURE__ */ new Set();
  const positionQty = /* @__PURE__ */ new Map();
  return {
    onBar(bar, barIndex, allBarsUpToNow) {
      const symbol = bar.symbol;
      if (!bought.has(symbol)) {
        const allocationAmount = initialCash * (allocationPct / 100);
        const qty = Math.floor(allocationAmount / bar.close);
        if (qty > 0) {
          bought.add(symbol);
          positionQty.set(symbol, qty);
          return [{
            symbol,
            side: "buy",
            qty,
            reason: `Buy and hold: Initial purchase of ${symbol}`
          }];
        }
      }
      return [];
    }
  };
}
function createStrategy(strategyConfig, universe, initialCash) {
  const { type, params } = strategyConfig;
  switch (type) {
    case "moving_average_crossover":
      return createMovingAverageCrossoverStrategy(
        universe,
        initialCash,
        params.fastPeriod || 10,
        params.slowPeriod || 20,
        params.allocationPct || 10
      );
    case "rsi_oscillator":
      return createRSIStrategy(
        universe,
        initialCash,
        params.period || 14,
        params.oversoldThreshold || 30,
        params.overboughtThreshold || 70,
        params.allocationPct || 10
      );
    case "buy_and_hold":
    default:
      return createBuyAndHoldStrategy(universe, initialCash, params.allocationPct || 10);
  }
}

// server/services/backtesting/backtest-runner.ts
init_logger();
import { eq as eq16, desc as desc10 } from "drizzle-orm";
import crypto3 from "crypto";
function hashConfig(config) {
  const sorted = JSON.stringify(config, Object.keys(config).sort());
  return crypto3.createHash("sha256").update(sorted).digest("hex").substring(0, 16);
}
async function runBacktest(params) {
  const startTime = Date.now();
  const configHash = hashConfig(params.strategyConfig);
  log.info("BacktestRunner", `Starting backtest for ${params.universe.length} symbols from ${params.startDate} to ${params.endDate}`);
  const [insertedRun] = await db.insert(backtestRuns).values({
    status: "QUEUED",
    strategyId: params.strategyId || null,
    strategyConfigHash: configHash,
    strategyConfig: params.strategyConfig,
    universe: params.universe,
    broker: "alpaca",
    timeframe: params.timeframe,
    startDate: params.startDate,
    endDate: params.endDate,
    initialCash: params.initialCash.toString(),
    feesModel: params.feesModel,
    slippageModel: params.slippageModel,
    executionPriceRule: params.executionPriceRule,
    dataSource: "alpaca"
  }).returning();
  const runId = insertedRun.id;
  try {
    await db.update(backtestRuns).set({ status: "RUNNING", updatedAt: /* @__PURE__ */ new Date() }).where(eq16(backtestRuns.id, runId));
    log.info("BacktestRunner", `Fetching historical data for run ${runId}`);
    const { bars, provenance } = await fetchHistoricalBars({
      symbols: params.universe,
      timeframe: params.timeframe,
      startDate: params.startDate,
      endDate: params.endDate
    });
    const totalBars = Object.values(bars).reduce((sum, arr) => sum + arr.length, 0);
    log.info("BacktestRunner", `Fetched ${totalBars} total bars for ${params.universe.length} symbols`);
    if (totalBars === 0) {
      const symbolsWithData = Object.entries(bars).filter(([_, symbolBars]) => symbolBars.length > 0).map(([symbol]) => symbol);
      const symbolsWithoutData = params.universe.filter((s) => !symbolsWithData.includes(s));
      throw new Error(
        `No historical data found for the specified date range (${params.startDate} to ${params.endDate}). Symbols without data: ${symbolsWithoutData.join(", ")}. Please verify the date range is valid and the symbols are active.`
      );
    }
    for (const symbol of params.universe) {
      const symbolBars = bars[symbol] || [];
      if (symbolBars.length === 0) {
        log.warn("BacktestRunner", `No bars fetched for symbol ${symbol} - it may be inactive or date range invalid`);
      } else {
        log.debug("BacktestRunner", `Symbol ${symbol}: ${symbolBars.length} bars`);
      }
    }
    const strategyConfig = {
      type: params.strategyType || "moving_average_crossover",
      params: params.strategyParams || { allocationPct: 10, fastPeriod: 10, slowPeriod: 20 }
    };
    const signalGenerator = createStrategy(strategyConfig, params.universe, params.initialCash);
    const simConfig = {
      runId,
      initialCash: params.initialCash,
      feesModel: params.feesModel,
      slippageModel: params.slippageModel,
      executionPriceRule: params.executionPriceRule
    };
    log.info("BacktestRunner", `Running simulation for run ${runId}`);
    const result = runSimulation(bars, signalGenerator, simConfig);
    if (!result || !result.metrics) {
      throw new Error("Simulation returned invalid results: metrics are null or undefined");
    }
    const metrics = result.metrics;
    if (typeof metrics.totalReturnPct !== "number" || typeof metrics.maxDrawdownPct !== "number" || typeof metrics.winRatePct !== "number" || typeof metrics.totalTrades !== "number") {
      throw new Error(
        `Metrics calculation failed: invalid metric values - totalReturnPct=${metrics.totalReturnPct}, maxDrawdownPct=${metrics.maxDrawdownPct}, winRatePct=${metrics.winRatePct}, totalTrades=${metrics.totalTrades}`
      );
    }
    if (result.trades.length > 0) {
      const tradeInserts = result.trades.map((trade) => ({
        runId: trade.runId,
        ts: new Date(trade.ts),
        symbol: trade.symbol,
        side: trade.side,
        qty: trade.qty.toString(),
        price: trade.price.toString(),
        reason: trade.reason,
        orderType: trade.orderType,
        fees: trade.fees.toString(),
        slippage: trade.slippage.toString(),
        positionAfter: trade.positionAfter.toString(),
        cashAfter: trade.cashAfter.toString()
      }));
      const BATCH_SIZE = 100;
      for (let i = 0; i < tradeInserts.length; i += BATCH_SIZE) {
        const batch = tradeInserts.slice(i, i + BATCH_SIZE);
        await db.insert(backtestTradeEvents).values(batch);
      }
      log.info("BacktestRunner", `Persisted ${result.trades.length} trade events`);
    }
    if (result.equityCurve.length > 0) {
      const sampleRate = Math.max(1, Math.floor(result.equityCurve.length / 1e3));
      const sampledEquity = result.equityCurve.filter((_, i) => i % sampleRate === 0);
      const equityInserts = sampledEquity.map((point) => ({
        runId: point.runId,
        ts: new Date(point.ts),
        equity: point.equity.toString(),
        cash: point.cash.toString(),
        exposure: point.exposure.toString()
      }));
      const BATCH_SIZE = 100;
      for (let i = 0; i < equityInserts.length; i += BATCH_SIZE) {
        const batch = equityInserts.slice(i, i + BATCH_SIZE);
        await db.insert(backtestEquityCurve).values(batch);
      }
      log.info("BacktestRunner", `Persisted ${equityInserts.length} equity curve points (sampled from ${result.equityCurve.length})`);
    }
    const runtimeMs = Date.now() - startTime;
    const [updatedRun] = await db.update(backtestRuns).set({
      status: "DONE",
      provenance,
      resultsSummary: result.metrics,
      runtimeMs,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq16(backtestRuns.id, runId)).returning();
    log.info("BacktestRunner", `Backtest ${runId} completed in ${runtimeMs}ms with ${result.trades.length} trades`);
    return mapToBacktestRun(updatedRun);
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    log.error("BacktestRunner", `Backtest ${runId} failed: ${errorMessage}`);
    const [failedRun] = await db.update(backtestRuns).set({
      status: "FAILED",
      errorMessage,
      runtimeMs: Date.now() - startTime,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq16(backtestRuns.id, runId)).returning();
    return mapToBacktestRun(failedRun);
  }
}
function mapToBacktestRun(row) {
  return {
    id: row.id,
    createdAt: row.createdAt.toISOString(),
    updatedAt: row.updatedAt.toISOString(),
    status: row.status,
    strategyId: row.strategyId,
    strategyConfigHash: row.strategyConfigHash,
    strategyConfig: row.strategyConfig,
    universe: row.universe,
    broker: row.broker,
    timeframe: row.timeframe,
    startDate: row.startDate,
    endDate: row.endDate,
    initialCash: parseFloat(row.initialCash),
    feesModel: row.feesModel,
    slippageModel: row.slippageModel,
    executionPriceRule: row.executionPriceRule,
    dataSource: row.dataSource,
    provenance: row.provenance,
    resultsSummary: row.resultsSummary,
    errorMessage: row.errorMessage,
    runtimeMs: row.runtimeMs
  };
}
async function getBacktestRun(runId) {
  const [run] = await db.select().from(backtestRuns).where(eq16(backtestRuns.id, runId)).limit(1);
  if (!run) {
    return null;
  }
  return mapToBacktestRun(run);
}
async function listBacktestRuns(limit4 = 20, offset = 0) {
  const runs = await db.select().from(backtestRuns).orderBy(desc10(backtestRuns.createdAt)).limit(limit4).offset(offset);
  return runs.map(mapToBacktestRun);
}

// server/services/backtesting/walk-forward-engine.ts
init_logger();
var WalkForwardEngine = class {
  async runWalkForward(strategyType, symbols, baseParams, config) {
    log.info("WalkForward", `Starting walk-forward optimization...`);
    log.info("WalkForward", `IS: ${config.inSampleDays}d, OOS: ${config.outOfSampleDays}d, Step: ${config.stepDays}d`);
    const windows = this.generateWindows(config);
    log.info("WalkForward", `Generated ${windows.length} windows`);
    const windowResults = [];
    let previousParams = null;
    for (let i = 0; i < windows.length; i++) {
      const window = windows[i];
      log.info("WalkForward", `Processing window ${i + 1}/${windows.length}`);
      const optimizedParams = await this.optimizeParameters(
        symbols,
        baseParams,
        window.inSampleStart,
        window.inSampleEnd,
        config
      );
      log.info("WalkForward", `Optimized params for window ${i + 1}: ${JSON.stringify(optimizedParams)}`);
      const inSampleMetrics = await this.runBacktest(
        symbols,
        baseParams,
        window.inSampleStart,
        window.inSampleEnd,
        optimizedParams
      );
      const outOfSampleMetrics = await this.runBacktest(
        symbols,
        baseParams,
        window.outOfSampleStart,
        window.outOfSampleEnd,
        optimizedParams
      );
      const performanceDegradation = this.calculateDegradation(
        inSampleMetrics,
        outOfSampleMetrics,
        config.optimizationMetric
      );
      const parameterStability = previousParams ? this.calculateParameterStability(previousParams, optimizedParams, config.parameterRanges) : 1;
      log.info(
        "WalkForward",
        `Window ${i + 1}: IS ${this.getOptimizationScore(inSampleMetrics, config.optimizationMetric).toFixed(2)} -> OOS ${this.getOptimizationScore(outOfSampleMetrics, config.optimizationMetric).toFixed(2)} (degradation: ${performanceDegradation.toFixed(1)}%)`
      );
      windowResults.push({
        windowIndex: i,
        inSampleStart: window.inSampleStart,
        inSampleEnd: window.inSampleEnd,
        outOfSampleStart: window.outOfSampleStart,
        outOfSampleEnd: window.outOfSampleEnd,
        optimizedParams,
        inSampleMetrics,
        outOfSampleMetrics,
        performanceDegradation,
        parameterStability
      });
      previousParams = optimizedParams;
    }
    const aggregateOOS = this.aggregateMetrics(windowResults.map((w) => w.outOfSampleMetrics));
    const aggregateIS = this.aggregateMetrics(windowResults.map((w) => w.inSampleMetrics));
    const overfittingScore = this.calculateOverfittingScore(windowResults, aggregateIS, aggregateOOS);
    const robustnessScore = this.calculateRobustnessScore(windowResults);
    const parameterStabilityScore = this.calculateParamStabilityScore(windowResults);
    log.info(
      "WalkForward",
      `Analysis complete - Overfitting: ${(overfittingScore * 100).toFixed(1)}%, Robustness: ${(robustnessScore * 100).toFixed(1)}%, Param Stability: ${(parameterStabilityScore * 100).toFixed(1)}%`
    );
    const { isOverfit, recommendations } = this.generateRecommendations(
      overfittingScore,
      robustnessScore,
      parameterStabilityScore,
      windowResults
    );
    return {
      config,
      windows: windowResults,
      aggregateOOS,
      overfittingScore,
      robustnessScore,
      parameterStabilityScore,
      isOverfit,
      recommendations
    };
  }
  generateWindows(config) {
    const windows = [];
    const totalDays = Math.floor(
      (config.endDate.getTime() - config.startDate.getTime()) / (1e3 * 60 * 60 * 24)
    );
    const windowSize = config.inSampleDays + config.outOfSampleDays;
    let currentStart = 0;
    while (currentStart + windowSize <= totalDays) {
      const inSampleStart = new Date(config.startDate);
      inSampleStart.setDate(inSampleStart.getDate() + currentStart);
      const inSampleEnd = new Date(inSampleStart);
      inSampleEnd.setDate(inSampleEnd.getDate() + config.inSampleDays);
      const outOfSampleStart = new Date(inSampleEnd);
      const outOfSampleEnd = new Date(outOfSampleStart);
      outOfSampleEnd.setDate(outOfSampleEnd.getDate() + config.outOfSampleDays);
      windows.push({
        inSampleStart,
        inSampleEnd,
        outOfSampleStart,
        outOfSampleEnd
      });
      currentStart += config.stepDays;
    }
    return windows;
  }
  async optimizeParameters(symbols, baseParams, startDate, endDate, config) {
    const combinations = this.generateParameterCombinations(config.parameterRanges);
    let bestParams = {};
    let bestScore = -Infinity;
    log.info("WalkForward", `Testing ${combinations.length} parameter combinations...`);
    for (const params of combinations) {
      const metrics = await this.runBacktest(symbols, baseParams, startDate, endDate, params);
      if (metrics.tradeCount < config.minTrades) continue;
      const score = this.getOptimizationScore(metrics, config.optimizationMetric);
      if (score > bestScore) {
        bestScore = score;
        bestParams = params;
      }
    }
    if (Object.keys(bestParams).length === 0) {
      log.warn("WalkForward", "No valid parameter combination found, using first combination");
      bestParams = combinations[0] || {};
    }
    return bestParams;
  }
  generateParameterCombinations(ranges) {
    if (ranges.length === 0) return [{}];
    const first = ranges[0];
    const rest = ranges.slice(1);
    const restCombinations = this.generateParameterCombinations(rest);
    const combinations = [];
    for (let value = first.min; value <= first.max; value += first.step) {
      for (const restCombo of restCombinations) {
        combinations.push({
          [first.name]: value,
          ...restCombo
        });
      }
    }
    return combinations;
  }
  async runBacktest(symbols, baseParams, startDate, endDate, params) {
    const backtestParams = {
      ...baseParams,
      startDate: startDate.toISOString().split("T")[0],
      endDate: endDate.toISOString().split("T")[0],
      universe: symbols,
      strategyParams: params
    };
    try {
      const result = await runBacktest(backtestParams);
      if (!result.resultsSummary) {
        return this.createEmptyMetrics();
      }
      const summary = result.resultsSummary;
      return {
        totalReturn: summary.totalReturnPct,
        annualizedReturn: summary.cagr || 0,
        sharpeRatio: summary.sharpeRatio || 0,
        sortinoRatio: summary.sortinoRatio || 0,
        calmarRatio: summary.calmarRatio || 0,
        maxDrawdown: summary.maxDrawdownPct,
        winRate: summary.winRatePct,
        profitFactor: summary.profitFactor || 0,
        tradeCount: summary.totalTrades,
        avgTradeDuration: summary.avgHoldingPeriodDays || 0
      };
    } catch (error) {
      log.error("WalkForward", `Backtest failed: ${error instanceof Error ? error.message : String(error)}`);
      return this.createEmptyMetrics();
    }
  }
  createEmptyMetrics() {
    return {
      totalReturn: 0,
      annualizedReturn: 0,
      sharpeRatio: 0,
      sortinoRatio: 0,
      calmarRatio: 0,
      maxDrawdown: 0,
      winRate: 0,
      profitFactor: 0,
      tradeCount: 0,
      avgTradeDuration: 0
    };
  }
  getOptimizationScore(metrics, metric) {
    switch (metric) {
      case "sharpe":
        return metrics.sharpeRatio;
      case "sortino":
        return metrics.sortinoRatio;
      case "calmar":
        return metrics.calmarRatio;
      case "returns":
        return metrics.annualizedReturn;
      case "profitFactor":
        return metrics.profitFactor;
      default:
        return metrics.sharpeRatio;
    }
  }
  calculateDegradation(is, oos, metric) {
    const isScore = this.getOptimizationScore(is, metric);
    const oosScore = this.getOptimizationScore(oos, metric);
    if (isScore === 0) return 0;
    return (isScore - oosScore) / Math.abs(isScore) * 100;
  }
  calculateParameterStability(prev, curr, ranges) {
    let totalDiff = 0;
    let totalRange = 0;
    for (const range of ranges) {
      const prevVal = prev[range.name] || 0;
      const currVal = curr[range.name] || 0;
      const rangeSize = range.max - range.min;
      if (rangeSize > 0) {
        totalDiff += Math.abs(prevVal - currVal) / rangeSize;
        totalRange += 1;
      }
    }
    return totalRange > 0 ? 1 - totalDiff / totalRange : 1;
  }
  aggregateMetrics(metrics) {
    const n = metrics.length;
    if (n === 0) return this.createEmptyMetrics();
    return {
      totalReturn: metrics.reduce((s, m) => s + m.totalReturn, 0) / n,
      annualizedReturn: metrics.reduce((s, m) => s + m.annualizedReturn, 0) / n,
      sharpeRatio: metrics.reduce((s, m) => s + m.sharpeRatio, 0) / n,
      sortinoRatio: metrics.reduce((s, m) => s + m.sortinoRatio, 0) / n,
      calmarRatio: metrics.reduce((s, m) => s + m.calmarRatio, 0) / n,
      maxDrawdown: Math.max(...metrics.map((m) => m.maxDrawdown)),
      winRate: metrics.reduce((s, m) => s + m.winRate, 0) / n,
      profitFactor: metrics.reduce((s, m) => s + m.profitFactor, 0) / n,
      tradeCount: metrics.reduce((s, m) => s + m.tradeCount, 0),
      avgTradeDuration: metrics.reduce((s, m) => s + m.avgTradeDuration, 0) / n
    };
  }
  calculateOverfittingScore(windows, aggIS, aggOOS) {
    const avgDegradation = windows.reduce((s, w) => s + w.performanceDegradation, 0) / windows.length;
    let score = Math.min(1, Math.max(0, avgDegradation / 100));
    if (aggIS.sharpeRatio > 0.5 && aggOOS.sharpeRatio < 0) {
      score = Math.min(1, score + 0.3);
    }
    return score;
  }
  calculateRobustnessScore(windows) {
    if (windows.length === 0) return 0;
    const profitableWindows = windows.filter((w) => w.outOfSampleMetrics.totalReturn > 0);
    const profitableRatio = profitableWindows.length / windows.length;
    const oosSharpes = windows.map((w) => w.outOfSampleMetrics.sharpeRatio);
    const avgSharpe = oosSharpes.reduce((a, b) => a + b, 0) / oosSharpes.length;
    const sharpeStdDev = Math.sqrt(
      oosSharpes.reduce((s, v) => s + Math.pow(v - avgSharpe, 2), 0) / oosSharpes.length
    );
    const consistencyScore = Math.max(0, 1 - sharpeStdDev / 2);
    return profitableRatio * 0.6 + consistencyScore * 0.4;
  }
  calculateParamStabilityScore(windows) {
    if (windows.length < 2) return 1;
    const stabilities = windows.slice(1).map((w) => w.parameterStability);
    return stabilities.reduce((a, b) => a + b, 0) / stabilities.length;
  }
  generateRecommendations(overfitting, robustness, paramStability, windows) {
    const recommendations = [];
    const isOverfit = overfitting > 0.4 || robustness < 0.5;
    if (overfitting > 0.6) {
      recommendations.push("HIGH OVERFITTING: Reduce parameter complexity or add regularization");
    } else if (overfitting > 0.4) {
      recommendations.push("MODERATE OVERFITTING: Consider simpler strategy rules");
    }
    if (robustness < 0.4) {
      recommendations.push("LOW ROBUSTNESS: Strategy may not work in live trading");
    } else if (robustness < 0.6) {
      recommendations.push("MODERATE ROBUSTNESS: Exercise caution with live deployment");
    }
    if (paramStability < 0.6) {
      recommendations.push("UNSTABLE PARAMETERS: Optimal params change significantly between periods");
      recommendations.push("Consider using parameter averaging or ensemble approach");
    }
    const negativeWindows = windows.filter((w) => w.outOfSampleMetrics.sharpeRatio < 0);
    if (negativeWindows.length > windows.length * 0.3) {
      recommendations.push(`WARNING: ${negativeWindows.length}/${windows.length} windows had negative OOS Sharpe`);
    }
    const negativeReturns = windows.filter((w) => w.outOfSampleMetrics.totalReturn < 0);
    if (negativeReturns.length > windows.length * 0.4) {
      recommendations.push(`WARNING: ${negativeReturns.length}/${windows.length} windows had negative OOS returns`);
    }
    if (recommendations.length === 0) {
      recommendations.push("Strategy appears robust with acceptable overfitting levels");
      recommendations.push("Consider live paper trading before deploying with real capital");
    }
    return { isOverfit, recommendations };
  }
};
var walkForwardEngine = new WalkForwardEngine();

// server/routes/backtests.ts
init_logger();
init_sanitization();
import { eq as eq17 } from "drizzle-orm";
var router = Router();
router.post("/run", async (req, res) => {
  try {
    const {
      strategyId,
      strategyConfig,
      universe,
      timeframe = "1Day",
      startDate,
      endDate,
      initialCash = 1e4,
      feesModel = { type: "fixed", value: 1 },
      slippageModel = { type: "bps", value: 5 },
      executionPriceRule = "NEXT_OPEN",
      strategyType = "moving_average_crossover",
      strategyParams = {}
    } = req.body;
    if (universe && !Array.isArray(universe)) {
      return res.status(400).json({ error: "universe must be an array of symbols" });
    }
    const defaultUniverse = ["SPY", "QQQ", "AAPL"];
    const backtestUniverse = universe && universe.length > 0 ? universe : defaultUniverse;
    if (backtestUniverse.length === 0) {
      return res.status(400).json({ error: "universe must contain at least one symbol. Default symbols: SPY, QQQ, AAPL" });
    }
    if (!startDate || !endDate) {
      return res.status(400).json({ error: "startDate and endDate are required" });
    }
    const validStrategyTypes = ["moving_average_crossover", "rsi_oscillator", "buy_and_hold"];
    if (strategyType && !validStrategyTypes.includes(strategyType)) {
      return res.status(400).json({
        error: `Invalid strategyType. Must be one of: ${validStrategyTypes.join(", ")}`
      });
    }
    const sanitizedUniverse = sanitizeArray(backtestUniverse);
    const result = await runBacktest({
      strategyId,
      strategyConfig: strategyConfig || {},
      universe: sanitizedUniverse,
      timeframe,
      startDate,
      endDate,
      initialCash,
      feesModel,
      slippageModel,
      executionPriceRule,
      strategyType,
      strategyParams: {
        fastPeriod: strategyParams.fastPeriod || 10,
        slowPeriod: strategyParams.slowPeriod || 20,
        period: strategyParams.period || 14,
        oversoldThreshold: strategyParams.oversoldThreshold || 30,
        overboughtThreshold: strategyParams.overboughtThreshold || 70,
        allocationPct: strategyParams.allocationPct || 10,
        ...strategyParams
      }
    });
    res.json(result);
  } catch (error) {
    log.error("BacktestAPI", `Failed to run backtest: ${error}`);
    res.status(500).json({ error: error.message || "Failed to run backtest" });
  }
});
router.get("/", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    const runs = await listBacktestRuns(limit4, offset);
    res.json({ runs, limit: limit4, offset });
  } catch (error) {
    log.error("BacktestAPI", `Failed to list backtests: ${error}`);
    res.status(500).json({ error: "Failed to list backtests" });
  }
});
router.get("/:id", async (req, res) => {
  try {
    const run = await getBacktestRun(req.params.id);
    if (!run) {
      return res.status(404).json({ error: "Backtest not found" });
    }
    res.json(run);
  } catch (error) {
    log.error("BacktestAPI", `Failed to get backtest: ${error}`);
    res.status(500).json({ error: "Failed to get backtest" });
  }
});
router.get("/:id/equity-curve", async (req, res) => {
  try {
    const points = await db.select().from(backtestEquityCurve).where(eq17(backtestEquityCurve.runId, req.params.id)).orderBy(backtestEquityCurve.ts);
    const formattedPoints = points.map((p) => ({
      ts: p.ts.toISOString(),
      equity: parseFloat(p.equity),
      cash: parseFloat(p.cash),
      exposure: parseFloat(p.exposure)
    }));
    res.json({ points: formattedPoints });
  } catch (error) {
    log.error("BacktestAPI", `Failed to get equity curve: ${error}`);
    res.status(500).json({ error: "Failed to get equity curve" });
  }
});
router.get("/:id/trades", async (req, res) => {
  try {
    const trades3 = await db.select().from(backtestTradeEvents).where(eq17(backtestTradeEvents.runId, req.params.id)).orderBy(backtestTradeEvents.ts);
    const formattedTrades = trades3.map((t) => ({
      id: t.id,
      runId: t.runId,
      ts: t.ts.toISOString(),
      symbol: t.symbol,
      side: t.side,
      qty: parseFloat(t.qty),
      price: parseFloat(t.price),
      reason: t.reason,
      orderType: t.orderType,
      fees: parseFloat(t.fees),
      slippage: parseFloat(t.slippage),
      positionAfter: parseFloat(t.positionAfter),
      cashAfter: parseFloat(t.cashAfter)
    }));
    res.json({ trades: formattedTrades });
  } catch (error) {
    log.error("BacktestAPI", `Failed to get trades: ${error}`);
    res.status(500).json({ error: "Failed to get trades" });
  }
});
var backtests_default = router;

// server/routes/traces.ts
init_db();
init_schema();
init_logger();
import { Router as Router2 } from "express";
import { eq as eq18, desc as desc12, and as and12, or as or2, like as like3 } from "drizzle-orm";
var tracesRouter = Router2();
tracesRouter.get("/:traceId", async (req, res) => {
  const { traceId } = req.params;
  if (!traceId) {
    return res.status(400).json({ error: "traceId is required" });
  }
  try {
    const [decisionResults, llmCallResults, workItemResults, tradeResults] = await Promise.all([
      db.select().from(aiDecisions).where(eq18(aiDecisions.traceId, traceId)),
      db.select().from(llmCalls).where(eq18(llmCalls.traceId, traceId)).orderBy(desc12(llmCalls.createdAt)),
      db.select().from(workItems).where(
        or2(
          like3(workItems.payload, `%${traceId}%`),
          like3(workItems.result, `%${traceId}%`)
        )
      ),
      Promise.resolve([])
    ]);
    const decision = decisionResults[0] || null;
    let relatedTrades = [];
    if (decision?.executedTradeId) {
      relatedTrades = await db.select().from(trades).where(eq18(trades.id, decision.executedTradeId));
    }
    const events = [];
    if (decision) {
      events.push({
        timestamp: decision.createdAt,
        type: "decision",
        id: decision.id,
        status: decision.status,
        details: {
          symbol: decision.symbol,
          action: decision.action,
          confidence: decision.confidence
        }
      });
    }
    for (const call of llmCallResults) {
      events.push({
        timestamp: call.createdAt,
        type: "llm_call",
        id: call.id,
        status: call.status,
        details: {
          role: call.role,
          provider: call.provider,
          model: call.model,
          tokensUsed: call.totalTokens,
          latencyMs: call.latencyMs
        }
      });
    }
    for (const item of workItemResults) {
      events.push({
        timestamp: item.nextRunAt,
        type: "work_item",
        id: item.id,
        status: item.status,
        details: {
          type: item.type,
          attempts: item.attempts,
          brokerOrderId: item.brokerOrderId
        }
      });
    }
    for (const trade of relatedTrades) {
      events.push({
        timestamp: trade.executedAt,
        type: "trade",
        id: trade.id,
        status: trade.status,
        details: {
          symbol: trade.symbol,
          side: trade.side,
          quantity: trade.quantity,
          price: trade.price
        }
      });
    }
    events.sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
    const totalTokens = llmCallResults.reduce((sum, c) => sum + (c.totalTokens || 0), 0);
    const estimatedCost = llmCallResults.reduce((sum, c) => sum + parseFloat(c.estimatedCost || "0"), 0);
    const totalLatency = llmCallResults.reduce((sum, c) => sum + (c.latencyMs || 0), 0);
    const providersUsed = [...new Set(llmCallResults.map((c) => c.provider))];
    let finalOutcome = "unknown";
    if (relatedTrades.length > 0) {
      finalOutcome = relatedTrades[0].status;
    } else if (decision?.status === "executed") {
      finalOutcome = "executed";
    } else if (decision?.status === "skipped") {
      finalOutcome = `skipped: ${decision.skipReason || "unknown"}`;
    } else if (decision) {
      finalOutcome = decision.status;
    } else if (llmCallResults.length > 0) {
      finalOutcome = "pending";
    }
    const response = {
      traceId,
      events,
      decision: decision ? {
        id: decision.id,
        symbol: decision.symbol,
        action: decision.action,
        confidence: decision.confidence ? parseFloat(decision.confidence) : null,
        reasoning: decision.reasoning,
        status: decision.status,
        createdAt: decision.createdAt
      } : void 0,
      llmCalls: llmCallResults.map((c) => {
        let purpose = null;
        let criticality = null;
        try {
          if (c.metadata) {
            const meta = JSON.parse(c.metadata);
            purpose = meta.purpose || null;
            criticality = meta.criticality || null;
          }
        } catch {
        }
        return {
          id: c.id,
          role: c.role,
          provider: c.provider,
          model: c.model,
          purpose: c.purpose || purpose,
          criticality: c.criticality || criticality,
          tokensUsed: c.totalTokens,
          latencyMs: c.latencyMs,
          status: c.status,
          createdAt: c.createdAt
        };
      }),
      workItems: workItemResults.map((w) => ({
        id: w.id,
        type: w.type,
        status: w.status,
        attempts: w.attempts,
        brokerOrderId: w.brokerOrderId,
        symbol: w.symbol,
        result: w.result
      })),
      trades: relatedTrades.map((t) => ({
        id: t.id,
        symbol: t.symbol,
        side: t.side,
        quantity: t.quantity,
        price: t.price,
        status: t.status,
        executedAt: t.executedAt
      })),
      summary: {
        totalLLMCalls: llmCallResults.length,
        totalTokens,
        estimatedCost,
        latencyMs: totalLatency,
        providersUsed,
        finalOutcome
      }
    };
    log.debug("Traces", "Trace lookup complete", {
      traceId,
      eventsCount: events.length,
      llmCallsCount: llmCallResults.length
    });
    return res.json(response);
  } catch (error) {
    log.error("Traces", "Failed to fetch trace", { traceId, error: String(error) });
    return res.status(500).json({ error: "Failed to fetch trace" });
  }
});
tracesRouter.get("/", async (req, res) => {
  const { limit: limitStr = "20", symbol, status } = req.query;
  const limit4 = Math.min(parseInt(limitStr, 10) || 20, 100);
  try {
    let query = db.select({
      traceId: aiDecisions.traceId,
      id: aiDecisions.id,
      symbol: aiDecisions.symbol,
      action: aiDecisions.action,
      status: aiDecisions.status,
      createdAt: aiDecisions.createdAt
    }).from(aiDecisions);
    const conditions = [];
    if (symbol) {
      conditions.push(eq18(aiDecisions.symbol, symbol));
    }
    if (status) {
      conditions.push(eq18(aiDecisions.status, status));
    }
    conditions.push(eq18(aiDecisions.traceId, aiDecisions.traceId));
    if (conditions.length > 0) {
      query = query.where(and12(...conditions));
    }
    const results = await query.orderBy(desc12(aiDecisions.createdAt)).limit(limit4);
    return res.json({
      traces: results.filter((r) => r.traceId),
      total: results.length
    });
  } catch (error) {
    log.error("Traces", "Failed to list traces", { error: String(error) });
    return res.status(500).json({ error: "Failed to list traces" });
  }
});

// server/observability/routes.ts
init_db();
init_schema();
init_logger();
import { Router as Router3 } from "express";
import { eq as eq20, desc as desc14, and as and14, or as or3, like as like4, gte as gte6, sql as sql11, count as count2 } from "drizzle-orm";

// server/observability/alertService.ts
init_db();
init_schema();
init_logger();
import { eq as eq19, desc as desc13, gte as gte5, sql as sql10, and as and13, count } from "drizzle-orm";
var AlertService = class {
  evaluationInterval = null;
  async getMetricsSnapshot() {
    const now = /* @__PURE__ */ new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
    const [queueCounts, llmStats, orchestratorStatus, oldestPending, retryCount] = await Promise.all([
      db.select({
        status: workItems.status,
        count: count()
      }).from(workItems).groupBy(workItems.status),
      db.select({
        total: count(),
        errors: sql10`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte5(llmCalls.createdAt, oneHourAgo)),
      db.select().from(agentStatus).limit(1),
      db.select({
        createdAt: workItems.createdAt
      }).from(workItems).where(eq19(workItems.status, "PENDING")).orderBy(workItems.createdAt).limit(1),
      db.select({
        count: count()
      }).from(workItems).where(and13(
        gte5(workItems.attempts, 1),
        gte5(workItems.updatedAt, new Date(now.getTime() - 60 * 1e3))
      ))
    ]);
    const counts = {};
    queueCounts.forEach((c) => {
      counts[c.status] = Number(c.count);
    });
    const llmTotal = Number(llmStats[0]?.total || 0);
    const llmErrors = Number(llmStats[0]?.errors || 0);
    const llmErrorRate = llmTotal > 0 ? llmErrors / llmTotal * 100 : 0;
    const lastHeartbeat = orchestratorStatus[0]?.lastHeartbeat;
    const orchestratorLastRunMinutesAgo = lastHeartbeat ? (now.getTime() - new Date(lastHeartbeat).getTime()) / 6e4 : Infinity;
    const oldestPendingAge = oldestPending[0]?.createdAt ? (now.getTime() - new Date(oldestPending[0].createdAt).getTime()) / 6e4 : 0;
    return {
      deadLetterCount: counts["DEAD_LETTER"] || 0,
      pendingCount: counts["PENDING"] || 0,
      runningCount: counts["RUNNING"] || 0,
      failedCount: counts["FAILED"] || 0,
      succeededCount: counts["SUCCEEDED"] || 0,
      oldestPendingAgeMinutes: oldestPendingAge,
      llmCallsLastHour: llmTotal,
      llmErrorsLastHour: llmErrors,
      llmErrorRate,
      orchestratorLastRunMinutesAgo,
      retryRatePerMinute: Number(retryCount[0]?.count || 0)
    };
  }
  async createRule(input) {
    const [rule] = await db.insert(alertRules).values({
      name: input.name,
      description: input.description || null,
      ruleType: input.ruleType,
      condition: input.condition,
      threshold: String(input.threshold),
      enabled: input.enabled ?? true,
      webhookUrl: input.webhookUrl || null
    }).returning();
    log.info("AlertService", "Created alert rule", { ruleId: rule.id, name: rule.name });
    return rule;
  }
  async getRules() {
    return db.select().from(alertRules).orderBy(desc13(alertRules.createdAt));
  }
  async getRule(id) {
    const [rule] = await db.select().from(alertRules).where(eq19(alertRules.id, id));
    return rule || null;
  }
  async toggleRule(id, enabled) {
    const [rule] = await db.update(alertRules).set({ enabled, updatedAt: /* @__PURE__ */ new Date() }).where(eq19(alertRules.id, id)).returning();
    return rule || null;
  }
  async deleteRule(id) {
    const result = await db.delete(alertRules).where(eq19(alertRules.id, id));
    return true;
  }
  async evaluateRules() {
    const enabledRules = await db.select().from(alertRules).where(eq19(alertRules.enabled, true));
    const metrics = await this.getMetricsSnapshot();
    const triggered = [];
    for (const rule of enabledRules) {
      const condition = rule.condition;
      const threshold = parseFloat(rule.threshold);
      let currentValue = 0;
      switch (rule.ruleType) {
        case "dead_letter_count":
          currentValue = metrics.deadLetterCount;
          break;
        case "retry_rate":
          currentValue = metrics.retryRatePerMinute;
          break;
        case "orchestrator_silent":
          currentValue = metrics.orchestratorLastRunMinutesAgo;
          break;
        case "llm_error_rate":
          currentValue = metrics.llmErrorRate;
          break;
        default:
          continue;
      }
      const shouldTrigger = this.evaluateCondition(currentValue, condition.operator, threshold);
      await db.update(alertRules).set({ lastCheckedAt: /* @__PURE__ */ new Date() }).where(eq19(alertRules.id, rule.id));
      if (shouldTrigger) {
        triggered.push(rule.name);
        await this.triggerAlert(rule, currentValue);
      }
    }
    return { triggered, checked: enabledRules.length };
  }
  evaluateCondition(value, operator, threshold) {
    switch (operator) {
      case ">":
        return value > threshold;
      case "<":
        return value < threshold;
      case ">=":
        return value >= threshold;
      case "<=":
        return value <= threshold;
      case "==":
        return value === threshold;
      default:
        return false;
    }
  }
  async triggerAlert(rule, triggeredValue) {
    const [event] = await db.insert(alertEvents).values({
      ruleId: rule.id,
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue: String(triggeredValue),
      threshold: rule.threshold,
      status: "triggered",
      webhookSent: false
    }).returning();
    await db.update(alertRules).set({ lastTriggeredAt: /* @__PURE__ */ new Date() }).where(eq19(alertRules.id, rule.id));
    log.warn("AlertService", "Alert triggered", {
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue,
      threshold: rule.threshold
    });
    if (rule.webhookUrl) {
      await this.sendWebhook(rule, event, triggeredValue);
    }
  }
  async sendWebhook(rule, event, triggeredValue) {
    if (!rule.webhookUrl) return;
    const payload = {
      alertId: event.id,
      ruleName: rule.name,
      ruleType: rule.ruleType,
      triggeredValue,
      threshold: parseFloat(rule.threshold),
      triggeredAt: event.createdAt.toISOString(),
      service: "ai-active-trader",
      severity: "warning"
    };
    try {
      const response = await fetch(rule.webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      await db.update(alertEvents).set({
        webhookSent: true,
        webhookResponse: `${response.status} ${response.statusText}`
      }).where(eq19(alertEvents.id, event.id));
      log.info("AlertService", "Webhook sent successfully", {
        ruleName: rule.name,
        webhookUrl: rule.webhookUrl,
        status: response.status
      });
    } catch (error) {
      await db.update(alertEvents).set({
        webhookSent: false,
        webhookResponse: String(error)
      }).where(eq19(alertEvents.id, event.id));
      log.error("AlertService", "Webhook failed", {
        ruleName: rule.name,
        error: String(error)
      });
    }
  }
  async getRecentEvents(limit4 = 50) {
    return db.select().from(alertEvents).orderBy(desc13(alertEvents.createdAt)).limit(limit4);
  }
  async testAlert(ruleId) {
    const rule = await this.getRule(ruleId);
    if (!rule) {
      return { success: false, message: "Rule not found" };
    }
    if (!rule.webhookUrl) {
      return { success: false, message: "No webhook URL configured" };
    }
    const testPayload = {
      alertId: "test-" + Date.now(),
      ruleName: rule.name + " (TEST)",
      ruleType: rule.ruleType,
      triggeredValue: parseFloat(rule.threshold),
      threshold: parseFloat(rule.threshold),
      triggeredAt: (/* @__PURE__ */ new Date()).toISOString(),
      service: "ai-active-trader",
      severity: "test"
    };
    try {
      const response = await fetch(rule.webhookUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(testPayload)
      });
      return {
        success: response.ok,
        message: `Webhook returned ${response.status} ${response.statusText}`
      };
    } catch (error) {
      return {
        success: false,
        message: String(error)
      };
    }
  }
  startEvaluationJob(intervalMs = 3e4) {
    if (this.evaluationInterval) {
      return;
    }
    log.info("AlertService", "Starting alert evaluation job", { intervalMs });
    this.evaluationInterval = setInterval(async () => {
      try {
        const result = await this.evaluateRules();
        if (result.triggered.length > 0) {
          log.warn("AlertService", "Alert evaluation complete", {
            checked: result.checked,
            triggered: result.triggered
          });
        }
      } catch (error) {
        log.error("AlertService", "Alert evaluation failed", { error: String(error) });
      }
    }, intervalMs);
  }
  stopEvaluationJob() {
    if (this.evaluationInterval) {
      clearInterval(this.evaluationInterval);
      this.evaluationInterval = null;
      log.info("AlertService", "Stopped alert evaluation job");
    }
  }
};
var alertService = new AlertService();

// server/observability/routes.ts
var observabilityRouter = Router3();
observabilityRouter.get("/health", async (req, res) => {
  try {
    const now = /* @__PURE__ */ new Date();
    const oneHourAgo = new Date(now.getTime() - 60 * 60 * 1e3);
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1e3);
    const [
      queueCounts,
      oldestPending,
      llmStatsHour,
      llmStatsDay,
      orchestratorStatus
    ] = await Promise.all([
      db.select({
        status: workItems.status,
        count: count2()
      }).from(workItems).groupBy(workItems.status),
      db.select({
        createdAt: workItems.createdAt
      }).from(workItems).where(eq20(workItems.status, "PENDING")).orderBy(workItems.createdAt).limit(1),
      db.select({
        total: count2(),
        errors: sql11`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte6(llmCalls.createdAt, oneHourAgo)),
      db.select({
        total: count2(),
        errors: sql11`count(case when ${llmCalls.status} = 'error' then 1 end)`
      }).from(llmCalls).where(gte6(llmCalls.createdAt, oneDayAgo)),
      db.select().from(agentStatus).limit(1)
    ]);
    const counts = {};
    queueCounts.forEach((c) => {
      counts[c.status] = Number(c.count);
    });
    const oldestPendingAge = oldestPending[0]?.createdAt ? Math.round((now.getTime() - new Date(oldestPending[0].createdAt).getTime()) / 6e4) : 0;
    const agent = orchestratorStatus[0];
    const lastHeartbeat = agent?.lastHeartbeat;
    const minutesSinceHeartbeat = lastHeartbeat ? Math.round((now.getTime() - new Date(lastHeartbeat).getTime()) / 6e4) : null;
    const llmHour = llmStatsHour[0] || { total: 0, errors: 0 };
    const llmDay = llmStatsDay[0] || { total: 0, errors: 0 };
    const response = {
      queue: {
        pending: counts["PENDING"] || 0,
        running: counts["RUNNING"] || 0,
        succeeded: counts["SUCCEEDED"] || 0,
        failed: counts["FAILED"] || 0,
        deadLetter: counts["DEAD_LETTER"] || 0,
        oldestPendingAgeMinutes: oldestPendingAge
      },
      orchestrator: {
        isRunning: agent?.isRunning ?? false,
        lastHeartbeat: lastHeartbeat?.toISOString() || null,
        minutesSinceHeartbeat,
        killSwitchActive: agent?.killSwitchActive ?? false,
        dynamicOrderLimit: agent?.dynamicOrderLimit ?? 10,
        marketCondition: agent?.marketCondition || "unknown"
      },
      llm: {
        lastHour: {
          calls: Number(llmHour.total),
          errors: Number(llmHour.errors),
          errorRate: llmHour.total > 0 ? (Number(llmHour.errors) / Number(llmHour.total) * 100).toFixed(2) + "%" : "0%"
        },
        last24Hours: {
          calls: Number(llmDay.total),
          errors: Number(llmDay.errors),
          errorRate: llmDay.total > 0 ? (Number(llmDay.errors) / Number(llmDay.total) * 100).toFixed(2) + "%" : "0%"
        }
      },
      fetchedAt: now.toISOString(),
      sources: {
        queue: "db:work_items",
        orchestrator: "db:agent_status",
        llm: "db:llm_calls"
      }
    };
    return res.json(response);
  } catch (error) {
    log.error("Observability", "Health endpoint failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch health data" });
  }
});
observabilityRouter.get("/metrics/summary", async (req, res) => {
  try {
    const metrics = await alertService.getMetricsSnapshot();
    return res.json({
      metrics,
      fetchedAt: (/* @__PURE__ */ new Date()).toISOString(),
      source: "db/computed"
    });
  } catch (error) {
    log.error("Observability", "Metrics summary failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch metrics" });
  }
});
observabilityRouter.get("/work-queue/items", async (req, res) => {
  try {
    const { status, type, traceId, limit: limitStr = "50" } = req.query;
    const limit4 = Math.min(parseInt(limitStr, 10) || 50, 200);
    const conditions = [];
    if (status && status !== "all") {
      conditions.push(eq20(workItems.status, status));
    }
    if (type) {
      conditions.push(eq20(workItems.type, type));
    }
    if (traceId) {
      conditions.push(like4(workItems.payload, `%${traceId}%`));
    }
    let query = db.select().from(workItems);
    if (conditions.length > 0) {
      query = query.where(and14(...conditions));
    }
    const items = await query.orderBy(desc14(workItems.createdAt)).limit(limit4);
    return res.json({
      items,
      total: items.length
    });
  } catch (error) {
    log.error("Observability", "Work queue list failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch work queue items" });
  }
});
observabilityRouter.get("/work-queue/items/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const item = await workQueue.getById(id);
    if (!item) {
      return res.status(404).json({ error: "Work item not found" });
    }
    let parsedPayload = null;
    try {
      if (item.payload) {
        parsedPayload = JSON.parse(item.payload);
      }
    } catch {
    }
    return res.json({
      ...item,
      parsedPayload
    });
  } catch (error) {
    log.error("Observability", "Work item fetch failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch work item" });
  }
});
observabilityRouter.post("/work-queue/items/:id/retry", async (req, res) => {
  try {
    const { id } = req.params;
    const item = await workQueue.retryDeadLetter(id);
    if (!item) {
      return res.status(404).json({ error: "Work item not found or not a dead letter" });
    }
    log.info("Observability", "Work item retried", { id, type: item.type });
    return res.json({ success: true, item });
  } catch (error) {
    log.error("Observability", "Work item retry failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to retry work item" });
  }
});
observabilityRouter.post("/work-queue/items/:id/cancel", async (req, res) => {
  try {
    const { id } = req.params;
    const item = await workQueue.getById(id);
    if (!item) {
      return res.status(404).json({ error: "Work item not found" });
    }
    if (item.status !== "PENDING") {
      return res.status(400).json({ error: "Only pending items can be cancelled" });
    }
    await workQueue.markDeadLetter(id, "Cancelled by admin");
    log.info("Observability", "Work item cancelled", { id, type: item.type });
    return res.json({ success: true, message: "Work item cancelled" });
  } catch (error) {
    log.error("Observability", "Work item cancel failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to cancel work item" });
  }
});
observabilityRouter.post("/work-queue/items/:id/dead-letter", async (req, res) => {
  try {
    const { id } = req.params;
    const { reason = "Force dead-lettered by admin" } = req.body;
    await workQueue.markDeadLetter(id, reason);
    log.info("Observability", "Work item force dead-lettered", { id, reason });
    return res.json({ success: true, message: "Work item moved to dead letter" });
  } catch (error) {
    log.error("Observability", "Force dead-letter failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to dead-letter work item" });
  }
});
observabilityRouter.get("/trace/:traceId", async (req, res) => {
  const { traceId } = req.params;
  if (!traceId) {
    return res.status(400).json({ error: "traceId is required" });
  }
  try {
    const [decisionResults, llmCallResults, workItemResults, tradeResults] = await Promise.all([
      db.select().from(aiDecisions).where(eq20(aiDecisions.traceId, traceId)),
      db.select().from(llmCalls).where(eq20(llmCalls.traceId, traceId)).orderBy(desc14(llmCalls.createdAt)),
      db.select().from(workItems).where(
        or3(
          like4(workItems.payload, `%${traceId}%`),
          like4(workItems.result, `%${traceId}%`)
        )
      ),
      db.select().from(trades).where(eq20(trades.traceId, traceId))
    ]);
    const totalTokens = llmCallResults.reduce((sum, c) => sum + (c.totalTokens || 0), 0);
    const estimatedCost = llmCallResults.reduce((sum, c) => sum + parseFloat(c.estimatedCost || "0"), 0);
    const totalLatency = llmCallResults.reduce((sum, c) => sum + (c.latencyMs || 0), 0);
    const providersUsed = [...new Set(llmCallResults.map((c) => c.provider))];
    const missingModules = [];
    return res.json({
      traceId,
      decisions: decisionResults.map((d) => ({
        id: d.id,
        symbol: d.symbol,
        action: d.action,
        confidence: d.confidence ? parseFloat(d.confidence) : null,
        status: d.status,
        createdAt: d.createdAt
      })),
      llmCalls: llmCallResults.map((c) => ({
        id: c.id,
        role: c.role,
        provider: c.provider,
        model: c.model,
        tokensUsed: c.totalTokens,
        latencyMs: c.latencyMs,
        status: c.status,
        createdAt: c.createdAt
      })),
      workItems: workItemResults.map((w) => ({
        id: w.id,
        type: w.type,
        status: w.status,
        attempts: w.attempts,
        symbol: w.symbol,
        brokerOrderId: w.brokerOrderId
      })),
      trades: tradeResults.map((t) => ({
        id: t.id,
        symbol: t.symbol,
        side: t.side,
        quantity: t.quantity,
        price: t.price,
        status: t.status,
        executedAt: t.executedAt
      })),
      summary: {
        totalDecisions: decisionResults.length,
        totalLLMCalls: llmCallResults.length,
        totalWorkItems: workItemResults.length,
        totalTrades: tradeResults.length,
        totalTokens,
        estimatedCost,
        latencyMs: totalLatency,
        providersUsed
      },
      missingModules
    });
  } catch (error) {
    log.error("Observability", "Trace lookup failed", { traceId, error: String(error) });
    return res.status(500).json({ error: "Failed to fetch trace" });
  }
});
observabilityRouter.get("/alerts/rules", async (req, res) => {
  try {
    const rules = await alertService.getRules();
    return res.json({ rules });
  } catch (error) {
    log.error("Observability", "Alert rules fetch failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch alert rules" });
  }
});
observabilityRouter.post("/alerts/rules", async (req, res) => {
  try {
    const { name, description, ruleType, condition, threshold, enabled, webhookUrl } = req.body;
    if (!name || !ruleType || !condition || threshold === void 0) {
      return res.status(400).json({ error: "Missing required fields: name, ruleType, condition, threshold" });
    }
    const rule = await alertService.createRule({
      name,
      description,
      ruleType,
      condition,
      threshold,
      enabled,
      webhookUrl
    });
    return res.status(201).json({ rule });
  } catch (error) {
    log.error("Observability", "Alert rule creation failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to create alert rule" });
  }
});
observabilityRouter.post("/alerts/rules/:id/toggle", async (req, res) => {
  try {
    const { id } = req.params;
    const { enabled } = req.body;
    if (typeof enabled !== "boolean") {
      return res.status(400).json({ error: "enabled must be a boolean" });
    }
    const rule = await alertService.toggleRule(id, enabled);
    if (!rule) {
      return res.status(404).json({ error: "Alert rule not found" });
    }
    return res.json({ rule });
  } catch (error) {
    log.error("Observability", "Alert rule toggle failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to toggle alert rule" });
  }
});
observabilityRouter.delete("/alerts/rules/:id", async (req, res) => {
  try {
    const { id } = req.params;
    await alertService.deleteRule(id);
    return res.json({ success: true });
  } catch (error) {
    log.error("Observability", "Alert rule deletion failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to delete alert rule" });
  }
});
observabilityRouter.post("/alerts/test", async (req, res) => {
  try {
    const { ruleId } = req.body;
    if (!ruleId) {
      return res.status(400).json({ error: "ruleId is required" });
    }
    const result = await alertService.testAlert(ruleId);
    return res.json(result);
  } catch (error) {
    log.error("Observability", "Alert test failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to test alert" });
  }
});
observabilityRouter.get("/alerts/events", async (req, res) => {
  try {
    const { limit: limitStr = "50" } = req.query;
    const limit4 = Math.min(parseInt(limitStr, 10) || 50, 200);
    const events = await alertService.getRecentEvents(limit4);
    return res.json({ events });
  } catch (error) {
    log.error("Observability", "Alert events fetch failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to fetch alert events" });
  }
});
observabilityRouter.post("/alerts/evaluate", async (req, res) => {
  try {
    const result = await alertService.evaluateRules();
    return res.json(result);
  } catch (error) {
    log.error("Observability", "Alert evaluation failed", { error: String(error) });
    return res.status(500).json({ error: "Failed to evaluate alerts" });
  }
});

// server/routes/debate.ts
import { Router as Router4 } from "express";

// server/ai/debateArena.ts
init_storage();
init_llmGateway();

// server/ai/toolRouter.ts
init_storage();
init_logger();
init_alpaca();
import { z as z4 } from "zod";
var toolRegistry = /* @__PURE__ */ new Map();
function registerTool(tool) {
  if (toolRegistry.has(tool.name)) {
    log.warn("ToolRouter", `Tool already registered: ${tool.name}, overwriting`);
  }
  toolRegistry.set(tool.name, tool);
  log.debug("ToolRouter", `Registered tool: ${tool.name}`, { category: tool.category });
}
function listTools() {
  return Array.from(toolRegistry.values());
}
function listToolsByCategory(category) {
  return Array.from(toolRegistry.values()).filter((t) => t.category === category);
}
function getToolSchemas() {
  return Array.from(toolRegistry.values()).map((t) => ({
    name: t.name,
    description: t.description,
    inputSchema: t.inputSchema instanceof z4.ZodObject ? t.inputSchema.shape : {}
  }));
}
async function invokeTool(toolName, params, context) {
  const startTime = Date.now();
  const tool = toolRegistry.get(toolName);
  if (!tool) {
    log.error("ToolRouter", `Tool not found: ${toolName}`, { traceId: context.traceId });
    return {
      success: false,
      error: `Tool not found: ${toolName}`,
      latencyMs: Date.now() - startTime,
      cacheHit: false,
      invocationId: ""
    };
  }
  const invocation = await storage.createToolInvocation({
    traceId: context.traceId,
    toolName,
    category: tool.category,
    inputParams: params,
    status: "pending",
    callerRole: context.callerRole,
    debateSessionId: context.debateSessionId
  });
  try {
    const parseResult = tool.inputSchema.safeParse(params);
    if (!parseResult.success) {
      const errorMsg = `Invalid input: ${parseResult.error.message}`;
      await storage.updateToolInvocation(invocation.id, {
        status: "error",
        errorMessage: errorMsg,
        latencyMs: Date.now() - startTime
      });
      return {
        success: false,
        error: errorMsg,
        latencyMs: Date.now() - startTime,
        cacheHit: false,
        invocationId: invocation.id
      };
    }
    const result = await tool.execute(parseResult.data, context);
    const latencyMs = Date.now() - startTime;
    await storage.updateToolInvocation(invocation.id, {
      status: "success",
      outputResult: result,
      latencyMs
    });
    log.debug("ToolRouter", `Tool invoked: ${toolName}`, {
      traceId: context.traceId,
      latencyMs
    });
    return {
      success: true,
      result,
      latencyMs,
      cacheHit: false,
      invocationId: invocation.id
    };
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : String(error);
    const latencyMs = Date.now() - startTime;
    await storage.updateToolInvocation(invocation.id, {
      status: "error",
      errorMessage: errorMsg,
      latencyMs
    });
    log.error("ToolRouter", `Tool execution failed: ${toolName}`, {
      traceId: context.traceId,
      error: errorMsg
    });
    return {
      success: false,
      error: errorMsg,
      latencyMs,
      cacheHit: false,
      invocationId: invocation.id
    };
  }
}
registerTool({
  name: "getQuote",
  description: "Get real-time quote for a symbol from Alpaca",
  category: "market_data",
  inputSchema: z4.object({
    symbol: z4.string().describe("Stock or crypto symbol")
  }),
  cacheable: true,
  cacheTtlMs: 5e3,
  execute: async (params) => {
    const { symbol } = params;
    const snapshots = await alpaca.getSnapshots([symbol]);
    const snapshot = snapshots[symbol];
    if (!snapshot) throw new Error(`No quote data for ${symbol}`);
    return {
      symbol,
      price: snapshot.latestTrade?.p || snapshot.dailyBar?.c,
      bid: snapshot.latestQuote?.bp,
      ask: snapshot.latestQuote?.ap,
      volume: snapshot.dailyBar?.v,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
});
registerTool({
  name: "getBars",
  description: "Get historical price bars for a symbol",
  category: "market_data",
  inputSchema: z4.object({
    symbol: z4.string(),
    timeframe: z4.enum(["1Min", "5Min", "15Min", "1Hour", "1Day"]).default("1Day"),
    limit: z4.number().min(1).max(100).default(20)
  }),
  cacheable: true,
  cacheTtlMs: 6e4,
  execute: async (params) => {
    const { symbol, timeframe, limit: limit4 } = params;
    const barsResponse = await alpaca.getBars([symbol], timeframe, void 0, void 0, limit4);
    const bars = barsResponse.bars[symbol] || [];
    return bars.map((b) => ({
      timestamp: b.t,
      open: b.o,
      high: b.h,
      low: b.l,
      close: b.c,
      volume: b.v
    }));
  }
});
registerTool({
  name: "listPositions",
  description: "Get all open positions from Alpaca",
  category: "broker",
  inputSchema: z4.object({}),
  execute: async () => {
    const positions2 = await alpaca.getPositions();
    return positions2.map((p) => ({
      symbol: p.symbol,
      qty: parseFloat(p.qty),
      marketValue: parseFloat(p.market_value),
      avgEntryPrice: parseFloat(p.avg_entry_price),
      unrealizedPnl: parseFloat(p.unrealized_pl),
      side: p.side
    }));
  }
});
registerTool({
  name: "getAccount",
  description: "Get Alpaca account information",
  category: "broker",
  inputSchema: z4.object({}),
  execute: async () => {
    const account = await alpaca.getAccount();
    return {
      id: account.id,
      status: account.status,
      buyingPower: parseFloat(account.buying_power),
      cash: parseFloat(account.cash),
      portfolioValue: parseFloat(account.portfolio_value),
      equity: parseFloat(account.equity),
      daytradeCount: account.daytrade_count,
      patternDayTrader: account.pattern_day_trader
    };
  }
});
registerTool({
  name: "listOrders",
  description: "Get orders from Alpaca",
  category: "broker",
  inputSchema: z4.object({
    status: z4.enum(["open", "closed", "all"]).default("open"),
    limit: z4.number().min(1).max(100).default(50)
  }),
  execute: async (params) => {
    const { status, limit: limit4 } = params;
    const orders2 = await alpaca.getOrders(status, limit4);
    return orders2.map((o) => ({
      id: o.id,
      clientOrderId: o.client_order_id,
      symbol: o.symbol,
      side: o.side,
      type: o.type,
      qty: o.qty,
      status: o.status,
      submittedAt: o.submitted_at,
      filledQty: o.filled_qty,
      filledAvgPrice: o.filled_avg_price ?? void 0
    }));
  }
});
registerTool({
  name: "getMarketClock",
  description: "Get market open/close times",
  category: "market_data",
  inputSchema: z4.object({}),
  cacheable: true,
  cacheTtlMs: 6e4,
  execute: async () => {
    const clock = await alpaca.getClock();
    return {
      isOpen: clock.is_open,
      nextOpen: clock.next_open,
      nextClose: clock.next_close,
      timestamp: clock.timestamp
    };
  }
});

// server/ai/debateArena.ts
init_logger();
var DEFAULT_ROLES = ["bull", "bear", "risk_manager", "technical_analyst", "fundamental_analyst"];
var ROLE_PROMPTS = {
  bull: `You are the BULL analyst. Your job is to find reasons WHY this trade could succeed.
Focus on: upside catalysts, momentum signals, positive news, growth indicators.
Be optimistic but data-driven. Cite specific evidence.`,
  bear: `You are the BEAR analyst. Your job is to find reasons WHY this trade could fail.
Focus on: downside risks, headwinds, negative news, valuation concerns.
Be skeptical but fair. Cite specific evidence.`,
  risk_manager: `You are the RISK MANAGER. Your job is to assess position sizing and risk controls.
Focus on: max drawdown, stop-loss levels, portfolio concentration, correlation risks.
Recommend specific risk parameters. Be conservative.`,
  technical_analyst: `You are the TECHNICAL ANALYST. Your job is to analyze price action and indicators.
Focus on: support/resistance, trend strength, RSI/MACD signals, volume patterns.
Provide specific entry/exit levels based on technicals.`,
  fundamental_analyst: `You are the FUNDAMENTAL ANALYST. Your job is to analyze company/asset fundamentals.
Focus on: valuation metrics, earnings, growth rates, competitive position.
Assess intrinsic value vs current price.`,
  judge: `You are the JUDGE. Your job is to synthesize all analyst opinions into a final decision.
Weigh each analyst's arguments and confidence levels.
Make a clear BUY/SELL/HOLD decision with risk parameters.
If there's strong dissent, explain why you overruled it.`
};
var ROLE_OUTPUT_SCHEMA = {
  type: "object",
  properties: {
    stance: { type: "string", enum: ["bullish", "bearish", "neutral", "abstain"] },
    confidence: { type: "number", minimum: 0, maximum: 1 },
    keySignals: { type: "array", items: { type: "string" } },
    risks: { type: "array", items: { type: "string" } },
    invalidationPoints: { type: "array", items: { type: "string" } },
    proposedAction: { type: "string", enum: ["buy", "sell", "hold", "scale_in", "scale_out"] },
    proposedOrder: {
      type: "object",
      properties: {
        side: { type: "string", enum: ["buy", "sell"] },
        qty: { type: "number" },
        notional: { type: "number" },
        type: { type: "string", enum: ["market", "limit"] },
        limitPrice: { type: "number" }
      }
    },
    evidenceRefs: { type: "array", items: { type: "string" } },
    rationale: { type: "string" }
  },
  required: ["stance", "confidence", "keySignals", "risks", "proposedAction", "rationale"]
};
async function gatherMarketContext(symbols, traceId) {
  const context = {};
  for (const symbol of symbols) {
    try {
      const quoteResult = await invokeTool("getQuote", { symbol }, { traceId });
      if (quoteResult.success) {
        context[`${symbol}_quote`] = quoteResult.result;
      }
      const barsResult = await invokeTool("getBars", { symbol, timeframe: "1Day", limit: 10 }, { traceId });
      if (barsResult.success) {
        context[`${symbol}_bars`] = barsResult.result;
      }
    } catch (e) {
      log.warn("DebateArena", `Failed to gather data for ${symbol}`, { error: e.message });
    }
  }
  try {
    const accountResult = await invokeTool("getAccount", {}, { traceId });
    if (accountResult.success) {
      context.account = accountResult.result;
    }
    const positionsResult = await invokeTool("listPositions", {}, { traceId });
    if (positionsResult.success) {
      context.positions = positionsResult.result;
    }
    const clockResult = await invokeTool("getMarketClock", {}, { traceId });
    if (clockResult.success) {
      context.marketClock = clockResult.result;
    }
  } catch (e) {
    log.warn("DebateArena", `Failed to gather account data`, { error: e.message });
  }
  return context;
}
async function runRole(role, symbols, marketContext, priorMessages, session, config) {
  const priorContext = priorMessages.map(
    (m) => `[${m.role.toUpperCase()}] Stance: ${m.stance}, Confidence: ${m.confidence}, Action: ${m.proposedAction}
Rationale: ${m.rawOutput?.slice(0, 500) || "N/A"}`
  ).join("\n\n");
  const systemPrompt = `${ROLE_PROMPTS[role]}

You are analyzing: ${symbols.join(", ")}

Your response MUST be valid JSON matching this schema:
${JSON.stringify(ROLE_OUTPUT_SCHEMA, null, 2)}

Market Context:
${JSON.stringify(marketContext, null, 2)}

${priorMessages.length > 0 ? `
Prior Analyst Opinions:
${priorContext}` : ""}`;
  const startTime = Date.now();
  try {
    const response = await callLLM({
      role: role === "judge" ? "execution_planner" : "technical_analyst",
      criticality: "high",
      traceId: session.traceId,
      purpose: `debate_${role}`,
      system: systemPrompt,
      messages: [{ role: "user", content: `Analyze ${symbols.join(", ")} and provide your ${role} perspective.` }],
      responseFormat: { type: "json_object" },
      maxTokens: config.tokenBudgetPerRole || 1500
    });
    const latencyMs = Date.now() - startTime;
    let parsed;
    try {
      parsed = response.json;
    } catch {
      parsed = JSON.parse(response.text || "{}");
    }
    const message = await storage.createDebateMessage({
      sessionId: session.id,
      role,
      stance: parsed.stance,
      confidence: String(parsed.confidence),
      keySignals: parsed.keySignals,
      risks: parsed.risks,
      invalidationPoints: parsed.invalidationPoints,
      proposedAction: parsed.proposedAction,
      proposedOrder: parsed.proposedOrder,
      evidenceRefs: parsed.evidenceRefs,
      rawOutput: parsed.rationale,
      provider: response.provider,
      model: response.model,
      tokensUsed: response.tokensUsed,
      estimatedCost: String(response.estimatedCost),
      latencyMs
    });
    log.info("DebateArena", `Role ${role} completed`, {
      sessionId: session.id,
      stance: parsed.stance,
      confidence: parsed.confidence,
      latencyMs
    });
    return message;
  } catch (error) {
    log.error("DebateArena", `Role ${role} failed`, {
      sessionId: session.id,
      error: error.message
    });
    throw error;
  }
}
async function runJudge(symbols, roleMessages, session) {
  const analysisContext = roleMessages.map((m) => `
[${m.role.toUpperCase()}]
Stance: ${m.stance} (Confidence: ${m.confidence})
Key Signals: ${(m.keySignals || []).join(", ")}
Risks: ${(m.risks || []).join(", ")}
Proposed Action: ${m.proposedAction}
Rationale: ${m.rawOutput || "N/A"}
`).join("\n---\n");
  const systemPrompt = `You are the JUDGE synthesizing analyst opinions for ${symbols.join(", ")}.

Analyst Opinions:
${analysisContext}

Make a final decision. Your response MUST be valid JSON:
{
  "decision": "buy" | "sell" | "hold" | "scale_in" | "scale_out",
  "orderIntent": { "symbol": "...", "side": "buy" | "sell", "qty": number, "type": "market" | "limit" } | null,
  "reasonsSummary": "Concise explanation of the decision",
  "riskChecks": {
    "passedAll": boolean,
    "checks": [{ "name": "...", "passed": boolean, "note": "..." }]
  },
  "confidence": 0.0-1.0,
  "dissent": [{ "role": "...", "reason": "..." }]
}

Include orderIntent ONLY if decision is buy/sell/scale_in/scale_out.
Be decisive. If the risk manager has serious concerns, address them.`;
  const response = await callLLM({
    role: "execution_planner",
    criticality: "high",
    traceId: session.traceId,
    purpose: "debate_judge",
    system: systemPrompt,
    messages: [{ role: "user", content: "Synthesize all analyst opinions and make a final decision." }],
    responseFormat: { type: "json_object" },
    maxTokens: 2e3
  });
  try {
    return response.json;
  } catch {
    return JSON.parse(response.text || "{}");
  }
}
async function startDebate(symbols, traceId, config = {}, triggeredBy, strategyVersionId) {
  const session = await storage.createDebateSession({
    traceId,
    symbols,
    status: "running",
    triggeredBy,
    strategyVersionId,
    config,
    startedAt: /* @__PURE__ */ new Date()
  });
  log.info("DebateArena", `Starting debate session`, {
    sessionId: session.id,
    symbols,
    traceId
  });
  const startTime = Date.now();
  const enabledRoles = config.enabledRoles || DEFAULT_ROLES;
  const roleMessages = [];
  let totalCost = 0;
  try {
    const marketContext = await gatherMarketContext(symbols, traceId);
    await storage.updateDebateSession(session.id, { marketContext });
    for (const role of enabledRoles) {
      const message = await runRole(role, symbols, marketContext, roleMessages, session, config);
      roleMessages.push(message);
      totalCost += parseFloat(message.estimatedCost || "0");
    }
    const consensusOutput = await runJudge(symbols, roleMessages, session);
    let workItemId;
    let brokerOrderId;
    if (consensusOutput.orderIntent && consensusOutput.decision !== "hold") {
      const workItem = await workQueue.enqueue({
        type: "ORDER_SUBMIT",
        symbol: consensusOutput.orderIntent.symbol,
        payload: JSON.stringify({
          symbol: consensusOutput.orderIntent.symbol,
          side: consensusOutput.orderIntent.side,
          qty: consensusOutput.orderIntent.qty,
          notional: consensusOutput.orderIntent.notional,
          type: consensusOutput.orderIntent.type,
          time_in_force: "day",
          debateSessionId: session.id
        }),
        idempotencyKey: `debate-${session.id}-${consensusOutput.orderIntent.symbol}`
      });
      workItemId = workItem.id;
      log.info("DebateArena", `Order enqueued from debate`, {
        sessionId: session.id,
        workItemId,
        symbol: consensusOutput.orderIntent.symbol,
        side: consensusOutput.orderIntent.side
      });
    }
    const consensus = await storage.createDebateConsensus({
      sessionId: session.id,
      decision: consensusOutput.decision,
      orderIntent: consensusOutput.orderIntent,
      reasonsSummary: consensusOutput.reasonsSummary,
      riskChecks: consensusOutput.riskChecks,
      confidence: String(consensusOutput.confidence),
      dissent: consensusOutput.dissent,
      workItemId,
      brokerOrderId
    });
    const durationMs = Date.now() - startTime;
    await storage.updateDebateSession(session.id, {
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs,
      totalCost: String(totalCost)
    });
    log.info("DebateArena", `Debate completed`, {
      sessionId: session.id,
      decision: consensusOutput.decision,
      confidence: consensusOutput.confidence,
      durationMs,
      totalCost
    });
    const updatedSession = await storage.getDebateSession(session.id);
    return { session: updatedSession, consensus };
  } catch (error) {
    await storage.updateDebateSession(session.id, {
      status: "failed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs: Date.now() - startTime
    });
    log.error("DebateArena", `Debate failed`, {
      sessionId: session.id,
      error: error.message
    });
    throw error;
  }
}
async function getDebateDetails(sessionId) {
  const session = await storage.getDebateSession(sessionId);
  if (!session) return null;
  const messages2 = await storage.getDebateMessagesBySession(sessionId);
  const consensus = await storage.getDebateConsensusBySession(sessionId);
  return { session, messages: messages2, consensus };
}
async function listDebateSessions(limit4 = 50) {
  return storage.getDebateSessions(limit4);
}

// server/routes/debate.ts
init_logger();
var router2 = Router4();
router2.post("/sessions", async (req, res) => {
  try {
    const {
      symbols,
      config = {},
      triggeredBy,
      strategyVersionId
    } = req.body;
    if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
      return res.status(400).json({ error: "symbols is required and must be a non-empty array" });
    }
    const traceId = `debate-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    const { session, consensus } = await startDebate(
      symbols,
      traceId,
      config,
      triggeredBy,
      strategyVersionId
    );
    res.json({ session, consensus });
  } catch (error) {
    log.error("DebateAPI", `Failed to start debate: ${error}`);
    res.status(500).json({ error: error.message || "Failed to start debate" });
  }
});
router2.get("/sessions", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const sessions2 = await listDebateSessions(limit4);
    res.json({ sessions: sessions2, limit: limit4 });
  } catch (error) {
    log.error("DebateAPI", `Failed to list debate sessions: ${error}`);
    res.status(500).json({ error: "Failed to list debate sessions" });
  }
});
router2.get("/sessions/:id", async (req, res) => {
  try {
    const details = await getDebateDetails(req.params.id);
    if (!details) {
      return res.status(404).json({ error: "Debate session not found" });
    }
    res.json(details);
  } catch (error) {
    log.error("DebateAPI", `Failed to get debate session: ${error}`);
    res.status(500).json({ error: "Failed to get debate session" });
  }
});
var debate_default = router2;

// server/routes/tools.ts
import { Router as Router5 } from "express";
init_storage();
init_logger();
var router3 = Router5();
router3.get("/", async (req, res) => {
  try {
    const category = req.query.category;
    const tools = category ? listToolsByCategory(category) : listTools();
    res.json({
      tools: tools.map((t) => ({
        name: t.name,
        description: t.description,
        category: t.category,
        dangerous: t.dangerous || false,
        cacheable: t.cacheable || false
      })),
      count: tools.length
    });
  } catch (error) {
    log.error("ToolsAPI", `Failed to list tools: ${error}`);
    return serverError(res, "Failed to list tools");
  }
});
router3.get("/schemas", async (req, res) => {
  try {
    const schemas = getToolSchemas();
    res.json({ schemas });
  } catch (error) {
    log.error("ToolsAPI", `Failed to get tool schemas: ${error}`);
    return serverError(res, "Failed to get tool schemas");
  }
});
router3.post("/invoke", async (req, res) => {
  try {
    const { toolName, params, traceId, callerRole, debateSessionId } = req.body;
    if (!toolName) {
      return badRequest(res, "toolName is required");
    }
    const context = {
      traceId: traceId || `tool-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`,
      callerRole,
      debateSessionId
    };
    const result = await invokeTool(toolName, params || {}, context);
    res.json(result);
  } catch (error) {
    log.error("ToolsAPI", `Failed to invoke tool: ${error}`);
    return serverError(res, error.message || "Failed to invoke tool");
  }
});
router3.get("/invocations", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 100;
    const traceId = req.query.traceId;
    const sessionId = req.query.sessionId;
    let invocations;
    if (traceId) {
      invocations = await storage.getToolInvocationsByTrace(traceId);
    } else if (sessionId) {
      invocations = await storage.getToolInvocationsBySession(sessionId);
    } else {
      invocations = await storage.getRecentToolInvocations(limit4);
    }
    res.json({ invocations, count: invocations.length });
  } catch (error) {
    log.error("ToolsAPI", `Failed to get tool invocations: ${error}`);
    return serverError(res, "Failed to get tool invocations");
  }
});
var tools_default = router3;

// server/routes/competition.ts
init_storage();
init_logger();
import { Router as Router6 } from "express";
var router4 = Router6();
router4.get("/traders", async (req, res) => {
  try {
    const traders = await storage.getTraderProfiles();
    res.json({ traders, count: traders.length });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to list traders: ${error}`);
    res.status(500).json({ error: "Failed to list traders" });
  }
});
router4.post("/traders", async (req, res) => {
  try {
    const { name, description, strategyVersionId, modelProfile, riskPreset, universeFilter } = req.body;
    if (!name) {
      return res.status(400).json({ error: "name is required" });
    }
    const trader = await storage.createTraderProfile({
      name,
      description,
      strategyVersionId,
      modelProfile,
      riskPreset,
      universeFilter,
      status: "active"
    });
    res.json(trader);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to create trader: ${error}`);
    res.status(500).json({ error: error.message || "Failed to create trader" });
  }
});
router4.get("/traders/:id", async (req, res) => {
  try {
    const trader = await storage.getTraderProfile(req.params.id);
    if (!trader) {
      return res.status(404).json({ error: "Trader not found" });
    }
    res.json(trader);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to get trader: ${error}`);
    res.status(500).json({ error: "Failed to get trader" });
  }
});
router4.patch("/traders/:id", async (req, res) => {
  try {
    const trader = await storage.updateTraderProfile(req.params.id, req.body);
    if (!trader) {
      return res.status(404).json({ error: "Trader not found" });
    }
    res.json(trader);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to update trader: ${error}`);
    res.status(500).json({ error: error.message || "Failed to update trader" });
  }
});
router4.get("/runs", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 20;
    const runs = await storage.getCompetitionRuns(limit4);
    res.json({ runs, count: runs.length });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to list competition runs: ${error}`);
    res.status(500).json({ error: "Failed to list competition runs" });
  }
});
router4.post("/runs", async (req, res) => {
  try {
    const { name, mode, traderIds, universeSymbols, config } = req.body;
    if (!name || !mode || !traderIds || !Array.isArray(traderIds) || traderIds.length === 0) {
      return res.status(400).json({ error: "name, mode, and traderIds are required" });
    }
    const validModes = ["paper", "backtest", "simulation"];
    if (!validModes.includes(mode)) {
      return res.status(400).json({ error: `Invalid mode. Must be one of: ${validModes.join(", ")}` });
    }
    const traceId = `competition-${Date.now()}-${crypto.randomUUID().slice(0, 8)}`;
    const run = await storage.createCompetitionRun({
      name,
      mode,
      traceId,
      traderIds,
      universeSymbols,
      config,
      status: "pending"
    });
    res.json(run);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to create competition run: ${error}`);
    res.status(500).json({ error: error.message || "Failed to create competition run" });
  }
});
router4.get("/runs/:id", async (req, res) => {
  try {
    const run = await storage.getCompetitionRun(req.params.id);
    if (!run) {
      return res.status(404).json({ error: "Competition run not found" });
    }
    const scores = await storage.getCompetitionScoresByRun(req.params.id);
    res.json({ run, scores });
  } catch (error) {
    log.error("CompetitionAPI", `Failed to get competition run: ${error}`);
    res.status(500).json({ error: "Failed to get competition run" });
  }
});
router4.patch("/runs/:id", async (req, res) => {
  try {
    const run = await storage.updateCompetitionRun(req.params.id, req.body);
    if (!run) {
      return res.status(404).json({ error: "Competition run not found" });
    }
    res.json(run);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to update competition run: ${error}`);
    res.status(500).json({ error: error.message || "Failed to update competition run" });
  }
});
router4.post("/runs/:id/scores", async (req, res) => {
  try {
    const { traderId, rank, metrics, pnl, pnlPct, sharpe, sortino, maxDrawdown, winRate, totalTrades } = req.body;
    if (!traderId) {
      return res.status(400).json({ error: "traderId is required" });
    }
    const score = await storage.createCompetitionScore({
      runId: req.params.id,
      traderProfileId: traderId,
      rank,
      totalPnl: pnl ? String(pnl) : void 0,
      roi: pnlPct ? String(pnlPct) : void 0,
      sharpe: sharpe ? String(sharpe) : void 0,
      sortino: sortino ? String(sortino) : void 0,
      maxDrawdown: maxDrawdown ? String(maxDrawdown) : void 0,
      winRate: winRate ? String(winRate) : void 0,
      tradeCount: totalTrades,
      details: metrics
    });
    res.json(score);
  } catch (error) {
    log.error("CompetitionAPI", `Failed to create score: ${error}`);
    res.status(500).json({ error: error.message || "Failed to create score" });
  }
});
var competition_default = router4;

// server/routes/strategies.ts
init_storage();
init_logger();
import { Router as Router7 } from "express";
init_sanitization();
var router5 = Router7();
router5.get("/versions", async (req, res) => {
  try {
    const strategyId = req.query.strategyId;
    const limit4 = parseInt(req.query.limit) || 50;
    if (!strategyId) {
      return badRequest(res, "strategyId is required");
    }
    const versions = await storage.getStrategyVersionsByStrategy(strategyId);
    res.json({ versions, count: versions.length });
  } catch (error) {
    log.error("StrategiesAPI", `Failed to list strategy versions: ${error}`);
    return serverError(res, "Failed to list strategy versions");
  }
});
router5.post("/versions", async (req, res) => {
  try {
    const {
      strategyId,
      name,
      spec,
      createdBy,
      universeConfig: universeConfig2,
      signalsConfig,
      riskConfig,
      executionConfig,
      backtestResultId,
      description
    } = req.body;
    if (!strategyId || !name || !spec) {
      return badRequest(res, "strategyId, name, and spec are required");
    }
    const sanitizedName = sanitizeInput(name);
    const sanitizedDescription = description ? sanitizeInput(description) : void 0;
    const version = await storage.getNextVersionNumber(strategyId);
    const strategyVersion = await storage.createStrategyVersion({
      strategyId,
      name: sanitizedName,
      version,
      spec,
      createdBy,
      universeConfig: universeConfig2,
      signalsConfig,
      riskConfig,
      executionConfig,
      backtestResultId,
      description: sanitizedDescription,
      status: "draft"
    });
    res.json(strategyVersion);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to create strategy version: ${error}`);
    return serverError(res, error.message || "Failed to create strategy version");
  }
});
router5.get("/versions/:id", async (req, res) => {
  try {
    const version = await storage.getStrategyVersion(req.params.id);
    if (!version) {
      return notFound(res, "Strategy version not found");
    }
    res.json(version);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to get strategy version: ${error}`);
    return serverError(res, "Failed to get strategy version");
  }
});
router5.patch("/versions/:id", async (req, res) => {
  try {
    const sanitizedBody = sanitizeStrategyInput(req.body);
    const version = await storage.updateStrategyVersion(req.params.id, sanitizedBody);
    if (!version) {
      return notFound(res, "Strategy version not found");
    }
    res.json(version);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to update strategy version: ${error}`);
    return serverError(res, error.message || "Failed to update strategy version");
  }
});
router5.post("/versions/:id/activate", async (req, res) => {
  try {
    const version = await storage.getStrategyVersion(req.params.id);
    if (!version) {
      return notFound(res, "Strategy version not found");
    }
    if (version.strategyId) {
      const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const { backtestRuns: backtestRuns3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
      const { eq: eq28, and: and19, desc: desc20 } = await import("drizzle-orm");
      const successfulBacktests = await db2.select().from(backtestRuns3).where(
        and19(
          eq28(backtestRuns3.strategyId, version.strategyId),
          eq28(backtestRuns3.status, "DONE")
        )
      ).orderBy(desc20(backtestRuns3.createdAt)).limit(1);
      if (successfulBacktests.length === 0) {
        log.warn("StrategiesAPI", `Activation blocked for strategy version ${req.params.id}: No successful backtest found`);
        return validationError(
          res,
          "Strategy must have at least one successful backtest before activation. Please run a backtest and verify results before activating this strategy.",
          {
            strategyId: version.strategyId,
            strategyVersionId: req.params.id
          }
        );
      }
      log.info("StrategiesAPI", `Backtest validation passed for strategy version ${req.params.id}`, {
        strategyId: version.strategyId,
        backtestId: successfulBacktests[0].id,
        backtestDate: successfulBacktests[0].createdAt
      });
    }
    const updatedVersion = await storage.updateStrategyVersion(req.params.id, {
      status: "active",
      activatedAt: /* @__PURE__ */ new Date()
    });
    if (!updatedVersion) {
      return notFound(res, "Strategy version not found");
    }
    res.json(updatedVersion);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to activate strategy version: ${error}`);
    return serverError(res, error.message || "Failed to activate strategy version");
  }
});
router5.post("/versions/:id/archive", async (req, res) => {
  try {
    const version = await storage.updateStrategyVersion(req.params.id, {
      status: "archived"
    });
    if (!version) {
      return res.status(404).json({ error: "Strategy version not found" });
    }
    res.json(version);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to archive strategy version: ${error}`);
    res.status(500).json({ error: error.message || "Failed to archive strategy version" });
  }
});
router5.get("/versions/:strategyId/latest", async (req, res) => {
  try {
    const version = await storage.getLatestStrategyVersion(req.params.strategyId);
    if (!version) {
      return res.status(404).json({ error: "No versions found for this strategy" });
    }
    res.json(version);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to get latest strategy version: ${error}`);
    res.status(500).json({ error: "Failed to get latest strategy version" });
  }
});
router5.get("/:id/performance", async (req, res) => {
  try {
    const strategyId = req.params.id;
    const strategy = await storage.getStrategy(strategyId);
    if (!strategy) {
      return res.status(404).json({ error: "Strategy not found" });
    }
    const { alpacaTradingEngine: alpacaTradingEngine2 } = await Promise.resolve().then(() => (init_alpaca_trading_engine(), alpaca_trading_engine_exports));
    const strategyState = alpacaTradingEngine2.getStrategyState(strategyId);
    const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
    const { trades: trades3 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const { eq: eq28, and: and19, isNotNull: isNotNull2, sql: sql17 } = await import("drizzle-orm");
    const allTrades = await db2.select().from(trades3).where(eq28(trades3.strategyId, strategyId)).orderBy(sql17`${trades3.executedAt} DESC`).limit(1e3);
    const totalTrades = allTrades.length;
    const closingTrades = allTrades.filter((t) => t.pnl !== null && t.pnl !== "0");
    const winningTrades = closingTrades.filter((t) => parseFloat(t.pnl || "0") > 0);
    const losingTrades = closingTrades.filter((t) => parseFloat(t.pnl || "0") < 0);
    const winRate = closingTrades.length > 0 ? winningTrades.length / closingTrades.length * 100 : 0;
    const totalPnl = closingTrades.reduce((sum, t) => {
      return sum + parseFloat(t.pnl || "0");
    }, 0);
    const avgWin = winningTrades.length > 0 ? winningTrades.reduce((sum, t) => sum + parseFloat(t.pnl || "0"), 0) / winningTrades.length : 0;
    const avgLoss = losingTrades.length > 0 ? losingTrades.reduce((sum, t) => sum + parseFloat(t.pnl || "0"), 0) / losingTrades.length : 0;
    const { positions: positions2 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
    const currentPositions = await db2.select().from(positions2).where(eq28(positions2.strategyId, strategyId));
    const unrealizedPnl = currentPositions.reduce((sum, p) => {
      return sum + parseFloat(p.unrealizedPnl || "0");
    }, 0);
    const performance = {
      strategyId,
      strategyName: strategy.name,
      status: strategyState?.isRunning ? "running" : "stopped",
      lastCheck: strategyState?.lastCheck || null,
      lastError: strategyState?.error || null,
      // Real-time metrics
      metrics: {
        totalTrades,
        closingTrades: closingTrades.length,
        openingTrades: totalTrades - closingTrades.length,
        // P&L metrics
        realizedPnl: totalPnl,
        unrealizedPnl,
        totalPnl: totalPnl + unrealizedPnl,
        // Win/Loss metrics
        winningTrades: winningTrades.length,
        losingTrades: losingTrades.length,
        winRate: parseFloat(winRate.toFixed(2)),
        // Average trade metrics
        avgWin: parseFloat(avgWin.toFixed(2)),
        avgLoss: parseFloat(avgLoss.toFixed(2)),
        avgTrade: closingTrades.length > 0 ? parseFloat((totalPnl / closingTrades.length).toFixed(2)) : 0,
        // Profit factor (avg win / abs(avg loss))
        profitFactor: avgLoss !== 0 ? parseFloat((avgWin / Math.abs(avgLoss)).toFixed(2)) : avgWin > 0 ? Infinity : 0
      },
      // Current positions
      positions: currentPositions.map((p) => ({
        id: p.id,
        symbol: p.symbol,
        side: p.side,
        quantity: parseFloat(p.quantity),
        entryPrice: parseFloat(p.entryPrice),
        currentPrice: parseFloat(p.currentPrice || p.entryPrice),
        unrealizedPnl: parseFloat(p.unrealizedPnl || "0"),
        openedAt: p.openedAt
      })),
      // Recent trades (last 10)
      recentTrades: allTrades.slice(0, 10).map((t) => ({
        id: t.id,
        symbol: t.symbol,
        side: t.side,
        quantity: parseFloat(t.quantity),
        price: parseFloat(t.price),
        pnl: t.pnl ? parseFloat(t.pnl) : null,
        status: t.status,
        executedAt: t.executedAt,
        notes: t.notes
      })),
      // Last decision info (if available)
      lastDecision: strategyState?.lastDecision ? {
        action: strategyState.lastDecision.action,
        confidence: strategyState.lastDecision.confidence,
        reasoning: strategyState.lastDecision.reasoning,
        riskLevel: strategyState.lastDecision.riskLevel
      } : null
    };
    res.json(performance);
  } catch (error) {
    log.error("StrategiesAPI", `Failed to get strategy performance: ${error}`);
    res.status(500).json({ error: error.message || "Failed to get strategy performance" });
  }
});
var strategies_default = router5;

// server/routes/arena.ts
import { Router as Router8 } from "express";

// server/ai/arenaCoordinator.ts
init_llmGateway();
init_logger();
init_db();
init_schema();
import { eq as eq21, and as and15, gte as gte7 } from "drizzle-orm";
import { z as z5 } from "zod";
var AgentDecisionOutputSchema = z5.object({
  action: z5.enum(["buy", "sell", "hold", "scale_in", "scale_out"]),
  symbols: z5.array(z5.string()).optional().default([]),
  confidence: z5.number().min(0).max(1),
  stance: z5.enum(["bullish", "bearish", "neutral", "abstain"]),
  rationale: z5.string(),
  keySignals: z5.array(z5.string()).optional().default([]),
  risks: z5.array(z5.string()).optional().default([]),
  proposedOrder: z5.object({
    symbol: z5.string(),
    side: z5.enum(["buy", "sell"]),
    qty: z5.number().optional(),
    notional: z5.number().optional(),
    type: z5.enum(["market", "limit"]),
    limitPrice: z5.number().optional()
  }).optional()
});
var DEFAULT_ESCALATION_POLICY = {
  disagreementThreshold: 0.34,
  minConfidenceThreshold: 0.62,
  highRiskPortfolioDeltaPct: 1.5,
  maxPowerCallsPerDay: 25
};
var ROLE_PROMPTS2 = {
  bull: `You are the BULL analyst. Find reasons WHY this trade could succeed. Focus on: upside catalysts, momentum, positive news, growth. Be optimistic but data-driven.`,
  bear: `You are the BEAR analyst. Find reasons WHY this trade could fail. Focus on: downside risks, headwinds, negative news, valuation concerns. Be skeptical but fair.`,
  risk_manager: `You are the RISK MANAGER. Assess position sizing and risk controls. Focus on: max drawdown, stop-loss levels, concentration, correlation risks. Be conservative.`,
  technical_analyst: `You are the TECHNICAL ANALYST. Analyze price action and indicators. Focus on: support/resistance, trend strength, RSI/MACD, volume. Provide specific levels.`,
  fundamental_analyst: `You are the FUNDAMENTAL ANALYST. Analyze company fundamentals. Focus on: valuation, earnings, growth rates, competitive position. Assess intrinsic value.`,
  judge: `You are the JUDGE. Synthesize all analyst opinions into a final decision. Weigh arguments and confidence levels. Make a clear BUY/SELL/HOLD decision.`
};
var ArenaCoordinator = class {
  escalationPolicy;
  powerCallsToday = 0;
  lastDayReset = /* @__PURE__ */ new Date();
  constructor(policy) {
    this.escalationPolicy = policy || DEFAULT_ESCALATION_POLICY;
  }
  resetDailyCounters() {
    const now = /* @__PURE__ */ new Date();
    if (now.getDate() !== this.lastDayReset.getDate()) {
      this.powerCallsToday = 0;
      this.lastDayReset = now;
    }
  }
  async runArena(config) {
    this.resetDailyCounters();
    const traceId = `arena-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
    const startTime = Date.now();
    log.info("ArenaCoordinator", `Starting arena run`, { traceId, mode: config.mode, symbols: config.symbols });
    const agentProfiles = await this.getActiveAgentProfiles(config.agentProfileIds);
    if (agentProfiles.length === 0) {
      throw new Error("No active agent profiles found for arena run");
    }
    const run = await this.createArenaRun({
      traceId,
      mode: config.mode,
      symbols: config.symbols,
      agentProfileIds: agentProfiles.map((p) => p.id),
      strategyVersionId: config.strategyVersionId,
      triggeredBy: config.triggeredBy,
      status: "running",
      startedAt: /* @__PURE__ */ new Date()
    });
    const marketContext = await this.gatherMarketContext(config.symbols, traceId);
    const cheapAgents = agentProfiles.filter((p) => p.mode === "cheap_first" || p.mode === "always");
    const powerAgents = agentProfiles.filter((p) => p.mode === "escalation_only");
    const allDecisions = [];
    let escalationTriggered = false;
    let escalationReason;
    log.info("ArenaCoordinator", `Running ${cheapAgents.length} cheap agents`, { traceId });
    const cheapDecisions = await Promise.all(
      cheapAgents.map((agent) => this.runAgent(agent, config.symbols, marketContext, run.id, traceId, false))
    );
    allDecisions.push(...cheapDecisions);
    let disagreementRate = this.calculateDisagreementRate(cheapDecisions);
    let avgConfidence = this.calculateAvgConfidence(cheapDecisions);
    const riskVeto = this.checkRiskVeto(cheapDecisions);
    if (this.shouldEscalate(disagreementRate, avgConfidence, riskVeto)) {
      escalationTriggered = true;
      escalationReason = this.getEscalationReason(disagreementRate, avgConfidence, riskVeto);
      log.info("ArenaCoordinator", `Escalation triggered: ${escalationReason}`, { traceId });
      if (powerAgents.length > 0 && this.powerCallsToday < this.escalationPolicy.maxPowerCallsPerDay) {
        log.info("ArenaCoordinator", `Running ${powerAgents.length} power agents`, { traceId });
        const powerDecisions = await Promise.all(
          powerAgents.map((agent) => this.runAgent(agent, config.symbols, marketContext, run.id, traceId, true))
        );
        allDecisions.push(...powerDecisions);
        this.powerCallsToday += powerAgents.length;
        disagreementRate = this.calculateDisagreementRate(allDecisions);
        avgConfidence = this.calculateAvgConfidence(allDecisions);
      } else if (this.powerCallsToday >= this.escalationPolicy.maxPowerCallsPerDay) {
        log.warn("ArenaCoordinator", `Power call limit reached (${this.powerCallsToday}/${this.escalationPolicy.maxPowerCallsPerDay}), using cheap decisions only`, { traceId });
      }
    }
    const consensus = this.computeConsensus(allDecisions, disagreementRate, escalationTriggered, escalationReason);
    const durationMs = Date.now() - startTime;
    const totalCost = allDecisions.reduce((sum, d) => sum + parseFloat(d.costUsd || "0"), 0);
    const totalTokens = allDecisions.reduce((sum, d) => sum + (d.tokensUsed || 0), 0);
    await this.updateArenaRun(run.id, {
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      durationMs,
      totalCostUsd: String(totalCost),
      totalTokensUsed: totalTokens,
      escalationTriggered,
      escalationReason,
      consensusReached: consensus.decision !== "no_trade",
      finalDecision: consensus.decision,
      disagreementRate: String(disagreementRate),
      avgConfidence: String(avgConfidence)
    });
    if (consensus.decision !== "no_trade" && consensus.decision !== "hold" && consensus.orderIntent) {
      const outcomeLink = await this.createOutcomeLink(run.id, consensus, totalCost, traceId);
      log.info("ArenaCoordinator", `Created outcome link: ${outcomeLink.id}`, { traceId });
    }
    log.info("ArenaCoordinator", `Arena run completed`, {
      traceId,
      durationMs,
      decision: consensus.decision,
      confidence: consensus.confidence,
      escalated: escalationTriggered,
      totalCost: totalCost.toFixed(4),
      agentsRun: allDecisions.length
    });
    const updatedRun = await db.query.aiArenaRuns.findFirst({ where: eq21(aiArenaRuns.id, run.id) });
    return {
      run: updatedRun,
      consensus,
      decisions: allDecisions
    };
  }
  async getActiveAgentProfiles(ids) {
    const allProfiles = await db.query.aiAgentProfiles.findMany({
      where: eq21(aiAgentProfiles.status, "active")
    });
    if (ids && ids.length > 0) {
      return allProfiles.filter((p) => ids.includes(p.id));
    }
    return allProfiles;
  }
  async createArenaRun(data) {
    const [run] = await db.insert(aiArenaRuns).values([data]).returning();
    return run;
  }
  async updateArenaRun(id, data) {
    await db.update(aiArenaRuns).set(data).where(eq21(aiArenaRuns.id, id));
  }
  async gatherMarketContext(symbols, traceId) {
    const context = {
      quotes: {},
      bars: {}
    };
    const quotePromises = symbols.map(async (symbol) => {
      try {
        const result = await invokeTool("getQuote", { symbol }, { traceId });
        if (result.success) {
          context.quotes[symbol] = result.result;
        }
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get quote for ${symbol}`, { error: e.message, traceId });
      }
    });
    const barsPromises = symbols.map(async (symbol) => {
      try {
        const result = await invokeTool("getBars", { symbol, timeframe: "1Day", limit: 10 }, { traceId });
        if (result.success) {
          context.bars[symbol] = result.result;
        }
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get bars for ${symbol}`, { error: e.message, traceId });
      }
    });
    const accountPromise = (async () => {
      try {
        const result = await invokeTool("getAccount", {}, { traceId });
        if (result.success) context.account = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get account`, { error: e.message, traceId });
      }
    })();
    const positionsPromise = (async () => {
      try {
        const result = await invokeTool("listPositions", {}, { traceId });
        if (result.success) context.positions = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get positions`, { error: e.message, traceId });
      }
    })();
    const clockPromise = (async () => {
      try {
        const result = await invokeTool("getMarketClock", {}, { traceId });
        if (result.success) context.marketClock = result.result;
      } catch (e) {
        log.warn("ArenaCoordinator", `Failed to get market clock`, { error: e.message, traceId });
      }
    })();
    await Promise.all([...quotePromises, ...barsPromises, accountPromise, positionsPromise, clockPromise]);
    log.info("ArenaCoordinator", `Gathered market context`, {
      traceId,
      quotesCount: Object.keys(context.quotes).length,
      barsCount: Object.keys(context.bars).length,
      hasAccount: !!context.account,
      positionsCount: context.positions?.length || 0
    });
    return context;
  }
  async runAgent(agent, symbols, marketContext, arenaRunId, traceId, isEscalation, retryCount = 0) {
    const MAX_RETRIES = 2;
    const startTime = Date.now();
    const role = agent.role;
    try {
      const contextSummary = this.formatMarketContext(symbols, marketContext);
      const systemPrompt = `${ROLE_PROMPTS2[role] || ROLE_PROMPTS2.bull}

You are analyzing: ${symbols.join(", ")}

CRITICAL: You MUST respond with a valid JSON object containing these exact fields:
- action: one of "buy", "sell", "hold", "scale_in", "scale_out"
- confidence: number between 0 and 1
- stance: one of "bullish", "bearish", "neutral", "abstain"
- rationale: your reasoning (string)
- keySignals: array of key signals supporting your view
- risks: array of risks to consider
- proposedOrder: optional object with {symbol, side, qty?, notional?, type, limitPrice?}

${contextSummary}`;
      const request = {
        role: "technical_analyst",
        criticality: isEscalation ? "high" : "medium",
        purpose: "arena_evaluation",
        traceId,
        system: systemPrompt,
        messages: [
          {
            role: "user",
            content: `Analyze ${symbols.join(", ")} and provide your ${role} perspective. Be specific and data-driven. Return valid JSON only. Do not include any text outside the JSON object.`
          }
        ],
        maxTokens: agent.maxTokens || 2e3,
        temperature: parseFloat(agent.temperature || "0.7"),
        responseFormat: { type: "json_object" }
      };
      const llmResult = await callLLM(request);
      const latencyMs = Date.now() - startTime;
      let output = null;
      let parseError = null;
      try {
        const rawJson = JSON.parse(llmResult.text || "{}");
        const parsed = AgentDecisionOutputSchema.safeParse(rawJson);
        if (parsed.success) {
          output = parsed.data;
        } else {
          parseError = parsed.error.message;
          log.warn("ArenaCoordinator", `Agent output validation failed (attempt ${retryCount + 1})`, { traceId, agentId: agent.id, error: parseError });
        }
      } catch (e) {
        parseError = e.message;
        log.warn("ArenaCoordinator", `Failed to parse agent output JSON (attempt ${retryCount + 1})`, { traceId, agentId: agent.id, error: parseError });
      }
      if (!output && retryCount < MAX_RETRIES) {
        log.info("ArenaCoordinator", `Retrying agent ${agent.name} due to parse failure`, { traceId, retryCount: retryCount + 1 });
        return this.runAgent(agent, symbols, marketContext, arenaRunId, traceId, isEscalation, retryCount + 1);
      }
      if (!output) {
        output = {
          action: "hold",
          symbols,
          confidence: 0.2,
          stance: "abstain",
          rationale: `Parse failed after ${MAX_RETRIES + 1} attempts: ${parseError}`,
          keySignals: [],
          risks: ["Output validation error - max retries exceeded"]
        };
      }
      const decision = {
        arenaRunId,
        agentProfileId: agent.id,
        role: agent.role,
        action: output.action,
        symbols: output.symbols || symbols,
        confidence: String(output.confidence),
        stance: output.stance,
        rationale: output.rationale,
        keySignals: output.keySignals,
        risks: output.risks,
        proposedOrder: output.proposedOrder,
        tokensUsed: llmResult.tokensUsed,
        costUsd: String(llmResult.estimatedCost || 0),
        latencyMs,
        modelUsed: llmResult.model,
        wasEscalation: isEscalation,
        rawOutput: (llmResult.text || "").slice(0, 5e3),
        errorMessage: parseError && retryCount >= MAX_RETRIES ? `Parse failed: ${parseError}` : void 0
      };
      await db.insert(aiArenaAgentDecisions).values([decision]);
      await this.updateAgentStats(agent.id, llmResult.tokensUsed || 0, llmResult.estimatedCost || 0);
      log.info("ArenaCoordinator", `Agent ${agent.name} completed`, {
        traceId,
        action: output.action,
        confidence: output.confidence,
        isEscalation,
        latencyMs,
        retries: retryCount
      });
      return decision;
    } catch (error) {
      if (retryCount < MAX_RETRIES) {
        log.info("ArenaCoordinator", `Retrying agent ${agent.name} due to error`, { traceId, retryCount: retryCount + 1, error: error.message });
        return this.runAgent(agent, symbols, marketContext, arenaRunId, traceId, isEscalation, retryCount + 1);
      }
      const latencyMs = Date.now() - startTime;
      log.error("ArenaCoordinator", `Agent ${agent.name} failed after ${MAX_RETRIES + 1} attempts: ${error.message}`, { traceId });
      const decision = {
        arenaRunId,
        agentProfileId: agent.id,
        role: agent.role,
        action: "hold",
        symbols,
        confidence: "0",
        stance: "abstain",
        rationale: `Agent execution failed after ${MAX_RETRIES + 1} attempts`,
        keySignals: [],
        risks: [error.message],
        latencyMs,
        wasEscalation: isEscalation,
        errorMessage: error.message
      };
      await db.insert(aiArenaAgentDecisions).values([decision]);
      return decision;
    }
  }
  formatMarketContext(symbols, context) {
    let summary = "=== MARKET CONTEXT ===\n\n";
    if (context.marketClock) {
      summary += `Market Clock: ${JSON.stringify(context.marketClock)}

`;
    }
    if (context.account) {
      const acc = context.account;
      summary += `Account: Buying Power=$${acc.buying_power || "N/A"}, Equity=$${acc.equity || "N/A"}

`;
    }
    for (const symbol of symbols) {
      summary += `--- ${symbol} ---
`;
      if (context.quotes[symbol]) {
        const q = context.quotes[symbol];
        summary += `Quote: Bid=$${q.bid_price || "N/A"}, Ask=$${q.ask_price || "N/A"}, Last=$${q.last_price || q.price || "N/A"}
`;
      }
      if (context.bars[symbol]) {
        const bars = context.bars[symbol];
        if (Array.isArray(bars) && bars.length > 0) {
          summary += `Recent bars: ${bars.length} days of data
`;
          const latest = bars[bars.length - 1];
          summary += `Latest: O=${latest.o || latest.open}, H=${latest.h || latest.high}, L=${latest.l || latest.low}, C=${latest.c || latest.close}, V=${latest.v || latest.volume}
`;
        }
      }
      summary += "\n";
    }
    if (context.positions && context.positions.length > 0) {
      summary += "=== CURRENT POSITIONS ===\n";
      for (const pos of context.positions) {
        const p = pos;
        summary += `${p.symbol}: ${p.qty} shares @ $${p.avg_entry_price}, P&L=$${p.unrealized_pl}
`;
      }
    }
    return summary.slice(0, 6e3);
  }
  async updateAgentStats(agentId, tokens, cost) {
    const agent = await db.query.aiAgentProfiles.findFirst({ where: eq21(aiAgentProfiles.id, agentId) });
    if (!agent) return;
    await db.update(aiAgentProfiles).set({
      totalCalls: agent.totalCalls + 1,
      totalTokens: agent.totalTokens + tokens,
      totalCostUsd: String(parseFloat(agent.totalCostUsd) + cost),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq21(aiAgentProfiles.id, agentId));
  }
  calculateDisagreementRate(decisions) {
    if (decisions.length < 2) return 0;
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length < 2) return 0;
    const actions = validDecisions.map((d) => d.action);
    const unique2 = new Set(actions);
    return (unique2.size - 1) / Math.max(1, validDecisions.length - 1);
  }
  calculateAvgConfidence(decisions) {
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length === 0) return 0;
    const sum = validDecisions.reduce((acc, d) => acc + parseFloat(d.confidence || "0"), 0);
    return sum / validDecisions.length;
  }
  checkRiskVeto(decisions) {
    const riskManager = decisions.find((d) => d.role === "risk_manager" && !d.errorMessage);
    if (!riskManager) return false;
    const confidence = parseFloat(riskManager.confidence || "0");
    return riskManager.action === "hold" && confidence > 0.8;
  }
  shouldEscalate(disagreement, avgConfidence, riskVeto) {
    if (riskVeto) return true;
    if (disagreement > this.escalationPolicy.disagreementThreshold) return true;
    if (avgConfidence < this.escalationPolicy.minConfidenceThreshold) return true;
    return false;
  }
  getEscalationReason(disagreement, avgConfidence, riskVeto) {
    if (riskVeto) return "Risk manager veto with high confidence";
    if (disagreement > this.escalationPolicy.disagreementThreshold)
      return `Disagreement rate ${(disagreement * 100).toFixed(1)}% > ${this.escalationPolicy.disagreementThreshold * 100}%`;
    if (avgConfidence < this.escalationPolicy.minConfidenceThreshold)
      return `Avg confidence ${(avgConfidence * 100).toFixed(1)}% < ${this.escalationPolicy.minConfidenceThreshold * 100}%`;
    return "Unknown";
  }
  computeConsensus(decisions, disagreementRate, escalationTriggered, escalationReason) {
    const validDecisions = decisions.filter((d) => !d.errorMessage);
    if (validDecisions.length === 0) {
      return {
        decision: "no_trade",
        confidence: 0,
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: false
      };
    }
    const powerDecisions = validDecisions.filter((d) => d.wasEscalation);
    const hasPowerAgents = powerDecisions.length > 0;
    const powerRiskManager = powerDecisions.find((d) => d.role === "risk_manager");
    const cheapRiskManager = validDecisions.find((d) => d.role === "risk_manager" && !d.wasEscalation);
    const powerRiskVeto = powerRiskManager && powerRiskManager.action === "hold" && parseFloat(powerRiskManager.confidence || "0") > 0.8;
    const cheapRiskVeto = cheapRiskManager && cheapRiskManager.action === "hold" && parseFloat(cheapRiskManager.confidence || "0") > 0.8;
    if (powerRiskVeto) {
      return {
        decision: "hold",
        confidence: parseFloat(powerRiskManager.confidence || "0.5"),
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: true,
        riskVetoReason: powerRiskManager.rationale || "Power risk manager vetoed the trade"
      };
    }
    if (cheapRiskVeto && !hasPowerAgents && !escalationTriggered) {
      return {
        decision: "hold",
        confidence: parseFloat(cheapRiskManager.confidence || "0.5"),
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: true,
        riskVetoReason: cheapRiskManager.rationale || "Risk manager vetoed the trade"
      };
    }
    if (cheapRiskVeto && !hasPowerAgents && escalationTriggered) {
      return {
        decision: "no_trade",
        confidence: 0.3,
        disagreementRate,
        escalationTriggered,
        escalationReason: (escalationReason || "") + " (power agents unavailable, deferring decision)",
        riskVeto: false,
        riskVetoReason: "Escalation triggered but power agents unavailable - decision deferred"
      };
    }
    const weightedVotes = {};
    const powerWeight = 1.5;
    const riskManagerDiscount = cheapRiskVeto && hasPowerAgents ? 0.3 : 1;
    for (const d of validDecisions) {
      const action = d.action;
      const confidence = parseFloat(d.confidence || "0");
      let weight = d.wasEscalation ? powerWeight : 1;
      if (d.role === "risk_manager" && !d.wasEscalation && cheapRiskVeto && hasPowerAgents) {
        weight *= riskManagerDiscount;
      }
      if (!weightedVotes[action]) {
        weightedVotes[action] = { score: 0, confidenceSum: 0, count: 0 };
      }
      weightedVotes[action].score += weight * (1 + confidence * 0.5);
      weightedVotes[action].confidenceSum += confidence;
      weightedVotes[action].count++;
    }
    let bestAction = "hold";
    let bestScore = 0;
    for (const [action, stats] of Object.entries(weightedVotes)) {
      if (stats.score > bestScore) {
        bestScore = stats.score;
        bestAction = action;
      }
    }
    const avgConfidence = this.calculateAvgConfidence(validDecisions);
    if (avgConfidence < 0.4 || disagreementRate > 0.7) {
      return {
        decision: "no_trade",
        confidence: avgConfidence,
        disagreementRate,
        escalationTriggered,
        escalationReason,
        riskVeto: false
      };
    }
    const orderDecision = validDecisions.find(
      (d) => d.action === bestAction && d.proposedOrder
    );
    const orderIntent = orderDecision?.proposedOrder;
    return {
      decision: bestAction,
      symbol: orderIntent?.symbol,
      confidence: avgConfidence,
      orderIntent,
      disagreementRate,
      escalationTriggered,
      escalationReason,
      riskVeto: false
    };
  }
  async createOutcomeLink(arenaRunId, consensus, llmCost, traceId) {
    if (!consensus.orderIntent) {
      throw new Error("No order intent in consensus");
    }
    const link = {
      symbol: consensus.orderIntent.symbol,
      side: consensus.orderIntent.side,
      intendedQty: consensus.orderIntent.qty ? String(consensus.orderIntent.qty) : void 0,
      intendedNotional: consensus.orderIntent.notional ? String(consensus.orderIntent.notional) : void 0,
      status: "pending",
      llmCostUsd: String(llmCost),
      traceId
    };
    const [inserted] = await db.insert(aiOutcomeLinks).values([link]).returning();
    await db.update(aiArenaRuns).set({ outcomeLinked: true }).where(eq21(aiArenaRuns.id, arenaRunId));
    return { id: inserted.id };
  }
  async getLeaderboard(windowDays = 30) {
    const agents = await db.query.aiAgentProfiles.findMany({
      where: eq21(aiAgentProfiles.status, "active")
    });
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - windowDays);
    const leaderboard = await Promise.all(
      agents.map(async (agent) => {
        const decisions = await db.query.aiArenaAgentDecisions.findMany({
          where: and15(
            eq21(aiArenaAgentDecisions.agentProfileId, agent.id),
            gte7(aiArenaAgentDecisions.createdAt, cutoffDate)
          )
        });
        const avgConfidence = decisions.length > 0 ? decisions.reduce((sum, d) => sum + parseFloat(d.confidence || "0"), 0) / decisions.length : 0;
        const avgLatency = decisions.length > 0 ? decisions.reduce((sum, d) => sum + (d.latencyMs || 0), 0) / decisions.length : 0;
        const successfulDecisions = decisions.filter((d) => !d.errorMessage);
        return {
          agentId: agent.id,
          agentName: agent.name,
          role: agent.role,
          totalRuns: decisions.length,
          avgConfidence,
          totalCost: parseFloat(agent.totalCostUsd),
          avgLatency,
          successRate: decisions.length > 0 ? successfulDecisions.length / decisions.length : 1
        };
      })
    );
    return leaderboard.sort((a, b) => b.totalRuns - a.totalRuns);
  }
};
var arenaCoordinator = new ArenaCoordinator();

// server/routes/arena.ts
init_db();
init_schema();
init_logger();
import { eq as eq22, desc as desc16, and as and16, gte as gte8, sql as sql13 } from "drizzle-orm";
var router6 = Router8();
router6.post("/run", async (req, res) => {
  try {
    const { symbols, mode = "debate", agentProfileIds, triggeredBy, strategyVersionId } = req.body;
    if (!symbols || !Array.isArray(symbols) || symbols.length === 0) {
      return badRequest(res, "symbols is required and must be a non-empty array");
    }
    const config = {
      mode,
      symbols,
      agentProfileIds,
      triggeredBy: triggeredBy || "admin_manual",
      strategyVersionId
    };
    const result = await arenaCoordinator.runArena(config);
    res.json({
      success: true,
      run: result.run,
      consensus: result.consensus,
      decisionsCount: result.decisions.length
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to run arena: ${error}`);
    return serverError(res, error.message || "Failed to run arena");
  }
});
router6.get("/runs", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const cursor = req.query.cursor;
    let whereClause = void 0;
    if (cursor) {
      whereClause = gte8(aiArenaRuns.createdAt, new Date(cursor));
    }
    const runs = await db.query.aiArenaRuns.findMany({
      where: whereClause,
      orderBy: [desc16(aiArenaRuns.createdAt)],
      limit: limit4
    });
    const costToday = await db.select({ total: sql13`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0))));
    res.json({
      runs,
      count: runs.length,
      costToday: parseFloat(costToday[0]?.total || "0"),
      nextCursor: runs.length === limit4 ? runs[runs.length - 1]?.createdAt?.toISOString() : null
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to list arena runs: ${error}`);
    return serverError(res, "Failed to list arena runs");
  }
});
router6.get("/runs/:id", async (req, res) => {
  try {
    const run = await db.query.aiArenaRuns.findFirst({
      where: eq22(aiArenaRuns.id, req.params.id)
    });
    if (!run) {
      return notFound(res, "Arena run not found");
    }
    const decisions = await db.query.aiArenaAgentDecisions.findMany({
      where: eq22(aiArenaAgentDecisions.arenaRunId, req.params.id),
      orderBy: [desc16(aiArenaAgentDecisions.createdAt)]
    });
    const agentIds = [...new Set(decisions.map((d) => d.agentProfileId))];
    const agents = await db.query.aiAgentProfiles.findMany();
    const agentMap = new Map(agents.map((a) => [a.id, a]));
    const decisionsWithAgents = decisions.map((d) => ({
      ...d,
      agent: agentMap.get(d.agentProfileId)
    }));
    const outcomeLinks = await db.query.aiOutcomeLinks.findMany({
      where: eq22(aiOutcomeLinks.traceId, run.traceId)
    });
    res.json({
      run,
      decisions: decisionsWithAgents,
      outcomeLinks,
      costBreakdown: {
        total: parseFloat(run.totalCostUsd || "0"),
        byAgent: decisionsWithAgents.map((d) => ({
          agent: d.agent?.name || "Unknown",
          cost: parseFloat(d.costUsd || "0"),
          tokens: d.tokensUsed || 0,
          latencyMs: d.latencyMs || 0
        }))
      }
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get arena run: ${error}`);
    res.status(500).json({ error: "Failed to get arena run" });
  }
});
router6.get("/leaderboard", async (req, res) => {
  try {
    const window = req.query.window || "30d";
    const days = parseInt(window.replace("d", "")) || 30;
    const leaderboard = await arenaCoordinator.getLeaderboard(days);
    res.json({
      window: `${days}d`,
      leaderboard,
      generatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get leaderboard: ${error}`);
    res.status(500).json({ error: "Failed to get leaderboard" });
  }
});
router6.get("/profiles", async (req, res) => {
  try {
    const profiles = await db.query.aiAgentProfiles.findMany({
      orderBy: [desc16(aiAgentProfiles.createdAt)]
    });
    res.json({ profiles, count: profiles.length });
  } catch (error) {
    log.error("ArenaAPI", `Failed to list agent profiles: ${error}`);
    res.status(500).json({ error: "Failed to list agent profiles" });
  }
});
router6.post("/profiles", async (req, res) => {
  try {
    const {
      name,
      description,
      provider,
      model,
      role,
      mode = "cheap_first",
      temperature = 0.7,
      maxTokens = 2e3,
      budgetLimitPerDay,
      budgetLimitPerRun,
      priority = 0
    } = req.body;
    if (!name || !provider || !model || !role) {
      return res.status(400).json({ error: "name, provider, model, and role are required" });
    }
    const validProviders = ["openai", "openrouter", "groq", "together"];
    if (!validProviders.includes(provider)) {
      return res.status(400).json({ error: `Invalid provider. Must be one of: ${validProviders.join(", ")}` });
    }
    const validModes = ["cheap_first", "escalation_only", "always"];
    if (!validModes.includes(mode)) {
      return res.status(400).json({ error: `Invalid mode. Must be one of: ${validModes.join(", ")}` });
    }
    const [profile] = await db.insert(aiAgentProfiles).values({
      name,
      description,
      provider,
      model,
      role,
      mode,
      temperature: String(temperature),
      maxTokens,
      budgetLimitPerDay: budgetLimitPerDay ? String(budgetLimitPerDay) : null,
      budgetLimitPerRun: budgetLimitPerRun ? String(budgetLimitPerRun) : null,
      priority,
      status: "active"
    }).returning();
    res.json(profile);
  } catch (error) {
    log.error("ArenaAPI", `Failed to create agent profile: ${error}`);
    res.status(500).json({ error: error.message || "Failed to create agent profile" });
  }
});
router6.get("/profiles/:id", async (req, res) => {
  try {
    const profile = await db.query.aiAgentProfiles.findFirst({
      where: eq22(aiAgentProfiles.id, req.params.id)
    });
    if (!profile) {
      return res.status(404).json({ error: "Agent profile not found" });
    }
    res.json(profile);
  } catch (error) {
    log.error("ArenaAPI", `Failed to get agent profile: ${error}`);
    res.status(500).json({ error: "Failed to get agent profile" });
  }
});
router6.patch("/profiles/:id", async (req, res) => {
  try {
    const { status, description, model, mode, temperature, maxTokens, budgetLimitPerDay, priority } = req.body;
    const updates = { updatedAt: /* @__PURE__ */ new Date() };
    if (status !== void 0) updates.status = status;
    if (description !== void 0) updates.description = description;
    if (model !== void 0) updates.model = model;
    if (mode !== void 0) updates.mode = mode;
    if (temperature !== void 0) updates.temperature = String(temperature);
    if (maxTokens !== void 0) updates.maxTokens = maxTokens;
    if (budgetLimitPerDay !== void 0) updates.budgetLimitPerDay = String(budgetLimitPerDay);
    if (priority !== void 0) updates.priority = priority;
    const [updated] = await db.update(aiAgentProfiles).set(updates).where(eq22(aiAgentProfiles.id, req.params.id)).returning();
    if (!updated) {
      return res.status(404).json({ error: "Agent profile not found" });
    }
    res.json(updated);
  } catch (error) {
    log.error("ArenaAPI", `Failed to update agent profile: ${error}`);
    res.status(500).json({ error: error.message || "Failed to update agent profile" });
  }
});
router6.delete("/profiles/:id", async (req, res) => {
  try {
    const [deleted] = await db.update(aiAgentProfiles).set({ status: "disabled", updatedAt: /* @__PURE__ */ new Date() }).where(eq22(aiAgentProfiles.id, req.params.id)).returning();
    if (!deleted) {
      return res.status(404).json({ error: "Agent profile not found" });
    }
    res.json({ success: true, message: "Agent profile disabled" });
  } catch (error) {
    log.error("ArenaAPI", `Failed to delete agent profile: ${error}`);
    res.status(500).json({ error: "Failed to delete agent profile" });
  }
});
router6.get("/stats", async (req, res) => {
  try {
    const today = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3);
    const [runsToday] = await db.select({ count: sql13`COUNT(*)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, today));
    const [costToday] = await db.select({ total: sql13`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, today));
    const [costWeek] = await db.select({ total: sql13`COALESCE(SUM(total_cost_usd::numeric), 0)` }).from(aiArenaRuns).where(gte8(aiArenaRuns.createdAt, weekAgo));
    const [escalationsToday] = await db.select({ count: sql13`COUNT(*)` }).from(aiArenaRuns).where(and16(gte8(aiArenaRuns.createdAt, today), eq22(aiArenaRuns.escalationTriggered, true)));
    const [activeProfiles] = await db.select({ count: sql13`COUNT(*)` }).from(aiAgentProfiles).where(eq22(aiAgentProfiles.status, "active"));
    res.json({
      runsToday: runsToday?.count || 0,
      costToday: parseFloat(costToday?.total || "0"),
      costWeek: parseFloat(costWeek?.total || "0"),
      escalationsToday: escalationsToday?.count || 0,
      activeProfiles: activeProfiles?.count || 0
    });
  } catch (error) {
    log.error("ArenaAPI", `Failed to get arena stats: ${error}`);
    res.status(500).json({ error: "Failed to get arena stats" });
  }
});
var arena_default = router6;

// server/routes/jina.ts
import { Router as Router9 } from "express";

// server/connectors/jina.ts
init_connectorClient();
init_logger();
var JINA_EMBEDDINGS_URL = "https://api.jina.ai/v1/embeddings";
var JINA_READER_URL = "https://r.jina.ai";
var JINA_SEARCH_URL = "https://s.jina.ai";
var JINA_RERANK_URL = "https://api.jina.ai/v1/rerank";
function getApiKey() {
  const key = process.env.JINA_API_KEY;
  if (!key) {
    throw new Error("JINA_API_KEY not configured");
  }
  return key;
}
function getAuthHeaders() {
  return {
    Authorization: `Bearer ${getApiKey()}`,
    "Content-Type": "application/json"
  };
}
async function generateEmbeddings(input, options = {}) {
  const { model = "jina-embeddings-v3", task = "retrieval.passage", dimensions } = options;
  const cacheKey = buildCacheKey(
    "jina",
    "embeddings",
    model,
    task,
    dimensions?.toString(),
    typeof input === "string" ? input.slice(0, 100) : `batch-${input.length}`
  );
  const body = {
    input,
    model,
    task,
    normalized: true
  };
  if (dimensions) body.dimensions = dimensions;
  try {
    const result = await connectorFetch(JINA_EMBEDDINGS_URL, {
      provider: "jina",
      endpoint: "embeddings",
      cacheKey,
      headers: getAuthHeaders(),
      method: "POST",
      body,
      customTTLMs: 864e5
    });
    log.info("Jina", `Generated ${result.data.data.length} embeddings (${result.data.usage.total_tokens} tokens)`);
    return result.data;
  } catch (error) {
    log.error("Jina", `Embeddings error: ${error}`);
    throw error;
  }
}
async function readUrl(url) {
  const cacheKey = buildCacheKey("jina", "reader", url);
  const readerUrl = `${JINA_READER_URL}/${encodeURIComponent(url)}`;
  try {
    const result = await connectorFetch(readerUrl, {
      provider: "jina",
      endpoint: "reader",
      cacheKey,
      headers: {
        Authorization: `Bearer ${getApiKey()}`,
        Accept: "application/json",
        "X-Return-Format": "json"
      },
      method: "GET",
      customTTLMs: 36e5
    });
    log.info("Jina", `Read URL: ${url} (${result.data.content?.length || 0} chars)`);
    return result.data;
  } catch (error) {
    log.error("Jina", `Reader error for ${url}: ${error}`);
    throw error;
  }
}
async function search(query, options = {}) {
  const { limit: limit4 = 5 } = options;
  const cacheKey = buildCacheKey("jina", "search", query, limit4.toString());
  const searchUrl = `${JINA_SEARCH_URL}/${encodeURIComponent(query)}`;
  try {
    const result = await connectorFetch(searchUrl, {
      provider: "jina",
      endpoint: "search",
      cacheKey,
      headers: {
        Authorization: `Bearer ${getApiKey()}`,
        Accept: "application/json",
        "X-Return-Format": "json"
      },
      method: "GET",
      customTTLMs: 18e5
    });
    log.info("Jina", `Search: "${query}" returned ${result.data.results?.length || 0} results`);
    return result.data;
  } catch (error) {
    log.error("Jina", `Search error for "${query}": ${error}`);
    throw error;
  }
}
async function rerank(query, documents, options = {}) {
  const { model = "jina-reranker-v2-base-multilingual", top_n = 10 } = options;
  const cacheKey = buildCacheKey("jina", "rerank", query.slice(0, 50), documents.length.toString());
  const body = {
    model,
    query,
    documents,
    top_n: Math.min(top_n, documents.length),
    return_documents: true
  };
  try {
    const result = await connectorFetch(JINA_RERANK_URL, {
      provider: "jina",
      endpoint: "rerank",
      cacheKey,
      headers: getAuthHeaders(),
      method: "POST",
      body,
      customTTLMs: 864e5
    });
    log.info("Jina", `Reranked ${documents.length} docs, top score: ${result.data.results[0]?.relevance_score?.toFixed(3)}`);
    return result.data;
  } catch (error) {
    log.error("Jina", `Rerank error: ${error}`);
    throw error;
  }
}
async function semanticSearch(query, corpus, options = {}) {
  const { topK = 5 } = options;
  const queryEmbedding = await generateEmbeddings(query, { task: "retrieval.query" });
  const queryVector = queryEmbedding.data[0].embedding;
  const corpusTexts = corpus.map((c) => c.text);
  const corpusEmbeddings = await generateEmbeddings(corpusTexts, { task: "retrieval.passage" });
  const similarities = corpus.map((doc, i) => {
    const docVector = corpusEmbeddings.data[i].embedding;
    const score = cosineSimilarity(queryVector, docVector);
    return { id: doc.id, text: doc.text, score };
  });
  similarities.sort((a, b) => b.score - a.score);
  return similarities.slice(0, topK);
}
function cosineSimilarity(a, b) {
  let dotProduct = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0; i < a.length; i++) {
    dotProduct += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }
  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
}
var jina = {
  generateEmbeddings,
  readUrl,
  search,
  rerank,
  semanticSearch
};

// server/routes/jina.ts
init_logger();
var router7 = Router9();
router7.post("/embeddings", async (req, res) => {
  try {
    const { input, model, task, dimensions } = req.body;
    if (!input) {
      return res.status(400).json({ error: "input is required" });
    }
    const result = await jina.generateEmbeddings(input, { model, task, dimensions });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Embeddings error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.get("/read", async (req, res) => {
  try {
    const { url } = req.query;
    if (!url || typeof url !== "string") {
      return res.status(400).json({ error: "url query parameter is required" });
    }
    const normalizedUrl = url.startsWith("http://") || url.startsWith("https://") ? url : `https://${url}`;
    const result = await jina.readUrl(normalizedUrl);
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Reader error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.get("/search", async (req, res) => {
  try {
    const { query, limit: limit4 } = req.query;
    if (!query || typeof query !== "string") {
      return res.status(400).json({ error: "query parameter is required" });
    }
    const result = await jina.search(query, {
      limit: limit4 ? parseInt(limit4, 10) : 5
    });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Search error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.post("/rerank", async (req, res) => {
  try {
    const { query, documents, model, top_n } = req.body;
    if (!query || !documents || !Array.isArray(documents)) {
      return res.status(400).json({ error: "query and documents array are required" });
    }
    const result = await jina.rerank(query, documents, { model, top_n });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Rerank error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.post("/semantic-search", async (req, res) => {
  try {
    const { query, corpus, topK } = req.body;
    if (!query || !corpus || !Array.isArray(corpus)) {
      return res.status(400).json({ error: "query and corpus array are required" });
    }
    if (corpus.length > 100) {
      return res.status(413).json({ error: "corpus exceeds maximum size of 100 documents" });
    }
    if (query.length > 1e4) {
      return res.status(413).json({ error: "query exceeds maximum length of 10000 characters" });
    }
    const result = await jina.semanticSearch(query, corpus, { topK });
    res.json(result);
  } catch (error) {
    log.error("JinaRoutes", `Semantic search error: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router7.get("/health", async (_req, res) => {
  const hasKey = !!process.env.JINA_API_KEY;
  res.json({
    status: hasKey ? "configured" : "missing_api_key",
    provider: "jina",
    capabilities: ["embeddings", "reader", "search", "rerank", "semantic-search"]
  });
});
var jina_default = router7;

// server/routes/macro.ts
init_fred();
import { Router as Router10 } from "express";

// server/services/macro-indicators-service.ts
init_db();
init_schema();
init_fred();
init_logger();
import { eq as eq23 } from "drizzle-orm";
var MacroIndicatorsService = class {
  async refreshAllIndicators() {
    log.info("MacroIndicatorsService", "Starting full macro indicators refresh from FRED");
    const allData = await fred.getAllIndicators();
    let updated = 0;
    let failed = 0;
    const errors = [];
    for (const data of allData) {
      try {
        await this.upsertIndicator(data);
        updated++;
      } catch (error) {
        failed++;
        errors.push(`${data.indicatorId}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
    log.info("MacroIndicatorsService", `Refresh complete: ${updated} updated, ${failed} failed`);
    return { success: failed === 0, updated, failed, errors };
  }
  async refreshCriticalIndicators() {
    log.info("MacroIndicatorsService", "Refreshing critical macro indicators from FRED");
    const criticalData = await fred.getCriticalIndicators();
    let updated = 0;
    for (const data of criticalData) {
      try {
        await this.upsertIndicator(data);
        updated++;
      } catch (error) {
        log.error("MacroIndicatorsService", `Failed to upsert ${data.indicatorId}`, { error });
      }
    }
    return { success: true, updated, data: criticalData };
  }
  async upsertIndicator(data) {
    const existing = await db.select().from(macroIndicators).where(eq23(macroIndicators.indicatorId, data.indicatorId)).limit(1);
    if (existing.length > 0) {
      await db.update(macroIndicators).set({
        latestValue: data.latestValue?.toString() || null,
        previousValue: data.previousValue?.toString() || null,
        changePercent: data.changePercent?.toString() || null,
        lastUpdatedAt: /* @__PURE__ */ new Date(),
        rawJson: data.rawJson
      }).where(eq23(macroIndicators.indicatorId, data.indicatorId));
    } else {
      await db.insert(macroIndicators).values({
        indicatorId: data.indicatorId,
        name: data.name,
        category: data.category,
        latestValue: data.latestValue?.toString() || null,
        previousValue: data.previousValue?.toString() || null,
        changePercent: data.changePercent?.toString() || null,
        frequency: data.frequency,
        lastUpdatedAt: /* @__PURE__ */ new Date(),
        source: "FRED",
        rawJson: data.rawJson
      });
    }
  }
  async getLatestIndicators() {
    return db.select().from(macroIndicators).orderBy(macroIndicators.lastUpdatedAt);
  }
  async getIndicatorsByCategory(category) {
    return db.select().from(macroIndicators).where(eq23(macroIndicators.category, category));
  }
  async getIndicator(indicatorId) {
    const result = await db.select().from(macroIndicators).where(eq23(macroIndicators.indicatorId, indicatorId)).limit(1);
    return result[0] || null;
  }
  async getMacroSummary() {
    const all = await this.getLatestIndicators();
    const byCategory = {
      treasury_yields: 0,
      inflation: 0,
      employment: 0,
      volatility: 0,
      interest_rates: 0,
      money_supply: 0,
      gdp: 0,
      consumer: 0,
      housing: 0,
      manufacturing: 0
    };
    for (const indicator of all) {
      const cat = indicator.category;
      if (cat in byCategory) {
        byCategory[cat]++;
      }
    }
    const criticalAlerts = this.detectAlerts(all);
    return {
      totalIndicators: all.length,
      lastUpdated: all.length > 0 ? all[0].lastUpdatedAt : /* @__PURE__ */ new Date(),
      byCategory,
      criticalAlerts
    };
  }
  detectAlerts(indicators) {
    const alerts = [];
    for (const indicator of indicators) {
      const value = parseFloat(indicator.latestValue || "0");
      if (indicator.indicatorId === "T10Y2Y" && value < 0) {
        alerts.push({
          indicatorId: indicator.indicatorId,
          name: indicator.name,
          type: "yield_curve_inversion",
          severity: "high",
          message: "Yield curve is inverted - potential recession signal",
          value,
          threshold: 0
        });
      }
      if (indicator.indicatorId === "VIXCLS" && value > 30) {
        alerts.push({
          indicatorId: indicator.indicatorId,
          name: indicator.name,
          type: "high_volatility",
          severity: value > 40 ? "high" : "medium",
          message: `VIX at ${value.toFixed(2)} indicates elevated market fear`,
          value,
          threshold: 30
        });
      }
      if (indicator.indicatorId === "CPIAUCSL") {
        const change = parseFloat(indicator.changePercent || "0");
        if (Math.abs(change) > 0.5) {
          alerts.push({
            indicatorId: indicator.indicatorId,
            name: indicator.name,
            type: "inflation_spike",
            severity: Math.abs(change) > 1 ? "high" : "medium",
            message: `CPI changed ${change.toFixed(2)}% - notable inflation movement`,
            value: change,
            threshold: 0.5
          });
        }
      }
      if (indicator.indicatorId === "FEDFUNDS") {
        const change = parseFloat(indicator.changePercent || "0");
        if (Math.abs(change) > 5) {
          alerts.push({
            indicatorId: indicator.indicatorId,
            name: indicator.name,
            type: "rate_change",
            severity: "high",
            message: `Fed Funds rate changed significantly (${change.toFixed(2)}%)`,
            value: change,
            threshold: 5
          });
        }
      }
    }
    return alerts;
  }
  getMarketRegimeFromMacro(indicators) {
    const signals = [];
    let riskOnScore = 0;
    let riskOffScore = 0;
    for (const indicator of indicators) {
      const value = parseFloat(indicator.latestValue || "0");
      if (indicator.indicatorId === "VIXCLS") {
        if (value < 15) {
          riskOnScore += 2;
          signals.push("Low VIX indicates market complacency");
        } else if (value > 25) {
          riskOffScore += 2;
          signals.push("Elevated VIX indicates fear");
        }
      }
      if (indicator.indicatorId === "T10Y2Y") {
        if (value < 0) {
          riskOffScore += 3;
          signals.push("Yield curve inversion - recession warning");
        } else if (value > 1) {
          riskOnScore += 1;
          signals.push("Steep yield curve - healthy growth outlook");
        }
      }
      if (indicator.indicatorId === "UMCSENT") {
        if (value > 80) {
          riskOnScore += 1;
          signals.push("Strong consumer sentiment");
        } else if (value < 60) {
          riskOffScore += 1;
          signals.push("Weak consumer sentiment");
        }
      }
    }
    const totalScore = Math.abs(riskOnScore - riskOffScore);
    const confidence = Math.min(totalScore * 0.15, 1);
    let regime;
    if (riskOnScore > riskOffScore + 2) {
      regime = "risk_on";
    } else if (riskOffScore > riskOnScore + 2) {
      regime = "risk_off";
    } else if (indicators.length < 3) {
      regime = "uncertain";
    } else {
      regime = "neutral";
    }
    return { regime, confidence, signals };
  }
  isConfigured() {
    return fred.isConfigured();
  }
};
var macroIndicatorsService = new MacroIndicatorsService();

// server/routes/macro.ts
init_logger();
var router8 = Router10();
router8.get("/indicators", async (_req, res) => {
  try {
    const indicators = await macroIndicatorsService.getLatestIndicators();
    res.json({ success: true, data: indicators });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get indicators", { error });
    return serverError(res, "Failed to fetch indicators");
  }
});
router8.get("/indicators/:id", async (req, res) => {
  try {
    const indicator = await macroIndicatorsService.getIndicator(req.params.id);
    if (!indicator) {
      return notFound(res, "Indicator not found");
    }
    res.json({ success: true, data: indicator });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get indicator", { error });
    return serverError(res, "Failed to fetch indicator");
  }
});
router8.get("/category/:category", async (req, res) => {
  try {
    const category = req.params.category;
    const validCategories = ["treasury_yields", "inflation", "employment", "volatility", "interest_rates", "money_supply", "gdp", "consumer", "housing", "manufacturing"];
    if (!validCategories.includes(category)) {
      return badRequest(res, "Invalid category");
    }
    const indicators = await macroIndicatorsService.getIndicatorsByCategory(category);
    res.json({ success: true, data: indicators });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get indicators by category", { error });
    return serverError(res, "Failed to fetch indicators");
  }
});
router8.get("/summary", async (_req, res) => {
  try {
    const summary = await macroIndicatorsService.getMacroSummary();
    res.json({ success: true, data: summary });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get summary", { error });
    res.status(500).json({ success: false, error: "Failed to fetch summary" });
  }
});
router8.post("/refresh", async (_req, res) => {
  try {
    const result = await macroIndicatorsService.refreshCriticalIndicators();
    res.json({ success: true, data: result });
  } catch (error) {
    log.error("MacroRoutes", "Failed to refresh indicators", { error });
    res.status(500).json({ success: false, error: "Failed to refresh indicators" });
  }
});
router8.post("/refresh/all", async (_req, res) => {
  try {
    const result = await macroIndicatorsService.refreshAllIndicators();
    res.json({ success: true, data: result });
  } catch (error) {
    log.error("MacroRoutes", "Failed to refresh all indicators", { error });
    res.status(500).json({ success: false, error: "Failed to refresh indicators" });
  }
});
router8.get("/regime", async (_req, res) => {
  try {
    const indicators = await macroIndicatorsService.getLatestIndicators();
    const regime = macroIndicatorsService.getMarketRegimeFromMacro(indicators);
    res.json({ success: true, data: regime });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get market regime", { error });
    res.status(500).json({ success: false, error: "Failed to determine regime" });
  }
});
router8.get("/series", async (_req, res) => {
  try {
    const series = Object.entries(FRED_SERIES).map(([id, config]) => ({
      id,
      name: config.name,
      category: config.category
    }));
    res.json({ success: true, data: series });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get series list", { error });
    res.status(500).json({ success: false, error: "Failed to fetch series" });
  }
});
router8.get("/status", async (_req, res) => {
  try {
    const isConfigured = macroIndicatorsService.isConfigured();
    const indicators = await macroIndicatorsService.getLatestIndicators();
    res.json({
      success: true,
      data: {
        configured: isConfigured,
        hasApiKey: isConfigured,
        cachedIndicators: indicators.length,
        availableSeries: Object.keys(FRED_SERIES).length
      }
    });
  } catch (error) {
    log.error("MacroRoutes", "Failed to get status", { error });
    res.status(500).json({ success: false, error: "Failed to get status" });
  }
});
var macro_default = router8;

// server/routes/enrichment.ts
import { Router as Router11 } from "express";

// server/services/enrichment-scheduler.ts
init_logger();
init_db();
init_schema();
init_finnhub();
init_alpaca();
init_technical_indicators();
import { eq as eq24, sql as sql14 } from "drizzle-orm";
var DEFAULT_CONFIG3 = {
  macroIndicatorsIntervalMs: 4 * 60 * 60 * 1e3,
  fundamentalsIntervalMs: 24 * 60 * 60 * 1e3,
  technicalsIntervalMs: 60 * 60 * 1e3,
  enabled: true
};
var EnrichmentScheduler = class {
  config = DEFAULT_CONFIG3;
  intervals = /* @__PURE__ */ new Map();
  jobStatus = /* @__PURE__ */ new Map();
  isStarted = false;
  constructor() {
    this.initJobStatus();
  }
  initJobStatus() {
    const jobs = ["macro_indicators", "fundamentals", "technicals"];
    for (const job of jobs) {
      this.jobStatus.set(job, {
        name: job,
        lastRun: null,
        lastSuccess: false,
        nextRun: null,
        isRunning: false
      });
    }
  }
  start() {
    if (this.isStarted) {
      log.warn("EnrichmentScheduler", "Scheduler already started");
      return;
    }
    if (!this.config.enabled) {
      log.info("EnrichmentScheduler", "Scheduler disabled by config");
      return;
    }
    log.info("EnrichmentScheduler", "Starting enrichment scheduler", {
      macroIntervalHours: this.config.macroIndicatorsIntervalMs / (60 * 60 * 1e3),
      fundamentalsIntervalHours: this.config.fundamentalsIntervalMs / (60 * 60 * 1e3),
      technicalsIntervalHours: this.config.technicalsIntervalMs / (60 * 60 * 1e3)
    });
    this.scheduleJob(
      "macro_indicators",
      this.config.macroIndicatorsIntervalMs,
      () => this.runMacroIndicatorsJob()
    );
    this.scheduleJob(
      "fundamentals",
      this.config.fundamentalsIntervalMs,
      () => this.runFundamentalsJob()
    );
    this.scheduleJob(
      "technicals",
      this.config.technicalsIntervalMs,
      () => this.runTechnicalsJob()
    );
    this.isStarted = true;
    setTimeout(() => this.runInitialEnrichment(), 3e4);
  }
  async runInitialEnrichment() {
    log.info("EnrichmentScheduler", "Running initial enrichment check");
    const [macroCount] = await db.select({ count: sql14`count(*)` }).from(sql14`macro_indicators`);
    if (Number(macroCount?.count || 0) === 0) {
      log.info("EnrichmentScheduler", "Macro indicators empty, running initial sync");
      this.runMacroIndicatorsJob().catch(
        (e) => log.error("EnrichmentScheduler", "Initial macro sync failed", { error: e })
      );
    }
    const [technicalsCount] = await db.select({ count: sql14`count(*)` }).from(universeTechnicals);
    const [brokerAssetsCount] = await db.select({ count: sql14`count(*)` }).from(brokerAssets).where(eq24(brokerAssets.tradable, true));
    const techCount = Number(technicalsCount?.count || 0);
    const assetCount = Number(brokerAssetsCount?.count || 0);
    const coverageThreshold = Math.min(assetCount, 50) * 0.5;
    if (techCount < coverageThreshold) {
      log.info("EnrichmentScheduler", "Technicals coverage low, running initial sync", {
        currentCount: techCount,
        threshold: coverageThreshold,
        brokerAssets: assetCount
      });
      this.runTechnicalsJob().catch(
        (e) => log.error("EnrichmentScheduler", "Initial technicals sync failed", { error: e })
      );
    }
  }
  stop() {
    log.info("EnrichmentScheduler", "Stopping enrichment scheduler");
    for (const [name, interval] of this.intervals) {
      clearInterval(interval);
      log.info("EnrichmentScheduler", `Stopped job: ${name}`);
    }
    this.intervals.clear();
    this.isStarted = false;
  }
  scheduleJob(name, intervalMs, job) {
    const status = this.jobStatus.get(name);
    if (status) {
      status.nextRun = new Date(Date.now() + intervalMs);
    }
    const interval = setInterval(async () => {
      await this.executeJob(name, job);
    }, intervalMs);
    this.intervals.set(name, interval);
    log.info("EnrichmentScheduler", `Scheduled job: ${name}`, { intervalMs });
  }
  async executeJob(name, job) {
    const status = this.jobStatus.get(name);
    if (!status) return;
    if (status.isRunning) {
      log.warn("EnrichmentScheduler", `Job ${name} already running, skipping`);
      return;
    }
    status.isRunning = true;
    status.lastRun = /* @__PURE__ */ new Date();
    try {
      log.info("EnrichmentScheduler", `Starting job: ${name}`);
      await job();
      status.lastSuccess = true;
      status.lastError = void 0;
      log.info("EnrichmentScheduler", `Completed job: ${name}`);
    } catch (error) {
      status.lastSuccess = false;
      status.lastError = error instanceof Error ? error.message : "Unknown error";
      log.error("EnrichmentScheduler", `Failed job: ${name}`, { error });
    } finally {
      status.isRunning = false;
      const intervalMs = this.getIntervalForJob(name);
      status.nextRun = new Date(Date.now() + intervalMs);
    }
  }
  getIntervalForJob(name) {
    switch (name) {
      case "macro_indicators":
        return this.config.macroIndicatorsIntervalMs;
      case "fundamentals":
        return this.config.fundamentalsIntervalMs;
      case "technicals":
        return this.config.technicalsIntervalMs;
      default:
        return 60 * 60 * 1e3;
    }
  }
  async runMacroIndicatorsJob() {
    const result = await macroIndicatorsService.refreshAllIndicators();
    const status = this.jobStatus.get("macro_indicators");
    if (status) {
      status.itemsProcessed = result.updated;
    }
  }
  async runFundamentalsJob() {
    const result = await fundamentalsService.fetchAndStoreFundamentals({
      batchSize: 10,
      traceId: `enrichment-${Date.now()}`
    });
    const status = this.jobStatus.get("fundamentals");
    if (status) {
      status.itemsProcessed = result.computed;
    }
  }
  async runTechnicalsJob() {
    const assets = await db.select({ symbol: brokerAssets.symbol, assetClass: brokerAssets.assetClass }).from(brokerAssets).where(eq24(brokerAssets.tradable, true)).limit(50);
    let processed = 0;
    const endDate = /* @__PURE__ */ new Date();
    const startDate = new Date(endDate.getTime() - 365 * 24 * 60 * 60 * 1e3);
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    for (const { symbol, assetClass } of assets) {
      try {
        const barsResponse = await alpaca.getBars(
          [symbol],
          "1Day",
          startDate.toISOString().split("T")[0],
          endDate.toISOString().split("T")[0],
          400
        );
        const bars = barsResponse.bars[symbol];
        if (!bars || bars.length < 200) {
          log.warn("EnrichmentScheduler", `Insufficient bars for ${symbol}: ${bars?.length || 0}`);
          continue;
        }
        const ohlcBars = bars.map((b) => ({
          open: b.o,
          high: b.h,
          low: b.l,
          close: b.c,
          volume: b.v
        }));
        const indicators = computeAllIndicators(ohlcBars);
        if (!indicators) {
          continue;
        }
        const lastBar = bars[bars.length - 1];
        const technicalSignals = await finnhub.getTechnicalSignals(symbol).catch(() => ({ adx: null }));
        await db.insert(universeTechnicals).values({
          symbol,
          date: today,
          open: lastBar.o?.toString(),
          high: lastBar.h?.toString(),
          low: lastBar.l?.toString(),
          close: lastBar.c?.toString(),
          volume: lastBar.v?.toString(),
          sma20: indicators.sma20?.toString(),
          sma50: indicators.sma50?.toString(),
          sma200: indicators.sma200?.toString(),
          ema12: indicators.ema12?.toString(),
          ema26: indicators.ema26?.toString(),
          rsi14: indicators.rsi14?.toString(),
          macd: indicators.macd?.toString(),
          macdSignal: indicators.macdSignal?.toString(),
          macdHistogram: indicators.macdHistogram?.toString(),
          atr14: indicators.atr14?.toString(),
          bollingerUpper: indicators.bollingerUpper?.toString(),
          bollingerLower: indicators.bollingerLower?.toString(),
          adx14: technicalSignals.adx?.toString(),
          source: "alpaca+computed",
          lastUpdatedAt: /* @__PURE__ */ new Date()
        }).onConflictDoUpdate({
          target: [universeTechnicals.symbol, universeTechnicals.date],
          set: {
            open: lastBar.o?.toString(),
            high: lastBar.h?.toString(),
            low: lastBar.l?.toString(),
            close: lastBar.c?.toString(),
            volume: lastBar.v?.toString(),
            sma20: indicators.sma20?.toString(),
            sma50: indicators.sma50?.toString(),
            sma200: indicators.sma200?.toString(),
            ema12: indicators.ema12?.toString(),
            ema26: indicators.ema26?.toString(),
            rsi14: indicators.rsi14?.toString(),
            macd: indicators.macd?.toString(),
            macdSignal: indicators.macdSignal?.toString(),
            macdHistogram: indicators.macdHistogram?.toString(),
            atr14: indicators.atr14?.toString(),
            bollingerUpper: indicators.bollingerUpper?.toString(),
            bollingerLower: indicators.bollingerLower?.toString(),
            adx14: technicalSignals.adx?.toString(),
            lastUpdatedAt: /* @__PURE__ */ new Date()
          }
        });
        processed++;
        log.info("EnrichmentScheduler", `Computed technicals for ${symbol}`, {
          rsi14: indicators.rsi14?.toFixed(2),
          sma20: indicators.sma20?.toFixed(2)
        });
      } catch (error) {
        const errorDetails = error instanceof Error ? { message: error.message, name: error.name, stack: error.stack?.split("\n").slice(0, 3).join(" | ") } : { raw: String(error) };
        log.warn("EnrichmentScheduler", `Failed to compute technicals for ${symbol}`, errorDetails);
      }
    }
    const status = this.jobStatus.get("technicals");
    if (status) {
      status.itemsProcessed = processed;
    }
  }
  async runJobManually(jobName) {
    const status = this.jobStatus.get(jobName);
    if (!status) {
      return { success: false, message: `Unknown job: ${jobName}`, statusCode: 400 };
    }
    if (status.isRunning) {
      return { success: false, message: `Job ${jobName} is already running`, statusCode: 409 };
    }
    try {
      switch (jobName) {
        case "macro_indicators":
          await this.executeJob(jobName, () => this.runMacroIndicatorsJob());
          break;
        case "fundamentals":
          await this.executeJob(jobName, () => this.runFundamentalsJob());
          break;
        case "technicals":
          await this.executeJob(jobName, () => this.runTechnicalsJob());
          break;
        default:
          return { success: false, message: `Unknown job: ${jobName}`, statusCode: 400 };
      }
      return { success: true, message: `Job ${jobName} completed successfully`, statusCode: 200 };
    } catch (error) {
      return {
        success: false,
        message: error instanceof Error ? error.message : "Unknown error",
        statusCode: 500
      };
    }
  }
  getStatus() {
    return Array.from(this.jobStatus.values());
  }
  getJobStatus(name) {
    return this.jobStatus.get(name);
  }
  updateConfig(config) {
    this.config = { ...this.config, ...config };
    log.info("EnrichmentScheduler", "Config updated", { config: this.config });
    if (this.isStarted) {
      this.stop();
      this.start();
    }
  }
};
var enrichmentScheduler = new EnrichmentScheduler();

// server/routes/enrichment.ts
init_logger();
init_db();
import { sql as sql15 } from "drizzle-orm";
var router9 = Router11();
router9.get("/status", async (_req, res) => {
  try {
    const status = enrichmentScheduler.getStatus();
    res.json({ success: true, data: status });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to get status", { error });
    res.status(500).json({ success: false, error: "Failed to get enrichment status" });
  }
});
router9.get("/status/:jobName", async (req, res) => {
  try {
    const status = enrichmentScheduler.getJobStatus(req.params.jobName);
    if (!status) {
      return res.status(404).json({ success: false, error: "Job not found" });
    }
    res.json({ success: true, data: status });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to get job status", { error });
    res.status(500).json({ success: false, error: "Failed to get job status" });
  }
});
router9.post("/run/:jobName", async (req, res) => {
  try {
    const result = await enrichmentScheduler.runJobManually(req.params.jobName);
    res.status(result.statusCode).json({ success: result.success, message: result.message });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to run job", { error });
    res.status(500).json({ success: false, error: "Failed to run job" });
  }
});
router9.get("/stats", async (_req, res) => {
  try {
    const technicals = await db.execute(sql15`SELECT COUNT(*) as count FROM universe_technicals`);
    const macro = await db.execute(sql15`SELECT COUNT(*) as count FROM macro_indicators`);
    const fundamentals = await db.execute(sql15`SELECT COUNT(*) as count FROM universe_fundamentals`);
    const classifications = await db.execute(sql15`SELECT COUNT(*) as count FROM asset_classifications`);
    const assets = await db.execute(sql15`SELECT COUNT(*) as count FROM broker_assets`);
    res.json({
      success: true,
      data: {
        universe_technicals: Number(technicals.rows[0]?.count || 0),
        macro_indicators: Number(macro.rows[0]?.count || 0),
        universe_fundamentals: Number(fundamentals.rows[0]?.count || 0),
        asset_classifications: Number(classifications.rows[0]?.count || 0),
        broker_assets: Number(assets.rows[0]?.count || 0)
      }
    });
  } catch (error) {
    log.error("EnrichmentRoutes", "Failed to get stats", { error });
    res.status(500).json({ success: false, error: "Failed to get stats" });
  }
});
var enrichment_default = router9;

// server/routes/providers.ts
import { Router as Router12 } from "express";
import { randomUUID as randomUUID3 } from "crypto";
var router10 = Router12();
var providers = [
  {
    id: "alpaca-paper",
    type: "broker",
    name: "Alpaca Paper Trading",
    baseUrl: "https://paper-api.alpaca.markets/v2",
    status: "active",
    tags: ["trading", "paper"],
    metadata: { mode: "paper" },
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  },
  {
    id: "openrouter",
    type: "llm",
    name: "OpenRouter",
    baseUrl: "https://openrouter.ai/api/v1",
    status: "active",
    tags: ["llm", "ai"],
    metadata: {},
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  },
  {
    id: "finnhub",
    type: "data",
    name: "Finnhub",
    baseUrl: "https://finnhub.io/api/v1",
    status: "active",
    tags: ["market-data", "news"],
    metadata: {},
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  }
];
var credentials = /* @__PURE__ */ new Map();
var budgets = /* @__PURE__ */ new Map();
var apiFunctions = /* @__PURE__ */ new Map();
router10.get("/", async (req, res) => {
  try {
    res.json(providers);
  } catch (error) {
    console.error("Failed to get providers:", error);
    res.status(500).json({ error: "Failed to get providers" });
  }
});
router10.post("/", async (req, res) => {
  try {
    const provider = {
      id: randomUUID3(),
      ...req.body,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    providers.push(provider);
    res.status(201).json(provider);
  } catch (error) {
    console.error("Failed to create provider:", error);
    res.status(500).json({ error: "Failed to create provider" });
  }
});
router10.get("/:id", async (req, res) => {
  try {
    const provider = providers.find((p) => p.id === req.params.id);
    if (!provider) {
      return res.status(404).json({ error: "Provider not found" });
    }
    res.json(provider);
  } catch (error) {
    console.error("Failed to get provider:", error);
    res.status(500).json({ error: "Failed to get provider" });
  }
});
router10.patch("/:id", async (req, res) => {
  try {
    const index2 = providers.findIndex((p) => p.id === req.params.id);
    if (index2 === -1) {
      return res.status(404).json({ error: "Provider not found" });
    }
    providers[index2] = {
      ...providers[index2],
      ...req.body,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    res.json(providers[index2]);
  } catch (error) {
    console.error("Failed to update provider:", error);
    res.status(500).json({ error: "Failed to update provider" });
  }
});
router10.delete("/:id", async (req, res) => {
  try {
    const index2 = providers.findIndex((p) => p.id === req.params.id);
    if (index2 === -1) {
      return res.status(404).json({ error: "Provider not found" });
    }
    providers.splice(index2, 1);
    credentials.delete(req.params.id);
    budgets.delete(req.params.id);
    apiFunctions.delete(req.params.id);
    res.status(204).send();
  } catch (error) {
    console.error("Failed to delete provider:", error);
    res.status(500).json({ error: "Failed to delete provider" });
  }
});
router10.post("/:id/test", async (req, res) => {
  try {
    const provider = providers.find((p) => p.id === req.params.id);
    if (!provider) {
      return res.status(404).json({ error: "Provider not found" });
    }
    const startTime = Date.now();
    await new Promise((resolve2) => setTimeout(resolve2, 100));
    const latency = Date.now() - startTime;
    res.json({
      success: true,
      latency,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("Failed to test provider:", error);
    res.status(500).json({
      success: false,
      error: "Connection test failed",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
});
router10.get("/:id/credentials", async (req, res) => {
  try {
    const creds = credentials.get(req.params.id) || [];
    const maskedCreds = creds.map((c) => ({
      ...c,
      encryptedValue: "********"
    }));
    res.json(maskedCreds);
  } catch (error) {
    console.error("Failed to get credentials:", error);
    res.status(500).json({ error: "Failed to get credentials" });
  }
});
router10.post("/:id/credentials", async (req, res) => {
  try {
    const credential = {
      id: randomUUID3(),
      providerId: req.params.id,
      kind: req.body.kind,
      encryptedValue: req.body.value,
      // In production, encrypt this
      lastRotatedAt: (/* @__PURE__ */ new Date()).toISOString(),
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const existing = credentials.get(req.params.id) || [];
    existing.push(credential);
    credentials.set(req.params.id, existing);
    res.status(201).json({
      ...credential,
      encryptedValue: "********"
    });
  } catch (error) {
    console.error("Failed to add credential:", error);
    res.status(500).json({ error: "Failed to add credential" });
  }
});
router10.get("/:id/budget", async (req, res) => {
  try {
    let budget = budgets.get(req.params.id);
    if (!budget) {
      budget = {
        id: randomUUID3(),
        providerId: req.params.id,
        dailyLimit: 100,
        monthlyLimit: 1e3,
        softLimit: 80,
        hardLimit: 100,
        usageToday: 0,
        usageMonth: 0,
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      budgets.set(req.params.id, budget);
    }
    res.json(budget);
  } catch (error) {
    console.error("Failed to get budget:", error);
    res.status(500).json({ error: "Failed to get budget" });
  }
});
router10.put("/:id/budget", async (req, res) => {
  try {
    const existing = budgets.get(req.params.id) || {
      id: randomUUID3(),
      providerId: req.params.id,
      usageToday: 0,
      usageMonth: 0,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const budget = {
      ...existing,
      ...req.body,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    budgets.set(req.params.id, budget);
    res.json(budget);
  } catch (error) {
    console.error("Failed to update budget:", error);
    res.status(500).json({ error: "Failed to update budget" });
  }
});
router10.get("/:id/usage", async (req, res) => {
  try {
    const days = parseInt(req.query.days) || 30;
    const metrics = [];
    for (let i = days - 1; i >= 0; i--) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      metrics.push({
        date: date.toISOString().split("T")[0],
        amount: Math.floor(Math.random() * 10),
        requests: Math.floor(Math.random() * 100)
      });
    }
    res.json(metrics);
  } catch (error) {
    console.error("Failed to get usage metrics:", error);
    res.status(500).json({ error: "Failed to get usage metrics" });
  }
});
router10.get("/:id/functions", async (req, res) => {
  try {
    const funcs = apiFunctions.get(req.params.id) || [];
    res.json(funcs);
  } catch (error) {
    console.error("Failed to get API functions:", error);
    res.status(500).json({ error: "Failed to get API functions" });
  }
});
router10.post("/:id/discover", async (req, res) => {
  try {
    const { documentUrl } = req.body;
    const discovered = [
      {
        id: randomUUID3(),
        providerId: req.params.id,
        name: "getAccount",
        method: "GET",
        path: "/account",
        summary: "Get account information",
        tags: ["account"],
        parameters: [],
        responses: {},
        security: [],
        authRequired: true,
        costPerCall: 1e-3,
        isEnabled: true,
        isDeprecated: false,
        metadata: {},
        createdAt: (/* @__PURE__ */ new Date()).toISOString(),
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    ];
    const existing = apiFunctions.get(req.params.id) || [];
    existing.push(...discovered);
    apiFunctions.set(req.params.id, existing);
    res.json({
      success: true,
      functionsDiscovered: discovered.length,
      schemasDiscovered: 0,
      functions: discovered,
      schemas: []
    });
  } catch (error) {
    console.error("Failed to discover APIs:", error);
    res.status(500).json({
      success: false,
      error: "API discovery failed"
    });
  }
});
router10.patch("/:id/functions/:funcId", async (req, res) => {
  try {
    const funcs = apiFunctions.get(req.params.id) || [];
    const index2 = funcs.findIndex((f) => f.id === req.params.funcId);
    if (index2 === -1) {
      return res.status(404).json({ error: "Function not found" });
    }
    funcs[index2] = {
      ...funcs[index2],
      ...req.body,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    apiFunctions.set(req.params.id, funcs);
    res.json(funcs[index2]);
  } catch (error) {
    console.error("Failed to update function:", error);
    res.status(500).json({ error: "Failed to update function" });
  }
});
router10.post("/:id/functions/:funcId/test", async (req, res) => {
  try {
    const funcs = apiFunctions.get(req.params.id) || [];
    const func = funcs.find((f) => f.id === req.params.funcId);
    if (!func) {
      return res.status(404).json({ error: "Function not found" });
    }
    const startTime = Date.now();
    await new Promise((resolve2) => setTimeout(resolve2, 50));
    const latencyMs = Date.now() - startTime;
    func.lastTestedAt = (/* @__PURE__ */ new Date()).toISOString();
    func.lastTestSuccess = true;
    func.lastTestLatencyMs = latencyMs;
    res.json({
      success: true,
      latencyMs
    });
  } catch (error) {
    console.error("Failed to test function:", error);
    res.status(500).json({
      success: false,
      error: "Function test failed"
    });
  }
});
router10.delete("/:id/functions/:funcId", async (req, res) => {
  try {
    const funcs = apiFunctions.get(req.params.id) || [];
    const index2 = funcs.findIndex((f) => f.id === req.params.funcId);
    if (index2 === -1) {
      return res.status(404).json({ error: "Function not found" });
    }
    funcs.splice(index2, 1);
    apiFunctions.set(req.params.id, funcs);
    res.status(204).send();
  } catch (error) {
    console.error("Failed to delete function:", error);
    res.status(500).json({ error: "Failed to delete function" });
  }
});
var providers_default = router10;

// server/routes/auth.ts
import { Router as Router13 } from "express";
import bcrypt from "bcryptjs";
init_storage();
init_logger();
init_sanitization();
init_schema();
var router11 = Router13();
function getCookieOptions() {
  return {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax",
    maxAge: 7 * 24 * 60 * 60 * 1e3
    // 7 days
  };
}
router11.post("/signup", async (req, res) => {
  try {
    const parsed = insertUserSchema.safeParse(req.body);
    if (!parsed.success) {
      return validationError(res, "Invalid input: username and password required", parsed.error);
    }
    const { username, password } = parsed.data;
    const sanitizedUsername = sanitizeInput(username);
    if (sanitizedUsername.length < 3) {
      return badRequest(res, "Username must be at least 3 characters");
    }
    if (password.length < 6) {
      return badRequest(res, "Password must be at least 6 characters");
    }
    const existingUser = await storage.getUserByUsername(sanitizedUsername);
    if (existingUser) {
      return badRequest(res, "Username already taken");
    }
    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await storage.createUser({ username: sanitizedUsername, password: hashedPassword });
    const sessionId = await createSession(user.id);
    res.cookie("session", sessionId, getCookieOptions());
    log.info("AuthAPI", `User registered: ${sanitizedUsername}`);
    res.status(201).json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Signup error: ${error}`);
    return serverError(res, "Failed to create account");
  }
});
router11.post("/login", async (req, res) => {
  try {
    const { username, password } = req.body;
    const sanitizedUsername = sanitizeInput(username);
    if (!username || !password) {
      return badRequest(res, "Username and password required");
    }
    const user = await storage.getUserByUsername(sanitizedUsername);
    if (!user) {
      return unauthorized(res, "Invalid username or password");
    }
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return unauthorized(res, "Invalid username or password");
    }
    const sessionId = await createSession(user.id);
    res.cookie("session", sessionId, getCookieOptions());
    log.info("AuthAPI", `User logged in: ${sanitizedUsername}`);
    res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Login error: ${error}`);
    return serverError(res, "Failed to login");
  }
});
router11.post("/logout", async (req, res) => {
  try {
    const sessionId = req.cookies?.session;
    if (sessionId) {
      await deleteSession(sessionId);
    }
    const { maxAge, ...clearOptions } = getCookieOptions();
    res.clearCookie("session", clearOptions);
    log.info("AuthAPI", "User logged out");
    res.json({ success: true });
  } catch (error) {
    log.error("AuthAPI", `Logout error: ${error}`);
    res.status(500).json({ error: "Failed to logout" });
  }
});
router11.get("/me", async (req, res) => {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const session = await getSession(sessionId);
    if (!session) {
      return res.status(401).json({ error: "Session expired" });
    }
    const user = await storage.getUser(session.userId);
    if (!user) {
      await deleteSession(sessionId);
      return res.status(401).json({ error: "User not found" });
    }
    res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
  } catch (error) {
    log.error("AuthAPI", `Get user error: ${error}`);
    res.status(500).json({ error: "Failed to get user" });
  }
});
var auth_default = router11;

// server/routes/positions.ts
init_storage();
init_logger();
import { Router as Router14 } from "express";
init_schema();
init_alpaca();
init_alpaca_trading_engine();
var router12 = Router14();
router12.get("/snapshot", async (req, res) => {
  try {
    const [alpacaAccount, alpacaPositions] = await Promise.all([
      alpaca.getAccount(),
      alpaca.getPositions()
    ]);
    const equity = parseFloat(alpacaAccount.equity);
    const lastEquity = parseFloat(alpacaAccount.last_equity);
    const buyingPower = parseFloat(alpacaAccount.buying_power);
    const cash = parseFloat(alpacaAccount.cash);
    const portfolioValue = parseFloat(alpacaAccount.portfolio_value);
    const dailyPl = equity - lastEquity;
    const dailyPlPct = lastEquity > 0 ? dailyPl / lastEquity * 100 : 0;
    const positions2 = alpacaPositions.map((pos) => ({
      id: pos.asset_id,
      symbol: pos.symbol,
      side: pos.side === "long" ? "long" : "short",
      qty: parseFloat(pos.qty),
      entryPrice: parseFloat(pos.avg_entry_price),
      currentPrice: parseFloat(pos.current_price),
      marketValue: parseFloat(pos.market_value),
      unrealizedPl: parseFloat(pos.unrealized_pl),
      unrealizedPlPct: parseFloat(pos.unrealized_plpc) * 100,
      costBasis: parseFloat(pos.cost_basis),
      assetClass: pos.asset_class === "crypto" ? "crypto" : "us_equity"
    }));
    const totalUnrealizedPl = positions2.reduce((sum, pos) => sum + pos.unrealizedPl, 0);
    const trades3 = await storage.getTrades(100);
    const closedTrades = trades3.filter((t) => t.pnl !== null && t.pnl !== "");
    const totalRealizedPl = closedTrades.reduce((sum, t) => sum + parseFloat(t.pnl || "0"), 0);
    const snapshot = {
      totalEquity: equity,
      buyingPower,
      cash,
      portfolioValue,
      dailyPl,
      dailyPlPct,
      totalPl: totalRealizedPl + totalUnrealizedPl,
      totalPlPct: lastEquity > 0 ? (totalRealizedPl + totalUnrealizedPl) / lastEquity * 100 : 0,
      positions: positions2,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      positionCount: positions2.length,
      longPositions: positions2.filter((p) => p.side === "long").length,
      shortPositions: positions2.filter((p) => p.side === "short").length,
      totalRealizedPl,
      totalUnrealizedPl
    };
    res.json(snapshot);
  } catch (error) {
    log.error("PositionsAPI", `Failed to get portfolio snapshot: ${error}`);
    res.status(500).json({
      error: "Failed to get portfolio snapshot",
      message: error.message
    });
  }
});
router12.get("/", async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  const DUST_THRESHOLD = 1e-4;
  try {
    const positions2 = await alpaca.getPositions();
    const filteredPositions = positions2.filter((p) => {
      const qty = Math.abs(parseFloat(p.qty || "0"));
      return qty >= DUST_THRESHOLD;
    });
    storage.syncPositionsFromAlpaca(req.userId, filteredPositions).catch(
      (err) => log.error("PositionsAPI", `Failed to sync positions to database: ${err}`)
    );
    const enrichedPositions = filteredPositions.map((p) => mapAlpacaPositionToEnriched(p, fetchedAt));
    res.json({
      positions: enrichedPositions,
      _source: createLiveSourceMetadata()
    });
  } catch (error) {
    log.error("PositionsAPI", `Failed to fetch positions from Alpaca: ${error}`);
    res.status(503).json({
      error: "Live position data unavailable from Alpaca",
      _source: createUnavailableSourceMetadata(),
      message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
    });
  }
});
router12.get("/broker", async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  const DUST_THRESHOLD = 1e-4;
  try {
    const positions2 = await alpaca.getPositions();
    const filteredPositions = positions2.filter((p) => {
      const qty = Math.abs(parseFloat(p.qty || "0"));
      return qty >= DUST_THRESHOLD;
    });
    const enrichedPositions = filteredPositions.map((p) => mapAlpacaPositionToEnriched(p, fetchedAt));
    res.json({
      positions: enrichedPositions,
      _source: createLiveSourceMetadata()
    });
  } catch (error) {
    log.error("PositionsAPI", `Failed to fetch broker positions: ${error}`);
    res.status(503).json({
      error: "Failed to fetch positions from broker",
      _source: createUnavailableSourceMetadata(),
      message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
    });
  }
});
router12.get("/:id", async (req, res) => {
  try {
    const position = await storage.getPosition(req.params.id);
    if (!position) {
      return notFound(res, "Position not found");
    }
    res.json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to get position: ${error}`);
    res.status(500).json({ error: "Failed to get position" });
  }
});
router12.post("/", async (req, res) => {
  try {
    const parsed = insertPositionSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const position = await storage.createPosition(parsed.data);
    res.status(201).json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to create position: ${error}`);
    res.status(500).json({ error: "Failed to create position" });
  }
});
router12.patch("/:id", async (req, res) => {
  try {
    const position = await storage.updatePosition(req.params.id, req.body);
    if (!position) {
      return notFound(res, "Position not found");
    }
    res.json(position);
  } catch (error) {
    log.error("PositionsAPI", `Failed to update position: ${error}`);
    res.status(500).json({ error: "Failed to update position" });
  }
});
router12.delete("/:id", async (req, res) => {
  try {
    const deleted = await storage.deletePosition(req.params.id);
    if (!deleted) {
      return notFound(res, "Position not found");
    }
    res.status(204).send();
  } catch (error) {
    log.error("PositionsAPI", `Failed to delete position: ${error}`);
    res.status(500).json({ error: "Failed to delete position" });
  }
});
router12.post("/reconcile", async (req, res) => {
  try {
    const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
    const force = req.query.force === "true";
    const result = await positionReconciler2.reconcile(force);
    res.json(result);
  } catch (error) {
    log.error("PositionsAPI", `Position reconciliation failed: ${error}`);
    res.status(500).json({ error: "Failed to reconcile positions" });
  }
});
router12.get("/reconcile/status", async (req, res) => {
  try {
    const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
    const status = positionReconciler2.getStatus();
    res.json(status);
  } catch (error) {
    log.error("PositionsAPI", `Failed to get reconciliation status: ${error}`);
    res.status(500).json({ error: "Failed to get reconciliation status" });
  }
});
router12.post("/close/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    if (!symbol) {
      return badRequest(res, "Symbol is required");
    }
    const result = await alpacaTradingEngine.closeAlpacaPosition(symbol);
    if (result.success) {
      res.json({
        success: true,
        message: `Position ${symbol} closed successfully`,
        result
      });
    } else {
      res.status(400).json({
        success: false,
        error: result.error || "Failed to close position"
      });
    }
  } catch (error) {
    log.error("PositionsAPI", `Failed to close position: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
router12.post("/close-all", async (req, res) => {
  try {
    const result = await alpacaTradingEngine.closeAllPositions();
    res.json({ success: true, ...result });
  } catch (error) {
    log.error("PositionsAPI", `Failed to close all positions: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
var positions_default = router12;

// server/routes/orders.ts
init_storage();
init_alpaca();
init_alpaca_trading_engine();
import { Router as Router15 } from "express";
init_tradability_service();
var router13 = Router15();
router13.get("/autonomous/open-orders", async (req, res) => {
  try {
    const orders2 = await alpacaTradingEngine.getOpenOrders();
    res.json(orders2);
  } catch (error) {
    console.error("Failed to get open orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.post("/autonomous/cancel-stale-orders", async (req, res) => {
  try {
    const { maxAgeMinutes } = req.body;
    const result = await alpacaTradingEngine.cancelStaleOrders(maxAgeMinutes || 60);
    res.json({ success: true, ...result });
  } catch (error) {
    console.error("Failed to cancel stale orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.post("/autonomous/cancel-all-orders", async (req, res) => {
  try {
    const result = await alpacaTradingEngine.cancelAllOpenOrders();
    res.json({ success: result.cancelled > 0, ...result });
  } catch (error) {
    console.error("Failed to cancel all orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/unreal", async (req, res) => {
  try {
    const unrealOrders = await identifyUnrealOrders();
    res.json({
      count: unrealOrders.length,
      orders: unrealOrders
    });
  } catch (error) {
    console.error("Failed to identify unreal orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.post("/cleanup", async (req, res) => {
  try {
    const result = await cleanupUnrealOrders();
    res.json({
      success: result.errors.length === 0,
      identified: result.identified,
      canceled: result.canceled,
      errors: result.errors
    });
  } catch (error) {
    console.error("Failed to cleanup unreal orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.post("/reconcile", async (req, res) => {
  try {
    const result = await reconcileOrderBook();
    res.json({
      success: true,
      alpacaOrders: result.alpacaOrders,
      localTrades: result.localTrades,
      missingLocal: result.missingLocal,
      orphanedLocal: result.orphanedLocal,
      synced: result.synced
    });
  } catch (error) {
    console.error("Failed to reconcile order book:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/execution-engine/status", async (req, res) => {
  try {
    const activeExecutions = orderExecutionEngine.getActiveExecutions();
    const executions = Array.from(activeExecutions.entries()).map(([id, state]) => ({
      clientOrderId: id,
      orderId: state.orderId,
      symbol: state.symbol,
      side: state.side,
      status: state.status,
      attempts: state.attempts,
      createdAt: state.createdAt.toISOString(),
      updatedAt: state.updatedAt.toISOString()
    }));
    res.json({
      activeCount: executions.length,
      executions
    });
  } catch (error) {
    console.error("Failed to get execution engine status:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/", async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const status = req.query.status;
    let orders2;
    if (status) {
      orders2 = await storage.getOrdersByStatus(req.userId, status, limit4);
    } else {
      orders2 = await storage.getRecentOrders(req.userId, limit4);
    }
    res.json({
      orders: orders2,
      _source: {
        type: "database",
        table: "orders",
        fetchedAt: fetchedAt.toISOString(),
        note: "Orders stored in local database, synced from broker"
      }
    });
  } catch (error) {
    console.error("Failed to fetch orders:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.post("/sync", async (req, res) => {
  try {
    const traceId = `api-sync-${Date.now()}`;
    const workItem = await workQueue.enqueue({
      type: "ORDER_SYNC",
      payload: JSON.stringify({ traceId }),
      maxAttempts: 3
    });
    res.json({
      success: true,
      workItemId: workItem.id,
      message: "Order sync enqueued",
      traceId
    });
  } catch (error) {
    console.error("Failed to enqueue order sync:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/recent", async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const orders2 = await alpaca.getOrders("all", limit4);
    const enrichedOrders = orders2.map((o) => ({
      ...mapAlpacaOrderToEnriched(o, fetchedAt),
      assetClass: o.asset_class,
      submittedAt: o.submitted_at,
      isAI: true
    }));
    res.json({
      orders: enrichedOrders,
      _source: createLiveSourceMetadata()
    });
  } catch (error) {
    console.error("Failed to fetch recent orders:", error);
    res.status(503).json({
      error: "Failed to fetch recent orders",
      _source: createUnavailableSourceMetadata(),
      message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
    });
  }
});
router13.get("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    let order = await storage.getOrderByBrokerOrderId(id);
    if (!order) {
      const orders2 = await storage.getRecentOrders(1e3);
      order = orders2.find((o) => o.id === id);
    }
    if (!order) {
      return res.status(404).json({ error: "Order not found" });
    }
    const fills2 = await storage.getFillsByOrderId(order.id);
    res.json({
      order,
      fills: fills2,
      _source: {
        type: "database",
        table: "orders",
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("Failed to fetch order:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/fills", async (req, res) => {
  const fetchedAt = /* @__PURE__ */ new Date();
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const orders2 = await storage.getRecentOrders(req.userId, 100);
    const orderIds = orders2.map((o) => o.id);
    let allFills = [];
    for (const orderId of orderIds) {
      const fills2 = await storage.getFillsByOrderId(orderId);
      allFills = allFills.concat(fills2);
    }
    allFills.sort(
      (a, b) => new Date(b.occurredAt).getTime() - new Date(a.occurredAt).getTime()
    );
    allFills = allFills.slice(0, limit4);
    res.json({
      fills: allFills,
      _source: {
        type: "database",
        table: "fills",
        fetchedAt: fetchedAt.toISOString()
      }
    });
  } catch (error) {
    console.error("Failed to fetch fills:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/fills/order/:orderId", async (req, res) => {
  try {
    const { orderId } = req.params;
    let fills2 = await storage.getFillsByOrderId(orderId);
    if (fills2.length === 0) {
      fills2 = await storage.getFillsByBrokerOrderId(orderId);
    }
    res.json({
      fills: fills2,
      _source: {
        type: "database",
        table: "fills",
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("Failed to fetch fills:", error);
    res.status(500).json({ error: String(error) });
  }
});
router13.get("/alpaca/orders", async (req, res) => {
  try {
    const status = req.query.status || "all";
    const limit4 = parseInt(req.query.limit) || 50;
    const orders2 = await alpaca.getOrders(status, limit4);
    res.json(orders2);
  } catch (error) {
    console.error("Failed to get Alpaca orders:", error);
    res.status(500).json({ error: "Failed to get Alpaca orders" });
  }
});
router13.post("/alpaca/orders", async (req, res) => {
  try {
    const { symbol } = req.body;
    if (!symbol) {
      return res.status(400).json({ error: "Symbol is required" });
    }
    const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
    if (!tradabilityCheck.tradable) {
      return res.status(400).json({
        error: `Symbol ${symbol} is not tradable`,
        reason: tradabilityCheck.reason || "Not found in broker universe",
        tradabilityCheck
      });
    }
    const order = await alpaca.createOrder(req.body);
    res.status(201).json(order);
  } catch (error) {
    console.error("Failed to create Alpaca order:", error);
    res.status(500).json({ error: "Failed to create Alpaca order" });
  }
});
router13.delete("/alpaca/orders/:orderId", async (req, res) => {
  try {
    await alpaca.cancelOrder(req.params.orderId);
    res.status(204).send();
  } catch (error) {
    console.error("Failed to cancel Alpaca order:", error);
    res.status(500).json({ error: "Failed to cancel Alpaca order" });
  }
});
var orders_default = router13;

// server/routes/trades.ts
init_storage();
init_alpaca();
init_numeric();
import { Router as Router16 } from "express";
init_schema();
var router14 = Router16();
router14.get("/", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const trades3 = await storage.getTrades(req.userId, limit4);
    res.json(trades3);
  } catch (error) {
    console.error("TradesAPI", `Failed to get trades: ${error}`);
    return serverError(res, "Failed to get trades");
  }
});
router14.get("/enriched", async (req, res) => {
  try {
    const filters = {
      limit: parseInt(req.query.limit) || 20,
      offset: parseInt(req.query.offset) || 0,
      symbol: req.query.symbol,
      strategyId: req.query.strategyId,
      pnlDirection: req.query.pnlDirection || "all",
      startDate: req.query.startDate ? new Date(req.query.startDate) : void 0,
      endDate: req.query.endDate ? new Date(req.query.endDate) : void 0
    };
    const result = await storage.getTradesFiltered(req.userId, filters);
    res.json(result);
  } catch (error) {
    console.error("TradesAPI", `Failed to get enriched trades: ${error}`);
    return serverError(res, "Failed to get enriched trades");
  }
});
router14.get("/symbols", async (req, res) => {
  try {
    const symbols = await storage.getDistinctSymbols();
    res.json(symbols);
  } catch (error) {
    console.error("TradesAPI", `Failed to get symbols: ${error}`);
    return serverError(res, "Failed to get symbols");
  }
});
router14.get("/:id", async (req, res) => {
  try {
    const trade = await storage.getTrade(req.params.id);
    if (!trade) {
      return notFound(res, "Trade not found");
    }
    res.json(trade);
  } catch (error) {
    console.error("TradesAPI", `Failed to get trade: ${error}`);
    return serverError(res, "Failed to get trade");
  }
});
router14.get("/:id/enriched", async (req, res) => {
  try {
    const trade = await storage.getEnrichedTrade(req.params.id);
    if (!trade) {
      return notFound(res, "Trade not found");
    }
    res.json(trade);
  } catch (error) {
    console.error("TradesAPI", `Failed to get enriched trade: ${error}`);
    return serverError(res, "Failed to get enriched trade");
  }
});
router14.post("/", async (req, res) => {
  try {
    const parsed = insertTradeSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const trade = await storage.createTrade(parsed.data);
    res.status(201).json(trade);
  } catch (error) {
    console.error("TradesAPI", `Failed to create trade: ${error}`);
    return serverError(res, "Failed to create trade");
  }
});
router14.post("/backfill-prices", async (req, res) => {
  try {
    const trades3 = await storage.getTrades(500);
    const zeroTrades = trades3.filter((t) => safeParseFloat(t.price, 0) === 0);
    if (zeroTrades.length === 0) {
      return res.json({ message: "No trades need backfilling", updated: 0 });
    }
    let orders2 = [];
    try {
      orders2 = await alpaca.getOrders("all", 500);
    } catch (e) {
      console.error("TradesAPI", `Failed to fetch Alpaca orders for backfill: ${e}`);
      return serverError(res, "Failed to fetch order history from broker");
    }
    let updated = 0;
    for (const trade of zeroTrades) {
      const matchingOrder = orders2.find(
        (o) => o.symbol === trade.symbol && o.side === trade.side && o.status === "filled" && safeParseFloat(o.filled_avg_price, 0) > 0 && Math.abs(new Date(o.filled_at).getTime() - new Date(trade.executedAt).getTime()) < 6e4
      );
      if (matchingOrder) {
        const filledPrice = safeParseFloat(matchingOrder.filled_avg_price, 0);
        const filledQty = safeParseFloat(matchingOrder.filled_qty, 0);
        await storage.updateTrade(trade.id, {
          price: filledPrice.toString(),
          quantity: filledQty.toString(),
          status: "filled"
        });
        updated++;
      }
    }
    res.json({
      message: `Backfilled ${updated} of ${zeroTrades.length} trades`,
      updated,
      remaining: zeroTrades.length - updated
    });
  } catch (error) {
    console.error("TradesAPI", `Trade backfill error: ${error}`);
    return serverError(res, "Failed to backfill trade prices");
  }
});
var trades_default = router14;

// server/routes/market-data.ts
init_logger();
import { Router as Router17 } from "express";
init_coingecko();
init_finnhub();
init_alpaca();
init_newsapi();
var router15 = Router17();
router15.get("/crypto/markets", async (req, res) => {
  try {
    const perPage = parseInt(req.query.per_page) || 20;
    const page = parseInt(req.query.page) || 1;
    const order = req.query.order || "market_cap_desc";
    const markets = await coingecko.getMarkets("usd", perPage, page, order);
    res.json(markets);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch crypto markets: ${error}`);
    return serverError(res, "Failed to fetch crypto market data");
  }
});
router15.get("/crypto/prices", async (req, res) => {
  try {
    const ids = req.query.ids || "bitcoin,ethereum,solana";
    const coinIds = ids.split(",").map((id) => id.trim());
    const prices = await coingecko.getSimplePrice(coinIds);
    res.json(prices);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch crypto prices: ${error}`);
    return serverError(res, "Failed to fetch crypto prices");
  }
});
router15.get("/crypto/chart/:coinId", async (req, res) => {
  try {
    const { coinId } = req.params;
    const days = req.query.days || "7";
    const chart = await coingecko.getMarketChart(coinId, "usd", days);
    res.json(chart);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch crypto chart: ${error}`);
    return serverError(res, "Failed to fetch crypto chart data");
  }
});
router15.get("/crypto/trending", async (req, res) => {
  try {
    const trending = await coingecko.getTrending();
    res.json(trending);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch trending coins: ${error}`);
    return serverError(res, "Failed to fetch trending coins");
  }
});
router15.get("/crypto/global", async (req, res) => {
  try {
    const global = await coingecko.getGlobalData();
    res.json(global);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch global market data: ${error}`);
    return serverError(res, "Failed to fetch global market data");
  }
});
router15.get("/crypto/search", async (req, res) => {
  try {
    const query = req.query.q || "";
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const results = await coingecko.searchCoins(query);
    res.json(results);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to search coins: ${error}`);
    return serverError(res, "Failed to search coins");
  }
});
router15.get("/stock/quote/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    const quote = await finnhub.getQuote(symbol);
    res.json(quote);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch stock quote: ${error}`);
    return serverError(res, "Failed to fetch stock quote");
  }
});
router15.get("/stock/quotes", async (req, res) => {
  try {
    const symbols = req.query.symbols || "AAPL,GOOGL,MSFT,AMZN,TSLA";
    const symbolList = symbols.split(",").map((s) => s.trim().toUpperCase());
    const quotes = await finnhub.getMultipleQuotes(symbolList);
    const result = {};
    quotes.forEach((quote, symbol) => {
      result[symbol] = quote;
    });
    res.json(result);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch stock quotes: ${error}`);
    return serverError(res, "Failed to fetch stock quotes");
  }
});
router15.get("/stock/candles/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    const resolution = req.query.resolution || "D";
    const from = req.query.from ? parseInt(req.query.from) : void 0;
    const to = req.query.to ? parseInt(req.query.to) : void 0;
    const candles = await finnhub.getCandles(symbol, resolution, from, to);
    res.json(candles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch stock candles: ${error}`);
    return serverError(res, "Failed to fetch stock candles");
  }
});
router15.get("/stock/profile/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    const profile = await finnhub.getCompanyProfile(symbol);
    res.json(profile);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch company profile: ${error}`);
    return serverError(res, "Failed to fetch company profile");
  }
});
router15.get("/stock/search", async (req, res) => {
  try {
    const query = req.query.q || "";
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const results = await finnhub.searchSymbols(query);
    res.json(results);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to search stocks: ${error}`);
    return serverError(res, "Failed to search stocks");
  }
});
router15.get("/stock/news", async (req, res) => {
  try {
    const category = req.query.category || "general";
    const news = await finnhub.getMarketNews(category);
    res.json(news);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to fetch market news: ${error}`);
    return serverError(res, "Failed to fetch market news");
  }
});
router15.get("/market/quotes", async (req, res) => {
  try {
    const symbolsParam = req.query.symbols;
    if (!symbolsParam) {
      return badRequest(res, "symbols parameter required");
    }
    const symbols = symbolsParam.split(",").map((s) => s.trim().toUpperCase());
    const snapshots = await alpaca.getSnapshots(symbols);
    const quotes = symbols.map((symbol) => {
      const snap = snapshots[symbol];
      if (!snap) {
        return { symbol, price: null, change: null, changePercent: null };
      }
      const price = snap.latestTrade?.p || snap.dailyBar?.c || 0;
      const prevClose = snap.prevDailyBar?.c || price;
      const change = price - prevClose;
      const changePercent = prevClose ? change / prevClose * 100 : 0;
      return {
        symbol,
        price,
        change,
        changePercent,
        volume: snap.dailyBar?.v || 0,
        high: snap.dailyBar?.h || 0,
        low: snap.dailyBar?.l || 0,
        open: snap.dailyBar?.o || 0
      };
    });
    res.json(quotes);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get market quotes: ${error}`);
    return serverError(res, "Failed to get market quotes");
  }
});
router15.get("/news/headlines", async (req, res) => {
  try {
    const category = req.query.category || "business";
    const country = req.query.country || "us";
    const pageSize = parseInt(req.query.pageSize) || 20;
    const headlines = await newsapi.getTopHeadlines(category, country, pageSize);
    res.json(headlines);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get news headlines: ${error}`);
    return serverError(res, "Failed to get news headlines");
  }
});
router15.get("/news/search", async (req, res) => {
  try {
    const query = req.query.q;
    if (!query) {
      return badRequest(res, "Search query required");
    }
    const sortBy = req.query.sortBy || "publishedAt";
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.searchNews(query, sortBy, pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to search news: ${error}`);
    return serverError(res, "Failed to search news");
  }
});
router15.get("/news/market", async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getMarketNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get market news: ${error}`);
    return serverError(res, "Failed to get market news");
  }
});
router15.get("/news/crypto", async (req, res) => {
  try {
    const pageSize = parseInt(req.query.pageSize) || 20;
    const articles = await newsapi.getCryptoNews(pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get crypto news: ${error}`);
    return serverError(res, "Failed to get crypto news");
  }
});
router15.get("/news/stock/:symbol", async (req, res) => {
  try {
    const { symbol } = req.params;
    const pageSize = parseInt(req.query.pageSize) || 10;
    const articles = await newsapi.getStockNews(symbol, pageSize);
    res.json(articles);
  } catch (error) {
    log.error("MarketDataAPI", `Failed to get stock news: ${error}`);
    return serverError(res, "Failed to get stock news");
  }
});
var market_data_default = router15;

// server/routes/webhooks.ts
import { Router as Router18 } from "express";
var router16 = Router18();
var redactWebhook = (webhook) => ({
  ...webhook,
  secret: webhook.secret ? "***REDACTED***" : void 0,
  headers: webhook.headers ? Object.fromEntries(
    Object.entries(webhook.headers).map(
      ([k, v]) => k.toLowerCase().includes("auth") || k.toLowerCase().includes("token") || k.toLowerCase().includes("key") ? [k, "***REDACTED***"] : [k, v]
    )
  ) : void 0
});
router16.get("/", (req, res) => {
  const webhooks2 = getWebhooks().map(redactWebhook);
  res.json({ webhooks: webhooks2, supportedEvents: SUPPORTED_EVENTS });
});
router16.post("/", (req, res) => {
  try {
    const { name, url, eventTypes, enabled, headers, secret } = req.body;
    if (!name || !url) {
      return res.status(400).json({ error: "name and url are required" });
    }
    if (!url.startsWith("https://") && process.env.NODE_ENV === "production") {
      return res.status(400).json({ error: "Webhook URL must use HTTPS in production" });
    }
    const id = `wh_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    const config = {
      id,
      name,
      url,
      eventTypes: eventTypes || ["*"],
      enabled: enabled !== false,
      headers,
      secret
    };
    registerWebhook(config);
    res.status(201).json(redactWebhook(config));
  } catch (error) {
    console.error("Webhook creation error:", error);
    res.status(500).json({ error: "Failed to create webhook" });
  }
});
router16.get("/:id", (req, res) => {
  const webhook = getWebhook(req.params.id);
  if (!webhook) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json(redactWebhook(webhook));
});
router16.put("/:id", (req, res) => {
  const updated = updateWebhook(req.params.id, req.body);
  if (!updated) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json(redactWebhook(updated));
});
router16.delete("/:id", (req, res) => {
  const result = unregisterWebhook(req.params.id);
  if (!result) {
    return res.status(404).json({ error: "Webhook not found" });
  }
  res.json({ success: true });
});
router16.post("/test", async (req, res) => {
  try {
    const { eventType, payload } = req.body;
    const results = await emitEvent(
      eventType || "system.test",
      payload || { test: true, timestamp: (/* @__PURE__ */ new Date()).toISOString() }
    );
    res.json({ deliveries: results.length, results });
  } catch (error) {
    console.error("Webhook test error:", error);
    res.status(500).json({ error: "Failed to send test event" });
  }
});
router16.get("/stats/overview", (req, res) => {
  res.json(getWebhookStats());
});
router16.get("/history/deliveries", (req, res) => {
  const limit4 = parseInt(req.query.limit) || 50;
  res.json({ deliveries: getDeliveryHistory(limit4) });
});
var webhooks_default = router16;

// server/routes/ai-decisions.ts
init_storage();
init_logger();
import { Router as Router19 } from "express";
init_decision_engine();
init_llmGateway();
init_alpaca_trading_engine();
init_alpaca();
init_schema();
var router17 = Router19();
router17.get("/", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 20;
    const decisions = await storage.getAiDecisions(req.userId, limit4);
    res.json(decisions);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI decisions: ${error}`);
    res.status(500).json({ error: "Failed to get AI decisions" });
  }
});
router17.get("/history", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 100;
    const offset = parseInt(req.query.offset) || 0;
    const statusFilter = req.query.status;
    const actionFilter = req.query.action;
    const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
    let filtered = decisions.slice(offset, offset + limit4);
    if (statusFilter) {
      filtered = filtered.filter((d) => d.status === statusFilter);
    }
    if (actionFilter) {
      filtered = filtered.filter((d) => d.action === actionFilter);
    }
    const pendingAnalysis = orchestrator.getPendingAnalysis?.() || [];
    res.json({
      decisions: filtered,
      total: decisions.length,
      hasMore: offset + limit4 < decisions.length,
      pendingAnalysis
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI decision history: ${error}`);
    res.status(500).json({ error: "Failed to get AI decision history" });
  }
});
router17.post("/", async (req, res) => {
  try {
    const parsed = insertAiDecisionSchema.safeParse(req.body);
    if (!parsed.success) {
      return badRequest(res, parsed.error.message);
    }
    const decision = await storage.createAiDecision(parsed.data);
    res.status(201).json(decision);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to create AI decision: ${error}`);
    res.status(500).json({ error: "Failed to create AI decision" });
  }
});
router17.get("/enriched", async (req, res) => {
  try {
    const limit4 = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    const statusFilter = req.query.status;
    const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
    const enrichedDecisions = await Promise.all(
      decisions.slice(offset, offset + limit4).map(async (decision) => {
        const enriched = {
          decision,
          linkedOrder: null,
          linkedTrade: null,
          linkedPosition: null,
          timeline: []
        };
        enriched.timeline.push({
          stage: "decision",
          status: "completed",
          timestamp: decision.createdAt,
          details: `${decision.action.toUpperCase()} signal with ${parseFloat(decision.confidence || "0").toFixed(1)}% confidence`
        });
        if (decision.status === "skipped") {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "skipped",
            timestamp: decision.createdAt,
            details: decision.skipReason || "Trade blocked by risk rules"
          });
        } else if (decision.status === "executed" || decision.executedTradeId) {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "completed",
            timestamp: decision.createdAt,
            details: "Risk check passed"
          });
        } else if (decision.status === "pending") {
          enriched.timeline.push({
            stage: "risk_gate",
            status: "pending",
            timestamp: null,
            details: "Awaiting risk evaluation"
          });
        }
        if (decision.id) {
          try {
            const linkedOrders = await storage.getOrdersByDecisionId(decision.id);
            if (linkedOrders.length > 0) {
              const order = linkedOrders[0];
              enriched.linkedOrder = order;
              enriched.timeline.push({
                stage: "order",
                status: order.status === "filled" || order.status === "partially_filled" ? "completed" : order.status === "pending_new" || order.status === "accepted" ? "pending" : "failed",
                timestamp: order.submittedAt,
                details: `${order.side.toUpperCase()} ${order.qty || order.notional} @ ${order.type}`
              });
              if (order.filledAt) {
                enriched.timeline.push({
                  stage: "fill",
                  status: "completed",
                  timestamp: order.filledAt,
                  details: `Filled ${order.filledQty} @ ${order.filledAvgPrice}`
                });
              } else if (order.status === "pending_new" || order.status === "accepted") {
                enriched.timeline.push({
                  stage: "fill",
                  status: "pending",
                  timestamp: null,
                  details: "Awaiting fill"
                });
              }
            }
          } catch (e) {
          }
        }
        if (decision.executedTradeId) {
          try {
            const trade = await storage.getTrade(decision.executedTradeId);
            if (trade) {
              enriched.linkedTrade = trade;
            }
          } catch (e) {
          }
        }
        try {
          const positions2 = await storage.getPositions();
          const symbolPosition = positions2.find(
            (p) => p.symbol.toUpperCase() === decision.symbol.toUpperCase()
          );
          if (symbolPosition) {
            enriched.linkedPosition = symbolPosition;
            enriched.timeline.push({
              stage: "position",
              status: "completed",
              timestamp: symbolPosition.openedAt,
              details: `${symbolPosition.side} ${symbolPosition.quantity} @ ${symbolPosition.entryPrice}`
            });
          }
        } catch (e) {
        }
        return enriched;
      })
    );
    let filtered = enrichedDecisions;
    if (statusFilter) {
      filtered = enrichedDecisions.filter((e) => e.decision.status === statusFilter);
    }
    res.json({
      enrichedDecisions: filtered,
      total: decisions.length,
      hasMore: offset + limit4 < decisions.length
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get enriched AI decisions: ${error}`);
    res.status(500).json({ error: "Failed to get enriched AI decisions" });
  }
});
router17.post("/analyze", async (req, res) => {
  try {
    const { symbol, marketData, newsContext, strategyId } = req.body;
    if (!symbol || !marketData) {
      return badRequest(res, "Symbol and market data are required");
    }
    let strategy;
    if (strategyId) {
      const dbStrategy = await storage.getStrategy(strategyId);
      if (dbStrategy) {
        strategy = {
          id: dbStrategy.id,
          name: dbStrategy.name,
          type: dbStrategy.type,
          parameters: dbStrategy.parameters ? JSON.parse(dbStrategy.parameters) : void 0
        };
      }
    }
    const traceId = generateTraceId();
    const decision = await aiDecisionEngine.analyzeOpportunity(
      symbol,
      marketData,
      newsContext,
      strategy,
      { traceId }
    );
    const aiDecisionRecord = await storage.createAiDecision({
      strategyId: strategyId || null,
      symbol,
      action: decision.action,
      confidence: decision.confidence.toString(),
      reasoning: decision.reasoning,
      traceId,
      marketContext: JSON.stringify({
        marketData,
        newsContext,
        riskLevel: decision.riskLevel,
        suggestedQuantity: decision.suggestedQuantity,
        targetPrice: decision.targetPrice,
        stopLoss: decision.stopLoss
      })
    });
    res.json({
      id: aiDecisionRecord.id,
      ...decision,
      createdAt: aiDecisionRecord.createdAt
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `AI analysis error: ${error}`);
    res.status(500).json({ error: "Failed to analyze trading opportunity" });
  }
});
router17.get("/status", async (req, res) => {
  try {
    const status = aiDecisionEngine.getStatus();
    res.json(status);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI status: ${error}`);
    res.status(500).json({ error: "Failed to get AI status" });
  }
});
router17.get("/events", async (req, res) => {
  try {
    const limit4 = Math.min(parseInt(req.query.limit) || 20, 100);
    const type = req.query.type;
    const decisions = await storage.getAiDecisions({ limit: limit4 * 2 });
    const events = decisions.filter((d) => !type || d.type === type).slice(0, limit4).map((d) => ({
      id: d.id,
      type: d.type || "signal",
      title: d.headline || `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol || "Market"}`,
      headline: d.headline,
      description: d.reasoning || d.explanation,
      explanation: d.explanation,
      symbol: d.symbol,
      confidence: typeof d.confidence === "string" ? parseFloat(d.confidence) : d.confidence,
      action: d.action,
      time: d.createdAt,
      createdAt: d.createdAt,
      metadata: {
        strategyId: d.strategyId,
        signals: d.signals
      }
    }));
    res.json(events);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get AI events: ${error}`);
    res.json([]);
  }
});
router17.get("/sentiment", async (req, res) => {
  try {
    const symbols = req.query.symbols?.split(",") || ["SPY", "QQQ", "AAPL", "TSLA", "NVDA"];
    const sentiments = symbols.map((symbol) => ({
      id: `sent-${symbol}-${Date.now()}`,
      sourceId: "data-fusion",
      sourceName: "Data Fusion Engine",
      symbol,
      score: Math.random() * 100 - 50,
      // -50 to +50
      trend: Math.random() > 0.5 ? "up" : Math.random() > 0.5 ? "down" : "neutral",
      explanation: `Aggregate sentiment analysis for ${symbol} based on news, social media, and market data`,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    }));
    res.json(sentiments);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get sentiment signals: ${error}`);
    res.status(500).json({ error: "Failed to get sentiment signals" });
  }
});
router17.get("/cache/stats", async (req, res) => {
  try {
    const stats = getLLMCacheStats();
    res.json(stats);
  } catch (error) {
    log.error("AiDecisionsAPI", `Error getting LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get cache stats" });
  }
});
router17.post("/cache/clear", async (req, res) => {
  try {
    clearLLMCache();
    res.json({ success: true, message: "LLM cache cleared" });
  } catch (error) {
    log.error("AiDecisionsAPI", `Error clearing LLM cache: ${error}`);
    res.status(500).json({ error: "Failed to clear cache" });
  }
});
router17.post("/cache/clear/:role", async (req, res) => {
  try {
    const { role } = req.params;
    clearLLMCacheForRole(role);
    res.json({ success: true, message: `Cache cleared for role: ${role}` });
  } catch (error) {
    log.error("AiDecisionsAPI", `Error clearing LLM cache for role: ${error}`);
    res.status(500).json({ error: "Failed to clear cache for role" });
  }
});
router17.post("/cache/reset-stats", async (req, res) => {
  try {
    resetLLMCacheStats();
    res.json({ success: true, message: "Cache statistics reset" });
  } catch (error) {
    log.error("AiDecisionsAPI", `Error resetting LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to reset cache stats" });
  }
});
router17.get("/agent/status", async (req, res) => {
  try {
    const status = await storage.getAgentStatus();
    if (!status) {
      const defaultStatus = await storage.updateAgentStatus({
        isRunning: false,
        totalTrades: 0,
        totalPnl: "0"
      });
      return res.json(defaultStatus);
    }
    res.json(status);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get agent status: ${error}`);
    res.status(500).json({ error: "Failed to get agent status" });
  }
});
router17.post("/agent/toggle", async (req, res) => {
  try {
    const currentStatus = await storage.getAgentStatus();
    const newIsRunning = !(currentStatus?.isRunning ?? false);
    if (newIsRunning) {
      await alpacaTradingEngine.resumeAgent();
    } else {
      await alpacaTradingEngine.stopAllStrategies();
    }
    const status = await storage.getAgentStatus();
    res.json(status);
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to toggle agent: ${error}`);
    res.status(500).json({ error: "Failed to toggle agent" });
  }
});
router17.get("/agent/market-analysis", async (req, res) => {
  try {
    const analyzerStatus = marketConditionAnalyzer.getStatus();
    const lastAnalysis = marketConditionAnalyzer.getLastAnalysis();
    res.json({
      isRunning: analyzerStatus.isRunning,
      lastAnalysis,
      lastAnalysisTime: analyzerStatus.lastAnalysisTime,
      currentOrderLimit: analyzerStatus.currentOrderLimit
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get market analysis: ${error}`);
    res.status(500).json({ error: "Failed to get market analysis" });
  }
});
router17.post("/agent/market-analysis/refresh", async (req, res) => {
  try {
    const analysis = await marketConditionAnalyzer.runAnalysis();
    res.json({ success: true, analysis });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to refresh market analysis: ${error}`);
    res.status(500).json({ error: "Failed to refresh market analysis" });
  }
});
router17.get("/agent/dynamic-limits", async (req, res) => {
  try {
    const agentStatus2 = await storage.getAgentStatus();
    const analyzerStatus = marketConditionAnalyzer.getStatus();
    const minLimit = agentStatus2?.minOrderLimit ?? 10;
    const maxLimit = agentStatus2?.maxOrderLimit ?? 50;
    let currentLimit = agentStatus2?.dynamicOrderLimit ?? analyzerStatus.currentOrderLimit ?? 25;
    currentLimit = Math.max(minLimit, Math.min(maxLimit, currentLimit));
    res.json({
      currentDynamicLimit: currentLimit,
      minOrderLimit: minLimit,
      maxOrderLimit: maxLimit,
      marketCondition: agentStatus2?.marketCondition || "neutral",
      aiConfidenceScore: agentStatus2?.aiConfidenceScore || "0.5",
      lastMarketAnalysis: agentStatus2?.lastMarketAnalysis
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get dynamic limits: ${error}`);
    res.status(500).json({ error: "Failed to get dynamic limits" });
  }
});
router17.post("/agent/set-limits", async (req, res) => {
  try {
    const { minOrderLimit, maxOrderLimit } = req.body;
    const updates = {};
    if (minOrderLimit !== void 0) {
      if (minOrderLimit < 1 || minOrderLimit > 100) {
        return badRequest(res, "minOrderLimit must be between 1 and 100");
      }
      updates.minOrderLimit = minOrderLimit;
    }
    if (maxOrderLimit !== void 0) {
      if (maxOrderLimit < 1 || maxOrderLimit > 100) {
        return badRequest(res, "maxOrderLimit must be between 1 and 100");
      }
      updates.maxOrderLimit = maxOrderLimit;
    }
    if (updates.minOrderLimit && updates.maxOrderLimit && updates.minOrderLimit > updates.maxOrderLimit) {
      return badRequest(
        res,
        "minOrderLimit cannot be greater than maxOrderLimit"
      );
    }
    await storage.updateAgentStatus(updates);
    const updatedStatus = await storage.getAgentStatus();
    res.json({
      success: true,
      minOrderLimit: updatedStatus?.minOrderLimit,
      maxOrderLimit: updatedStatus?.maxOrderLimit
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to set limits: ${error}`);
    res.status(500).json({ error: "Failed to set limits" });
  }
});
router17.get("/agent/health", async (req, res) => {
  try {
    const healthStatus = orchestrator.getHealthStatus();
    const agentStatus2 = await storage.getAgentStatus();
    res.json({
      ...healthStatus,
      autoStartEnabled: agentStatus2?.autoStartEnabled ?? true,
      lastHeartbeatFromDb: agentStatus2?.lastHeartbeat
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to get agent health: ${error}`);
    res.status(500).json({ error: "Failed to get agent health" });
  }
});
router17.post("/agent/auto-start", async (req, res) => {
  try {
    const { enabled } = req.body;
    if (typeof enabled !== "boolean") {
      return badRequest(res, "enabled must be a boolean");
    }
    await orchestrator.setAutoStartEnabled(enabled);
    res.json({ success: true, autoStartEnabled: enabled });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to set auto-start: ${error}`);
    res.status(500).json({ error: "Failed to set auto-start" });
  }
});
router17.post("/autonomous/execute-trades", async (req, res) => {
  try {
    const { decisionIds } = req.body;
    if (!decisionIds || !Array.isArray(decisionIds) || decisionIds.length === 0) {
      return badRequest(res, "Decision IDs array is required");
    }
    const results = [];
    for (const decisionId of decisionIds) {
      const decisions = await storage.getAiDecisions(100);
      const decision = decisions.find((d) => d.id === decisionId);
      if (!decision) {
        results.push({ decisionId, success: false, error: "Decision not found" });
        continue;
      }
      try {
        const metadata = decision.metadata ? JSON.parse(decision.metadata) : {};
        const suggestedPct = metadata?.suggestedQuantity ? parseFloat(String(metadata.suggestedQuantity)) : 0.05;
        const account = await alpaca.getAccount();
        const buyingPower = parseFloat(account.buying_power);
        const price = parseFloat(decision.entryPrice || "0");
        if (!price) {
          results.push({ decisionId, success: false, error: "No entry price available" });
          continue;
        }
        const tradeValue = buyingPower * Math.min(Math.max(suggestedPct, 0.01), 0.1);
        const quantity = Math.floor(tradeValue / price);
        if (quantity < 1) {
          results.push({
            decisionId,
            success: false,
            error: "Calculated quantity less than 1 share"
          });
          continue;
        }
        const orderResult = await alpacaTradingEngine.executeAlpacaTrade({
          symbol: decision.symbol,
          side: decision.action,
          quantity
        });
        if (orderResult.success) {
          results.push({ decisionId, success: true, order: orderResult.order });
        } else {
          results.push({
            decisionId,
            success: false,
            error: orderResult.error
          });
        }
      } catch (err) {
        results.push({ decisionId, success: false, error: String(err) });
      }
    }
    const successCount = results.filter((r) => r.success).length;
    res.json({
      success: successCount > 0,
      message: `Executed ${successCount}/${decisionIds.length} trades`,
      results
    });
  } catch (error) {
    log.error("AiDecisionsAPI", `Failed to execute trades: ${error}`);
    res.status(500).json({ error: String(error) });
  }
});
var ai_decisions_default = router17;

// server/routes/autonomous.ts
init_alpaca_trading_engine();
init_storage();
init_alpaca();
init_orchestration();
function registerAutonomousRoutes(app2, authMiddleware2) {
  app2.get("/api/autonomous/state", authMiddleware2, async (req, res) => {
    try {
      const state = orchestrator.getState();
      const riskLimits = orchestrator.getRiskLimits();
      res.json({
        ...state,
        riskLimits,
        activePositions: Array.from(state.activePositions.entries()).map(([key, pos]) => ({
          ...pos,
          symbol: key
        })),
        pendingSignals: Array.from(state.pendingSignals.entries()).map(([symbol, signal]) => ({
          symbol,
          ...signal
        }))
      });
    } catch (error) {
      console.error("Failed to get autonomous state:", error);
      res.status(500).json({ error: "Failed to get autonomous state" });
    }
  });
  app2.get("/api/autonomous/status", authMiddleware2, async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      const userId = req.userId;
      const recentDecisions = await storage.getAiDecisions(userId, 10);
      const positions2 = await storage.getPositions(userId);
      res.json({
        isRunning: status.isRunning,
        killSwitchActive: status.killSwitchActive,
        lastRunTime: status.lastRunTime,
        consecutiveErrors: status.consecutiveErrors,
        activePositions: positions2.length,
        recentDecisions: recentDecisions.length,
        lastDecisionTime: recentDecisions[0]?.createdAt || null,
        config: status.config || {}
      });
    } catch (error) {
      console.error("Failed to get autonomous status:", error);
      res.status(500).json({ error: "Failed to get autonomous status" });
    }
  });
  app2.post("/api/autonomous/start", authMiddleware2, async (req, res) => {
    try {
      await orchestrator.start();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      console.error("Failed to start autonomous mode:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/stop", authMiddleware2, async (req, res) => {
    try {
      await orchestrator.stop();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      console.error("Failed to stop autonomous mode:", error);
      res.status(500).json({ error: "Failed to stop autonomous mode" });
    }
  });
  app2.post("/api/autonomous/mode", authMiddleware2, async (req, res) => {
    try {
      const { mode } = req.body;
      if (!["autonomous", "semi-auto", "manual"].includes(mode)) {
        return res.status(400).json({ error: "Invalid mode. Use: autonomous, semi-auto, or manual" });
      }
      await orchestrator.setMode(mode);
      res.json({ success: true, mode: orchestrator.getMode() });
    } catch (error) {
      console.error("Failed to set mode:", error);
      res.status(500).json({ error: "Failed to set mode" });
    }
  });
  app2.post("/api/autonomous/kill-switch", authMiddleware2, async (req, res) => {
    try {
      const { activate, reason } = req.body;
      if (activate) {
        await orchestrator.activateKillSwitch(reason || "Manual activation");
      } else {
        await orchestrator.deactivateKillSwitch();
      }
      const state = orchestrator.getState();
      res.json({ success: true, killSwitchActive: orchestrator.getRiskLimits().killSwitchActive, state });
    } catch (error) {
      console.error("Failed to toggle kill switch:", error);
      res.status(500).json({ error: "Failed to toggle kill switch" });
    }
  });
  app2.put("/api/autonomous/risk-limits", authMiddleware2, async (req, res) => {
    try {
      const {
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      } = req.body;
      await orchestrator.updateRiskLimits({
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      });
      res.json({ success: true, riskLimits: orchestrator.getRiskLimits() });
    } catch (error) {
      console.error("Failed to update risk limits:", error);
      res.status(500).json({ error: "Failed to update risk limits" });
    }
  });
  app2.get("/api/autonomous/execution-history", authMiddleware2, async (req, res) => {
    try {
      const state = orchestrator.getState();
      res.json(state.executionHistory);
    } catch (error) {
      res.status(500).json({ error: "Failed to get execution history" });
    }
  });
  app2.post("/api/autonomous/close-position", authMiddleware2, async (req, res) => {
    try {
      const { symbol } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const result = await alpacaTradingEngine.closeAlpacaPosition(symbol);
      if (result.success) {
        res.json({ success: true, message: `Position ${symbol} closed successfully`, result });
      } else {
        res.status(400).json({ success: false, error: result.error || "Failed to close position" });
      }
    } catch (error) {
      console.error("Failed to close position:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/close-all-positions", authMiddleware2, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.closeAllPositions();
      res.json({ success: true, ...result });
    } catch (error) {
      console.error("Failed to close all positions:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/autonomous/reconcile-positions", authMiddleware2, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.reconcilePositions();
      res.json(result);
    } catch (error) {
      console.error("Failed to reconcile positions:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/sync-positions", authMiddleware2, async (req, res) => {
    try {
      const userId = req.userId;
      const result = await alpacaTradingEngine.syncPositionsFromAlpaca(userId);
      res.json({ success: true, ...result });
    } catch (error) {
      console.error("Failed to sync positions:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/execute-trades", authMiddleware2, async (req, res) => {
    try {
      const { decisionIds } = req.body;
      if (!decisionIds || !Array.isArray(decisionIds) || decisionIds.length === 0) {
        return res.status(400).json({ error: "Decision IDs array is required" });
      }
      const results = [];
      for (const decisionId of decisionIds) {
        const decisions = await storage.getAiDecisions(100);
        const decision = decisions.find((d) => d.id === decisionId);
        if (!decision) {
          results.push({ decisionId, success: false, error: "Decision not found" });
          continue;
        }
        try {
          const metadata = decision.metadata ? JSON.parse(decision.metadata) : {};
          const suggestedPct = metadata?.suggestedQuantity ? parseFloat(String(metadata.suggestedQuantity)) : 0.05;
          const account = await alpaca.getAccount();
          const buyingPower = parseFloat(account.buying_power);
          const price = parseFloat(decision.entryPrice || "0");
          if (!price) {
            results.push({ decisionId, success: false, error: "No entry price available" });
            continue;
          }
          const tradeValue = buyingPower * Math.min(Math.max(suggestedPct, 0.01), 0.1);
          const quantity = Math.floor(tradeValue / price);
          if (quantity < 1) {
            results.push({ decisionId, success: false, error: "Calculated quantity less than 1 share" });
            continue;
          }
          const orderResult = await alpacaTradingEngine.executeAlpacaTrade({
            symbol: decision.symbol,
            side: decision.action,
            quantity
          });
          if (orderResult.success) {
            results.push({ decisionId, success: true, order: orderResult.order });
          } else {
            results.push({ decisionId, success: false, error: orderResult.error });
          }
        } catch (err) {
          results.push({ decisionId, success: false, error: String(err) });
        }
      }
      const successCount = results.filter((r) => r.success).length;
      res.json({
        success: successCount > 0,
        message: `Executed ${successCount}/${decisionIds.length} trades`,
        results
      });
    } catch (error) {
      console.error("Failed to execute trades:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/autonomous/open-orders", authMiddleware2, async (req, res) => {
    try {
      const orders2 = await alpacaTradingEngine.getOpenOrders();
      res.json(orders2);
    } catch (error) {
      console.error("Failed to get open orders:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/cancel-stale-orders", authMiddleware2, async (req, res) => {
    try {
      const { maxAgeMinutes } = req.body;
      const result = await alpacaTradingEngine.cancelStaleOrders(maxAgeMinutes || 60);
      res.json({ success: true, ...result });
    } catch (error) {
      console.error("Failed to cancel stale orders:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/cancel-all-orders", authMiddleware2, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.cancelAllOpenOrders();
      res.json({ success: result.cancelled > 0, ...result });
    } catch (error) {
      console.error("Failed to cancel all orders:", error);
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/orchestration/status", authMiddleware2, async (req, res) => {
    try {
      const status = coordinator.getStatus();
      const config = coordinator.getConfig();
      res.json({ status, config });
    } catch (error) {
      console.error("Get orchestration status error:", error);
      res.status(500).json({ error: "Failed to get orchestration status" });
    }
  });
  app2.post("/api/orchestration/start", authMiddleware2, async (req, res) => {
    try {
      await coordinator.start();
      res.json({ success: true, message: "Coordinator started" });
    } catch (error) {
      console.error("Start coordinator error:", error);
      res.status(500).json({ error: "Failed to start coordinator" });
    }
  });
  app2.post("/api/orchestration/stop", authMiddleware2, async (req, res) => {
    try {
      await coordinator.stop();
      res.json({ success: true, message: "Coordinator stopped" });
    } catch (error) {
      console.error("Stop coordinator error:", error);
      res.status(500).json({ error: "Failed to stop coordinator" });
    }
  });
  app2.put("/api/orchestration/config", authMiddleware2, async (req, res) => {
    try {
      const updates = req.body;
      coordinator.updateConfig(updates);
      res.json({ success: true, config: coordinator.getConfig() });
    } catch (error) {
      console.error("Update orchestration config error:", error);
      res.status(500).json({ error: "Failed to update configuration" });
    }
  });
  app2.get("/api/orchestration/logs", authMiddleware2, async (req, res) => {
    try {
      const { level, category, limit: limit4 } = req.query;
      const logs = logger.getLogs({
        level,
        category,
        limit: limit4 ? parseInt(limit4) : 100
      });
      res.json({ logs, stats: logger.getStats() });
    } catch (error) {
      console.error("Get logs error:", error);
      res.status(500).json({ error: "Failed to get logs" });
    }
  });
  app2.get("/api/orchestration/logs/errors", authMiddleware2, async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const errors = logger.getErrorLogs(limit4 ? parseInt(limit4) : 50);
      res.json({ errors });
    } catch (error) {
      console.error("Get error logs error:", error);
      res.status(500).json({ error: "Failed to get error logs" });
    }
  });
  app2.get("/api/orchestration/events", authMiddleware2, async (req, res) => {
    try {
      const { type, source, limit: limit4 } = req.query;
      const events = eventBus.getEventHistory({
        type,
        source,
        limit: limit4 ? parseInt(limit4) : 50
      });
      res.json({ events, stats: eventBus.getStats() });
    } catch (error) {
      console.error("Get events error:", error);
      res.status(500).json({ error: "Failed to get events" });
    }
  });
  app2.post("/api/orchestration/reset-stats", authMiddleware2, async (req, res) => {
    try {
      coordinator.resetStats();
      res.json({ success: true, message: "Statistics reset" });
    } catch (error) {
      console.error("Reset stats error:", error);
      res.status(500).json({ error: "Failed to reset statistics" });
    }
  });
}

// server/routes/cache.ts
init_logger();
import { Router as Router20 } from "express";
init_persistentApiCache();
init_llmGateway();
var router18 = Router20();
router18.get("/llm/stats", async (req, res) => {
  try {
    const stats = getLLMCacheStats();
    res.json(stats);
  } catch (error) {
    log.error("CacheAPI", `Failed to get LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get cache stats" });
  }
});
router18.post("/llm/clear", async (req, res) => {
  try {
    clearLLMCache();
    res.json({ success: true, message: "LLM cache cleared" });
  } catch (error) {
    log.error("CacheAPI", `Failed to clear LLM cache: ${error}`);
    res.status(500).json({ error: "Failed to clear cache" });
  }
});
router18.post("/llm/clear/:role", async (req, res) => {
  try {
    const { role } = req.params;
    if (!role) {
      return badRequest(res, "Role parameter is required");
    }
    clearLLMCacheForRole(role);
    res.json({ success: true, message: `Cache cleared for role: ${role}` });
  } catch (error) {
    log.error("CacheAPI", `Failed to clear LLM cache for role: ${error}`);
    res.status(500).json({ error: "Failed to clear cache for role" });
  }
});
router18.post("/llm/reset-stats", async (req, res) => {
  try {
    resetLLMCacheStats();
    res.json({ success: true, message: "Cache statistics reset" });
  } catch (error) {
    log.error("CacheAPI", `Failed to reset LLM cache stats: ${error}`);
    res.status(500).json({ error: "Failed to reset cache stats" });
  }
});
router18.get("/api", async (req, res) => {
  try {
    const { provider } = req.query;
    const providerFilter = typeof provider === "string" ? provider : void 0;
    const stats = await getCacheStats(providerFilter);
    const entries = await getAllCacheEntries(providerFilter);
    res.json({ stats, entries });
  } catch (error) {
    log.error("CacheAPI", `Failed to get API cache stats: ${error}`);
    res.status(500).json({ error: "Failed to get API cache stats" });
  }
});
router18.post("/api/purge", async (req, res) => {
  try {
    const { provider, key, expiredOnly } = req.body;
    if (!provider && !expiredOnly) {
      return badRequest(
        res,
        "Either 'provider' or 'expiredOnly' must be specified"
      );
    }
    let purgedCount = 0;
    let message = "";
    if (provider && key) {
      purgedCount = await invalidateCache(provider, key);
      message = `Invalidated cache for ${provider}:${key}`;
    } else if (provider && !expiredOnly) {
      purgedCount = await invalidateCache(provider);
      message = `Invalidated all cache entries for ${provider}`;
    } else {
      purgedCount = await purgeExpiredCache();
      message = provider ? `Purged expired cache entries (provider filter not supported for expired purge)` : "Purged all expired cache entries";
    }
    res.json({ success: true, purgedCount, message });
  } catch (error) {
    log.error("CacheAPI", `Failed to purge API cache: ${error}`);
    res.status(500).json({ error: "Failed to purge API cache" });
  }
});
var cache_default = router18;

// server/routes/llm.ts
init_logger();
import { Router as Router21 } from "express";
var router19 = Router21();
router19.get("/configs", async (req, res) => {
  try {
    const configs = await getAllRoleConfigs();
    const availableProviders = roleBasedRouter.getAvailableProviders();
    res.json({ configs, availableProviders });
  } catch (error) {
    log.error("LLMAPI", `Failed to get role configs: ${error}`);
    res.status(500).json({ error: "Failed to get role configurations" });
  }
});
router19.put("/configs/:role", async (req, res) => {
  try {
    const { role } = req.params;
    const validRoles = [
      "market_news_summarizer",
      "technical_analyst",
      "risk_manager",
      "execution_planner",
      "post_trade_reporter"
    ];
    if (!validRoles.includes(role)) {
      return badRequest(
        res,
        `Invalid role. Must be one of: ${validRoles.join(", ")}`
      );
    }
    const updates = req.body;
    const updated = await updateRoleConfig(role, updates);
    res.json({ success: true, config: updated });
  } catch (error) {
    log.error("LLMAPI", `Failed to update role config: ${error}`);
    res.status(500).json({ error: "Failed to update role configuration" });
  }
});
router19.get("/calls", async (req, res) => {
  try {
    const { role, limit: limit4 } = req.query;
    const limitNum = parseInt(limit4) || 20;
    const roleFilter = typeof role === "string" ? role : void 0;
    const calls = await getRecentCalls(limitNum, roleFilter);
    res.json({ calls, count: calls.length });
  } catch (error) {
    log.error("LLMAPI", `Failed to get recent LLM calls: ${error}`);
    res.status(500).json({ error: "Failed to get recent LLM calls" });
  }
});
router19.get("/stats", async (req, res) => {
  try {
    const stats = await getCallStats();
    res.json(stats);
  } catch (error) {
    log.error("LLMAPI", `Failed to get LLM call stats: ${error}`);
    res.status(500).json({ error: "Failed to get LLM call statistics" });
  }
});
var llm_default = router19;

// server/admin/registry.ts
init_logger();
var moduleRegistry = /* @__PURE__ */ new Map();
function registerAdminModule(module) {
  if (moduleRegistry.has(module.id)) {
    log.warn("AdminRegistry", `Module ${module.id} already registered, overwriting`);
  }
  const registeredModule = {
    ...module,
    enabled: module.enabled ?? true,
    priority: module.priority ?? 100,
    version: module.version ?? "1.0.0"
  };
  moduleRegistry.set(module.id, registeredModule);
  log.info("AdminRegistry", `Registered module: ${module.id}`, { title: module.title, navGroup: module.navGroup });
  return { success: true, moduleId: module.id };
}
function getModules() {
  return Array.from(moduleRegistry.values()).filter((m) => m.enabled).sort((a, b) => (a.priority ?? 100) - (b.priority ?? 100));
}
function getModule(moduleId) {
  return moduleRegistry.get(moduleId);
}
async function getAdminOverview() {
  const modules = getModules();
  const moduleStatuses = modules.map((m) => ({
    id: m.id,
    title: m.title,
    navGroup: m.navGroup,
    enabled: m.enabled ?? true,
    health: void 0
  }));
  const unhealthyCount = moduleStatuses.filter((m) => m.health?.status === "unhealthy").length;
  const degradedCount = moduleStatuses.filter((m) => m.health?.status === "degraded").length;
  let overall = "healthy";
  if (unhealthyCount > 0) overall = "unhealthy";
  else if (degradedCount > 0) overall = "degraded";
  return {
    modules: moduleStatuses,
    systemHealth: {
      overall,
      unhealthyCount,
      degradedCount
    }
  };
}
function initializeDefaultModules() {
  registerAdminModule({
    id: "api-budget",
    title: "API Budgets",
    description: "Monitor rate limits, budget usage, and cache status for all providers",
    icon: "activity",
    navGroup: "system",
    capability: "admin:read",
    route: "ApiBudget",
    apiEndpoints: [
      "/api/admin/api-usage",
      "/api/admin/api-cache",
      "/api/admin/provider-status"
    ],
    priority: 10
  });
  registerAdminModule({
    id: "model-router",
    title: "LLM Model Router",
    description: "Role-based routing, fallback chains, cost tracking, and call logs",
    icon: "git-branch",
    navGroup: "ai",
    capability: "admin:read",
    route: "ModelRouter",
    apiEndpoints: [
      "/api/admin/model-router/configs",
      "/api/admin/model-router/calls",
      "/api/admin/model-router/stats"
    ],
    priority: 10
  });
  registerAdminModule({
    id: "connector-health",
    title: "Connector Health",
    description: "Monitor external API connector status and sync times",
    icon: "database",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/connectors-health"],
    priority: 20
  });
  registerAdminModule({
    id: "data-fusion",
    title: "Data Fusion Engine",
    description: "Intelligence score, active sources, and capabilities overview",
    icon: "layers",
    navGroup: "ai",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/data-fusion-status"],
    priority: 20
  });
  registerAdminModule({
    id: "ai-config",
    title: "AI Configuration",
    description: "Auto-execute trades, conservative mode, and confidence thresholds",
    icon: "cpu",
    navGroup: "ai",
    capability: "admin:write",
    apiEndpoints: ["/api/admin/ai-config"],
    settingsSchema: {
      sections: [
        {
          id: "trading",
          title: "Trading Settings",
          fields: [
            {
              key: "autoExecuteTrades",
              label: "Auto-Execute Trades",
              type: "boolean",
              description: "Allow AI to execute trades automatically without approval",
              defaultValue: false
            },
            {
              key: "conservativeMode",
              label: "Conservative Mode",
              type: "boolean",
              description: "Require 85% confidence instead of 70%",
              defaultValue: false
            }
          ]
        }
      ]
    },
    priority: 30
  });
  registerAdminModule({
    id: "api-keys",
    title: "API Keys",
    description: "View configured API keys status across all providers",
    icon: "key",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: ["/api/admin/api-keys-status"],
    priority: 30
  });
  registerAdminModule({
    id: "work-queue",
    title: "Work Queue",
    description: "Monitor pending, processing, and failed work items",
    icon: "list",
    navGroup: "system",
    capability: "admin:read",
    apiEndpoints: [
      "/api/admin/work-items",
      "/api/admin/work-items/retry",
      "/api/admin/work-items/dead-letter"
    ],
    priority: 15
  });
  registerAdminModule({
    id: "orchestrator",
    title: "Orchestrator",
    description: "Trading agent status, cycle management, and kill switch",
    icon: "play-circle",
    navGroup: "trading",
    capability: "trading:manage",
    apiEndpoints: ["/api/admin/orchestrator-health"],
    priority: 5
  });
  registerAdminModule({
    id: "debate-arena",
    title: "AI Debate Arena",
    description: "Multi-role AI consensus system with debate sessions and voting",
    icon: "message-circle",
    navGroup: "ai",
    capability: "admin:read",
    route: "Debate",
    apiEndpoints: [
      "/api/debate/sessions",
      "/api/debate/sessions/:id"
    ],
    priority: 25
  });
  registerAdminModule({
    id: "competition",
    title: "Competition Mode",
    description: "AI trader profiles competing with performance tracking",
    icon: "award",
    navGroup: "ai",
    capability: "admin:read",
    route: "Competition",
    apiEndpoints: [
      "/api/competition/traders",
      "/api/competition/runs"
    ],
    priority: 26
  });
  registerAdminModule({
    id: "strategy-studio",
    title: "Strategy Studio",
    description: "Strategy versioning, activation, and configuration",
    icon: "layers",
    navGroup: "trading",
    capability: "trading:manage",
    route: "Strategies",
    apiEndpoints: [
      "/api/strategies/versions"
    ],
    priority: 6
  });
  registerAdminModule({
    id: "tool-router",
    title: "Tool Registry",
    description: "MCP-style tool router with invocation audit trail",
    icon: "tool",
    navGroup: "ai",
    capability: "admin:read",
    route: "Tools",
    apiEndpoints: [
      "/api/tools",
      "/api/tools/invoke",
      "/api/tools/invocations"
    ],
    priority: 27
  });
  log.info("AdminRegistry", `Initialized ${moduleRegistry.size} default modules`);
}

// server/admin/rbac.ts
var ROLE_CAPABILITIES = {
  admin: [
    "admin:read",
    "admin:write",
    "admin:danger",
    "trading:read",
    "trading:write",
    "trading:manage",
    "system:read",
    "system:write",
    "ai:read",
    "ai:write"
  ],
  operator: [
    "admin:read",
    "admin:write",
    "trading:read",
    "trading:write",
    "trading:manage",
    "system:read",
    "ai:read",
    "ai:write"
  ],
  viewer: [
    "admin:read",
    "trading:read",
    "system:read",
    "ai:read"
  ],
  guest: []
};
function getRoleFromUser(user) {
  return user.isAdmin ? "admin" : "viewer";
}
function getCapabilitiesForRole(role) {
  return ROLE_CAPABILITIES[role] || [];
}
function hasCapability(context, capability) {
  return context.capabilities.includes(capability);
}
function createRBACContext(user) {
  const role = getRoleFromUser(user);
  return {
    userId: user.id,
    username: user.username,
    isAdmin: user.isAdmin,
    role,
    capabilities: getCapabilitiesForRole(role)
  };
}
function filterModulesByCapability(modules, context) {
  return modules.filter((module) => hasCapability(context, module.capability));
}
function getAllRoles() {
  return ["admin", "operator", "viewer", "guest"];
}
function getRoleInfo(role) {
  const descriptions = {
    admin: "Full access to all admin features including dangerous operations",
    operator: "Can manage trading and view all data, but no destructive operations",
    viewer: "Read-only access to dashboards and data",
    guest: "No access to admin features"
  };
  return {
    role,
    capabilities: getCapabilitiesForRole(role),
    description: descriptions[role]
  };
}

// server/admin/global-search.ts
init_db();
init_schema();
import { like as like5, or as or4, eq as eq25, desc as desc18 } from "drizzle-orm";
async function globalSearch(query, limit4 = 50) {
  if (!query || query.length < 2) {
    return { query, totalResults: 0, results: [], byType: {} };
  }
  const likePattern = `%${query}%`;
  const results = [];
  const aiDecisionResults = await db.select().from(aiDecisions).where(
    or4(
      like5(aiDecisions.traceId, likePattern),
      like5(aiDecisions.symbol, likePattern),
      like5(aiDecisions.id, likePattern)
    )
  ).orderBy(desc18(aiDecisions.createdAt)).limit(limit4);
  for (const r of aiDecisionResults) {
    results.push({
      type: "ai_decision",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.action} ${r.symbol} - ${r.reasoning?.substring(0, 50) || "No reason"}`
    });
  }
  const tradeResults = await db.select().from(trades).where(
    or4(
      like5(trades.traceId, likePattern),
      like5(trades.symbol, likePattern),
      like5(trades.id, likePattern)
    )
  ).orderBy(desc18(trades.executedAt)).limit(limit4);
  for (const r of tradeResults) {
    results.push({
      type: "trade",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.executedAt,
      summary: `${r.side} ${r.quantity} ${r.symbol} @ $${r.price}`
    });
  }
  const orderResults = await db.select().from(orders).where(
    or4(
      like5(orders.traceId, likePattern),
      like5(orders.symbol, likePattern),
      like5(orders.id, likePattern),
      like5(orders.brokerOrderId, likePattern),
      like5(orders.clientOrderId, likePattern)
    )
  ).orderBy(desc18(orders.createdAt)).limit(limit4);
  for (const r of orderResults) {
    results.push({
      type: "order",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.side} ${r.qty || r.notional} ${r.symbol} - ${r.status}`
    });
  }
  const fillResults = await db.select().from(fills).where(
    or4(
      like5(fills.traceId, likePattern),
      like5(fills.symbol, likePattern),
      like5(fills.id, likePattern),
      like5(fills.brokerOrderId, likePattern)
    )
  ).orderBy(desc18(fills.createdAt)).limit(limit4);
  for (const r of fillResults) {
    results.push({
      type: "fill",
      id: r.id,
      traceId: r.traceId,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.side} ${r.qty} ${r.symbol} @ $${r.price}`
    });
  }
  const workItemResults = await db.select().from(workItems).where(
    or4(
      like5(workItems.id, likePattern),
      like5(workItems.idempotencyKey, likePattern),
      like5(workItems.symbol, likePattern)
    )
  ).orderBy(desc18(workItems.createdAt)).limit(limit4);
  for (const r of workItemResults) {
    results.push({
      type: "work_item",
      id: r.id,
      traceId: null,
      symbol: r.symbol,
      createdAt: r.createdAt,
      summary: `${r.type} - ${r.status}`
    });
  }
  const llmCallResults = await db.select().from(llmCalls).where(
    or4(
      like5(llmCalls.traceId, likePattern),
      like5(llmCalls.id, likePattern)
    )
  ).orderBy(desc18(llmCalls.createdAt)).limit(limit4);
  for (const r of llmCallResults) {
    results.push({
      type: "llm_call",
      id: r.id,
      traceId: r.traceId,
      symbol: null,
      createdAt: r.createdAt,
      summary: `${r.role} via ${r.provider} - ${r.status}`
    });
  }
  results.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  const limitedResults = results.slice(0, limit4);
  const byType = {};
  for (const r of limitedResults) {
    byType[r.type] = (byType[r.type] || 0) + 1;
  }
  return {
    query,
    totalResults: limitedResults.length,
    results: limitedResults,
    byType
  };
}
async function getRelatedEntities(traceId) {
  const [aiDecisionResults, tradeResults, orderResults, fillResults, llmCallResults] = await Promise.all([
    db.select().from(aiDecisions).where(eq25(aiDecisions.traceId, traceId)),
    db.select().from(trades).where(eq25(trades.traceId, traceId)),
    db.select().from(orders).where(eq25(orders.traceId, traceId)),
    db.select().from(fills).where(eq25(fills.traceId, traceId)),
    db.select().from(llmCalls).where(eq25(llmCalls.traceId, traceId))
  ]);
  return {
    aiDecisions: aiDecisionResults,
    trades: tradeResults,
    orders: orderResults,
    fills: fillResults,
    llmCalls: llmCallResults
  };
}

// server/routes.ts
init_audit_logger();
init_logger();
var isProduction = process.env.NODE_ENV === "production";
function getCookieOptions2() {
  return {
    httpOnly: true,
    secure: isProduction,
    sameSite: isProduction ? "none" : "lax",
    maxAge: 7 * 24 * 60 * 60 * 1e3,
    path: "/"
  };
}
async function authMiddleware(req, res, next) {
  try {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      log.warn("Auth", "No session cookie found for request:", { path: req.path });
      return res.status(401).json({
        error: "Not authenticated",
        code: "NO_SESSION",
        message: "Please log in to access this resource"
      });
    }
    const session = await getSession(sessionId);
    if (!session) {
      log.warn("Auth", "Session expired or invalid:", { sessionId: sessionId.substring(0, 8) + "..." });
      return res.status(401).json({
        error: "Session expired",
        code: "SESSION_EXPIRED",
        message: "Your session has expired. Please log in again."
      });
    }
    req.userId = session.userId;
    next();
  } catch (error) {
    log.error("Auth", "Middleware error", { error });
    return res.status(500).json({
      error: "Authentication error",
      code: "AUTH_ERROR",
      message: "An error occurred while verifying your session"
    });
  }
}
function requireCapability(...capabilities) {
  return async (req, res, next) => {
    if (!req.userId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const user = await storage.getUser(req.userId);
    if (!user) {
      return res.status(401).json({ error: "User not found" });
    }
    const rbacContext = createRBACContext(user);
    req.rbac = rbacContext;
    const hasRequiredCapability = capabilities.some((cap) => hasCapability(rbacContext, cap));
    if (!hasRequiredCapability) {
      return res.status(403).json({
        error: "Forbidden",
        message: `Requires one of: ${capabilities.join(", ")}`,
        userCapabilities: rbacContext.capabilities
      });
    }
    next();
  };
}
async function registerRoutes(app2) {
  log.info("Routes", "Starting route registration...");
  initializeDefaultModules();
  log.info("Routes", "Admin module registry initialized");
  setTimeout(() => {
    log.info("Routes", "Starting delayed initializations...");
    coordinator.start().catch(
      (err) => log.error("Routes", "Failed to start trading coordinator", { error: err })
    );
    alpacaTradingEngine.initialize().catch(
      (err) => log.error("Routes", "Failed to initialize Alpaca trading engine", { error: err })
    );
    orchestrator.autoStart().catch(
      (err) => log.error("Routes", "Failed to auto-start orchestrator", { error: err })
    );
    workQueue.startWorker(5e3);
    log.info("Routes", "Work queue worker started with 5s poll interval");
    alpacaStream.connect().catch((err) => {
      log.error("Routes", "Failed to connect to Alpaca stream", { error: err });
    });
    log.info("Routes", "Alpaca trade updates stream connecting...");
    setInterval(async () => {
      try {
        const traceId = `reconcile-${Date.now()}`;
        await workQueue.enqueue({
          type: "ORDER_SYNC",
          payload: JSON.stringify({ traceId }),
          idempotencyKey: `ORDER_SYNC:periodic:${Math.floor(Date.now() / 45e3)}`
        });
        log.info("Routes", "Periodic order reconciliation triggered");
      } catch (err) {
        log.error("Routes", "Failed to trigger order reconciliation", { error: err });
      }
    }, 45e3);
    log.info("Routes", "Order reconciliation job scheduled (45s interval)");
  }, 2e3);
  setTimeout(async () => {
    try {
      log.info("Bootstrap", "Checking for admin user...");
      const adminUser = await storage.getUserByUsername("admintest");
      log.info("Bootstrap", "Admin user check complete:", { status: adminUser ? "exists" : "not found" });
      if (!adminUser) {
        const hashedPassword = await bcrypt2.hash("admin1234", 10);
        await storage.createUser({ username: "admintest", password: hashedPassword, isAdmin: true });
        log.info("Bootstrap", "Created admin user: admintest");
      } else {
        if (!adminUser.isAdmin) {
          await storage.updateUser(adminUser.id, { isAdmin: true });
          log.info("Bootstrap", "Promoted admintest to admin");
        } else {
          log.info("Bootstrap", "Admin user admintest already exists");
        }
      }
    } catch (err) {
      log.error("Bootstrap", "Failed to create admin user", { error: err });
    }
  }, 3e3);
  log.info("Routes", "Continuing registration (admin bootstrap deferred)...");
  app2.use("/api", auditLogger);
  log.info("Routes", "Audit logging middleware enabled for all API routes");
  app2.use("/api/backtests", authMiddleware, backtests_default);
  app2.use("/api/traces", authMiddleware, tracesRouter);
  app2.use("/api/admin/observability", authMiddleware, observabilityRouter);
  app2.use("/api/admin/providers", authMiddleware, providers_default);
  app2.use("/api/debate", authMiddleware, debate_default);
  app2.use("/api/tools", authMiddleware, tools_default);
  app2.use("/api/competition", authMiddleware, competition_default);
  app2.use("/api/strategies", authMiddleware, strategies_default);
  app2.use("/api/arena", authMiddleware, arena_default);
  app2.use("/api/jina", authMiddleware, jina_default);
  app2.use("/api/macro", authMiddleware, macro_default);
  app2.use("/api/enrichment", authMiddleware, enrichment_default);
  app2.use("/api", auth_default);
  app2.use("/api", authMiddleware, positions_default);
  app2.use("/api", authMiddleware, orders_default);
  app2.use("/api", authMiddleware, trades_default);
  app2.use("/api", authMiddleware, market_data_default);
  app2.use("/api", authMiddleware, webhooks_default);
  app2.use("/api", authMiddleware, ai_decisions_default);
  registerAutonomousRoutes(app2, authMiddleware);
  app2.use("/api", authMiddleware, cache_default);
  app2.use("/api", authMiddleware, llm_default);
  alertService.startEvaluationJob(6e4);
  enrichmentScheduler.start();
  app2.post("/api/auth/signup", async (req, res) => {
    try {
      const parsed = insertUserSchema.safeParse(req.body);
      if (!parsed.success) {
        return validationError(res, "Invalid input: username and password required", parsed.error);
      }
      const { username, password } = parsed.data;
      const sanitizedUsername = sanitizeInput(username);
      if (sanitizedUsername.length < 3) {
        return badRequest(res, "Username must be at least 3 characters");
      }
      if (password.length < 6) {
        return badRequest(res, "Password must be at least 6 characters");
      }
      const existingUser = await storage.getUserByUsername(sanitizedUsername);
      if (existingUser) {
        return badRequest(res, "Username already taken");
      }
      const hashedPassword = await bcrypt2.hash(password, 10);
      const user = await storage.createUser({ username: sanitizedUsername, password: hashedPassword });
      const sessionId = await createSession(user.id);
      res.cookie("session", sessionId, getCookieOptions2());
      res.status(201).json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
    } catch (error) {
      log.error("Routes", "Signup error", { error });
      return serverError(res, "Failed to create account");
    }
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      const sanitizedUsername = sanitizeInput(username);
      if (!username || !password) {
        return badRequest(res, "Username and password required");
      }
      const user = await storage.getUserByUsername(sanitizedUsername);
      if (!user) {
        return unauthorized(res, "Invalid username or password");
      }
      const validPassword = await bcrypt2.compare(password, user.password);
      if (!validPassword) {
        return unauthorized(res, "Invalid username or password");
      }
      const sessionId = await createSession(user.id);
      res.cookie("session", sessionId, getCookieOptions2());
      res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
    } catch (error) {
      log.error("Routes", "Login error", { error });
      return serverError(res, "Failed to login");
    }
  });
  app2.post("/api/auth/logout", async (req, res) => {
    try {
      const sessionId = req.cookies?.session;
      if (sessionId) {
        await deleteSession(sessionId);
      }
      const { maxAge, ...clearOptions } = getCookieOptions2();
      res.clearCookie("session", clearOptions);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to logout" });
    }
  });
  app2.get("/api/auth/me", async (req, res) => {
    try {
      const sessionId = req.cookies?.session;
      if (!sessionId) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const session = await getSession(sessionId);
      if (!session) {
        return res.status(401).json({ error: "Session expired" });
      }
      const user = await storage.getUser(session.userId);
      if (!user) {
        await deleteSession(sessionId);
        return res.status(401).json({ error: "User not found" });
      }
      res.json({ id: user.id, username: user.username, isAdmin: user.isAdmin });
    } catch (error) {
      res.status(500).json({ error: "Failed to get user" });
    }
  });
  app2.get("/api/events", async (req, res) => {
    const sessionId = req.cookies?.session;
    if (!sessionId) {
      return res.status(401).json({ error: "Not authenticated" });
    }
    const session = await getSession(sessionId);
    if (!session) {
      return res.status(401).json({ error: "Session expired" });
    }
    const userId = session.userId;
    const clientId = `${userId}-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    const { sseEmitter: sseEmitter2 } = (init_sse_emitter(), __toCommonJS(sse_emitter_exports));
    sseEmitter2.addClient(clientId, res, userId);
    req.on("close", () => {
      sseEmitter2.removeClient(clientId, userId);
    });
  });
  app2.get("/api/agent/status", authMiddleware, async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      if (!status) {
        const defaultStatus = await storage.updateAgentStatus({
          isRunning: false,
          totalTrades: 0,
          totalPnl: "0"
        });
        return res.json(defaultStatus);
      }
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: "Failed to get agent status" });
    }
  });
  app2.post("/api/agent/toggle", authMiddleware, async (req, res) => {
    try {
      const currentStatus = await storage.getAgentStatus();
      const newIsRunning = !(currentStatus?.isRunning ?? false);
      if (newIsRunning) {
        await alpacaTradingEngine.resumeAgent();
      } else {
        await alpacaTradingEngine.stopAllStrategies();
      }
      const status = await storage.getAgentStatus();
      res.json(status);
    } catch (error) {
      log.error("Routes", "Failed to toggle agent", { error });
      res.status(500).json({ error: "Failed to toggle agent" });
    }
  });
  app2.get("/api/autonomous/state", authMiddleware, async (req, res) => {
    try {
      const state = orchestrator.getState();
      const riskLimits = orchestrator.getRiskLimits();
      res.json({
        ...state,
        riskLimits,
        activePositions: Array.from(state.activePositions.entries()).map(([key, pos]) => ({
          ...pos,
          symbol: key
        })),
        pendingSignals: Array.from(state.pendingSignals.entries()).map(([symbol, signal]) => ({
          symbol,
          ...signal
        }))
      });
    } catch (error) {
      log.error("Routes", "Failed to get autonomous state", { error });
      res.status(500).json({ error: "Failed to get autonomous state" });
    }
  });
  app2.post("/api/autonomous/start", authMiddleware, async (req, res) => {
    try {
      await orchestrator.start();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      log.error("Routes", "Failed to start autonomous mode", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/stop", authMiddleware, async (req, res) => {
    try {
      await orchestrator.stop();
      const state = orchestrator.getState();
      res.json({ success: true, mode: state.mode, isRunning: state.isRunning });
    } catch (error) {
      log.error("Routes", "Failed to stop autonomous mode", { error });
      res.status(500).json({ error: "Failed to stop autonomous mode" });
    }
  });
  app2.post("/api/autonomous/kill-switch", authMiddleware, async (req, res) => {
    try {
      const { activate, reason } = req.body;
      if (activate) {
        await orchestrator.activateKillSwitch(reason || "Manual activation");
      } else {
        await orchestrator.deactivateKillSwitch();
      }
      const state = orchestrator.getState();
      res.json({ success: true, killSwitchActive: orchestrator.getRiskLimits().killSwitchActive, state });
    } catch (error) {
      log.error("Routes", "Failed to toggle kill switch", { error });
      res.status(500).json({ error: "Failed to toggle kill switch" });
    }
  });
  app2.put("/api/autonomous/risk-limits", authMiddleware, async (req, res) => {
    try {
      const {
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      } = req.body;
      await orchestrator.updateRiskLimits({
        maxPositionSizePercent,
        maxTotalExposurePercent,
        maxPositionsCount,
        dailyLossLimitPercent
      });
      res.json({ success: true, riskLimits: orchestrator.getRiskLimits() });
    } catch (error) {
      log.error("Routes", "Failed to update risk limits", { error });
      res.status(500).json({ error: "Failed to update risk limits" });
    }
  });
  app2.post("/api/autonomous/mode", authMiddleware, async (req, res) => {
    try {
      const { mode } = req.body;
      if (!["autonomous", "semi-auto", "manual"].includes(mode)) {
        return res.status(400).json({ error: "Invalid mode. Use: autonomous, semi-auto, or manual" });
      }
      await orchestrator.setMode(mode);
      res.json({ success: true, mode: orchestrator.getMode() });
    } catch (error) {
      log.error("Routes", "Failed to set mode", { error });
      res.status(500).json({ error: "Failed to set mode" });
    }
  });
  app2.get("/api/agent/market-analysis", authMiddleware, async (req, res) => {
    try {
      const analyzerStatus = marketConditionAnalyzer.getStatus();
      const lastAnalysis = marketConditionAnalyzer.getLastAnalysis();
      res.json({
        isRunning: analyzerStatus.isRunning,
        lastAnalysis,
        lastAnalysisTime: analyzerStatus.lastAnalysisTime,
        currentOrderLimit: analyzerStatus.currentOrderLimit
      });
    } catch (error) {
      log.error("Routes", "Failed to get market analysis", { error });
      res.status(500).json({ error: "Failed to get market analysis" });
    }
  });
  app2.post("/api/agent/market-analysis/refresh", authMiddleware, async (req, res) => {
    try {
      const analysis = await marketConditionAnalyzer.runAnalysis();
      res.json({ success: true, analysis });
    } catch (error) {
      log.error("Routes", "Failed to refresh market analysis", { error });
      res.status(500).json({ error: "Failed to refresh market analysis" });
    }
  });
  app2.get("/api/agent/dynamic-limits", authMiddleware, async (req, res) => {
    try {
      const agentStatus2 = await storage.getAgentStatus();
      const analyzerStatus = marketConditionAnalyzer.getStatus();
      const minLimit = agentStatus2?.minOrderLimit ?? 10;
      const maxLimit = agentStatus2?.maxOrderLimit ?? 50;
      let currentLimit = agentStatus2?.dynamicOrderLimit ?? analyzerStatus.currentOrderLimit ?? 25;
      currentLimit = Math.max(minLimit, Math.min(maxLimit, currentLimit));
      res.json({
        currentDynamicLimit: currentLimit,
        minOrderLimit: minLimit,
        maxOrderLimit: maxLimit,
        marketCondition: agentStatus2?.marketCondition || "neutral",
        aiConfidenceScore: agentStatus2?.aiConfidenceScore || "0.5",
        lastMarketAnalysis: agentStatus2?.lastMarketAnalysis
      });
    } catch (error) {
      log.error("Routes", "Failed to get dynamic limits", { error });
      res.status(500).json({ error: "Failed to get dynamic limits" });
    }
  });
  app2.post("/api/agent/set-limits", authMiddleware, async (req, res) => {
    try {
      const { minOrderLimit, maxOrderLimit } = req.body;
      const updates = {};
      if (minOrderLimit !== void 0) {
        if (minOrderLimit < 1 || minOrderLimit > 100) {
          return res.status(400).json({ error: "minOrderLimit must be between 1 and 100" });
        }
        updates.minOrderLimit = minOrderLimit;
      }
      if (maxOrderLimit !== void 0) {
        if (maxOrderLimit < 1 || maxOrderLimit > 100) {
          return res.status(400).json({ error: "maxOrderLimit must be between 1 and 100" });
        }
        updates.maxOrderLimit = maxOrderLimit;
      }
      if (updates.minOrderLimit && updates.maxOrderLimit && updates.minOrderLimit > updates.maxOrderLimit) {
        return res.status(400).json({ error: "minOrderLimit cannot be greater than maxOrderLimit" });
      }
      await storage.updateAgentStatus(updates);
      const updatedStatus = await storage.getAgentStatus();
      res.json({
        success: true,
        minOrderLimit: updatedStatus?.minOrderLimit,
        maxOrderLimit: updatedStatus?.maxOrderLimit
      });
    } catch (error) {
      log.error("Routes", "Failed to set limits", { error });
      res.status(500).json({ error: "Failed to set limits" });
    }
  });
  app2.get("/api/agent/health", authMiddleware, async (req, res) => {
    try {
      const healthStatus = orchestrator.getHealthStatus();
      const agentStatus2 = await storage.getAgentStatus();
      res.json({
        ...healthStatus,
        autoStartEnabled: agentStatus2?.autoStartEnabled ?? true,
        lastHeartbeatFromDb: agentStatus2?.lastHeartbeat
      });
    } catch (error) {
      log.error("Routes", "Failed to get agent health", { error });
      res.status(500).json({ error: "Failed to get agent health" });
    }
  });
  app2.post("/api/agent/auto-start", authMiddleware, async (req, res) => {
    try {
      const { enabled } = req.body;
      if (typeof enabled !== "boolean") {
        return res.status(400).json({ error: "enabled must be a boolean" });
      }
      await orchestrator.setAutoStartEnabled(enabled);
      res.json({ success: true, autoStartEnabled: enabled });
    } catch (error) {
      log.error("Routes", "Failed to set auto-start", { error });
      res.status(500).json({ error: "Failed to set auto-start" });
    }
  });
  app2.get("/api/autonomous/execution-history", authMiddleware, async (req, res) => {
    try {
      const state = orchestrator.getState();
      res.json(state.executionHistory);
    } catch (error) {
      res.status(500).json({ error: "Failed to get execution history" });
    }
  });
  app2.post("/api/autonomous/close-position", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const result = await alpacaTradingEngine.closeAlpacaPosition(symbol);
      if (result.success) {
        res.json({ success: true, message: `Position ${symbol} closed successfully`, result });
      } else {
        res.status(400).json({ success: false, error: result.error || "Failed to close position" });
      }
    } catch (error) {
      log.error("Routes", "Failed to close position", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/execute-trades", authMiddleware, async (req, res) => {
    try {
      const { decisionIds } = req.body;
      if (!decisionIds || !Array.isArray(decisionIds) || decisionIds.length === 0) {
        return res.status(400).json({ error: "Decision IDs array is required" });
      }
      const results = [];
      for (const decisionId of decisionIds) {
        const decisions = await storage.getAiDecisions(100);
        const decision = decisions.find((d) => d.id === decisionId);
        if (!decision) {
          results.push({ decisionId, success: false, error: "Decision not found" });
          continue;
        }
        try {
          const metadata = decision.metadata ? JSON.parse(decision.metadata) : {};
          const suggestedPct = metadata?.suggestedQuantity ? parseFloat(String(metadata.suggestedQuantity)) : 0.05;
          const account = await alpaca.getAccount();
          const buyingPower = parseFloat(account.buying_power);
          const price = parseFloat(decision.entryPrice || "0");
          if (!price) {
            results.push({ decisionId, success: false, error: "No entry price available" });
            continue;
          }
          const tradeValue = buyingPower * Math.min(Math.max(suggestedPct, 0.01), 0.1);
          const quantity = Math.floor(tradeValue / price);
          if (quantity < 1) {
            results.push({ decisionId, success: false, error: "Calculated quantity less than 1 share" });
            continue;
          }
          const orderResult = await alpacaTradingEngine.executeAlpacaTrade({
            symbol: decision.symbol,
            side: decision.action,
            quantity
          });
          if (orderResult.success) {
            results.push({ decisionId, success: true, order: orderResult.order });
          } else {
            results.push({ decisionId, success: false, error: orderResult.error });
          }
        } catch (err) {
          results.push({ decisionId, success: false, error: String(err) });
        }
      }
      const successCount = results.filter((r) => r.success).length;
      res.json({
        success: successCount > 0,
        message: `Executed ${successCount}/${decisionIds.length} trades`,
        results
      });
    } catch (error) {
      log.error("Routes", "Failed to execute trades", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/autonomous/open-orders", authMiddleware, async (req, res) => {
    try {
      const orders2 = await alpacaTradingEngine.getOpenOrders();
      res.json(orders2);
    } catch (error) {
      log.error("Routes", "Failed to get open orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/cancel-stale-orders", authMiddleware, async (req, res) => {
    try {
      const { maxAgeMinutes } = req.body;
      const result = await alpacaTradingEngine.cancelStaleOrders(maxAgeMinutes || 60);
      res.json({ success: true, ...result });
    } catch (error) {
      log.error("Routes", "Failed to cancel stale orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/cancel-all-orders", authMiddleware, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.cancelAllOpenOrders();
      res.json({ success: result.cancelled > 0, ...result });
    } catch (error) {
      log.error("Routes", "Failed to cancel all orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/autonomous/reconcile-positions", authMiddleware, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.reconcilePositions();
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to reconcile positions", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/sync-positions", authMiddleware, async (req, res) => {
    try {
      const userId = req.userId;
      const result = await alpacaTradingEngine.syncPositionsFromAlpaca(userId);
      res.json({ success: true, ...result });
    } catch (error) {
      log.error("Routes", "Failed to sync positions", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/autonomous/close-all-positions", authMiddleware, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.closeAllPositions();
      res.json({ success: true, ...result });
    } catch (error) {
      log.error("Routes", "Failed to close all positions", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/orders/unreal", authMiddleware, async (req, res) => {
    try {
      const unrealOrders = await identifyUnrealOrders();
      res.json({
        count: unrealOrders.length,
        orders: unrealOrders
      });
    } catch (error) {
      log.error("Routes", "Failed to identify unreal orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/orders/cleanup", authMiddleware, async (req, res) => {
    try {
      const result = await cleanupUnrealOrders();
      res.json({
        success: result.errors.length === 0,
        identified: result.identified,
        canceled: result.canceled,
        errors: result.errors
      });
    } catch (error) {
      log.error("Routes", "Failed to cleanup unreal orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/orders/reconcile", authMiddleware, async (req, res) => {
    try {
      const result = await reconcileOrderBook();
      res.json({
        success: true,
        alpacaOrders: result.alpacaOrders,
        localTrades: result.localTrades,
        missingLocal: result.missingLocal,
        orphanedLocal: result.orphanedLocal,
        synced: result.synced
      });
    } catch (error) {
      log.error("Routes", "Failed to reconcile order book", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/orders/execution-engine/status", authMiddleware, async (req, res) => {
    try {
      const activeExecutions = orderExecutionEngine.getActiveExecutions();
      const executions = Array.from(activeExecutions.entries()).map(([id, state]) => ({
        clientOrderId: id,
        orderId: state.orderId,
        symbol: state.symbol,
        side: state.side,
        status: state.status,
        attempts: state.attempts,
        createdAt: state.createdAt.toISOString(),
        updatedAt: state.updatedAt.toISOString()
      }));
      res.json({
        activeCount: executions.length,
        executions
      });
    } catch (error) {
      log.error("Routes", "Failed to get execution engine status", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/strategies", authMiddleware, async (req, res) => {
    try {
      const strategies2 = await storage.getStrategies();
      res.json(strategies2);
    } catch (error) {
      res.status(500).json({ error: "Failed to get strategies" });
    }
  });
  app2.get("/api/strategies/:id", authMiddleware, async (req, res) => {
    try {
      const strategy = await storage.getStrategy(req.params.id);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      res.json(strategy);
    } catch (error) {
      res.status(500).json({ error: "Failed to get strategy" });
    }
  });
  app2.post("/api/strategies", authMiddleware, async (req, res) => {
    try {
      const parsed = insertStrategySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const strategy = await storage.createStrategy(parsed.data);
      res.status(201).json(strategy);
    } catch (error) {
      res.status(500).json({ error: "Failed to create strategy" });
    }
  });
  app2.patch("/api/strategies/:id", authMiddleware, async (req, res) => {
    try {
      const strategy = await storage.updateStrategy(req.params.id, req.body);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      res.json(strategy);
    } catch (error) {
      res.status(500).json({ error: "Failed to update strategy" });
    }
  });
  app2.put("/api/strategies/:id", authMiddleware, async (req, res) => {
    try {
      const strategy = await storage.updateStrategy(req.params.id, req.body);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      res.json(strategy);
    } catch (error) {
      res.status(500).json({ error: "Failed to update strategy" });
    }
  });
  app2.post("/api/strategies/:id/toggle", authMiddleware, async (req, res) => {
    try {
      const currentStrategy = await storage.getStrategy(req.params.id);
      if (!currentStrategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      const strategy = await storage.toggleStrategy(req.params.id, !currentStrategy.isActive);
      res.json(strategy);
    } catch (error) {
      res.status(500).json({ error: "Failed to toggle strategy" });
    }
  });
  app2.post("/api/strategies/:id/start", authMiddleware, async (req, res) => {
    try {
      const strategy = await storage.getStrategy(req.params.id);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      const result = await alpacaTradingEngine.startStrategy(req.params.id);
      if (!result.success) {
        return res.status(400).json({ error: result.error || "Failed to start strategy" });
      }
      const updatedStrategy = await storage.getStrategy(req.params.id);
      res.json(updatedStrategy);
    } catch (error) {
      log.error("Routes", "Failed to start strategy", { error });
      res.status(500).json({ error: "Failed to start strategy" });
    }
  });
  app2.post("/api/strategies/:id/stop", authMiddleware, async (req, res) => {
    try {
      const strategy = await storage.getStrategy(req.params.id);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      const result = await alpacaTradingEngine.stopStrategy(req.params.id);
      if (!result.success) {
        return res.status(400).json({ error: result.error || "Failed to stop strategy" });
      }
      const updatedStrategy = await storage.getStrategy(req.params.id);
      res.json(updatedStrategy);
    } catch (error) {
      log.error("Routes", "Failed to stop strategy", { error });
      res.status(500).json({ error: "Failed to stop strategy" });
    }
  });
  app2.get("/api/strategies/moving-average/schema", authMiddleware, async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error("Routes", "Failed to get MA strategy schema", { error });
      res.status(500).json({ error: "Failed to get strategy schema" });
    }
  });
  app2.post("/api/strategies/moving-average/backtest", authMiddleware, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2, backtestMovingAverageStrategy: backtestMovingAverageStrategy2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const config = normalizeMovingAverageConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMovingAverageStrategy2(config, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to run MA backtest", { error });
      res.status(500).json({ error: error.message || "Failed to run backtest" });
    }
  });
  app2.post("/api/strategies/moving-average/ai-validate", authMiddleware, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const { validateMovingAverageConfig: validateMovingAverageConfig2, getValidatorStatus: getValidatorStatus2 } = await Promise.resolve().then(() => (init_ai_strategy_validator(), ai_strategy_validator_exports));
      const status = getValidatorStatus2();
      if (!status.available) {
        return res.status(503).json({ error: "AI validation service is not available" });
      }
      const config = normalizeMovingAverageConfig2(req.body.config || req.body);
      const marketIntelligence = req.body.marketIntelligence;
      const result = await validateMovingAverageConfig2(config, marketIntelligence);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to AI validate strategy", { error });
      res.status(500).json({ error: error.message || "Failed to validate strategy" });
    }
  });
  app2.get("/api/strategies/mean-reversion/schema", authMiddleware, async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error("Routes", "Failed to get mean reversion strategy schema", { error });
      res.status(500).json({ error: "Failed to get strategy schema" });
    }
  });
  app2.post("/api/strategies/mean-reversion/backtest", authMiddleware, async (req, res) => {
    try {
      const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      const config = normalizeMeanReversionConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMeanReversionStrategy2(config, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to run mean reversion backtest", { error });
      res.status(500).json({ error: error.message || "Failed to run backtest" });
    }
  });
  app2.post("/api/strategies/mean-reversion/signal", authMiddleware, async (req, res) => {
    try {
      const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, generateMeanReversionSignal: generateMeanReversionSignal2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
      const config = normalizeMeanReversionConfig2(req.body.config || req.body);
      const prices = req.body.prices;
      if (!prices || !Array.isArray(prices) || prices.length < config.lookbackPeriod) {
        return res.status(400).json({ error: `Need at least ${config.lookbackPeriod} price points` });
      }
      const signal = generateMeanReversionSignal2(prices, config);
      res.json(signal);
    } catch (error) {
      log.error("Routes", "Failed to generate mean reversion signal", { error });
      res.status(500).json({ error: error.message || "Failed to generate signal" });
    }
  });
  app2.get("/api/strategies/momentum/schema", authMiddleware, async (req, res) => {
    try {
      const { STRATEGY_SCHEMA: STRATEGY_SCHEMA4 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      res.json(STRATEGY_SCHEMA4);
    } catch (error) {
      log.error("Routes", "Failed to get momentum strategy schema", { error });
      res.status(500).json({ error: "Failed to get strategy schema" });
    }
  });
  app2.post("/api/strategies/momentum/backtest", authMiddleware, async (req, res) => {
    try {
      const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      const config = normalizeMomentumConfig2(req.body);
      const lookbackDays = parseInt(req.query.lookbackDays) || 365;
      const result = await backtestMomentumStrategy2(config, lookbackDays);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to run momentum backtest", { error });
      res.status(500).json({ error: error.message || "Failed to run backtest" });
    }
  });
  app2.post("/api/strategies/momentum/signal", authMiddleware, async (req, res) => {
    try {
      const { normalizeMomentumConfig: normalizeMomentumConfig2, generateMomentumSignal: generateMomentumSignal2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
      const config = normalizeMomentumConfig2(req.body.config || req.body);
      const prices = req.body.prices;
      const requiredLength = Math.max(config.lookbackPeriod, config.rsiPeriod) + 1;
      if (!prices || !Array.isArray(prices) || prices.length < requiredLength) {
        return res.status(400).json({ error: `Need at least ${requiredLength} price points` });
      }
      const signal = generateMomentumSignal2(prices, config);
      res.json(signal);
    } catch (error) {
      log.error("Routes", "Failed to generate momentum signal", { error });
      res.status(500).json({ error: error.message || "Failed to generate signal" });
    }
  });
  app2.get("/api/strategies/all-schemas", authMiddleware, async (req, res) => {
    try {
      const { ALL_STRATEGIES: ALL_STRATEGIES2 } = await Promise.resolve().then(() => (init_strategies(), strategies_exports));
      res.json(ALL_STRATEGIES2);
    } catch (error) {
      log.error("Routes", "Failed to get all strategy schemas", { error });
      res.status(500).json({ error: "Failed to get strategy schemas" });
    }
  });
  app2.post("/api/strategies/backtest", authMiddleware, async (req, res) => {
    try {
      const { strategyType, symbol, lookbackDays = 365 } = req.body;
      const parameters = req.body.parameters || {};
      if (!strategyType || typeof strategyType !== "string") {
        return res.status(400).json({
          error: "strategyType is required",
          message: "Please provide a valid strategy type (e.g., 'moving-average-crossover', 'momentum', 'mean-reversion')"
        });
      }
      if (!symbol || typeof symbol !== "string") {
        return res.status(400).json({
          error: "symbol is required",
          message: "Please provide a valid trading symbol (e.g., 'SPY', 'AAPL')"
        });
      }
      let result;
      switch (strategyType) {
        case "moving-average-crossover":
        case "moving-average": {
          const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2, backtestMovingAverageStrategy: backtestMovingAverageStrategy2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
          const config = normalizeMovingAverageConfig2({ symbol, ...parameters });
          result = await backtestMovingAverageStrategy2(config, lookbackDays);
          break;
        }
        case "mean-reversion":
        case "mean-reversion-scalper": {
          const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
          const config = normalizeMeanReversionConfig2({ symbol, ...parameters });
          result = await backtestMeanReversionStrategy2(config, lookbackDays);
          break;
        }
        case "momentum":
        case "momentum-breakout": {
          const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
          const config = normalizeMomentumConfig2({ symbol, ...parameters });
          result = await backtestMomentumStrategy2(config, lookbackDays);
          break;
        }
        case "range-trading":
        case "breakout": {
          const { normalizeMeanReversionConfig: normalizeMeanReversionConfig2, backtestMeanReversionStrategy: backtestMeanReversionStrategy2 } = await Promise.resolve().then(() => (init_mean_reversion_scalper(), mean_reversion_scalper_exports));
          const defaultParams = {
            lookbackPeriod: parameters?.lookbackPeriod ?? 20,
            deviationThreshold: parameters?.deviationThreshold ?? 2,
            maxHoldingPeriod: parameters?.maxHoldingPeriod ?? 10,
            ...parameters
          };
          const config = normalizeMeanReversionConfig2({ symbol, ...defaultParams });
          result = await backtestMeanReversionStrategy2(config, lookbackDays);
          break;
        }
        default: {
          const { normalizeMomentumConfig: normalizeMomentumConfig2, backtestMomentumStrategy: backtestMomentumStrategy2 } = await Promise.resolve().then(() => (init_momentum_strategy(), momentum_strategy_exports));
          const config = normalizeMomentumConfig2({ symbol, ...parameters });
          result = await backtestMomentumStrategy2(config, lookbackDays);
          break;
        }
      }
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to run generic backtest", { error });
      res.status(500).json({ error: error.message || "Failed to run backtest" });
    }
  });
  app2.post("/api/strategy-config", authMiddleware, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const config = normalizeMovingAverageConfig2(req.body);
      res.json(config);
    } catch (error) {
      log.error("Routes", "Failed to normalize strategy config", { error });
      res.status(500).json({ error: error.message || "Failed to normalize config" });
    }
  });
  app2.post("/api/strategy-validate", authMiddleware, async (req, res) => {
    try {
      const { normalizeMovingAverageConfig: normalizeMovingAverageConfig2 } = await Promise.resolve().then(() => (init_moving_average_crossover(), moving_average_crossover_exports));
      const { validateMovingAverageConfig: validateMovingAverageConfig2, getValidatorStatus: getValidatorStatus2 } = await Promise.resolve().then(() => (init_ai_strategy_validator(), ai_strategy_validator_exports));
      const status = getValidatorStatus2();
      if (!status.available) {
        return res.status(503).json({ error: "AI validation service is not available" });
      }
      const config = normalizeMovingAverageConfig2(req.body.config || req.body);
      const result = await validateMovingAverageConfig2(config);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to validate strategy", { error });
      res.status(500).json({ error: error.message || "Failed to validate strategy" });
    }
  });
  app2.get("/api/trades", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const trades3 = await storage.getTrades(req.userId, limit4);
      res.json(trades3);
    } catch (error) {
      res.status(500).json({ error: "Failed to get trades" });
    }
  });
  app2.get("/api/trades/enriched", authMiddleware, async (req, res) => {
    try {
      const filters = {
        limit: parseInt(req.query.limit) || 20,
        offset: parseInt(req.query.offset) || 0,
        symbol: req.query.symbol,
        strategyId: req.query.strategyId,
        pnlDirection: req.query.pnlDirection || "all",
        startDate: req.query.startDate ? new Date(req.query.startDate) : void 0,
        endDate: req.query.endDate ? new Date(req.query.endDate) : void 0
      };
      const result = await storage.getTradesFiltered(req.userId, filters);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to get enriched trades", { error });
      res.status(500).json({ error: "Failed to get enriched trades" });
    }
  });
  app2.get("/api/trades/symbols", authMiddleware, async (req, res) => {
    try {
      const symbols = await storage.getDistinctSymbols();
      res.json(symbols);
    } catch (error) {
      res.status(500).json({ error: "Failed to get symbols" });
    }
  });
  app2.get("/api/trades/:id", authMiddleware, async (req, res) => {
    try {
      const trade = await storage.getTrade(req.params.id);
      if (!trade) {
        return res.status(404).json({ error: "Trade not found" });
      }
      res.json(trade);
    } catch (error) {
      res.status(500).json({ error: "Failed to get trade" });
    }
  });
  app2.get("/api/trades/:id/enriched", authMiddleware, async (req, res) => {
    try {
      const trade = await storage.getEnrichedTrade(req.params.id);
      if (!trade) {
        return res.status(404).json({ error: "Trade not found" });
      }
      res.json(trade);
    } catch (error) {
      res.status(500).json({ error: "Failed to get enriched trade" });
    }
  });
  app2.post("/api/trades", authMiddleware, async (req, res) => {
    try {
      const parsed = insertTradeSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const trade = await storage.createTrade(parsed.data);
      res.status(201).json(trade);
    } catch (error) {
      res.status(500).json({ error: "Failed to create trade" });
    }
  });
  app2.get("/api/positions/snapshot", authMiddleware, async (req, res) => {
    try {
      const [alpacaAccount, alpacaPositions] = await Promise.all([
        alpaca.getAccount(),
        alpaca.getPositions()
      ]);
      const equity = parseFloat(alpacaAccount.equity);
      const lastEquity = parseFloat(alpacaAccount.last_equity);
      const buyingPower = parseFloat(alpacaAccount.buying_power);
      const cash = parseFloat(alpacaAccount.cash);
      const portfolioValue = parseFloat(alpacaAccount.portfolio_value);
      const dailyPl = equity - lastEquity;
      const dailyPlPct = lastEquity > 0 ? dailyPl / lastEquity * 100 : 0;
      const positions2 = alpacaPositions.map((pos) => ({
        id: pos.asset_id,
        symbol: pos.symbol,
        side: pos.side === "long" ? "long" : "short",
        qty: parseFloat(pos.qty),
        entryPrice: parseFloat(pos.avg_entry_price),
        currentPrice: parseFloat(pos.current_price),
        marketValue: parseFloat(pos.market_value),
        unrealizedPl: parseFloat(pos.unrealized_pl),
        unrealizedPlPct: parseFloat(pos.unrealized_plpc) * 100,
        costBasis: parseFloat(pos.cost_basis),
        assetClass: pos.asset_class === "crypto" ? "crypto" : "us_equity"
      }));
      const totalUnrealizedPl = positions2.reduce((sum, pos) => sum + pos.unrealizedPl, 0);
      const trades3 = await storage.getTrades(100);
      const closedTrades = trades3.filter((t) => t.pnl !== null && t.pnl !== "");
      const totalRealizedPl = closedTrades.reduce((sum, t) => sum + parseFloat(t.pnl || "0"), 0);
      const snapshot = {
        totalEquity: equity,
        buyingPower,
        cash,
        portfolioValue,
        dailyPl,
        dailyPlPct,
        totalPl: totalRealizedPl + totalUnrealizedPl,
        totalPlPct: lastEquity > 0 ? (totalRealizedPl + totalUnrealizedPl) / lastEquity * 100 : 0,
        positions: positions2,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        positionCount: positions2.length,
        longPositions: positions2.filter((p) => p.side === "long").length,
        shortPositions: positions2.filter((p) => p.side === "short").length,
        totalRealizedPl,
        totalUnrealizedPl
      };
      res.json(snapshot);
    } catch (error) {
      log.error("Routes", "Get portfolio snapshot error", { error });
      res.status(500).json({ error: "Failed to get portfolio snapshot", message: error.message });
    }
  });
  app2.get("/api/positions", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    const DUST_THRESHOLD = 1e-4;
    try {
      const positions2 = await alpaca.getPositions();
      const filteredPositions = positions2.filter((p) => {
        const qty = Math.abs(parseFloat(p.qty || "0"));
        return qty >= DUST_THRESHOLD;
      });
      storage.syncPositionsFromAlpaca(req.userId, filteredPositions).catch(
        (err) => log.error("Routes", "Failed to sync positions to database", { error: err })
      );
      const enrichedPositions = filteredPositions.map((p) => mapAlpacaPositionToEnriched(p, fetchedAt));
      res.json({
        positions: enrichedPositions,
        _source: createLiveSourceMetadata()
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch positions from Alpaca", { error });
      res.status(503).json({
        error: "Live position data unavailable from Alpaca",
        _source: createUnavailableSourceMetadata(),
        message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
      });
    }
  });
  app2.get("/api/positions/broker", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    const DUST_THRESHOLD = 1e-4;
    try {
      const positions2 = await alpaca.getPositions();
      const filteredPositions = positions2.filter((p) => {
        const qty = Math.abs(parseFloat(p.qty || "0"));
        return qty >= DUST_THRESHOLD;
      });
      const enrichedPositions = filteredPositions.map((p) => mapAlpacaPositionToEnriched(p, fetchedAt));
      res.json({
        positions: enrichedPositions,
        _source: createLiveSourceMetadata()
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch broker positions", { error });
      res.status(503).json({
        error: "Failed to fetch positions from broker",
        _source: createUnavailableSourceMetadata(),
        message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
      });
    }
  });
  app2.get("/api/positions/:id", authMiddleware, async (req, res) => {
    try {
      const position = await storage.getPosition(req.params.id);
      if (!position) {
        return res.status(404).json({ error: "Position not found" });
      }
      res.json(position);
    } catch (error) {
      res.status(500).json({ error: "Failed to get position" });
    }
  });
  app2.post("/api/positions", authMiddleware, async (req, res) => {
    try {
      const parsed = insertPositionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const position = await storage.createPosition(parsed.data);
      res.status(201).json(position);
    } catch (error) {
      res.status(500).json({ error: "Failed to create position" });
    }
  });
  app2.patch("/api/positions/:id", authMiddleware, async (req, res) => {
    try {
      const position = await storage.updatePosition(req.params.id, req.body);
      if (!position) {
        return res.status(404).json({ error: "Position not found" });
      }
      res.json(position);
    } catch (error) {
      res.status(500).json({ error: "Failed to update position" });
    }
  });
  app2.delete("/api/positions/:id", authMiddleware, async (req, res) => {
    try {
      const deleted = await storage.deletePosition(req.params.id);
      if (!deleted) {
        return res.status(404).json({ error: "Position not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete position" });
    }
  });
  app2.post("/api/positions/reconcile", authMiddleware, async (req, res) => {
    try {
      const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
      const force = req.query.force === "true";
      const result = await positionReconciler2.reconcile(force);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Position reconciliation failed", { error });
      res.status(500).json({ error: "Failed to reconcile positions" });
    }
  });
  app2.get("/api/positions/reconcile/status", authMiddleware, async (req, res) => {
    try {
      const { positionReconciler: positionReconciler2 } = await Promise.resolve().then(() => (init_position_reconciler(), position_reconciler_exports));
      const status = positionReconciler2.getStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: "Failed to get reconciliation status" });
    }
  });
  app2.get("/api/portfolio/snapshot", authMiddleware, async (req, res) => {
    try {
      const userId = req.userId;
      const account = await alpaca.getAccount();
      const positions2 = await storage.getPositions(userId);
      const totalEquity = parseFloat(account.equity);
      const totalCash = parseFloat(account.cash);
      const todayPnL = parseFloat(account.equity) - parseFloat(account.last_equity);
      const totalPositionValue = positions2.reduce((sum, pos) => sum + parseFloat(pos.currentPrice) * parseFloat(pos.quantity), 0);
      res.json({
        totalEquity,
        totalCash,
        todayPnL,
        totalPositions: positions2.length,
        totalPositionValue,
        buyingPower: parseFloat(account.buying_power),
        portfolioValue: parseFloat(account.portfolio_value),
        lastEquity: parseFloat(account.last_equity),
        accountStatus: account.status,
        daytradeCount: parseInt(account.daytrade_count),
        patternDayTrader: account.pattern_day_trader
      });
    } catch (error) {
      log.error("Routes", "Failed to get portfolio snapshot", { error });
      res.status(500).json({ error: "Failed to get portfolio snapshot" });
    }
  });
  app2.get("/api/trading/candidates", authMiddleware, async (req, res) => {
    try {
      const userId = req.userId;
      const recentDecisions = await storage.getAiDecisions(userId, 50);
      const candidates = recentDecisions.filter(
        (d) => (d.action === "buy" || d.action === "sell") && d.status === "pending" && (d.confidence || 0) >= 0.6
      ).map((d) => ({
        symbol: d.symbol,
        action: d.action,
        confidence: d.confidence,
        reasoning: d.reasoning,
        createdAt: d.createdAt,
        entryPrice: d.entryPrice,
        stopLoss: d.stopLoss,
        takeProfit: d.takeProfit
      })).slice(0, 20);
      res.json(candidates);
    } catch (error) {
      log.error("Routes", "Failed to get trading candidates", { error });
      res.status(500).json({ error: "Failed to get trading candidates" });
    }
  });
  app2.get("/api/autonomous/status", authMiddleware, async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      const userId = req.userId;
      const recentDecisions = await storage.getAiDecisions(userId, 10);
      const positions2 = await storage.getPositions(userId);
      res.json({
        isRunning: status.isRunning,
        killSwitchActive: status.killSwitchActive,
        lastRunTime: status.lastRunTime,
        consecutiveErrors: status.consecutiveErrors,
        activePositions: positions2.length,
        recentDecisions: recentDecisions.length,
        lastDecisionTime: recentDecisions[0]?.createdAt || null,
        config: status.config || {}
      });
    } catch (error) {
      log.error("Routes", "Failed to get autonomous status", { error });
      res.status(500).json({ error: "Failed to get autonomous status" });
    }
  });
  app2.get("/api/ai-decisions", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 20;
      const decisions = await storage.getAiDecisions(req.userId, limit4);
      res.json(decisions);
    } catch (error) {
      res.status(500).json({ error: "Failed to get AI decisions" });
    }
  });
  app2.get("/api/ai-decisions/history", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 100;
      const offset = parseInt(req.query.offset) || 0;
      const statusFilter = req.query.status;
      const actionFilter = req.query.action;
      const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
      let filtered = decisions.slice(offset, offset + limit4);
      if (statusFilter) {
        filtered = filtered.filter((d) => d.status === statusFilter);
      }
      if (actionFilter) {
        filtered = filtered.filter((d) => d.action === actionFilter);
      }
      const pendingAnalysis = orchestrator.getPendingAnalysis?.() || [];
      res.json({
        decisions: filtered,
        total: decisions.length,
        hasMore: offset + limit4 < decisions.length,
        pendingAnalysis
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get AI decision history" });
    }
  });
  app2.post("/api/ai-decisions", authMiddleware, async (req, res) => {
    try {
      const parsed = insertAiDecisionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const decision = await storage.createAiDecision(parsed.data);
      res.status(201).json(decision);
    } catch (error) {
      res.status(500).json({ error: "Failed to create AI decision" });
    }
  });
  app2.get("/api/ai-decisions/enriched", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const statusFilter = req.query.status;
      const decisions = await storage.getAiDecisions(req.userId, limit4 + offset);
      const enrichedDecisions = await Promise.all(
        decisions.slice(offset, offset + limit4).map(async (decision) => {
          const enriched = {
            decision,
            linkedOrder: null,
            linkedTrade: null,
            linkedPosition: null,
            timeline: []
          };
          enriched.timeline.push({
            stage: "decision",
            status: "completed",
            timestamp: decision.createdAt,
            details: `${decision.action.toUpperCase()} signal with ${parseFloat(decision.confidence || "0").toFixed(1)}% confidence`
          });
          if (decision.status === "skipped") {
            enriched.timeline.push({
              stage: "risk_gate",
              status: "skipped",
              timestamp: decision.createdAt,
              details: decision.skipReason || "Trade blocked by risk rules"
            });
          } else if (decision.status === "executed" || decision.executedTradeId) {
            enriched.timeline.push({
              stage: "risk_gate",
              status: "completed",
              timestamp: decision.createdAt,
              details: "Risk check passed"
            });
          } else if (decision.status === "pending") {
            enriched.timeline.push({
              stage: "risk_gate",
              status: "pending",
              timestamp: null,
              details: "Awaiting risk evaluation"
            });
          }
          if (decision.id) {
            try {
              const linkedOrders = await storage.getOrdersByDecisionId(decision.id);
              if (linkedOrders.length > 0) {
                const order = linkedOrders[0];
                enriched.linkedOrder = order;
                enriched.timeline.push({
                  stage: "order",
                  status: order.status === "filled" || order.status === "partially_filled" ? "completed" : order.status === "pending_new" || order.status === "accepted" ? "pending" : "failed",
                  timestamp: order.submittedAt,
                  details: `${order.side.toUpperCase()} ${order.qty || order.notional} @ ${order.type}`
                });
                if (order.filledAt) {
                  enriched.timeline.push({
                    stage: "fill",
                    status: "completed",
                    timestamp: order.filledAt,
                    details: `Filled ${order.filledQty} @ ${order.filledAvgPrice}`
                  });
                } else if (order.status === "pending_new" || order.status === "accepted") {
                  enriched.timeline.push({
                    stage: "fill",
                    status: "pending",
                    timestamp: null,
                    details: "Awaiting fill"
                  });
                }
              }
            } catch (e) {
            }
          }
          if (decision.executedTradeId) {
            try {
              const trade = await storage.getTrade(decision.executedTradeId);
              if (trade) {
                enriched.linkedTrade = trade;
              }
            } catch (e) {
            }
          }
          try {
            const positions2 = await storage.getPositions();
            const symbolPosition = positions2.find((p) => p.symbol.toUpperCase() === decision.symbol.toUpperCase());
            if (symbolPosition) {
              enriched.linkedPosition = symbolPosition;
              enriched.timeline.push({
                stage: "position",
                status: "completed",
                timestamp: symbolPosition.openedAt,
                details: `${symbolPosition.side} ${symbolPosition.quantity} @ ${symbolPosition.entryPrice}`
              });
            }
          } catch (e) {
          }
          return enriched;
        })
      );
      let filtered = enrichedDecisions;
      if (statusFilter) {
        filtered = enrichedDecisions.filter((e) => e.decision.status === statusFilter);
      }
      res.json({
        enrichedDecisions: filtered,
        total: decisions.length,
        hasMore: offset + limit4 < decisions.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get enriched AI decisions", { error });
      res.status(500).json({ error: "Failed to get enriched AI decisions" });
    }
  });
  app2.get("/api/activity/timeline", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const cursor = req.query.cursor;
      const categoryFilter = req.query.category;
      const [decisions, brokerOrders, trades3] = await Promise.all([
        storage.getAiDecisions(limit4 * 2),
        alpaca.getOrders("all", limit4).catch(() => []),
        storage.getTrades(limit4)
      ]);
      const alpacaConnected = brokerOrders.length > 0 || decisions.some((d) => d.executedTradeId);
      const alpacaStatus = alpacaConnected ? "live" : "unavailable";
      const events = [];
      for (const d of decisions) {
        const status = d.status === "filled" || d.status === "executed" ? "success" : d.status === "skipped" || d.status === "rejected" ? "warning" : d.status === "pending" || d.status === "pending_execution" ? "pending" : d.status === "failed" ? "error" : "info";
        const subtitle = d.action === "hold" ? "No action taken" : d.skipReason ? `Skipped: ${d.skipReason}` : `${d.action.toUpperCase()} ${d.symbol}`;
        events.push({
          id: `decision-${d.id}`,
          ts: new Date(d.createdAt).toISOString(),
          category: "decision",
          title: `AI Decision: ${d.action.toUpperCase()} ${d.symbol}`,
          subtitle: d.confidence ? `Confidence: ${(parseFloat(d.confidence) * 100).toFixed(0)}%` : null,
          status,
          entityLinks: {
            decisionId: d.id,
            symbol: d.symbol,
            strategyId: d.strategyId ?? void 0,
            tradeId: d.executedTradeId ?? void 0
          },
          provenance: {
            provider: "ai-decision-engine",
            cacheStatus: "unknown"
          },
          details: {
            action: d.action,
            confidence: d.confidence,
            reasoning: d.reasoning?.substring(0, 200),
            entryPrice: d.entryPrice,
            stopLoss: d.stopLoss,
            takeProfit: d.takeProfit
          }
        });
      }
      for (const o of brokerOrders) {
        const status = o.status === "filled" ? "success" : o.status === "canceled" || o.status === "expired" ? "warning" : o.status === "rejected" ? "error" : "pending";
        const filledInfo = o.filled_qty && parseFloat(o.filled_qty) > 0 ? `${o.filled_qty} @ $${parseFloat(o.filled_avg_price || "0").toFixed(2)}` : `${o.qty} shares`;
        events.push({
          id: `order-${o.id}`,
          ts: o.submitted_at,
          category: o.status === "filled" ? "fill" : "order",
          title: `${o.side.toUpperCase()} ${o.symbol}`,
          subtitle: filledInfo,
          status,
          entityLinks: {
            brokerOrderId: o.id,
            symbol: o.symbol
          },
          provenance: {
            provider: "alpaca",
            cacheStatus: "fresh"
          },
          details: {
            orderId: o.id,
            orderType: o.order_type,
            timeInForce: o.time_in_force,
            limitPrice: o.limit_price,
            stopPrice: o.stop_price,
            filledQty: o.filled_qty,
            filledAvgPrice: o.filled_avg_price,
            brokerStatus: o.status
          }
        });
      }
      for (const t of trades3) {
        const matchingOrder = brokerOrders.find(
          (o) => o.symbol === t.symbol && o.status === "filled" && Math.abs(new Date(o.filled_at || 0).getTime() - new Date(t.executedAt).getTime()) < 6e4
        );
        if (matchingOrder) continue;
        const pnl = t.pnl ? parseFloat(t.pnl) : null;
        const status = pnl !== null ? pnl >= 0 ? "success" : "warning" : "info";
        events.push({
          id: `trade-${t.id}`,
          ts: new Date(t.executedAt).toISOString(),
          category: "fill",
          title: `${t.side.toUpperCase()} ${t.symbol}`,
          subtitle: `${t.quantity} @ $${parseFloat(t.price).toFixed(2)}`,
          status,
          entityLinks: {
            tradeId: t.id,
            symbol: t.symbol,
            strategyId: t.strategyId ?? void 0
          },
          provenance: {
            provider: "database",
            cacheStatus: "unknown"
          },
          details: {
            quantity: t.quantity,
            price: t.price,
            pnl: t.pnl
          }
        });
      }
      let filteredEvents = events;
      if (categoryFilter && categoryFilter !== "all") {
        filteredEvents = events.filter((e) => e.category === categoryFilter);
      }
      filteredEvents.sort((a, b) => new Date(b.ts).getTime() - new Date(a.ts).getTime());
      let startIdx = 0;
      if (cursor) {
        const cursorIdx = filteredEvents.findIndex((e) => e.id === cursor);
        if (cursorIdx >= 0) startIdx = cursorIdx + 1;
      }
      const paginatedEvents = filteredEvents.slice(startIdx, startIdx + limit4);
      const hasMore = startIdx + limit4 < filteredEvents.length;
      const nextCursor = hasMore ? paginatedEvents[paginatedEvents.length - 1]?.id : null;
      res.json({
        events: paginatedEvents,
        hasMore,
        cursor: nextCursor,
        meta: {
          alpacaConnected,
          alpacaStatus,
          totalEvents: filteredEvents.length,
          fetchedAt: fetchedAt.toISOString()
        }
      });
    } catch (error) {
      log.error("Routes", "Timeline fetch error", { error });
      res.status(500).json({
        error: "Failed to fetch activity timeline",
        meta: {
          alpacaConnected: false,
          alpacaStatus: "unavailable",
          totalEvents: 0
        }
      });
    }
  });
  app2.post("/api/trades/backfill-prices", authMiddleware, async (req, res) => {
    try {
      const trades3 = await storage.getTrades(500);
      const zeroTrades = trades3.filter((t) => safeParseFloat(t.price, 0) === 0);
      if (zeroTrades.length === 0) {
        return res.json({ message: "No trades need backfilling", updated: 0 });
      }
      let orders2 = [];
      try {
        orders2 = await alpaca.getOrders("all", 500);
      } catch (e) {
        log.error("Routes", "Failed to fetch Alpaca orders for backfill", { error: e });
        return res.status(500).json({ error: "Failed to fetch order history from broker" });
      }
      let updated = 0;
      for (const trade of zeroTrades) {
        const matchingOrder = orders2.find(
          (o) => o.symbol === trade.symbol && o.side === trade.side && o.status === "filled" && safeParseFloat(o.filled_avg_price, 0) > 0 && Math.abs(new Date(o.filled_at).getTime() - new Date(trade.executedAt).getTime()) < 6e4
        );
        if (matchingOrder) {
          const filledPrice = safeParseFloat(matchingOrder.filled_avg_price, 0);
          const filledQty = safeParseFloat(matchingOrder.filled_qty, 0);
          await storage.updateTrade(trade.id, {
            price: filledPrice.toString(),
            quantity: filledQty.toString(),
            status: "filled"
          });
          updated++;
        }
      }
      res.json({
        message: `Backfilled ${updated} of ${zeroTrades.length} trades`,
        updated,
        remaining: zeroTrades.length - updated
      });
    } catch (error) {
      log.error("Routes", "Trade backfill error", { error });
      res.status(500).json({ error: "Failed to backfill trade prices" });
    }
  });
  app2.get("/api/orders", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const status = req.query.status;
      let orders2;
      if (status) {
        orders2 = await storage.getOrdersByStatus(req.userId, status, limit4);
      } else {
        orders2 = await storage.getRecentOrders(req.userId, limit4);
      }
      res.json({
        orders: orders2,
        _source: {
          type: "database",
          table: "orders",
          fetchedAt: fetchedAt.toISOString(),
          note: "Orders stored in local database, synced from broker"
        }
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch orders", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/fills", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const orders2 = await storage.getRecentOrders(req.userId, 100);
      const orderIds = orders2.map((o) => o.id);
      let allFills = [];
      for (const orderId of orderIds) {
        const fills2 = await storage.getFillsByOrderId(orderId);
        allFills = allFills.concat(fills2);
      }
      allFills.sort(
        (a, b) => new Date(b.occurredAt).getTime() - new Date(a.occurredAt).getTime()
      );
      allFills = allFills.slice(0, limit4);
      res.json({
        fills: allFills,
        _source: {
          type: "database",
          table: "fills",
          fetchedAt: fetchedAt.toISOString()
        }
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch fills", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/fills/order/:orderId", authMiddleware, async (req, res) => {
    try {
      const { orderId } = req.params;
      let fills2 = await storage.getFillsByOrderId(orderId);
      if (fills2.length === 0) {
        fills2 = await storage.getFillsByBrokerOrderId(orderId);
      }
      res.json({
        fills: fills2,
        _source: {
          type: "database",
          table: "fills",
          fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch fills", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.post("/api/orders/sync", authMiddleware, async (req, res) => {
    try {
      const traceId = `api-sync-${Date.now()}`;
      const workItem = await workQueue.enqueue({
        type: "ORDER_SYNC",
        payload: JSON.stringify({ traceId }),
        maxAttempts: 3
      });
      res.json({
        success: true,
        workItemId: workItem.id,
        message: "Order sync enqueued",
        traceId
      });
    } catch (error) {
      log.error("Routes", "Failed to enqueue order sync", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/orders/recent", authMiddleware, async (req, res) => {
    const fetchedAt = /* @__PURE__ */ new Date();
    try {
      const limit4 = parseInt(req.query.limit) || 50;
      const orders2 = await alpaca.getOrders("all", limit4);
      const enrichedOrders = orders2.map((o) => ({
        ...mapAlpacaOrderToEnriched(o, fetchedAt),
        assetClass: o.asset_class,
        submittedAt: o.submitted_at,
        isAI: true
      }));
      res.json({
        orders: enrichedOrders,
        _source: createLiveSourceMetadata()
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch recent orders", { error });
      res.status(503).json({
        error: "Failed to fetch recent orders",
        _source: createUnavailableSourceMetadata(),
        message: "Could not connect to Alpaca Paper Trading. Please try again shortly."
      });
    }
  });
  app2.get("/api/orders/:id", authMiddleware, async (req, res) => {
    try {
      const { id } = req.params;
      let order = await storage.getOrderByBrokerOrderId(id);
      if (!order) {
        const orders2 = await storage.getRecentOrders(1e3);
        order = orders2.find((o) => o.id === id);
      }
      if (!order) {
        return res.status(404).json({ error: "Order not found" });
      }
      const fills2 = await storage.getFillsByOrderId(order.id);
      res.json({
        order,
        fills: fills2,
        _source: {
          type: "database",
          table: "orders",
          fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    } catch (error) {
      log.error("Routes", "Failed to fetch order", { error });
      res.status(500).json({ error: String(error) });
    }
  });
  app2.get("/api/analytics/summary", authMiddleware, async (req, res) => {
    try {
      const orchestratorState = orchestrator.getState();
      const riskLimits = orchestrator.getRiskLimits();
      let alpacaPositions = [];
      let unrealizedPnl = 0;
      let dailyPnlFromAccount = 0;
      let accountData = {
        equity: "0",
        cash: "0",
        buyingPower: "0",
        lastEquity: "0",
        portfolioValue: "0"
      };
      const [trades3, alpacaData] = await Promise.all([
        storage.getTrades(100),
        // Reduced from 5000 - only need recent trades
        Promise.all([alpaca.getPositions(), alpaca.getAccount()]).catch((e) => {
          log.error("Routes", "Failed to fetch Alpaca data for analytics", { error: e });
          return [[], null];
        })
      ]);
      const [positions2, account] = alpacaData;
      if (positions2 && positions2.length > 0) {
        alpacaPositions = positions2;
        unrealizedPnl = alpacaPositions.reduce((sum, p) => sum + safeParseFloat(p.unrealized_pl, 0), 0);
      }
      if (account) {
        const portfolioValue = safeParseFloat(account.portfolio_value, 0);
        const lastEquity = safeParseFloat(account.last_equity, 0);
        dailyPnlFromAccount = portfolioValue - lastEquity;
        accountData = {
          equity: account.equity || "0",
          cash: account.cash || "0",
          buyingPower: account.buying_power || "0",
          lastEquity: account.last_equity || "0",
          portfolioValue: account.portfolio_value || "0"
        };
      }
      const filledTrades = trades3.filter((t) => {
        const status = (t.status || "").toLowerCase();
        return status === "filled" || status === "completed" || status === "executed";
      });
      const sellTrades = filledTrades.filter((t) => t.side === "sell");
      const closedTrades = sellTrades.filter((t) => {
        if (t.pnl === null || t.pnl === void 0) return false;
        const pnlStr = String(t.pnl).trim();
        if (pnlStr === "") return false;
        const pnlValue = parseFloat(pnlStr);
        return Number.isFinite(pnlValue);
      });
      const realizedPnl = closedTrades.reduce((sum, t) => sum + safeParseFloat(t.pnl, 0), 0);
      const totalPnl = unrealizedPnl + realizedPnl;
      const winningTrades = closedTrades.filter((t) => safeParseFloat(t.pnl, 0) > 0);
      const losingTrades = closedTrades.filter((t) => safeParseFloat(t.pnl, 0) < 0);
      const winRate = closedTrades.length > 0 ? winningTrades.length / closedTrades.length * 100 : 0;
      const todayStart = /* @__PURE__ */ new Date();
      todayStart.setHours(0, 0, 0, 0);
      const todaysTrades = closedTrades.filter((t) => {
        const executedAt = new Date(t.executedAt);
        return executedAt >= todayStart;
      });
      const dailyTradeCount = todaysTrades.length;
      const dailyWinningTrades = todaysTrades.filter((t) => safeParseFloat(t.pnl, 0) > 0);
      const dailyLosingTrades = todaysTrades.filter((t) => safeParseFloat(t.pnl, 0) < 0);
      const dailyRealizedPnl = todaysTrades.reduce((sum, t) => sum + safeParseFloat(t.pnl, 0), 0);
      res.json({
        totalTrades: filledTrades.length,
        closedTradesCount: closedTrades.length,
        totalPnl: totalPnl.toFixed(2),
        realizedPnl: realizedPnl.toFixed(2),
        winRate: winRate.toFixed(1),
        winningTrades: winningTrades.length,
        losingTrades: losingTrades.length,
        openPositions: alpacaPositions.length,
        unrealizedPnl: unrealizedPnl.toFixed(2),
        isAgentRunning: orchestratorState.isRunning,
        dailyPnl: dailyPnlFromAccount.toFixed(2),
        dailyTradeCount,
        dailyWinningTrades: dailyWinningTrades.length,
        dailyLosingTrades: dailyLosingTrades.length,
        dailyRealizedPnl: dailyRealizedPnl.toFixed(2),
        account: accountData,
        riskControls: {
          maxPositionSizePercent: riskLimits.maxPositionSizePercent,
          maxTotalExposurePercent: riskLimits.maxTotalExposurePercent,
          maxPositionsCount: riskLimits.maxPositionsCount,
          dailyLossLimitPercent: riskLimits.dailyLossLimitPercent,
          killSwitchActive: riskLimits.killSwitchActive
        }
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get analytics summary" });
    }
  });
  app2.get("/api/crypto/markets", async (req, res) => {
    try {
      const perPage = parseInt(req.query.per_page) || 20;
      const page = parseInt(req.query.page) || 1;
      const order = req.query.order || "market_cap_desc";
      const markets = await coingecko.getMarkets("usd", perPage, page, order);
      res.json(markets);
    } catch (error) {
      log.error("Routes", "Failed to fetch crypto markets", { error });
      res.status(500).json({ error: "Failed to fetch crypto market data" });
    }
  });
  app2.get("/api/crypto/prices", async (req, res) => {
    try {
      const ids = req.query.ids || "bitcoin,ethereum,solana";
      const coinIds = ids.split(",").map((id) => id.trim());
      const prices = await coingecko.getSimplePrice(coinIds);
      res.json(prices);
    } catch (error) {
      log.error("Routes", "Failed to fetch crypto prices", { error });
      res.status(500).json({ error: "Failed to fetch crypto prices" });
    }
  });
  app2.get("/api/crypto/chart/:coinId", async (req, res) => {
    try {
      const { coinId } = req.params;
      const days = req.query.days || "7";
      const chart = await coingecko.getMarketChart(coinId, "usd", days);
      res.json(chart);
    } catch (error) {
      log.error("Routes", "Failed to fetch crypto chart", { error });
      res.status(500).json({ error: "Failed to fetch crypto chart data" });
    }
  });
  app2.get("/api/crypto/trending", async (req, res) => {
    try {
      const trending = await coingecko.getTrending();
      res.json(trending);
    } catch (error) {
      log.error("Routes", "Failed to fetch trending coins", { error });
      res.status(500).json({ error: "Failed to fetch trending coins" });
    }
  });
  app2.get("/api/crypto/global", async (req, res) => {
    try {
      const global = await coingecko.getGlobalData();
      res.json(global);
    } catch (error) {
      log.error("Routes", "Failed to fetch global market data", { error });
      res.status(500).json({ error: "Failed to fetch global market data" });
    }
  });
  app2.get("/api/crypto/search", async (req, res) => {
    try {
      const query = req.query.q || "";
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const results = await coingecko.searchCoins(query);
      res.json(results);
    } catch (error) {
      log.error("Routes", "Failed to search coins", { error });
      res.status(500).json({ error: "Failed to search coins" });
    }
  });
  app2.get("/api/stock/quote/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const quote = await finnhub.getQuote(symbol);
      res.json(quote);
    } catch (error) {
      log.error("Routes", "Failed to fetch stock quote", { error });
      res.status(500).json({ error: "Failed to fetch stock quote" });
    }
  });
  app2.get("/api/stock/quotes", async (req, res) => {
    try {
      const symbols = req.query.symbols || "AAPL,GOOGL,MSFT,AMZN,TSLA";
      const symbolList = symbols.split(",").map((s) => s.trim().toUpperCase());
      const quotes = await finnhub.getMultipleQuotes(symbolList);
      const result = {};
      quotes.forEach((quote, symbol) => {
        result[symbol] = quote;
      });
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to fetch stock quotes", { error });
      res.status(500).json({ error: "Failed to fetch stock quotes" });
    }
  });
  app2.get("/api/stock/candles/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const resolution = req.query.resolution || "D";
      const from = req.query.from ? parseInt(req.query.from) : void 0;
      const to = req.query.to ? parseInt(req.query.to) : void 0;
      const candles = await finnhub.getCandles(symbol, resolution, from, to);
      res.json(candles);
    } catch (error) {
      log.error("Routes", "Failed to fetch stock candles", { error });
      res.status(500).json({ error: "Failed to fetch stock candles" });
    }
  });
  app2.get("/api/stock/profile/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const profile = await finnhub.getCompanyProfile(symbol);
      res.json(profile);
    } catch (error) {
      log.error("Routes", "Failed to fetch company profile", { error });
      res.status(500).json({ error: "Failed to fetch company profile" });
    }
  });
  app2.get("/api/stock/search", async (req, res) => {
    try {
      const query = req.query.q || "";
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const results = await finnhub.searchSymbols(query);
      res.json(results);
    } catch (error) {
      log.error("Routes", "Failed to search stocks", { error });
      res.status(500).json({ error: "Failed to search stocks" });
    }
  });
  app2.get("/api/stock/news", async (req, res) => {
    try {
      const category = req.query.category || "general";
      const news = await finnhub.getMarketNews(category);
      res.json(news);
    } catch (error) {
      log.error("Routes", "Failed to fetch market news", { error });
      res.status(500).json({ error: "Failed to fetch market news" });
    }
  });
  app2.get("/api/uae/stocks", async (req, res) => {
    try {
      const exchange = req.query.exchange;
      const stocks = await uaeMarkets.getTopStocks(exchange);
      res.json(stocks);
    } catch (error) {
      log.error("Routes", "Failed to fetch UAE stocks", { error });
      res.status(500).json({ error: "Failed to fetch UAE stocks" });
    }
  });
  app2.get("/api/uae/summary", async (req, res) => {
    try {
      const exchange = req.query.exchange;
      const summary = await uaeMarkets.getMarketSummary(exchange);
      res.json(summary);
    } catch (error) {
      log.error("Routes", "Failed to fetch UAE market summary", { error });
      res.status(500).json({ error: "Failed to fetch UAE market summary" });
    }
  });
  app2.get("/api/uae/info", async (req, res) => {
    try {
      const info = uaeMarkets.getMarketInfo();
      res.json(info);
    } catch (error) {
      log.error("Routes", "Failed to fetch UAE market info", { error });
      res.status(500).json({ error: "Failed to fetch UAE market info" });
    }
  });
  app2.get("/api/uae/status", async (req, res) => {
    try {
      const status = uaeMarkets.getConnectionStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: "Failed to get UAE connector status" });
    }
  });
  app2.post("/api/ai/analyze", authMiddleware, async (req, res) => {
    try {
      const { symbol, marketData, newsContext, strategyId } = req.body;
      if (!symbol || !marketData) {
        return res.status(400).json({ error: "Symbol and market data are required" });
      }
      let strategy;
      if (strategyId) {
        const dbStrategy = await storage.getStrategy(strategyId);
        if (dbStrategy) {
          strategy = {
            id: dbStrategy.id,
            name: dbStrategy.name,
            type: dbStrategy.type,
            parameters: dbStrategy.parameters ? JSON.parse(dbStrategy.parameters) : void 0
          };
        }
      }
      const traceId = generateTraceId();
      const decision = await aiDecisionEngine.analyzeOpportunity(
        symbol,
        marketData,
        newsContext,
        strategy,
        { traceId }
      );
      const aiDecisionRecord = await storage.createAiDecision({
        strategyId: strategyId || null,
        symbol,
        action: decision.action,
        confidence: decision.confidence.toString(),
        reasoning: decision.reasoning,
        traceId,
        marketContext: JSON.stringify({
          marketData,
          newsContext,
          riskLevel: decision.riskLevel,
          suggestedQuantity: decision.suggestedQuantity,
          targetPrice: decision.targetPrice,
          stopLoss: decision.stopLoss
        })
      });
      res.json({
        id: aiDecisionRecord.id,
        ...decision,
        createdAt: aiDecisionRecord.createdAt
      });
    } catch (error) {
      log.error("Routes", "AI analysis error", { error });
      res.status(500).json({ error: "Failed to analyze trading opportunity" });
    }
  });
  app2.get("/api/ai/status", authMiddleware, async (req, res) => {
    try {
      const status = aiDecisionEngine.getStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: "Failed to get AI status" });
    }
  });
  app2.get("/api/ai/events", authMiddleware, async (req, res) => {
    try {
      const limit4 = Math.min(parseInt(req.query.limit) || 20, 100);
      const type = req.query.type;
      const decisions = await storage.getAiDecisions({ limit: limit4 * 2 });
      const events = decisions.filter((d) => !type || d.type === type).slice(0, limit4).map((d) => ({
        id: d.id,
        type: d.type || "signal",
        title: d.headline || `${d.action?.toUpperCase() || "SIGNAL"} - ${d.symbol || "Market"}`,
        headline: d.headline,
        description: d.reasoning || d.explanation,
        explanation: d.explanation,
        symbol: d.symbol,
        confidence: typeof d.confidence === "string" ? parseFloat(d.confidence) : d.confidence,
        action: d.action,
        time: d.createdAt,
        createdAt: d.createdAt,
        metadata: {
          strategyId: d.strategyId,
          signals: d.signals
        }
      }));
      res.json(events);
    } catch (error) {
      log.error("Routes", "Failed to get AI events", { error });
      res.json([]);
    }
  });
  app2.get("/api/ai/cache/stats", authMiddleware, async (req, res) => {
    try {
      const stats = getLLMCacheStats();
      res.json(stats);
    } catch (error) {
      log.error("Routes", "Error getting LLM cache stats", { error });
      res.status(500).json({ error: "Failed to get cache stats" });
    }
  });
  app2.post("/api/ai/cache/clear", authMiddleware, async (req, res) => {
    try {
      clearLLMCache();
      res.json({ success: true, message: "LLM cache cleared" });
    } catch (error) {
      log.error("Routes", "Error clearing LLM cache", { error });
      res.status(500).json({ error: "Failed to clear cache" });
    }
  });
  app2.post("/api/ai/cache/clear/:role", authMiddleware, async (req, res) => {
    try {
      const { role } = req.params;
      clearLLMCacheForRole(role);
      res.json({ success: true, message: `Cache cleared for role: ${role}` });
    } catch (error) {
      log.error("Routes", "Error clearing LLM cache for role", { error });
      res.status(500).json({ error: "Failed to clear cache for role" });
    }
  });
  app2.post("/api/ai/cache/reset-stats", authMiddleware, async (req, res) => {
    try {
      resetLLMCacheStats();
      res.json({ success: true, message: "Cache statistics reset" });
    } catch (error) {
      log.error("Routes", "Error resetting LLM cache stats", { error });
      res.status(500).json({ error: "Failed to reset cache stats" });
    }
  });
  app2.get("/api/connectors/status", authMiddleware, async (req, res) => {
    try {
      const cryptoStatus = coingecko.getConnectionStatus();
      const stockStatus = finnhub.getConnectionStatus();
      const aiStatus = aiDecisionEngine.getStatus();
      const fusionStatus = dataFusionEngine.getStatus();
      const alpacaStatus = alpaca.getConnectionStatus();
      const newsStatus = await newsapi.getConnectionStatus();
      const coinmarketcapStatus = coinmarketcap.getConnectionStatus();
      const valyuStatus = valyu.getConnectionStatus();
      const huggingfaceStatus = huggingface.getConnectionStatus();
      const uaeStatus = uaeMarkets.getConnectionStatus();
      const gdeltStatus = gdelt.getConnectionStatus();
      res.json({
        crypto: {
          provider: "CoinGecko",
          ...cryptoStatus,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        stock: {
          provider: "Finnhub",
          ...stockStatus,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        ai: {
          ...aiStatus,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        fusion: {
          provider: "Data Fusion Engine",
          ...fusionStatus,
          lastChecked: (/* @__PURE__ */ new Date()).toISOString()
        },
        allConnectors: [
          {
            id: "alpaca",
            name: "Alpaca",
            category: "broker",
            description: "Paper trading execution & account management",
            connected: alpacaStatus.connected,
            hasApiKey: alpacaStatus.hasCredentials,
            cacheSize: alpacaStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "finnhub",
            name: "Finnhub",
            category: "market_data",
            description: "Real-time stock quotes & fundamentals",
            connected: stockStatus.connected,
            hasApiKey: stockStatus.hasApiKey,
            cacheSize: stockStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "coingecko",
            name: "CoinGecko",
            category: "market_data",
            description: "Cryptocurrency prices & market data",
            connected: cryptoStatus.connected,
            hasApiKey: cryptoStatus.hasApiKey,
            cacheSize: cryptoStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "coinmarketcap",
            name: "CoinMarketCap",
            category: "market_data",
            description: "Comprehensive crypto market data",
            connected: coinmarketcapStatus.connected,
            hasApiKey: coinmarketcapStatus.hasApiKey,
            cacheSize: coinmarketcapStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "newsapi",
            name: "NewsAPI",
            category: "news",
            description: "Real-time news headlines for sentiment",
            connected: newsStatus.connected,
            hasApiKey: newsStatus.hasApiKey,
            cacheSize: newsStatus.cacheSize,
            budgetAllowed: newsStatus.budgetStatus.allowed,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "valyu",
            name: "Valyu.ai",
            category: "enrichment",
            description: "9 financial datasets: earnings, ratios, balance sheets, income, cash flow, dividends, insider trades, SEC filings, market movers",
            connected: valyuStatus.connected,
            hasApiKey: valyuStatus.hasApiKey,
            cacheSize: valyuStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "huggingface",
            name: "Hugging Face",
            category: "enrichment",
            description: "FinBERT sentiment analysis & ML models",
            connected: huggingfaceStatus.connected,
            hasApiKey: huggingfaceStatus.hasApiKey,
            cacheSize: huggingfaceStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "openai",
            name: "OpenAI",
            category: "ai",
            description: "GPT-4o-mini for trading decisions",
            connected: aiStatus.available,
            hasApiKey: aiStatus.available,
            model: aiStatus.model,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "uae-markets",
            name: "UAE Markets",
            category: "market_data",
            description: "Dubai DFM & Abu Dhabi ADX stocks",
            connected: uaeStatus.connected,
            hasApiKey: false,
            // Demo data, no API key required
            cacheSize: uaeStatus.cacheSize,
            isMockData: uaeStatus.isMockData,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          },
          {
            id: "gdelt",
            name: "GDELT",
            category: "news",
            description: "Real-time global news (100+ languages), sentiment tracking, breaking news detection (FREE, updates every 15min)",
            connected: gdeltStatus.connected,
            hasApiKey: true,
            cacheSize: gdeltStatus.cacheSize,
            lastChecked: (/* @__PURE__ */ new Date()).toISOString()
          }
        ]
      });
    } catch (error) {
      res.status(500).json({ error: "Failed to get connector status" });
    }
  });
  app2.get("/api/fusion/intelligence", authMiddleware, async (req, res) => {
    try {
      const intelligence = await dataFusionEngine.getMarketIntelligence();
      res.json(intelligence);
    } catch (error) {
      log.error("Routes", "Failed to get market intelligence", { error });
      res.status(500).json({ error: "Failed to get market intelligence" });
    }
  });
  app2.get("/api/fusion/market-data", authMiddleware, async (req, res) => {
    try {
      const fusedData = await dataFusionEngine.getFusedMarketData();
      res.json(fusedData);
    } catch (error) {
      log.error("Routes", "Failed to get fused market data", { error });
      res.status(500).json({ error: "Failed to get fused market data" });
    }
  });
  app2.get("/api/fusion/status", authMiddleware, async (req, res) => {
    try {
      const status = dataFusionEngine.getStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ error: "Failed to get fusion status" });
    }
  });
  app2.get("/api/risk/settings", authMiddleware, async (req, res) => {
    try {
      const status = await storage.getAgentStatus();
      if (!status) {
        return res.json({
          killSwitchActive: false,
          maxPositionSizePercent: "10",
          maxTotalExposurePercent: "50",
          maxPositionsCount: 10,
          dailyLossLimitPercent: "5"
        });
      }
      res.json({
        killSwitchActive: status.killSwitchActive ?? false,
        maxPositionSizePercent: status.maxPositionSizePercent ?? "10",
        maxTotalExposurePercent: status.maxTotalExposurePercent ?? "50",
        maxPositionsCount: status.maxPositionsCount ?? 10,
        dailyLossLimitPercent: status.dailyLossLimitPercent ?? "5"
      });
    } catch (error) {
      log.error("Routes", "Failed to get risk settings", { error });
      res.status(500).json({ error: "Failed to get risk settings" });
    }
  });
  app2.post("/api/risk/settings", authMiddleware, async (req, res) => {
    try {
      const { maxPositionSizePercent, maxTotalExposurePercent, maxPositionsCount, dailyLossLimitPercent } = req.body;
      const updates = {};
      if (maxPositionSizePercent !== void 0) {
        const val = parseFloat(maxPositionSizePercent);
        if (isNaN(val) || val <= 0 || val > 100) {
          return res.status(400).json({ error: "Max position size must be between 0 and 100" });
        }
        updates.maxPositionSizePercent = val.toString();
      }
      if (maxTotalExposurePercent !== void 0) {
        const val = parseFloat(maxTotalExposurePercent);
        if (isNaN(val) || val <= 0 || val > 300) {
          return res.status(400).json({ error: "Max total exposure must be between 0 and 300" });
        }
        updates.maxTotalExposurePercent = val.toString();
      }
      if (maxPositionsCount !== void 0) {
        const val = parseInt(maxPositionsCount);
        if (isNaN(val) || val <= 0 || val > 100) {
          return res.status(400).json({ error: "Max positions count must be between 1 and 100" });
        }
        updates.maxPositionsCount = val;
      }
      if (dailyLossLimitPercent !== void 0) {
        const val = parseFloat(dailyLossLimitPercent);
        if (isNaN(val) || val <= 0 || val > 100) {
          return res.status(400).json({ error: "Daily loss limit must be between 0 and 100" });
        }
        updates.dailyLossLimitPercent = val.toString();
      }
      const status = await storage.updateAgentStatus(updates);
      res.json({
        killSwitchActive: status?.killSwitchActive ?? false,
        maxPositionSizePercent: status?.maxPositionSizePercent ?? "10",
        maxTotalExposurePercent: status?.maxTotalExposurePercent ?? "50",
        maxPositionsCount: status?.maxPositionsCount ?? 10,
        dailyLossLimitPercent: status?.dailyLossLimitPercent ?? "5"
      });
    } catch (error) {
      log.error("Routes", "Failed to update risk settings", { error });
      res.status(500).json({ error: "Failed to update risk settings" });
    }
  });
  app2.post("/api/risk/kill-switch", authMiddleware, async (req, res) => {
    try {
      const { activate } = req.body;
      const shouldActivate = activate === true || activate === "true";
      const updateData = {
        killSwitchActive: shouldActivate
      };
      if (shouldActivate) {
        updateData.isRunning = false;
      }
      const status = await storage.updateAgentStatus(updateData);
      res.json({
        killSwitchActive: status?.killSwitchActive ?? shouldActivate,
        isRunning: status?.isRunning ?? false,
        message: shouldActivate ? "Kill switch activated - all trading halted" : "Kill switch deactivated"
      });
    } catch (error) {
      log.error("Routes", "Failed to toggle kill switch", { error });
      res.status(500).json({ error: "Failed to toggle kill switch" });
    }
  });
  app2.post("/api/risk/close-all", authMiddleware, async (req, res) => {
    try {
      log.info("RISK", "Closing all positions via Alpaca...");
      const result = await alpacaTradingEngine.closeAllPositions();
      res.json({
        ...result,
        _source: createLiveSourceMetadata()
      });
    } catch (error) {
      log.error("Routes", "Failed to close all positions", { error });
      res.status(500).json({ error: "Failed to close all positions" });
    }
  });
  app2.post("/api/risk/emergency-liquidate", authMiddleware, async (req, res) => {
    try {
      log.info("EMERGENCY", "Initiating full portfolio liquidation...");
      await storage.updateAgentStatus({ killSwitchActive: true, isRunning: false });
      log.info("EMERGENCY", "Kill switch activated");
      const openOrders = await alpaca.getOrders("open", 100);
      const orderCount = openOrders.length;
      await alpaca.cancelAllOrders();
      log.info("EMERGENCY", `Cancelled ${orderCount} orders`);
      const closeResult = await alpaca.closeAllPositions();
      log.info("EMERGENCY", `Submitted close orders for ${closeResult.length} positions`);
      await new Promise((resolve2) => setTimeout(resolve2, 1e3));
      const userId = req.userId;
      await alpacaTradingEngine.syncPositionsFromAlpaca(userId);
      const account = await alpaca.getAccount();
      log.info("EMERGENCY", `Synced positions from Alpaca. Account equity: $${account.equity}`);
      res.json({
        success: true,
        killSwitchActivated: true,
        ordersCancelled: orderCount,
        positionsClosing: closeResult.length,
        closeOrders: closeResult.map((order) => ({
          symbol: order.symbol,
          qty: order.qty,
          status: order.status,
          type: order.type
        })),
        message: `Emergency liquidation initiated: ${orderCount} orders cancelled, ${closeResult.length} positions closing`
      });
    } catch (error) {
      log.error("EMERGENCY", "Liquidation failed", { error });
      res.status(500).json({ error: "Emergency liquidation failed: " + String(error) });
    }
  });
  app2.get("/api/alpaca/account", authMiddleware, async (req, res) => {
    try {
      const account = await alpaca.getAccount();
      res.json(account);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca account", { error });
      res.status(500).json({ error: "Failed to get Alpaca account" });
    }
  });
  app2.get("/api/market/quotes", authMiddleware, async (req, res) => {
    try {
      const symbolsParam = req.query.symbols;
      if (!symbolsParam) {
        return res.status(400).json({ error: "symbols parameter required" });
      }
      const symbols = symbolsParam.split(",").map((s) => s.trim().toUpperCase());
      const snapshots = await alpaca.getSnapshots(symbols);
      const quotes = symbols.map((symbol) => {
        const snap = snapshots[symbol];
        if (!snap) {
          return { symbol, price: null, change: null, changePercent: null };
        }
        const price = snap.latestTrade?.p || snap.dailyBar?.c || 0;
        const prevClose = snap.prevDailyBar?.c || price;
        const change = price - prevClose;
        const changePercent = prevClose ? change / prevClose * 100 : 0;
        return {
          symbol,
          price,
          change,
          changePercent,
          volume: snap.dailyBar?.v || 0,
          high: snap.dailyBar?.h || 0,
          low: snap.dailyBar?.l || 0,
          open: snap.dailyBar?.o || 0
        };
      });
      res.json(quotes);
    } catch (error) {
      log.error("Routes", "Failed to get market quotes", { error });
      res.status(500).json({ error: "Failed to get market quotes" });
    }
  });
  app2.get("/api/alpaca/positions", authMiddleware, async (req, res) => {
    try {
      const positions2 = await alpaca.getPositions();
      const DUST_THRESHOLD = 1e-4;
      const filteredPositions = positions2.filter((p) => {
        const qty = Math.abs(parseFloat(p.qty || "0"));
        return qty >= DUST_THRESHOLD;
      });
      res.json(filteredPositions);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca positions", { error });
      res.status(500).json({ error: "Failed to get Alpaca positions" });
    }
  });
  app2.get("/api/alpaca/orders", authMiddleware, async (req, res) => {
    try {
      const status = req.query.status || "all";
      const limit4 = parseInt(req.query.limit) || 50;
      const orders2 = await alpaca.getOrders(status, limit4);
      res.json(orders2);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca orders", { error });
      res.status(500).json({ error: "Failed to get Alpaca orders" });
    }
  });
  app2.post("/api/alpaca/orders", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const tradabilityCheck = await tradabilityService.validateSymbolTradable(symbol);
      if (!tradabilityCheck.tradable) {
        return res.status(400).json({
          error: `Symbol ${symbol} is not tradable`,
          reason: tradabilityCheck.reason || "Not found in broker universe",
          tradabilityCheck
        });
      }
      const order = await alpaca.createOrder(req.body);
      res.status(201).json(order);
    } catch (error) {
      log.error("Routes", "Failed to create Alpaca order", { error });
      res.status(500).json({ error: "Failed to create Alpaca order" });
    }
  });
  app2.delete("/api/alpaca/orders/:orderId", authMiddleware, async (req, res) => {
    try {
      await alpaca.cancelOrder(req.params.orderId);
      res.status(204).send();
    } catch (error) {
      log.error("Routes", "Failed to cancel Alpaca order", { error });
      res.status(500).json({ error: "Failed to cancel Alpaca order" });
    }
  });
  app2.get("/api/alpaca/assets", authMiddleware, async (req, res) => {
    try {
      const assetClass = req.query.asset_class || "us_equity";
      const assets = await alpaca.getAssets("active", assetClass);
      res.json(assets);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca assets", { error });
      res.status(500).json({ error: "Failed to get Alpaca assets" });
    }
  });
  app2.get("/api/alpaca/allocations", authMiddleware, async (req, res) => {
    try {
      const result = await alpacaTradingEngine.getCurrentAllocations();
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to get current allocations", { error });
      res.status(500).json({ error: "Failed to get current allocations" });
    }
  });
  app2.post("/api/alpaca/rebalance/preview", authMiddleware, async (req, res) => {
    try {
      const { targetAllocations } = req.body;
      if (!targetAllocations || !Array.isArray(targetAllocations)) {
        return res.status(400).json({ error: "targetAllocations array required" });
      }
      for (const alloc of targetAllocations) {
        if (!alloc.symbol || typeof alloc.targetPercent !== "number") {
          return res.status(400).json({ error: "Each allocation must have symbol and targetPercent" });
        }
        if (alloc.targetPercent < 0 || alloc.targetPercent > 100) {
          return res.status(400).json({ error: "targetPercent must be between 0 and 100" });
        }
      }
      const preview = await alpacaTradingEngine.previewRebalance(targetAllocations);
      res.json(preview);
    } catch (error) {
      log.error("Routes", "Failed to preview rebalance", { error });
      res.status(500).json({ error: error.message || "Failed to preview rebalance" });
    }
  });
  app2.post("/api/alpaca/rebalance/execute", authMiddleware, async (req, res) => {
    try {
      const { targetAllocations, dryRun = false } = req.body;
      if (!targetAllocations || !Array.isArray(targetAllocations)) {
        return res.status(400).json({ error: "targetAllocations array required" });
      }
      for (const alloc of targetAllocations) {
        if (!alloc.symbol || typeof alloc.targetPercent !== "number") {
          return res.status(400).json({ error: "Each allocation must have symbol and targetPercent" });
        }
        if (alloc.targetPercent < 0 || alloc.targetPercent > 100) {
          return res.status(400).json({ error: "targetPercent must be between 0 and 100" });
        }
      }
      const result = await alpacaTradingEngine.executeRebalance(targetAllocations, dryRun);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to execute rebalance", { error });
      res.status(500).json({ error: error.message || "Failed to execute rebalance" });
    }
  });
  app2.get("/api/alpaca/rebalance/suggestions", authMiddleware, async (req, res) => {
    try {
      const suggestions = await alpacaTradingEngine.getRebalanceSuggestions();
      res.json(suggestions);
    } catch (error) {
      log.error("Routes", "Failed to get rebalance suggestions", { error });
      res.status(500).json({ error: "Failed to get rebalance suggestions" });
    }
  });
  app2.get("/api/alpaca/assets/search", authMiddleware, async (req, res) => {
    try {
      const query = req.query.q;
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const assets = await alpaca.searchAssets(query);
      res.json(assets);
    } catch (error) {
      log.error("Routes", "Failed to search Alpaca assets", { error });
      res.status(500).json({ error: "Failed to search Alpaca assets" });
    }
  });
  app2.get("/api/alpaca/bars", authMiddleware, async (req, res) => {
    try {
      const symbols = req.query.symbols?.split(",") || ["AAPL"];
      const timeframe = req.query.timeframe || "1Day";
      const start = req.query.start;
      const end = req.query.end;
      const bars = await alpaca.getBars(symbols, timeframe, start, end);
      res.json(bars);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca bars", { error });
      res.status(500).json({ error: "Failed to get Alpaca bars" });
    }
  });
  app2.get("/api/alpaca/snapshots", authMiddleware, async (req, res) => {
    try {
      const symbols = req.query.symbols?.split(",") || ["AAPL"];
      const cryptoSymbols = [];
      const stockSymbols = [];
      for (const symbol of symbols) {
        if (symbol.includes("/") || ["BTCUSD", "ETHUSD", "SOLUSD"].includes(symbol.toUpperCase())) {
          const normalizedCrypto = symbol.includes("/") ? symbol : symbol.toUpperCase() === "BTCUSD" ? "BTC/USD" : symbol.toUpperCase() === "ETHUSD" ? "ETH/USD" : symbol.toUpperCase() === "SOLUSD" ? "SOL/USD" : symbol;
          cryptoSymbols.push(normalizedCrypto);
        } else {
          stockSymbols.push(symbol);
        }
      }
      let result = {};
      if (stockSymbols.length > 0) {
        const stockSnapshots = await alpaca.getSnapshots(stockSymbols);
        result = { ...result, ...stockSnapshots };
      }
      if (cryptoSymbols.length > 0) {
        const cryptoSnapshots = await alpaca.getCryptoSnapshots(cryptoSymbols);
        result = { ...result, ...cryptoSnapshots };
      }
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca snapshots", { error });
      res.status(500).json({ error: "Failed to get Alpaca snapshots" });
    }
  });
  app2.get("/api/health/db", authMiddleware, async (req, res) => {
    try {
      const stats = getPoolStats();
      await db.execute(sql16`SELECT 1 as test`);
      res.json({
        status: "healthy",
        pool: stats,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Database health check failed", { error });
      res.status(503).json({
        status: "unhealthy",
        error: error instanceof Error ? error.message : "Unknown error",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app2.get("/api/alpaca/health", authMiddleware, async (req, res) => {
    try {
      const health = await alpaca.healthCheck();
      const account = await alpaca.getAccount();
      const clock = await alpacaTradingEngine.getClock();
      res.json({
        ...health,
        accountStatus: account.status,
        tradingBlocked: account.trading_blocked,
        marketOpen: clock.is_open,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to check Alpaca health", { error });
      res.status(503).json({
        status: "unhealthy",
        error: error instanceof Error ? error.message : "Failed to check Alpaca health",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
  });
  app2.get("/api/alpaca/clock", authMiddleware, async (req, res) => {
    try {
      const clock = await alpacaTradingEngine.getClock();
      res.json(clock);
    } catch (error) {
      log.error("Routes", "Failed to get market clock", { error });
      res.status(500).json({ error: "Failed to get market clock" });
    }
  });
  app2.get("/api/alpaca/market-status", authMiddleware, async (req, res) => {
    try {
      const status = await alpacaTradingEngine.getMarketStatus();
      res.json(status);
    } catch (error) {
      log.error("Routes", "Failed to get market status", { error });
      res.status(500).json({ error: "Failed to get market status" });
    }
  });
  app2.get("/api/alpaca/can-trade-extended/:symbol", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.params;
      const result = await alpacaTradingEngine.canTradeExtendedHours(symbol);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to check extended hours availability", { error });
      res.status(500).json({ error: "Failed to check extended hours availability" });
    }
  });
  app2.get("/api/trading-sessions/all", authMiddleware, async (req, res) => {
    try {
      const allSessions = tradingSessionManager.getAllSessionInfo();
      res.json({
        sessions: allSessions,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get all trading sessions", { error });
      res.status(500).json({ error: "Failed to get trading sessions" });
    }
  });
  app2.get("/api/trading-sessions/:exchange", authMiddleware, async (req, res) => {
    try {
      const { exchange } = req.params;
      const session = tradingSessionManager.getCurrentSession(exchange.toUpperCase());
      const config = tradingSessionManager.getSessionConfig(exchange.toUpperCase());
      res.json({
        exchange: exchange.toUpperCase(),
        session,
        config,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get trading session", { error });
      res.status(500).json({ error: "Failed to get trading session" });
    }
  });
  app2.get("/api/trading-sessions/:exchange/is-open", authMiddleware, async (req, res) => {
    try {
      const { exchange } = req.params;
      const isOpen = tradingSessionManager.isMarketOpen(exchange.toUpperCase());
      res.json({
        exchange: exchange.toUpperCase(),
        isOpen,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to check if market is open", { error });
      res.status(500).json({ error: "Failed to check market status" });
    }
  });
  app2.get("/api/trading-sessions/:exchange/next-open", authMiddleware, async (req, res) => {
    try {
      const { exchange } = req.params;
      const nextOpen = tradingSessionManager.getNextMarketOpen(exchange.toUpperCase());
      res.json({
        exchange: exchange.toUpperCase(),
        nextOpen: nextOpen?.toISOString() || null,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get next market open", { error });
      res.status(500).json({ error: "Failed to get next market open" });
    }
  });
  app2.get("/api/trading-sessions/:exchange/volatility", authMiddleware, async (req, res) => {
    try {
      const { exchange } = req.params;
      const session = tradingSessionManager.getCurrentSession(exchange.toUpperCase());
      const volatilityMultiplier = tradingSessionManager.getSessionVolatilityMultiplier(
        exchange.toUpperCase(),
        session.session
      );
      res.json({
        exchange: exchange.toUpperCase(),
        session: session.session,
        volatilityMultiplier,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get volatility multiplier", { error });
      res.status(500).json({ error: "Failed to get volatility multiplier" });
    }
  });
  app2.get("/api/alpaca/portfolio-history", authMiddleware, async (req, res) => {
    try {
      const period = req.query.period || "1M";
      const timeframe = req.query.timeframe || "1D";
      const history = await alpaca.getPortfolioHistory(period, timeframe);
      res.json(history);
    } catch (error) {
      log.error("Routes", "Failed to get portfolio history", { error });
      res.status(500).json({ error: "Failed to get portfolio history" });
    }
  });
  app2.get("/api/alpaca/top-stocks", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 25;
      const stocks = await alpaca.getTopStocks(limit4);
      res.json(stocks);
    } catch (error) {
      log.error("Routes", "Failed to get top stocks", { error });
      res.status(500).json({ error: "Failed to get top stocks" });
    }
  });
  app2.get("/api/alpaca/top-crypto", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 25;
      const crypto4 = await alpaca.getTopCrypto(limit4);
      res.json(crypto4);
    } catch (error) {
      log.error("Routes", "Failed to get top crypto", { error });
      res.status(500).json({ error: "Failed to get top crypto" });
    }
  });
  app2.get("/api/alpaca/top-etfs", authMiddleware, async (req, res) => {
    try {
      const limit4 = parseInt(req.query.limit) || 25;
      const etfs = await alpaca.getTopETFs(limit4);
      res.json(etfs);
    } catch (error) {
      log.error("Routes", "Failed to get top ETFs", { error });
      res.status(500).json({ error: "Failed to get top ETFs" });
    }
  });
  app2.post("/api/alpaca/validate-order", authMiddleware, async (req, res) => {
    try {
      const validation = alpaca.validateOrder(req.body);
      res.json(validation);
    } catch (error) {
      log.error("Routes", "Failed to validate order", { error });
      res.status(500).json({ error: "Failed to validate order" });
    }
  });
  app2.get("/api/feeds", authMiddleware, async (req, res) => {
    try {
      const feeds = [
        {
          id: "alpaca",
          name: "Alpaca Markets",
          category: "market",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "coingecko",
          name: "CoinGecko",
          category: "market",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "finnhub",
          name: "Finnhub",
          category: "market",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "coinmarketcap",
          name: "CoinMarketCap",
          category: "market",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "newsapi",
          name: "NewsAPI",
          category: "news",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "gdelt",
          name: "GDELT Project",
          category: "news",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "uae-markets",
          name: "UAE Markets",
          category: "market",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        },
        {
          id: "huggingface",
          name: "HuggingFace",
          category: "fundamental",
          status: "active",
          lastUpdate: (/* @__PURE__ */ new Date()).toISOString()
        }
      ];
      res.json(feeds);
    } catch (error) {
      log.error("Routes", "Failed to get feed sources", { error });
      res.status(500).json({ error: "Failed to get feed sources" });
    }
  });
  app2.get("/api/ai/sentiment", authMiddleware, async (req, res) => {
    try {
      const symbols = req.query.symbols?.split(",") || ["SPY", "QQQ", "AAPL", "TSLA", "NVDA"];
      const sentiments = symbols.map((symbol) => ({
        id: `sent-${symbol}-${Date.now()}`,
        sourceId: "data-fusion",
        sourceName: "Data Fusion Engine",
        symbol,
        score: Math.random() * 100 - 50,
        // -50 to +50
        trend: Math.random() > 0.5 ? "up" : Math.random() > 0.5 ? "down" : "neutral",
        explanation: `Aggregate sentiment analysis for ${symbol} based on news, social media, and market data`,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      }));
      res.json(sentiments);
    } catch (error) {
      log.error("Routes", "Failed to get sentiment signals", { error });
      res.status(500).json({ error: "Failed to get sentiment signals" });
    }
  });
  app2.get("/api/cmc/listings", async (req, res) => {
    try {
      const start = parseInt(req.query.start) || 1;
      const limit4 = parseInt(req.query.limit) || 100;
      const listings = await coinmarketcap.getLatestListings(start, limit4);
      res.json(listings);
    } catch (error) {
      log.error("Routes", "Failed to get CMC listings", { error });
      res.status(500).json({ error: "Failed to get CoinMarketCap listings" });
    }
  });
  app2.get("/api/cmc/quotes", async (req, res) => {
    try {
      const symbols = req.query.symbols?.split(",") || ["BTC", "ETH"];
      const quotes = await coinmarketcap.getQuotesBySymbols(symbols);
      res.json(quotes);
    } catch (error) {
      log.error("Routes", "Failed to get CMC quotes", { error });
      res.status(500).json({ error: "Failed to get CoinMarketCap quotes" });
    }
  });
  app2.get("/api/cmc/global", async (req, res) => {
    try {
      const metrics = await coinmarketcap.getGlobalMetrics();
      res.json(metrics);
    } catch (error) {
      log.error("Routes", "Failed to get CMC global metrics", { error });
      res.status(500).json({ error: "Failed to get CoinMarketCap global metrics" });
    }
  });
  app2.get("/api/cmc/search", async (req, res) => {
    try {
      const query = req.query.q;
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const results = await coinmarketcap.searchCryptos(query);
      res.json(results);
    } catch (error) {
      log.error("Routes", "Failed to search CMC", { error });
      res.status(500).json({ error: "Failed to search CoinMarketCap" });
    }
  });
  app2.get("/api/news/headlines", async (req, res) => {
    try {
      const category = req.query.category || "business";
      const country = req.query.country || "us";
      const pageSize = parseInt(req.query.pageSize) || 20;
      const headlines = await newsapi.getTopHeadlines(category, country, pageSize);
      res.json(headlines);
    } catch (error) {
      log.error("Routes", "Failed to get news headlines", { error });
      res.status(500).json({ error: "Failed to get news headlines" });
    }
  });
  app2.get("/api/news/search", async (req, res) => {
    try {
      const query = req.query.q;
      if (!query) {
        return res.status(400).json({ error: "Search query required" });
      }
      const sortBy = req.query.sortBy || "publishedAt";
      const pageSize = parseInt(req.query.pageSize) || 20;
      const articles = await newsapi.searchNews(query, sortBy, pageSize);
      res.json(articles);
    } catch (error) {
      log.error("Routes", "Failed to search news", { error });
      res.status(500).json({ error: "Failed to search news" });
    }
  });
  app2.get("/api/news/market", async (req, res) => {
    try {
      const pageSize = parseInt(req.query.pageSize) || 20;
      const articles = await newsapi.getMarketNews(pageSize);
      res.json(articles);
    } catch (error) {
      log.error("Routes", "Failed to get market news", { error });
      res.status(500).json({ error: "Failed to get market news" });
    }
  });
  app2.get("/api/news/crypto", async (req, res) => {
    try {
      const pageSize = parseInt(req.query.pageSize) || 20;
      const articles = await newsapi.getCryptoNews(pageSize);
      res.json(articles);
    } catch (error) {
      log.error("Routes", "Failed to get crypto news", { error });
      res.status(500).json({ error: "Failed to get crypto news" });
    }
  });
  app2.get("/api/news/stock/:symbol", async (req, res) => {
    try {
      const { symbol } = req.params;
      const pageSize = parseInt(req.query.pageSize) || 10;
      const articles = await newsapi.getStockNews(symbol, pageSize);
      res.json(articles);
    } catch (error) {
      log.error("Routes", "Failed to get stock news", { error });
      res.status(500).json({ error: "Failed to get stock news" });
    }
  });
  app2.get("/api/alpaca-trading/status", authMiddleware, async (req, res) => {
    try {
      const status = alpacaTradingEngine.getStatus();
      const connected = await alpacaTradingEngine.isAlpacaConnected();
      res.json({ ...status, alpacaConnected: connected });
    } catch (error) {
      log.error("Routes", "Failed to get Alpaca trading status", { error });
      res.status(500).json({ error: "Failed to get Alpaca trading status" });
    }
  });
  app2.post("/api/alpaca-trading/execute", authMiddleware, async (req, res) => {
    try {
      const { symbol, side, quantity, strategyId, notes, orderType, limitPrice } = req.body;
      if (!symbol || !side || !quantity) {
        return res.status(400).json({ error: "Symbol, side, and quantity are required" });
      }
      if (!["buy", "sell"].includes(side)) {
        return res.status(400).json({ error: "Side must be 'buy' or 'sell'" });
      }
      const result = await alpacaTradingEngine.executeAlpacaTrade({
        symbol,
        side,
        quantity: safeParseFloat(quantity),
        strategyId,
        notes,
        orderType,
        limitPrice: limitPrice ? safeParseFloat(limitPrice) : void 0
      });
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json(result);
    } catch (error) {
      log.error("Routes", "Alpaca trade execution error", { error });
      res.status(500).json({ error: "Failed to execute Alpaca trade" });
    }
  });
  app2.post("/api/alpaca-trading/close/:symbol", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.params;
      const { strategyId } = req.body;
      const result = await alpacaTradingEngine.closeAlpacaPosition(symbol, strategyId);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json(result);
    } catch (error) {
      log.error("Routes", "Close Alpaca position error", { error });
      res.status(500).json({ error: "Failed to close Alpaca position" });
    }
  });
  app2.post("/api/alpaca-trading/analyze", authMiddleware, async (req, res) => {
    try {
      const { symbol, strategyId } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const result = await alpacaTradingEngine.analyzeSymbol(symbol, strategyId);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Analyze symbol error", { error });
      res.status(500).json({ error: "Failed to analyze symbol" });
    }
  });
  app2.post("/api/alpaca-trading/analyze-execute", authMiddleware, async (req, res) => {
    try {
      const { symbol, strategyId } = req.body;
      if (!symbol) {
        return res.status(400).json({ error: "Symbol is required" });
      }
      const result = await alpacaTradingEngine.analyzeAndExecute(symbol, strategyId);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Analyze and execute error", { error });
      res.status(500).json({ error: "Failed to analyze and execute trade" });
    }
  });
  app2.post("/api/strategies/:id/start", authMiddleware, async (req, res) => {
    try {
      const { id } = req.params;
      const result = await alpacaTradingEngine.startStrategy(id);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({ success: true, message: "Strategy started" });
    } catch (error) {
      log.error("Routes", "Start strategy error", { error });
      res.status(500).json({ error: "Failed to start strategy" });
    }
  });
  app2.post("/api/strategies/:id/stop", authMiddleware, async (req, res) => {
    try {
      const { id } = req.params;
      const result = await alpacaTradingEngine.stopStrategy(id);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({ success: true, message: "Strategy stopped" });
    } catch (error) {
      log.error("Routes", "Stop strategy error", { error });
      res.status(500).json({ error: "Failed to stop strategy" });
    }
  });
  app2.get("/api/strategies/:id/status", authMiddleware, async (req, res) => {
    try {
      const { id } = req.params;
      const state = alpacaTradingEngine.getStrategyState(id);
      const strategy = await storage.getStrategy(id);
      if (!strategy) {
        return res.status(404).json({ error: "Strategy not found" });
      }
      res.json({
        strategy,
        runState: state || { strategyId: id, isRunning: false }
      });
    } catch (error) {
      log.error("Routes", "Get strategy status error", { error });
      res.status(500).json({ error: "Failed to get strategy status" });
    }
  });
  app2.post("/api/alpaca-trading/stop-all", authMiddleware, async (req, res) => {
    try {
      await alpacaTradingEngine.stopAllStrategies();
      res.json({ success: true, message: "All strategies stopped" });
    } catch (error) {
      log.error("Routes", "Stop all strategies error", { error });
      res.status(500).json({ error: "Failed to stop all strategies" });
    }
  });
  app2.get("/api/orchestration/status", authMiddleware, async (req, res) => {
    try {
      const status = coordinator.getStatus();
      const config = coordinator.getConfig();
      res.json({ status, config });
    } catch (error) {
      log.error("Routes", "Get orchestration status error", { error });
      res.status(500).json({ error: "Failed to get orchestration status" });
    }
  });
  app2.post("/api/orchestration/start", authMiddleware, async (req, res) => {
    try {
      await coordinator.start();
      res.json({ success: true, message: "Coordinator started" });
    } catch (error) {
      log.error("Routes", "Start coordinator error", { error });
      res.status(500).json({ error: "Failed to start coordinator" });
    }
  });
  app2.post("/api/orchestration/stop", authMiddleware, async (req, res) => {
    try {
      await coordinator.stop();
      res.json({ success: true, message: "Coordinator stopped" });
    } catch (error) {
      log.error("Routes", "Stop coordinator error", { error });
      res.status(500).json({ error: "Failed to stop coordinator" });
    }
  });
  app2.put("/api/orchestration/config", authMiddleware, async (req, res) => {
    try {
      const updates = req.body;
      coordinator.updateConfig(updates);
      res.json({ success: true, config: coordinator.getConfig() });
    } catch (error) {
      log.error("Routes", "Update orchestration config error", { error });
      res.status(500).json({ error: "Failed to update configuration" });
    }
  });
  app2.get("/api/orchestration/logs", authMiddleware, async (req, res) => {
    try {
      const { level, category, limit: limit4 } = req.query;
      const logs = logger.getLogs({
        level,
        category,
        limit: limit4 ? parseInt(limit4) : 100
      });
      res.json({ logs, stats: logger.getStats() });
    } catch (error) {
      log.error("Routes", "Get logs error", { error });
      res.status(500).json({ error: "Failed to get logs" });
    }
  });
  app2.get("/api/orchestration/logs/errors", authMiddleware, async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const errors = logger.getErrorLogs(limit4 ? parseInt(limit4) : 50);
      res.json({ errors });
    } catch (error) {
      log.error("Routes", "Get error logs error", { error });
      res.status(500).json({ error: "Failed to get error logs" });
    }
  });
  app2.get("/api/orchestration/events", authMiddleware, async (req, res) => {
    try {
      const { type, source, limit: limit4 } = req.query;
      const events = eventBus.getEventHistory({
        type,
        source,
        limit: limit4 ? parseInt(limit4) : 50
      });
      res.json({ events, stats: eventBus.getStats() });
    } catch (error) {
      log.error("Routes", "Get events error", { error });
      res.status(500).json({ error: "Failed to get events" });
    }
  });
  app2.post("/api/orchestration/reset-stats", authMiddleware, async (req, res) => {
    try {
      coordinator.resetStats();
      res.json({ success: true, message: "Statistics reset" });
    } catch (error) {
      log.error("Routes", "Reset stats error", { error });
      res.status(500).json({ error: "Failed to reset statistics" });
    }
  });
  app2.get("/api/performance/metrics", authMiddleware, async (req, res) => {
    try {
      const { performanceTracker: performanceTracker2 } = await Promise.resolve().then(() => (init_performance_metrics(), performance_metrics_exports));
      const { getOrderCacheStats: getOrderCacheStats2 } = await Promise.resolve().then(() => (init_order_execution_cache(), order_execution_cache_exports));
      const { getPoolStats: getPoolStats2 } = await Promise.resolve().then(() => (init_db(), db_exports));
      const metrics = performanceTracker2.getMetrics();
      const sloStatus = performanceTracker2.getSLOStatus();
      const cacheStats = getOrderCacheStats2();
      const poolStats = getPoolStats2();
      res.json({
        orderExecution: performanceTracker2.getMetricSummary("orderExecution"),
        quoteRetrieval: performanceTracker2.getMetricSummary("quoteRetrieval"),
        aiDecision: performanceTracker2.getMetricSummary("aiDecision"),
        databaseQuery: performanceTracker2.getMetricSummary("databaseQuery"),
        apiCall: performanceTracker2.getMetricSummary("apiCall"),
        sloCompliance: sloStatus,
        cache: cacheStats,
        dbPool: poolStats,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Performance metrics error", { error });
      res.status(500).json({ error: "Failed to get performance metrics" });
    }
  });
  const redactWebhook2 = (webhook) => ({
    ...webhook,
    secret: webhook.secret ? "***REDACTED***" : void 0,
    headers: webhook.headers ? Object.fromEntries(
      Object.entries(webhook.headers).map(
        ([k, v]) => k.toLowerCase().includes("auth") || k.toLowerCase().includes("token") || k.toLowerCase().includes("key") ? [k, "***REDACTED***"] : [k, v]
      )
    ) : void 0
  });
  app2.get("/api/webhooks", authMiddleware, (req, res) => {
    const webhooks2 = getWebhooks().map(redactWebhook2);
    res.json({ webhooks: webhooks2, supportedEvents: SUPPORTED_EVENTS });
  });
  app2.get("/api/webhooks/:id", authMiddleware, (req, res) => {
    const webhook = getWebhook(req.params.id);
    if (!webhook) {
      return res.status(404).json({ error: "Webhook not found" });
    }
    res.json(redactWebhook2(webhook));
  });
  app2.post("/api/webhooks", authMiddleware, (req, res) => {
    try {
      const { name, url, eventTypes, enabled, headers, secret } = req.body;
      if (!name || !url) {
        return res.status(400).json({ error: "name and url are required" });
      }
      if (!url.startsWith("https://") && process.env.NODE_ENV === "production") {
        return res.status(400).json({ error: "Webhook URL must use HTTPS in production" });
      }
      const id = `wh_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
      const config = {
        id,
        name,
        url,
        eventTypes: eventTypes || ["*"],
        enabled: enabled !== false,
        headers,
        secret
      };
      registerWebhook(config);
      res.status(201).json(redactWebhook2(config));
    } catch (error) {
      log.error("Routes", "Webhook creation error", { error });
      res.status(500).json({ error: "Failed to create webhook" });
    }
  });
  app2.put("/api/webhooks/:id", authMiddleware, (req, res) => {
    const updated = updateWebhook(req.params.id, req.body);
    if (!updated) {
      return res.status(404).json({ error: "Webhook not found" });
    }
    res.json(redactWebhook2(updated));
  });
  app2.delete("/api/webhooks/:id", authMiddleware, (req, res) => {
    const result = unregisterWebhook(req.params.id);
    if (!result) {
      return res.status(404).json({ error: "Webhook not found" });
    }
    res.json({ success: true });
  });
  app2.post("/api/webhooks/test", authMiddleware, async (req, res) => {
    try {
      const { eventType, payload } = req.body;
      const results = await emitEvent(eventType || "system.test", payload || { test: true, timestamp: (/* @__PURE__ */ new Date()).toISOString() });
      res.json({ deliveries: results.length, results });
    } catch (error) {
      log.error("Routes", "Webhook test error", { error });
      res.status(500).json({ error: "Failed to send test event" });
    }
  });
  app2.get("/api/webhooks/stats/overview", authMiddleware, (req, res) => {
    res.json(getWebhookStats());
  });
  app2.get("/api/webhooks/history/deliveries", authMiddleware, (req, res) => {
    const limit4 = parseInt(req.query.limit) || 50;
    res.json({ deliveries: getDeliveryHistory(limit4) });
  });
  const {
    registerChannel: registerChannel2,
    getChannel: getChannel2,
    getChannels: getChannels2,
    updateChannel: updateChannel2,
    deleteChannel: deleteChannel2,
    registerTemplate: registerTemplate2,
    getTemplates: getTemplates2,
    updateTemplate: updateTemplate2,
    deleteTemplate: deleteTemplate2,
    sendNotification: sendNotification2,
    sendDirectNotification: sendDirectNotification2,
    getNotificationHistory: getNotificationHistory2,
    getNotificationStats: getNotificationStats2
  } = await Promise.resolve().then(() => (init_notification_service(), notification_service_exports));
  const redactChannelConfig = (channel) => {
    const redacted = { ...channel };
    if (redacted.config) {
      const config = { ...redacted.config };
      if ("botToken" in config) config.botToken = "***REDACTED***";
      if ("webhookUrl" in config) config.webhookUrl = config.webhookUrl.replace(/\/[^/]+$/, "/***REDACTED***");
      if ("password" in config) config.password = "***REDACTED***";
      redacted.config = config;
    }
    return redacted;
  };
  app2.get("/api/notifications/channels", authMiddleware, (req, res) => {
    res.json({ channels: getChannels2().map(redactChannelConfig) });
  });
  app2.get("/api/notifications/channels/:id", authMiddleware, (req, res) => {
    const channel = getChannel2(req.params.id);
    if (!channel) {
      return res.status(404).json({ error: "Channel not found" });
    }
    res.json(redactChannelConfig(channel));
  });
  app2.post("/api/notifications/channels", authMiddleware, (req, res) => {
    try {
      const { type, name, config, enabled } = req.body;
      if (!type || !name || !config) {
        return res.status(400).json({ error: "type, name, and config are required" });
      }
      if (!["telegram", "slack", "discord", "email"].includes(type)) {
        return res.status(400).json({ error: "Invalid channel type" });
      }
      if (type === "email") {
        return res.status(400).json({ error: "Email notifications not yet supported" });
      }
      const id = `ch_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
      const channel = {
        id,
        type,
        name,
        config,
        enabled: enabled === true,
        createdAt: /* @__PURE__ */ new Date()
      };
      registerChannel2(channel);
      res.status(201).json(redactChannelConfig(channel));
    } catch (error) {
      log.error("Routes", "Channel creation error", { error });
      res.status(500).json({ error: "Failed to create channel" });
    }
  });
  app2.put("/api/notifications/channels/:id", authMiddleware, (req, res) => {
    const updated = updateChannel2(req.params.id, req.body);
    if (!updated) {
      return res.status(404).json({ error: "Channel not found" });
    }
    res.json(redactChannelConfig(updated));
  });
  app2.delete("/api/notifications/channels/:id", authMiddleware, (req, res) => {
    const result = deleteChannel2(req.params.id);
    if (!result) {
      return res.status(404).json({ error: "Channel not found" });
    }
    res.json({ success: true });
  });
  app2.get("/api/notifications/templates", authMiddleware, (req, res) => {
    res.json({ templates: getTemplates2() });
  });
  app2.post("/api/notifications/templates", authMiddleware, (req, res) => {
    try {
      const { name, eventType, channels: channels2, messageTemplate, enabled } = req.body;
      if (!name || !eventType || !messageTemplate) {
        return res.status(400).json({ error: "name, eventType, and messageTemplate are required" });
      }
      const id = `tpl_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
      const template = {
        id,
        name,
        eventType,
        channels: channels2 || [],
        messageTemplate,
        enabled: enabled !== false
      };
      registerTemplate2(template);
      res.status(201).json(template);
    } catch (error) {
      log.error("Routes", "Template creation error", { error });
      res.status(500).json({ error: "Failed to create template" });
    }
  });
  app2.put("/api/notifications/templates/:id", authMiddleware, (req, res) => {
    const updated = updateTemplate2(req.params.id, req.body);
    if (!updated) {
      return res.status(404).json({ error: "Template not found" });
    }
    res.json(updated);
  });
  app2.delete("/api/notifications/templates/:id", authMiddleware, (req, res) => {
    const result = deleteTemplate2(req.params.id);
    if (!result) {
      return res.status(404).json({ error: "Template not found" });
    }
    res.json({ success: true });
  });
  app2.post("/api/notifications/send", authMiddleware, async (req, res) => {
    try {
      const { eventType, data } = req.body;
      if (!eventType) {
        return res.status(400).json({ error: "eventType is required" });
      }
      const results = await sendNotification2(eventType, data || {});
      res.json({ sent: results.length, results });
    } catch (error) {
      log.error("Routes", "Notification send error", { error });
      res.status(500).json({ error: "Failed to send notification" });
    }
  });
  app2.post("/api/notifications/channels/:id/test", authMiddleware, async (req, res) => {
    try {
      const { message } = req.body;
      const result = await sendDirectNotification2(
        req.params.id,
        message || "Test notification from AI Active Trader"
      );
      if (!result) {
        return res.status(404).json({ error: "Channel not found" });
      }
      res.json(result);
    } catch (error) {
      log.error("Routes", "Notification test error", { error });
      res.status(500).json({ error: "Failed to send test notification" });
    }
  });
  app2.get("/api/notifications/history", authMiddleware, (req, res) => {
    const limit4 = parseInt(req.query.limit) || 50;
    res.json({ notifications: getNotificationHistory2(limit4) });
  });
  app2.get("/api/notifications/stats", authMiddleware, (req, res) => {
    res.json(getNotificationStats2());
  });
  app2.get("/api/admin/api-usage", authMiddleware, async (req, res) => {
    try {
      const { provider } = req.query;
      if (provider && typeof provider === "string") {
        const stats = await getUsageStats(provider);
        const policy = getProviderPolicy(provider);
        res.json({ provider, stats, policy });
      } else {
        const allStats = await getAllUsageStats();
        const policies = getAllProviderPolicies();
        res.json({ usage: allStats, policies });
      }
    } catch (error) {
      log.error("Routes", "Failed to get API usage stats", { error });
      res.status(500).json({ error: "Failed to get API usage stats" });
    }
  });
  app2.get("/api/admin/api-cache", authMiddleware, async (req, res) => {
    try {
      const { provider } = req.query;
      const providerFilter = typeof provider === "string" ? provider : void 0;
      const stats = await getCacheStats(providerFilter);
      const entries = await getAllCacheEntries(providerFilter);
      res.json({ stats, entries });
    } catch (error) {
      log.error("Routes", "Failed to get API cache stats", { error });
      res.status(500).json({ error: "Failed to get API cache stats" });
    }
  });
  app2.post("/api/admin/api-cache/purge", authMiddleware, requireCapability("admin:danger"), async (req, res) => {
    try {
      const { provider, key, expiredOnly } = req.body;
      let purgedCount = 0;
      let message = "";
      if (provider && key) {
        purgedCount = await invalidateCache(provider, key);
        message = `Invalidated cache for ${provider}:${key}`;
      } else if (provider && !expiredOnly) {
        purgedCount = await invalidateCache(provider);
        message = `Invalidated all cache entries for ${provider}`;
      } else {
        purgedCount = await purgeExpiredCache();
        message = provider ? `Purged expired cache entries (provider filter not supported for expired purge)` : "Purged all expired cache entries";
      }
      res.json({ success: true, purgedCount, message });
    } catch (error) {
      log.error("Routes", "Failed to purge API cache", { error });
      res.status(500).json({ error: "Failed to purge API cache" });
    }
  });
  app2.get("/api/admin/provider-status", authMiddleware, async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const statuses = await getAllProviderStatuses2();
      res.json({ providers: statuses });
    } catch (error) {
      log.error("Routes", "Failed to get provider statuses", { error });
      res.status(500).json({ error: "Failed to get provider statuses" });
    }
  });
  app2.post("/api/admin/provider/:provider/force-refresh", authMiddleware, requireCapability("admin:danger"), async (req, res) => {
    try {
      const { provider } = req.params;
      const { cacheKey, confirmValyu } = req.body;
      if (provider.toLowerCase() === "valyu" && !confirmValyu) {
        return res.status(400).json({
          error: "Valyu force refresh requires explicit confirmation",
          message: "Set confirmValyu: true to force refresh Valyu data (1 call/week limit)"
        });
      }
      if (cacheKey) {
        await invalidateCache(provider, cacheKey);
        res.json({
          success: true,
          message: `Cache invalidated for ${provider}:${cacheKey}. Next request will fetch fresh data.`
        });
      } else {
        await invalidateCache(provider);
        res.json({
          success: true,
          message: `All cache entries invalidated for ${provider}. Next requests will fetch fresh data.`
        });
      }
    } catch (error) {
      log.error("Routes", "Failed to force refresh provider", { error });
      res.status(500).json({ error: "Failed to force refresh provider" });
    }
  });
  app2.patch("/api/admin/provider/:provider/toggle", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { provider } = req.params;
      const { enabled } = req.body;
      if (enabled === true) {
        enableProvider(provider);
      } else if (enabled === false) {
        disableProvider(provider);
      } else {
        return res.status(400).json({ error: "enabled must be true or false" });
      }
      const policy = getProviderPolicy(provider);
      res.json({
        success: true,
        provider,
        enabled: policy.enabled,
        message: `Provider ${provider} is now ${policy.enabled ? "enabled" : "disabled"}`
      });
    } catch (error) {
      log.error("Routes", "Failed to toggle provider", { error });
      res.status(500).json({ error: "Failed to toggle provider" });
    }
  });
  app2.get("/api/admin/valyu-budget", authMiddleware, async (req, res) => {
    try {
      const { getValyuBudgetStatus: getValyuBudgetStatus2, getValyuBudgetConfig: getValyuBudgetConfig2 } = await Promise.resolve().then(() => (init_valyuBudget(), valyuBudget_exports));
      const statuses = await getValyuBudgetStatus2();
      const config = getValyuBudgetConfig2();
      res.json({ statuses, config });
    } catch (error) {
      log.error("Routes", "Failed to get Valyu budget status", { error });
      res.status(500).json({ error: "Failed to get Valyu budget status" });
    }
  });
  app2.put("/api/admin/valyu-budget", authMiddleware, async (req, res) => {
    try {
      const { updateValyuBudgetConfig: updateValyuBudgetConfig2, getValyuBudgetConfig: getValyuBudgetConfig2 } = await Promise.resolve().then(() => (init_valyuBudget(), valyuBudget_exports));
      const { webRetrievalsPerMonth, financeRetrievalsPerMonth, proprietaryRetrievalsPerMonth } = req.body;
      const updates = {};
      if (webRetrievalsPerMonth !== void 0) updates.webRetrievalsPerMonth = webRetrievalsPerMonth;
      if (financeRetrievalsPerMonth !== void 0) updates.financeRetrievalsPerMonth = financeRetrievalsPerMonth;
      if (proprietaryRetrievalsPerMonth !== void 0) updates.proprietaryRetrievalsPerMonth = proprietaryRetrievalsPerMonth;
      updateValyuBudgetConfig2(updates);
      const config = getValyuBudgetConfig2();
      res.json({ success: true, config, message: "Valyu budget limits updated" });
    } catch (error) {
      log.error("Routes", "Failed to update Valyu budget", { error });
      res.status(500).json({ error: "Failed to update Valyu budget" });
    }
  });
  app2.get("/api/admin/connectors-health", authMiddleware, async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const providerStatuses = await getAllProviderStatuses2();
      const connectors = [
        {
          name: "Alpaca Paper",
          provider: "alpaca",
          type: "brokerage",
          hasApiKey: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY),
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "Finnhub",
          provider: "finnhub",
          type: "market_data",
          hasApiKey: !!process.env.FINNHUB_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "CoinGecko",
          provider: "coingecko",
          type: "crypto_data",
          hasApiKey: true,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "CoinMarketCap",
          provider: "coinmarketcap",
          type: "crypto_data",
          hasApiKey: !!process.env.COINMARKETCAP_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "GDELT News",
          provider: "gdelt",
          type: "news",
          hasApiKey: true,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "NewsAPI",
          provider: "newsapi",
          type: "news",
          hasApiKey: !!process.env.NEWS_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "Valyu AI",
          provider: "valyu",
          type: "data_enrichment",
          hasApiKey: !!process.env.VALYU_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        {
          name: "Hugging Face",
          provider: "huggingface",
          type: "ai_sentiment",
          hasApiKey: !!process.env.HUGGINGFACE_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        },
        // New enhanced data source connectors
        {
          name: "SEC EDGAR",
          provider: "sec-edgar",
          type: "fundamentals",
          hasApiKey: true,
          // Free, no API key needed
          status: "healthy",
          lastSync: "Always available",
          callsRemaining: null,
          healthDetails: { overall: "healthy" }
        },
        {
          name: "FINRA RegSHO",
          provider: "finra",
          type: "short_interest",
          hasApiKey: true,
          // Free, no API key needed
          status: "healthy",
          lastSync: "Always available",
          callsRemaining: null,
          healthDetails: { overall: "healthy" }
        },
        {
          name: "Frankfurter (ECB)",
          provider: "frankfurter",
          type: "forex",
          hasApiKey: true,
          // Free, no API key needed
          status: "healthy",
          lastSync: "Always available",
          callsRemaining: null,
          healthDetails: { overall: "healthy" }
        },
        {
          name: "FRED (Fed Reserve)",
          provider: "fred",
          type: "macro_data",
          hasApiKey: !!process.env.FRED_API_KEY,
          status: "checking",
          lastSync: null,
          callsRemaining: null,
          healthDetails: null
        }
      ];
      let alpacaHealthResult = null;
      const alpacaConnector = connectors.find((c) => c.provider === "alpaca");
      if (alpacaConnector?.hasApiKey) {
        try {
          alpacaHealthResult = await alpaca.healthCheck();
        } catch (err) {
          log.error("Routes", "Alpaca health check failed", { error: err });
        }
      }
      for (const connector of connectors) {
        const providerStatus = providerStatuses[connector.provider];
        if (connector.provider === "alpaca") {
          if (!connector.hasApiKey) {
            connector.status = "offline";
            connector.lastSync = "Not configured";
          } else if (alpacaHealthResult) {
            connector.healthDetails = {
              overall: alpacaHealthResult.overall,
              account: alpacaHealthResult.account
            };
            if (alpacaHealthResult.overall === "healthy") {
              connector.status = "healthy";
              connector.lastSync = alpacaHealthResult.timestamp ? new Date(alpacaHealthResult.timestamp).toLocaleTimeString() : "Connected";
            } else if (alpacaHealthResult.overall === "degraded") {
              connector.status = "warning";
              connector.lastSync = "Partially connected";
            } else {
              connector.status = "offline";
              connector.lastSync = "Connection failed";
            }
          } else {
            connector.status = "offline";
            connector.lastSync = "Health check failed";
          }
          if (providerStatus?.policy.maxRequestsPerMinute) {
            connector.callsRemaining = Math.max(0, providerStatus.policy.maxRequestsPerMinute - providerStatus.budgetStatus.currentCount);
          }
          continue;
        }
        if (providerStatus) {
          if (!connector.hasApiKey) {
            connector.status = "offline";
            connector.lastSync = "Not configured";
          } else if (!providerStatus.enabled) {
            connector.status = "disabled";
            connector.lastSync = "Disabled";
          } else if (!providerStatus.budgetStatus.allowed) {
            connector.status = "warning";
            connector.lastSync = "Rate limited";
            connector.callsRemaining = 0;
          } else {
            connector.status = "healthy";
            if (providerStatus.lastCallTime) {
              const ago = Date.now() - providerStatus.lastCallTime;
              if (ago < 6e4) connector.lastSync = "Just now";
              else if (ago < 36e5) connector.lastSync = `${Math.floor(ago / 6e4)} min ago`;
              else connector.lastSync = `${Math.floor(ago / 36e5)} hr ago`;
            } else {
              connector.lastSync = "Ready";
            }
            if (providerStatus.policy.maxRequestsPerMinute) {
              connector.callsRemaining = Math.max(0, providerStatus.policy.maxRequestsPerMinute - providerStatus.budgetStatus.currentCount);
            }
          }
        }
      }
      res.json({ connectors });
    } catch (error) {
      log.error("Routes", "Failed to get connector health", { error });
      res.status(500).json({ error: "Failed to get connector health" });
    }
  });
  app2.get("/api/admin/api-keys-status", authMiddleware, async (req, res) => {
    try {
      const { getAllAvailableProviders: getAllAvailableProviders2 } = await Promise.resolve().then(() => (init_ai(), ai_exports));
      const aiProviders = getAllAvailableProviders2();
      const providerPolicies2 = getAllProviderPolicies();
      const getPolicyEnabled = (provider) => {
        const policy = providerPolicies2.find((p) => p.provider.toLowerCase() === provider.toLowerCase());
        return policy?.enabled ?? true;
      };
      const apiKeys = [
        { name: "Alpaca API", key: "ALPACA_API_KEY", category: "brokerage", configured: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY), enabled: getPolicyEnabled("alpaca") },
        { name: "Finnhub API", key: "FINNHUB_API_KEY", category: "market_data", configured: !!process.env.FINNHUB_API_KEY, enabled: getPolicyEnabled("finnhub") },
        { name: "CoinGecko API", key: "COINGECKO_API_KEY", category: "crypto", configured: true, enabled: getPolicyEnabled("coingecko") },
        { name: "CoinMarketCap API", key: "COINMARKETCAP_API_KEY", category: "crypto", configured: !!process.env.COINMARKETCAP_API_KEY, enabled: getPolicyEnabled("coinmarketcap") },
        { name: "NewsAPI", key: "NEWS_API_KEY", category: "news", configured: !!process.env.NEWS_API_KEY, enabled: getPolicyEnabled("newsapi") },
        { name: "GDELT News", key: "GDELT", category: "news", configured: true, enabled: getPolicyEnabled("gdelt") },
        { name: "Valyu API", key: "VALYU_API_KEY", category: "data", configured: !!process.env.VALYU_API_KEY, enabled: getPolicyEnabled("valyu") },
        { name: "Hugging Face API", key: "HUGGINGFACE_API_KEY", category: "ai", configured: !!process.env.HUGGINGFACE_API_KEY, enabled: getPolicyEnabled("huggingface") },
        { name: "OpenAI API", key: "OPENAI_API_KEY", category: "ai", configured: aiProviders.includes("openai"), enabled: getPolicyEnabled("openai") },
        { name: "Groq API", key: "GROQ_API_KEY", category: "ai", configured: aiProviders.includes("groq"), enabled: getPolicyEnabled("groq") },
        { name: "Together API", key: "TOGETHER_API_KEY", category: "ai", configured: aiProviders.includes("together"), enabled: getPolicyEnabled("together") },
        { name: "AIML API", key: "AIMLAPI_KEY", category: "ai", configured: aiProviders.includes("aimlapi"), enabled: true },
        { name: "OpenRouter API", key: "OPENROUTER_API_KEY", category: "ai", configured: !!process.env.OPENROUTER_API_KEY, enabled: true }
      ];
      const summary = {
        total: apiKeys.length,
        configured: apiKeys.filter((k) => k.configured).length,
        missing: apiKeys.filter((k) => !k.configured).length,
        enabled: apiKeys.filter((k) => k.enabled).length,
        byCategory: {
          brokerage: apiKeys.filter((k) => k.category === "brokerage"),
          market_data: apiKeys.filter((k) => k.category === "market_data"),
          crypto: apiKeys.filter((k) => k.category === "crypto"),
          news: apiKeys.filter((k) => k.category === "news"),
          data: apiKeys.filter((k) => k.category === "data"),
          ai: apiKeys.filter((k) => k.category === "ai")
        }
      };
      res.json({ apiKeys, summary });
    } catch (error) {
      log.error("Routes", "Failed to get API keys status", { error });
      res.status(500).json({ error: "Failed to get API keys status" });
    }
  });
  app2.get("/api/admin/data-fusion-status", authMiddleware, async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const providerStatuses = await getAllProviderStatuses2();
      const fusionEngineStatus = dataFusionEngine.getStatus();
      let marketIntelligence = null;
      try {
        marketIntelligence = await dataFusionEngine.getMarketIntelligence();
      } catch (err) {
        log.error("Routes", "Failed to get market intelligence", { error: err });
      }
      const dataSources = [
        // Market Data Sources
        { name: "Market Prices", provider: "finnhub", active: !!process.env.FINNHUB_API_KEY && providerStatuses.finnhub?.enabled, category: "market_data" },
        { name: "Crypto Prices", provider: "coingecko", active: providerStatuses.coingecko?.enabled, category: "market_data" },
        { name: "Trade Execution", provider: "alpaca", active: !!(process.env.ALPACA_API_KEY && process.env.ALPACA_SECRET_KEY) && providerStatuses.alpaca?.enabled, category: "brokerage" },
        // Fundamental Data Sources (Enhanced)
        { name: "SEC Filings (EDGAR)", provider: "sec-edgar", active: true, category: "fundamentals" },
        // Free, no API key
        { name: "Financial Data", provider: "valyu", active: !!process.env.VALYU_API_KEY && providerStatuses.valyu?.enabled, category: "fundamentals" },
        { name: "Macro Indicators (FRED)", provider: "fred", active: !!process.env.FRED_API_KEY, category: "macro" },
        // Short Interest & Institutional (New)
        { name: "Short Interest (FINRA)", provider: "finra", active: true, category: "short_interest" },
        // Free, no API key
        { name: "Forex Rates (ECB)", provider: "frankfurter", active: true, category: "forex" },
        // Free, no API key
        // Sentiment & News Sources
        { name: "News Feed", provider: "gdelt", active: providerStatuses.gdelt?.enabled, category: "news" },
        { name: "News Headlines", provider: "newsapi", active: !!process.env.NEWS_API_KEY && providerStatuses.newsapi?.enabled, category: "news" },
        { name: "Sentiment Analysis", provider: "huggingface", active: !!process.env.HUGGINGFACE_API_KEY && providerStatuses.huggingface?.enabled, category: "sentiment" }
      ];
      const activeSourcesCount = marketIntelligence?.activeSources ?? dataSources.filter((s) => s.active).length;
      const totalSources = marketIntelligence?.totalSources ?? dataSources.length;
      const intelligenceScore = marketIntelligence?.overall ?? activeSourcesCount / totalSources;
      const fusionMetrics = {
        intelligenceScore,
        activeSources: activeSourcesCount,
        totalSources,
        dataSources,
        dataQuality: marketIntelligence?.dataQuality ?? "unknown",
        components: marketIntelligence?.components ?? null,
        signals: marketIntelligence?.signals ?? [],
        embeddingsCount: fusionEngineStatus.cacheSize,
        lastFusionRun: fusionEngineStatus.lastFusionTime ? new Date(fusionEngineStatus.lastFusionTime).toISOString() : null,
        capabilities: {
          marketData: dataSources.some((s) => s.provider === "finnhub" && s.active) || dataSources.some((s) => s.provider === "coingecko" && s.active),
          newsAnalysis: dataSources.some((s) => (s.provider === "gdelt" || s.provider === "newsapi") && s.active),
          sentimentAnalysis: dataSources.some((s) => s.provider === "huggingface" && s.active),
          tradingCapability: dataSources.some((s) => s.provider === "alpaca" && s.active),
          // New enhanced capabilities
          fundamentals: dataSources.some((s) => (s.provider === "sec-edgar" || s.provider === "valyu") && s.active),
          shortInterest: dataSources.some((s) => s.provider === "finra" && s.active),
          macroAnalysis: dataSources.some((s) => s.provider === "fred" && s.active),
          forexData: dataSources.some((s) => s.provider === "frankfurter" && s.active)
        }
      };
      res.json(fusionMetrics);
    } catch (error) {
      log.error("Routes", "Failed to get data fusion status", { error });
      res.status(500).json({ error: "Failed to get data fusion status" });
    }
  });
  app2.get("/api/admin/ai-config", authMiddleware, async (req, res) => {
    try {
      const agentStatus2 = await storage.getAgentStatus();
      res.json({
        autoExecuteTrades: agentStatus2?.autoExecuteTrades ?? false,
        conservativeMode: agentStatus2?.conservativeMode ?? false
      });
    } catch (error) {
      log.error("Routes", "Failed to get AI config", { error });
      res.status(500).json({ error: "Failed to get AI config" });
    }
  });
  app2.put("/api/admin/ai-config", authMiddleware, async (req, res) => {
    try {
      const { autoExecuteTrades, conservativeMode } = req.body;
      const updates = {};
      if (typeof autoExecuteTrades === "boolean") updates.autoExecuteTrades = autoExecuteTrades;
      if (typeof conservativeMode === "boolean") updates.conservativeMode = conservativeMode;
      await storage.updateAgentStatus(updates);
      const status = await storage.getAgentStatus();
      res.json({
        autoExecuteTrades: status?.autoExecuteTrades ?? false,
        conservativeMode: status?.conservativeMode ?? false
      });
    } catch (error) {
      log.error("Routes", "Failed to update AI config", { error });
      res.status(500).json({ error: "Failed to update AI config" });
    }
  });
  app2.get("/api/admin/model-router/configs", authMiddleware, async (req, res) => {
    try {
      const configs = await getAllRoleConfigs();
      const availableProviders = roleBasedRouter.getAvailableProviders();
      res.json({ configs, availableProviders });
    } catch (error) {
      log.error("Routes", "Failed to get role configs", { error });
      res.status(500).json({ error: "Failed to get role configurations" });
    }
  });
  app2.put("/api/admin/model-router/configs/:role", authMiddleware, async (req, res) => {
    try {
      const { role } = req.params;
      const validRoles = ["market_news_summarizer", "technical_analyst", "risk_manager", "execution_planner", "post_trade_reporter"];
      if (!validRoles.includes(role)) {
        return res.status(400).json({ error: `Invalid role. Must be one of: ${validRoles.join(", ")}` });
      }
      const updates = req.body;
      const updated = await updateRoleConfig(role, updates);
      res.json({ success: true, config: updated });
    } catch (error) {
      log.error("Routes", "Failed to update role config", { error });
      res.status(500).json({ error: "Failed to update role configuration" });
    }
  });
  app2.get("/api/admin/model-router/calls", authMiddleware, async (req, res) => {
    try {
      const { role, limit: limit4 } = req.query;
      const limitNum = parseInt(limit4) || 20;
      const roleFilter = typeof role === "string" ? role : void 0;
      const calls = await getRecentCalls(limitNum, roleFilter);
      res.json({ calls, count: calls.length });
    } catch (error) {
      log.error("Routes", "Failed to get recent LLM calls", { error });
      res.status(500).json({ error: "Failed to get recent LLM calls" });
    }
  });
  app2.get("/api/admin/model-router/stats", authMiddleware, async (req, res) => {
    try {
      const stats = await getCallStats();
      res.json(stats);
    } catch (error) {
      log.error("Routes", "Failed to get LLM call stats", { error });
      res.status(500).json({ error: "Failed to get LLM call statistics" });
    }
  });
  app2.get("/api/admin/work-items", authMiddleware, async (req, res) => {
    try {
      const { status, type, limit: limit4 } = req.query;
      const limitNum = parseInt(limit4) || 50;
      const items = await storage.getWorkItems(limitNum, status);
      const filteredItems = type ? items.filter((i) => i.type === type) : items;
      const counts = {
        PENDING: await storage.getWorkItemCount("PENDING"),
        RUNNING: await storage.getWorkItemCount("RUNNING"),
        SUCCEEDED: await storage.getWorkItemCount("SUCCEEDED"),
        FAILED: await storage.getWorkItemCount("FAILED"),
        DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
      };
      res.json({
        items: filteredItems,
        counts,
        total: items.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get work items", { error });
      res.status(500).json({ error: "Failed to get work items" });
    }
  });
  app2.post("/api/admin/work-items/retry", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { id } = req.body;
      if (!id) {
        return res.status(400).json({ error: "Work item ID required" });
      }
      const item = await storage.getWorkItem(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      if (item.status !== "DEAD_LETTER" && item.status !== "FAILED") {
        return res.status(400).json({ error: "Can only retry DEAD_LETTER or FAILED items" });
      }
      await storage.updateWorkItem(id, {
        status: "PENDING",
        attempts: 0,
        nextRunAt: /* @__PURE__ */ new Date(),
        lastError: null
      });
      res.json({ success: true, message: "Work item queued for retry" });
    } catch (error) {
      log.error("Routes", "Failed to retry work item", { error });
      res.status(500).json({ error: "Failed to retry work item" });
    }
  });
  app2.post("/api/admin/work-items/dead-letter", authMiddleware, requireCapability("admin:danger"), async (req, res) => {
    try {
      const { id, reason } = req.body;
      if (!id) {
        return res.status(400).json({ error: "Work item ID required" });
      }
      const item = await storage.getWorkItem(id);
      if (!item) {
        return res.status(404).json({ error: "Work item not found" });
      }
      await storage.updateWorkItem(id, {
        status: "DEAD_LETTER",
        lastError: reason || "Manually moved to dead letter"
      });
      res.json({ success: true, message: "Work item moved to dead letter" });
    } catch (error) {
      log.error("Routes", "Failed to dead-letter work item", { error });
      res.status(500).json({ error: "Failed to dead-letter work item" });
    }
  });
  app2.get("/api/admin/orchestrator-health", authMiddleware, async (req, res) => {
    try {
      const agentStatusData = await storage.getAgentStatus();
      const counts = {
        PENDING: await storage.getWorkItemCount("PENDING"),
        RUNNING: await storage.getWorkItemCount("RUNNING"),
        FAILED: await storage.getWorkItemCount("FAILED"),
        DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
      };
      const recentErrors = await storage.getWorkItems(5, "FAILED");
      res.json({
        isRunning: agentStatusData?.isRunning || false,
        killSwitchActive: agentStatusData?.killSwitchActive || false,
        lastHeartbeat: agentStatusData?.lastHeartbeat || null,
        queueDepth: counts,
        totalPending: counts.PENDING + counts.RUNNING,
        recentErrors: recentErrors.map((e) => ({
          id: e.id,
          type: e.type,
          symbol: e.symbol,
          error: e.lastError,
          createdAt: e.createdAt
        })),
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get orchestrator health", { error });
      res.status(500).json({ error: "Failed to get orchestrator health" });
    }
  });
  app2.get("/api/admin/modules", authMiddleware, async (req, res) => {
    try {
      const modules = getModules();
      res.json({
        modules,
        count: modules.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get admin modules", { error });
      res.status(500).json({ error: "Failed to get admin modules" });
    }
  });
  app2.get("/api/admin/modules/accessible", authMiddleware, async (req, res) => {
    try {
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const rbacContext = createRBACContext(user);
      const allModules = getModules();
      const accessibleModules = filterModulesByCapability(allModules, rbacContext);
      res.json({
        modules: accessibleModules,
        count: accessibleModules.length,
        totalModules: allModules.length,
        userRole: rbacContext.role
      });
    } catch (error) {
      log.error("Routes", "Failed to get accessible modules", { error });
      res.status(500).json({ error: "Failed to get accessible modules" });
    }
  });
  app2.get("/api/admin/modules/:id", authMiddleware, async (req, res) => {
    try {
      const module = getModule(req.params.id);
      if (!module) {
        return res.status(404).json({ error: "Module not found" });
      }
      res.json(module);
    } catch (error) {
      log.error("Routes", "Failed to get admin module", { error });
      res.status(500).json({ error: "Failed to get admin module" });
    }
  });
  app2.get("/api/admin/overview", authMiddleware, async (req, res) => {
    try {
      const overview = await getAdminOverview();
      const agentStatusData = await storage.getAgentStatus();
      const queueCounts = {
        PENDING: await storage.getWorkItemCount("PENDING"),
        RUNNING: await storage.getWorkItemCount("RUNNING"),
        FAILED: await storage.getWorkItemCount("FAILED"),
        DEAD_LETTER: await storage.getWorkItemCount("DEAD_LETTER")
      };
      const llmStats = await getCallStats();
      const allUsage = await getAllUsageStats();
      res.json({
        ...overview,
        orchestrator: {
          isRunning: agentStatusData?.isRunning || false,
          killSwitchActive: agentStatusData?.killSwitchActive || false,
          lastHeartbeat: agentStatusData?.lastHeartbeat || null
        },
        workQueue: {
          pending: queueCounts.PENDING,
          running: queueCounts.RUNNING,
          failed: queueCounts.FAILED,
          deadLetter: queueCounts.DEAD_LETTER
        },
        llm: {
          totalCalls: llmStats.total,
          successRate: llmStats.byProvider && Object.keys(llmStats.byProvider).length > 0 ? Object.values(llmStats.byProvider).reduce((acc, p) => acc + (p.successRate || 0), 0) / Object.keys(llmStats.byProvider).length : 0,
          avgLatency: llmStats.byRole && Object.keys(llmStats.byRole).length > 0 ? Object.values(llmStats.byRole).reduce((acc, r) => acc + (r.avgLatency || 0), 0) / Object.keys(llmStats.byRole).length : 0
        },
        providers: Object.keys(allUsage).map((provider) => ({
          provider,
          callsUsed: allUsage[provider]?.length || 0
        })),
        fetchedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get admin overview", { error });
      res.status(500).json({ error: "Failed to get admin overview" });
    }
  });
  app2.get("/api/admin/rbac/me", authMiddleware, async (req, res) => {
    try {
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const rbacContext = createRBACContext(user);
      res.json({
        userId: rbacContext.userId,
        username: rbacContext.username,
        role: rbacContext.role,
        isAdmin: rbacContext.isAdmin,
        capabilities: rbacContext.capabilities
      });
    } catch (error) {
      log.error("Routes", "Failed to get RBAC context", { error });
      res.status(500).json({ error: "Failed to get RBAC context" });
    }
  });
  app2.get("/api/admin/rbac/roles", authMiddleware, async (req, res) => {
    try {
      const roles = getAllRoles().map((role) => getRoleInfo(role));
      res.json({ roles });
    } catch (error) {
      log.error("Routes", "Failed to get roles", { error });
      res.status(500).json({ error: "Failed to get roles" });
    }
  });
  app2.get("/api/admin/rbac/check/:capability", authMiddleware, async (req, res) => {
    try {
      const { capability } = req.params;
      const user = await storage.getUser(req.userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const rbacContext = createRBACContext(user);
      const hasIt = hasCapability(rbacContext, capability);
      res.json({
        capability,
        hasCapability: hasIt,
        userRole: rbacContext.role
      });
    } catch (error) {
      log.error("Routes", "Failed to check capability", { error });
      res.status(500).json({ error: "Failed to check capability" });
    }
  });
  app2.get("/api/admin/settings", authMiddleware, async (req, res) => {
    try {
      const { namespace } = req.query;
      const namespaceFilter = typeof namespace === "string" ? namespace : void 0;
      const settings = await listSettings(namespaceFilter);
      const sanitized = settings.map(sanitizeSettingForResponse);
      res.json({
        settings: sanitized,
        count: sanitized.length
      });
    } catch (error) {
      log.error("Routes", "Failed to list settings", { error });
      res.status(500).json({ error: "Failed to list settings" });
    }
  });
  app2.get("/api/admin/settings/:namespace/:key", authMiddleware, async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const setting = await getSettingFull(namespace, key);
      if (!setting) {
        return res.status(404).json({ error: "Setting not found" });
      }
      const sanitized = sanitizeSettingForResponse(setting);
      res.json(sanitized);
    } catch (error) {
      log.error("Routes", "Failed to get setting", { error });
      res.status(500).json({ error: "Failed to get setting" });
    }
  });
  app2.put("/api/admin/settings/:namespace/:key", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const { value, description, isSecret, isReadOnly } = req.body;
      if (value === void 0) {
        return res.status(400).json({ error: "Value is required" });
      }
      const setting = await setSetting(namespace, key, value, {
        description,
        isSecret,
        isReadOnly,
        userId: req.userId
      });
      res.json(sanitizeSettingForResponse(setting));
    } catch (error) {
      if (error.message?.includes("read-only")) {
        return res.status(403).json({ error: error.message });
      }
      log.error("Routes", "Failed to set setting", { error });
      res.status(500).json({ error: "Failed to set setting" });
    }
  });
  app2.delete("/api/admin/settings/:namespace/:key", authMiddleware, requireCapability("admin:danger"), async (req, res) => {
    try {
      const { namespace, key } = req.params;
      const deleted = await deleteSetting(namespace, key);
      if (!deleted) {
        return res.status(404).json({ error: "Setting not found" });
      }
      res.json({ success: true, message: `Deleted ${namespace}:${key}` });
    } catch (error) {
      if (error.message?.includes("read-only")) {
        return res.status(403).json({ error: error.message });
      }
      log.error("Routes", "Failed to delete setting", { error });
      res.status(500).json({ error: "Failed to delete setting" });
    }
  });
  app2.get("/api/admin/orchestrator/status", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const status = coordinator.getStatus();
      const config = coordinator.getConfig();
      const activeStrategies = coordinator.getActiveStrategies();
      res.json({
        status,
        config,
        activeStrategies,
        source: "coordinator",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Get orchestrator status error", { error });
      res.status(500).json({ error: "Failed to get orchestrator status" });
    }
  });
  app2.post("/api/admin/orchestrator/pause", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      await coordinator.stop();
      res.json({ success: true, message: "Orchestrator paused", isRunning: false });
    } catch (error) {
      log.error("Routes", "Pause orchestrator error", { error });
      res.status(500).json({ error: "Failed to pause orchestrator" });
    }
  });
  app2.post("/api/admin/orchestrator/resume", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      await coordinator.start();
      res.json({ success: true, message: "Orchestrator resumed", isRunning: true });
    } catch (error) {
      log.error("Routes", "Resume orchestrator error", { error });
      res.status(500).json({ error: "Failed to resume orchestrator" });
    }
  });
  app2.post("/api/admin/orchestrator/run-now", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const result = await coordinator.triggerReconcileNow();
      res.json(result);
    } catch (error) {
      log.error("Routes", "Trigger reconcile error", { error });
      res.status(500).json({ error: "Failed to trigger reconciliation" });
    }
  });
  app2.put("/api/admin/orchestrator/config", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const updates = req.body;
      coordinator.updateConfig(updates);
      res.json({ success: true, config: coordinator.getConfig() });
    } catch (error) {
      log.error("Routes", "Update orchestrator config error", { error });
      res.status(500).json({ error: "Failed to update configuration" });
    }
  });
  app2.post("/api/admin/orchestrator/reset-stats", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      coordinator.resetStats();
      res.json({ success: true, message: "Statistics reset" });
    } catch (error) {
      log.error("Routes", "Reset stats error", { error });
      res.status(500).json({ error: "Failed to reset statistics" });
    }
  });
  app2.get("/api/admin/jobs/status", authMiddleware, async (req, res) => {
    try {
      const { positionReconciliationJob: positionReconciliationJob2 } = await Promise.resolve().then(() => (init_position_reconciliation(), position_reconciliation_exports));
      const stats = positionReconciliationJob2.getStats();
      res.json({
        positionReconciliation: {
          enabled: true,
          schedule: "Every 5 minutes",
          ...stats
        }
      });
    } catch (error) {
      log.error("Routes", "Get job status error", { error });
      res.status(500).json({ error: "Failed to get job status" });
    }
  });
  app2.post("/api/admin/jobs/sync-positions", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { positionReconciliationJob: positionReconciliationJob2 } = await Promise.resolve().then(() => (init_position_reconciliation(), position_reconciliation_exports));
      if (positionReconciliationJob2.isJobRunning()) {
        return res.status(409).json({
          error: "Position sync already in progress",
          message: "Please wait for the current sync to complete"
        });
      }
      log.info("API", "Manual position sync triggered by admin");
      const result = await positionReconciliationJob2.executeSync();
      res.json({
        success: true,
        message: "Position sync completed successfully",
        result: {
          created: result.created,
          updated: result.updated,
          removed: result.removed,
          errors: result.errors,
          summary: {
            totalChanges: result.created.length + result.updated.length + result.removed.length,
            createdCount: result.created.length,
            updatedCount: result.updated.length,
            removedCount: result.removed.length,
            errorCount: result.errors.length
          }
        }
      });
    } catch (error) {
      log.error("Routes", "Manual sync positions error", { error });
      res.status(500).json({
        error: "Failed to sync positions",
        message: error.message
      });
    }
  });
  app2.get("/api/admin/search", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { q, limit: limit4 } = req.query;
      const query = typeof q === "string" ? q : "";
      const maxResults = typeof limit4 === "string" && !isNaN(parseInt(limit4, 10)) ? parseInt(limit4, 10) : 50;
      if (!query || query.length < 2) {
        return res.status(400).json({ error: "Search query must be at least 2 characters" });
      }
      const results = await globalSearch(query, Math.min(maxResults, 100));
      res.json(results);
    } catch (error) {
      log.error("Routes", "Failed to perform global search", { error });
      res.status(500).json({ error: "Failed to perform search" });
    }
  });
  app2.get("/api/admin/trace/:traceId", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { traceId } = req.params;
      const related = await getRelatedEntities(traceId);
      const totalCount = related.aiDecisions.length + related.trades.length + related.orders.length + related.fills.length + related.llmCalls.length;
      res.json({
        traceId,
        totalEntities: totalCount,
        ...related
      });
    } catch (error) {
      log.error("Routes", "Failed to get related entities", { error });
      res.status(500).json({ error: "Failed to get related entities" });
    }
  });
  app2.get("/api/admin/universe/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await alpacaUniverseService.getStats();
      res.json({
        ...stats,
        source: "universe_assets",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get universe stats", { error });
      res.status(500).json({ error: "Failed to get universe stats" });
    }
  });
  app2.get("/api/admin/universe/assets", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { tradableOnly, excludeOtc, excludeSpac, excludePennyStocks, exchange, limit: limit4, offset } = req.query;
      const assets = await alpacaUniverseService.getAssets({
        tradableOnly: tradableOnly !== "false",
        excludeOtc: excludeOtc !== "false",
        excludeSpac: excludeSpac !== "false",
        excludePennyStocks: excludePennyStocks !== "false",
        exchange,
        limit: limit4 ? parseInt(limit4) : 1e3,
        offset: offset ? parseInt(offset) : 0
      });
      res.json({
        assets,
        count: assets.length,
        source: "universe_assets",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get universe assets", { error });
      res.status(500).json({ error: "Failed to get universe assets" });
    }
  });
  app2.get("/api/admin/universe/assets/:symbol", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const asset = await alpacaUniverseService.getAssetBySymbol(symbol);
      if (!asset) {
        return res.status(404).json({ error: "Asset not found" });
      }
      res.json(asset);
    } catch (error) {
      log.error("Routes", "Failed to get asset", { error });
      res.status(500).json({ error: "Failed to get asset" });
    }
  });
  app2.post("/api/admin/universe/refresh", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { includeOtc, includeSpac, includePennyStocks, assetClass, traceId } = req.body;
      const result = await alpacaUniverseService.refreshAssets({
        includeOtc: includeOtc === true,
        includeSpac: includeSpac === true,
        includePennyStocks: includePennyStocks === true,
        assetClass: assetClass || "us_equity",
        traceId: traceId || `univ-${Date.now()}`
      });
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to refresh universe", { error });
      res.status(500).json({ error: "Failed to refresh universe" });
    }
  });
  app2.post("/api/admin/universe/exclude/:symbol", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const { excluded, reason } = req.body;
      await alpacaUniverseService.setExcluded(symbol, excluded === true, reason);
      res.json({ success: true, symbol, excluded: excluded === true });
    } catch (error) {
      log.error("Routes", "Failed to set exclusion", { error });
      res.status(500).json({ error: "Failed to set exclusion" });
    }
  });
  app2.get("/api/admin/universe/tradable", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const symbols = await alpacaUniverseService.getTradableSymbols();
      res.json({ symbols, count: symbols.length });
    } catch (error) {
      log.error("Routes", "Failed to get tradable symbols", { error });
      res.status(500).json({ error: "Failed to get tradable symbols" });
    }
  });
  app2.get("/api/admin/liquidity/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await liquidityService.getTierStats();
      const thresholds = await liquidityService.getThresholdsForAdmin();
      res.json({
        ...stats,
        thresholds,
        source: "universe_liquidity_metrics",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get liquidity stats", { error });
      res.status(500).json({ error: "Failed to get liquidity stats" });
    }
  });
  app2.get("/api/admin/liquidity/metrics/:symbol", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const metrics = await liquidityService.getMetricsBySymbol(symbol);
      if (!metrics) {
        return res.status(404).json({ error: "Liquidity metrics not found" });
      }
      res.json(metrics);
    } catch (error) {
      log.error("Routes", "Failed to get liquidity metrics", { error });
      res.status(500).json({ error: "Failed to get liquidity metrics" });
    }
  });
  app2.get("/api/admin/liquidity/tier/:tier", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { tier } = req.params;
      const { limit: limit4 } = req.query;
      if (!["A", "B", "C"].includes(tier)) {
        return res.status(400).json({ error: "Invalid tier. Must be A, B, or C" });
      }
      const metrics = await liquidityService.getMetricsByTier(
        tier,
        limit4 ? parseInt(limit4) : 100
      );
      res.json({ metrics, count: metrics.length, tier });
    } catch (error) {
      log.error("Routes", "Failed to get tier metrics", { error });
      res.status(500).json({ error: "Failed to get tier metrics" });
    }
  });
  app2.get("/api/admin/liquidity/top", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const topLiquid = await liquidityService.getTopLiquid(
        limit4 ? parseInt(limit4) : 50
      );
      res.json({ metrics: topLiquid, count: topLiquid.length });
    } catch (error) {
      log.error("Routes", "Failed to get top liquid assets", { error });
      res.status(500).json({ error: "Failed to get top liquid assets" });
    }
  });
  app2.post("/api/admin/liquidity/compute", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbols, batchSize, traceId } = req.body;
      const result = await liquidityService.computeLiquidityMetrics({
        symbols,
        batchSize: batchSize ? parseInt(batchSize) : 50,
        traceId: traceId || `liq-${Date.now()}`
      });
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to compute liquidity metrics", { error });
      res.status(500).json({ error: "Failed to compute liquidity metrics" });
    }
  });
  app2.get("/api/admin/fundamentals/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await fundamentalsService.getStats();
      res.json({
        ...stats,
        source: "universe_fundamentals",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get fundamentals stats", { error });
      res.status(500).json({ error: "Failed to get fundamentals stats" });
    }
  });
  app2.get("/api/admin/fundamentals/:symbol", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const fundamentals = await fundamentalsService.getFundamentalsBySymbol(symbol);
      if (!fundamentals) {
        return res.status(404).json({ error: "Fundamentals not found" });
      }
      const scores = fundamentalsService.calculateQualityGrowthScore(fundamentals);
      res.json({ ...fundamentals, ...scores });
    } catch (error) {
      log.error("Routes", "Failed to get fundamentals", { error });
      res.status(500).json({ error: "Failed to get fundamentals" });
    }
  });
  app2.get("/api/admin/fundamentals/top/scores", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const top = await fundamentalsService.getTopByScore(
        limit4 ? parseInt(limit4) : 50
      );
      res.json({ fundamentals: top, count: top.length });
    } catch (error) {
      log.error("Routes", "Failed to get top fundamentals", { error });
      res.status(500).json({ error: "Failed to get top fundamentals" });
    }
  });
  app2.post("/api/admin/fundamentals/fetch", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbols, batchSize, traceId } = req.body;
      const result = await fundamentalsService.fetchAndStoreFundamentals({
        symbols,
        batchSize: batchSize ? parseInt(batchSize) : 10,
        traceId: traceId || `fund-${Date.now()}`
      });
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to fetch fundamentals", { error });
      res.status(500).json({ error: "Failed to fetch fundamentals" });
    }
  });
  app2.get("/api/admin/candidates/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await candidatesService.getStats();
      res.json({
        ...stats,
        source: "universe_candidates",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get candidates stats", { error });
      res.status(500).json({ error: "Failed to get candidates stats" });
    }
  });
  app2.get("/api/admin/candidates", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { status, limit: limit4 } = req.query;
      let candidates;
      if (status && ["NEW", "WATCHLIST", "APPROVED", "REJECTED"].includes(status)) {
        candidates = await candidatesService.getCandidatesByStatus(
          status,
          limit4 ? parseInt(limit4) : 100
        );
      } else {
        candidates = await candidatesService.getTopCandidates(
          limit4 ? parseInt(limit4) : 100
        );
      }
      res.json({ candidates, count: candidates.length });
    } catch (error) {
      log.error("Routes", "Failed to get candidates", { error });
      res.status(500).json({ error: "Failed to get candidates" });
    }
  });
  app2.get("/api/admin/candidates/:symbol", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const candidate = await candidatesService.getCandidateBySymbol(symbol);
      if (!candidate) {
        return res.status(404).json({ error: "Candidate not found" });
      }
      res.json(candidate);
    } catch (error) {
      log.error("Routes", "Failed to get candidate", { error });
      res.status(500).json({ error: "Failed to get candidate" });
    }
  });
  app2.post("/api/admin/candidates/generate", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { minLiquidityTier, minScore, limit: limit4, traceId } = req.body;
      const result = await candidatesService.generateCandidates({
        minLiquidityTier,
        minScore: minScore ? parseFloat(minScore) : 0.4,
        limit: limit4 ? parseInt(limit4) : 100,
        traceId: traceId || `cand-${Date.now()}`
      });
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to generate candidates", { error });
      res.status(500).json({ error: "Failed to generate candidates" });
    }
  });
  app2.post("/api/admin/candidates/:symbol/approve", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const userId = req.userId;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const result = await candidatesService.approveCandidate(symbol, userId);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to approve candidate", { error });
      res.status(500).json({ error: "Failed to approve candidate" });
    }
  });
  app2.post("/api/admin/candidates/:symbol/reject", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const result = await candidatesService.rejectCandidate(symbol);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to reject candidate", { error });
      res.status(500).json({ error: "Failed to reject candidate" });
    }
  });
  app2.post("/api/admin/candidates/:symbol/watchlist", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { symbol } = req.params;
      const result = await candidatesService.watchlistCandidate(symbol);
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to watchlist candidate", { error });
      res.status(500).json({ error: "Failed to watchlist candidate" });
    }
  });
  app2.get("/api/admin/candidates/approved/list", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const symbols = await candidatesService.getApprovedSymbols();
      res.json({ symbols, count: symbols.length });
    } catch (error) {
      log.error("Routes", "Failed to get approved symbols", { error });
      res.status(500).json({ error: "Failed to get approved symbols" });
    }
  });
  app2.get("/api/admin/enforcement/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await tradingEnforcementService.getStats();
      res.json({
        ...stats,
        source: "trading_enforcement",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get enforcement stats", { error });
      res.status(500).json({ error: "Failed to get enforcement stats" });
    }
  });
  app2.post("/api/admin/enforcement/check", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { symbol, symbols, traceId } = req.body;
      if (symbol) {
        const result = await tradingEnforcementService.canTradeSymbol(symbol, traceId || `chk-${Date.now()}`);
        res.json(result);
      } else if (symbols && Array.isArray(symbols)) {
        const results = await tradingEnforcementService.canTradeMultiple(symbols, traceId || `chk-${Date.now()}`);
        res.json({ results: Object.fromEntries(results) });
      } else {
        res.status(400).json({ error: "Provide symbol or symbols array" });
      }
    } catch (error) {
      log.error("Routes", "Failed to check trading eligibility", { error });
      res.status(500).json({ error: "Failed to check trading eligibility" });
    }
  });
  app2.post("/api/admin/enforcement/reset-stats", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      tradingEnforcementService.resetStats();
      res.json({ success: true, message: "Enforcement stats reset" });
    } catch (error) {
      log.error("Routes", "Failed to reset enforcement stats", { error });
      res.status(500).json({ error: "Failed to reset enforcement stats" });
    }
  });
  app2.get("/api/admin/allocation/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await allocationService.getStats();
      res.json({
        ...stats,
        source: "allocation_policies",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get allocation stats", { error });
      res.status(500).json({ error: "Failed to get allocation stats" });
    }
  });
  app2.get("/api/admin/allocation/policies", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const policies = await allocationService.listPolicies();
      res.json({ policies, count: policies.length });
    } catch (error) {
      log.error("Routes", "Failed to list policies", { error });
      res.status(500).json({ error: "Failed to list policies" });
    }
  });
  app2.get("/api/admin/allocation/policies/active", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const policy = await allocationService.getActivePolicy();
      if (!policy) {
        return res.status(404).json({ error: "No active policy found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("Routes", "Failed to get active policy", { error });
      res.status(500).json({ error: "Failed to get active policy" });
    }
  });
  app2.get("/api/admin/allocation/policies/:id", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.getPolicyById(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("Routes", "Failed to get policy", { error });
      res.status(500).json({ error: "Failed to get policy" });
    }
  });
  app2.post("/api/admin/allocation/policies", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const userId = req.userId;
      const policy = await allocationService.createPolicy({
        ...req.body,
        createdBy: userId
      });
      res.status(201).json(policy);
    } catch (error) {
      log.error("Routes", "Failed to create policy", { error });
      res.status(500).json({ error: "Failed to create policy" });
    }
  });
  app2.patch("/api/admin/allocation/policies/:id", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.updatePolicy(id, req.body);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(policy);
    } catch (error) {
      log.error("Routes", "Failed to update policy", { error });
      res.status(500).json({ error: "Failed to update policy" });
    }
  });
  app2.post("/api/admin/allocation/policies/:id/activate", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.activatePolicy(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, policy });
    } catch (error) {
      log.error("Routes", "Failed to activate policy", { error });
      res.status(500).json({ error: "Failed to activate policy" });
    }
  });
  app2.post("/api/admin/allocation/policies/:id/deactivate", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { id } = req.params;
      const policy = await allocationService.deactivatePolicy(id);
      if (!policy) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, policy });
    } catch (error) {
      log.error("Routes", "Failed to deactivate policy", { error });
      res.status(500).json({ error: "Failed to deactivate policy" });
    }
  });
  app2.post("/api/admin/allocation/analyze", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { traceId } = req.body;
      const analysis = await allocationService.analyzeRebalance(traceId || `analyze-${Date.now()}`);
      if (!analysis) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      res.json({
        ...analysis,
        currentPositions: Object.fromEntries(analysis.currentPositions)
      });
    } catch (error) {
      log.error("Routes", "Failed to analyze rebalance", { error });
      res.status(500).json({ error: "Failed to analyze rebalance" });
    }
  });
  app2.get("/api/admin/allocation/runs", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { limit: limit4 } = req.query;
      const runs = await allocationService.getRebalanceRuns(
        limit4 ? parseInt(limit4) : 20
      );
      res.json({ runs, count: runs.length });
    } catch (error) {
      log.error("Routes", "Failed to get rebalance runs", { error });
      res.status(500).json({ error: "Failed to get rebalance runs" });
    }
  });
  app2.get("/api/admin/allocation/runs/:id", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { id } = req.params;
      const run = await allocationService.getRebalanceRunById(id);
      if (!run) {
        return res.status(404).json({ error: "Rebalance run not found" });
      }
      res.json(run);
    } catch (error) {
      log.error("Routes", "Failed to get rebalance run", { error });
      res.status(500).json({ error: "Failed to get rebalance run" });
    }
  });
  app2.get("/api/admin/rebalancer/stats", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const stats = await rebalancerService.getStats();
      res.json({
        ...stats,
        source: "rebalancer",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get rebalancer stats", { error });
      res.status(500).json({ error: "Failed to get rebalancer stats" });
    }
  });
  app2.post("/api/admin/rebalancer/dry-run", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { traceId } = req.body;
      const analysis = await rebalancerService.executeDryRun(traceId || `dry-${Date.now()}`);
      if (!analysis) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      res.json({
        ...analysis,
        analysis: analysis.analysis ? {
          ...analysis.analysis,
          currentPositions: Object.fromEntries(analysis.analysis.currentPositions)
        } : null
      });
    } catch (error) {
      log.error("Routes", "Failed to execute dry run", { error });
      res.status(500).json({ error: "Failed to execute dry run" });
    }
  });
  app2.post("/api/admin/rebalancer/execute", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { traceId, dryRun } = req.body;
      const result = await rebalancerService.executeRebalance(
        traceId || `rebal-${Date.now()}`,
        dryRun === true
      );
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to execute rebalance", { error });
      res.status(500).json({ error: "Failed to execute rebalance" });
    }
  });
  app2.post("/api/admin/rebalancer/profit-taking/analyze", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { traceId } = req.body;
      const policy = await allocationService.getActivePolicy();
      if (!policy) {
        return res.status(400).json({ error: "No active allocation policy configured" });
      }
      const analysis = await rebalancerService.analyzeProfitTaking(policy, traceId || `profit-${Date.now()}`);
      res.json({ candidates: analysis, count: analysis.length });
    } catch (error) {
      log.error("Routes", "Failed to analyze profit-taking", { error });
      res.status(500).json({ error: "Failed to analyze profit-taking" });
    }
  });
  app2.get("/api/universe/stats", authMiddleware, async (req, res) => {
    try {
      const stats = await tradabilityService.getUniverseStats();
      res.json(stats);
    } catch (error) {
      log.error("Routes", "Failed to get universe stats", { error });
      res.status(500).json({ error: "Failed to get universe stats" });
    }
  });
  app2.get("/api/universe/symbols", authMiddleware, async (req, res) => {
    try {
      const { assetClass, tradableOnly, limit: limit4 } = req.query;
      const assets = await storage.getBrokerAssets(
        assetClass,
        tradableOnly === "true",
        limit4 ? parseInt(limit4) : 1e3
      );
      res.json({
        assets,
        count: assets.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get symbols", { error });
      res.status(500).json({ error: "Failed to get symbols" });
    }
  });
  app2.get("/api/universe/search", authMiddleware, async (req, res) => {
    try {
      const { q, limit: limit4 } = req.query;
      if (!q || typeof q !== "string") {
        return res.status(400).json({ error: "Search query required" });
      }
      const assets = await tradabilityService.searchSymbols(
        q,
        limit4 ? parseInt(limit4) : 20
      );
      res.json({ assets, count: assets.length });
    } catch (error) {
      log.error("Routes", "Failed to search symbols", { error });
      res.status(500).json({ error: "Failed to search symbols" });
    }
  });
  app2.get("/api/universe/check/:symbol", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.params;
      const check = await tradabilityService.validateSymbolTradable(symbol);
      res.json(check);
    } catch (error) {
      log.error("Routes", "Failed to check tradability", { error });
      res.status(500).json({ error: "Failed to check tradability" });
    }
  });
  app2.post("/api/universe/sync", authMiddleware, async (req, res) => {
    try {
      const { assetClass } = req.body;
      await workQueue.enqueue({
        type: "ASSET_UNIVERSE_SYNC",
        status: "PENDING",
        payload: JSON.stringify({ assetClass: assetClass || "us_equity" }),
        maxAttempts: 3,
        nextRunAt: /* @__PURE__ */ new Date()
      });
      res.json({
        message: "Asset universe sync queued",
        assetClass: assetClass || "us_equity"
      });
    } catch (error) {
      log.error("Routes", "Failed to queue universe sync", { error });
      res.status(500).json({ error: "Failed to queue universe sync" });
    }
  });
  app2.post("/api/universe/sync-now", authMiddleware, async (req, res) => {
    try {
      const { assetClass } = req.body;
      const result = await tradabilityService.syncAssetUniverse(assetClass || "us_equity");
      tradabilityService.clearMemoryCache();
      res.json(result);
    } catch (error) {
      log.error("Routes", "Failed to sync universe", { error });
      res.status(500).json({ error: "Failed to sync universe" });
    }
  });
  app2.get("/api/candidates", authMiddleware, async (req, res) => {
    try {
      const { status, limit: limit4 } = req.query;
      let candidates;
      if (status && ["NEW", "WATCHLIST", "APPROVED", "REJECTED"].includes(status)) {
        candidates = await candidatesService.getCandidatesByStatus(
          status,
          limit4 ? parseInt(limit4) : 50
        );
      } else {
        candidates = await candidatesService.getTopCandidates(
          limit4 ? parseInt(limit4) : 50
        );
      }
      res.json({ candidates, count: candidates.length });
    } catch (error) {
      log.error("Routes", "Failed to get candidates", { error });
      res.status(500).json({ error: "Failed to get candidates" });
    }
  });
  app2.get("/api/watchlist", authMiddleware, async (req, res) => {
    try {
      const candidates = await candidatesService.getCandidatesByStatus("WATCHLIST", 100);
      res.json({
        watchlist: candidates.map((c) => ({
          symbol: c.symbol,
          tier: c.tier,
          score: c.finalScore,
          addedAt: c.createdAt
        })),
        count: candidates.length
      });
    } catch (error) {
      log.error("Routes", "Failed to get watchlist", { error });
      res.status(500).json({ error: "Failed to get watchlist" });
    }
  });
  app2.get("/api/admin/audit-logs", authMiddleware, async (req, res) => {
    try {
      const { getAuditLogs } = await Promise.resolve().then(() => (init_audit_logger(), audit_logger_exports));
      const {
        userId,
        resource,
        action,
        startDate,
        endDate,
        limit: limit4,
        offset
      } = req.query;
      const logs = await getAuditLogs({
        userId,
        resource,
        action,
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0,
        limit: limit4 ? parseInt(limit4) : 100,
        offset: offset ? parseInt(offset) : 0
      });
      res.json({ logs, count: logs.length });
    } catch (error) {
      log.error("Routes", "Failed to get audit logs", { error });
      res.status(500).json({ error: "Failed to get audit logs" });
    }
  });
  app2.get("/api/admin/audit-logs/stats", authMiddleware, async (req, res) => {
    try {
      const { getAuditStats } = await Promise.resolve().then(() => (init_audit_logger(), audit_logger_exports));
      const { startDate, endDate } = req.query;
      const stats = await getAuditStats({
        startDate: startDate ? new Date(startDate) : void 0,
        endDate: endDate ? new Date(endDate) : void 0
      });
      res.json(stats);
    } catch (error) {
      log.error("Routes", "Failed to get audit stats", { error });
      res.status(500).json({ error: "Failed to get audit stats" });
    }
  });
  app2.get("/api/allocation-policies", authMiddleware, async (req, res) => {
    try {
      const policies = await db.query.allocationPolicies.findMany({
        orderBy: [desc19(allocationPolicies.createdAt)]
      });
      res.json({ policies, count: policies.length });
    } catch (error) {
      log.error("Routes", "Failed to get allocation policies", { error });
      res.status(500).json({ error: "Failed to get allocation policies" });
    }
  });
  app2.post("/api/allocation-policies", authMiddleware, async (req, res) => {
    try {
      const { name, description, maxPositionWeightPct, maxSectorWeightPct, rebalanceFrequency, isActive } = req.body;
      if (!name) {
        return res.status(400).json({ error: "name is required" });
      }
      const [policy] = await db.insert(allocationPolicies).values({
        name,
        description: description || null,
        maxPositionWeightPct: maxPositionWeightPct ? String(maxPositionWeightPct) : "8",
        maxSectorWeightPct: maxSectorWeightPct ? String(maxSectorWeightPct) : "25",
        rebalanceFrequency: rebalanceFrequency || "daily",
        isActive: isActive !== void 0 ? isActive : false,
        createdBy: req.user?.id || null
      }).returning();
      res.json(policy);
    } catch (error) {
      log.error("Routes", "Failed to create allocation policy", { error });
      res.status(500).json({ error: "Failed to create allocation policy" });
    }
  });
  app2.patch("/api/allocation-policies/:id", authMiddleware, async (req, res) => {
    try {
      const { name, description, maxPositionWeightPct, maxSectorWeightPct, rebalanceFrequency, isActive } = req.body;
      const updates = { updatedAt: /* @__PURE__ */ new Date() };
      if (name !== void 0) updates.name = name;
      if (description !== void 0) updates.description = description;
      if (maxPositionWeightPct !== void 0) updates.maxPositionWeightPct = String(maxPositionWeightPct);
      if (maxSectorWeightPct !== void 0) updates.maxSectorWeightPct = String(maxSectorWeightPct);
      if (rebalanceFrequency !== void 0) updates.rebalanceFrequency = rebalanceFrequency;
      if (isActive !== void 0) updates.isActive = isActive;
      const [updated] = await db.update(allocationPolicies).set(updates).where(eq27(allocationPolicies.id, req.params.id)).returning();
      if (!updated) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json(updated);
    } catch (error) {
      log.error("Routes", "Failed to update allocation policy", { error });
      res.status(500).json({ error: "Failed to update allocation policy" });
    }
  });
  app2.delete("/api/allocation-policies/:id", authMiddleware, async (req, res) => {
    try {
      const [deleted] = await db.delete(allocationPolicies).where(eq27(allocationPolicies.id, req.params.id)).returning();
      if (!deleted) {
        return res.status(404).json({ error: "Policy not found" });
      }
      res.json({ success: true, message: "Policy deleted" });
    } catch (error) {
      log.error("Routes", "Failed to delete allocation policy", { error });
      res.status(500).json({ error: "Failed to delete allocation policy" });
    }
  });
  app2.get("/api/rebalance/runs", authMiddleware, async (req, res) => {
    try {
      const { limit: limit4, status } = req.query;
      let whereClause = void 0;
      if (status) {
        whereClause = eq27(rebalanceRuns.status, status);
      }
      const runs = await db.query.rebalanceRuns.findMany({
        where: whereClause,
        orderBy: [desc19(rebalanceRuns.startedAt)],
        limit: limit4 ? parseInt(limit4) : 50
      });
      res.json({ runs, count: runs.length });
    } catch (error) {
      log.error("Routes", "Failed to get rebalance runs", { error });
      res.status(500).json({ error: "Failed to get rebalance runs" });
    }
  });
  app2.post("/api/rebalance/trigger", authMiddleware, async (req, res) => {
    try {
      const { policyId, triggerType = "manual" } = req.body;
      const traceId = `rebalance-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
      const [run] = await db.insert(rebalanceRuns).values({
        policyId: policyId || null,
        traceId,
        status: "running",
        triggerType,
        inputSnapshot: {}
      }).returning();
      setTimeout(async () => {
        await db.update(rebalanceRuns).set({ status: "completed", completedAt: /* @__PURE__ */ new Date() }).where(eq27(rebalanceRuns.id, run.id));
      }, 2e3);
      res.json({ success: true, run });
    } catch (error) {
      log.error("Routes", "Failed to trigger rebalance", { error });
      res.status(500).json({ error: "Failed to trigger rebalance" });
    }
  });
  app2.get("/api/enforcement/rules", authMiddleware, async (req, res) => {
    try {
      const rules = await db.query.alertRules.findMany({
        orderBy: [desc19(alertRules.createdAt)]
      });
      res.json({ rules, count: rules.length });
    } catch (error) {
      log.error("Routes", "Failed to get enforcement rules", { error });
      res.status(500).json({ error: "Failed to get enforcement rules" });
    }
  });
  app2.post("/api/enforcement/rules", authMiddleware, async (req, res) => {
    try {
      const { name, description, ruleType, condition, threshold, enabled, webhookUrl } = req.body;
      if (!name || !ruleType || threshold === void 0) {
        return res.status(400).json({ error: "name, ruleType, and threshold are required" });
      }
      const [rule] = await db.insert(alertRules).values({
        name,
        description: description || null,
        ruleType,
        condition: condition || { scope: "portfolio" },
        threshold: String(threshold),
        enabled: enabled !== void 0 ? enabled : true,
        webhookUrl: webhookUrl || null
      }).returning();
      res.json(rule);
    } catch (error) {
      log.error("Routes", "Failed to create enforcement rule", { error });
      res.status(500).json({ error: "Failed to create enforcement rule" });
    }
  });
  app2.patch("/api/enforcement/rules/:id", authMiddleware, async (req, res) => {
    try {
      const { name, description, ruleType, condition, threshold, enabled, webhookUrl } = req.body;
      const updates = { updatedAt: /* @__PURE__ */ new Date() };
      if (name !== void 0) updates.name = name;
      if (description !== void 0) updates.description = description;
      if (ruleType !== void 0) updates.ruleType = ruleType;
      if (condition !== void 0) updates.condition = condition;
      if (threshold !== void 0) updates.threshold = String(threshold);
      if (enabled !== void 0) updates.enabled = enabled;
      if (webhookUrl !== void 0) updates.webhookUrl = webhookUrl;
      const [updated] = await db.update(alertRules).set(updates).where(eq27(alertRules.id, req.params.id)).returning();
      if (!updated) {
        return res.status(404).json({ error: "Rule not found" });
      }
      res.json(updated);
    } catch (error) {
      log.error("Routes", "Failed to update enforcement rule", { error });
      res.status(500).json({ error: "Failed to update enforcement rule" });
    }
  });
  app2.delete("/api/enforcement/rules/:id", authMiddleware, async (req, res) => {
    try {
      const [deleted] = await db.delete(alertRules).where(eq27(alertRules.id, req.params.id)).returning();
      if (!deleted) {
        return res.status(404).json({ error: "Rule not found" });
      }
      res.json({ success: true, message: "Rule deleted" });
    } catch (error) {
      log.error("Routes", "Failed to delete enforcement rule", { error });
      res.status(500).json({ error: "Failed to delete enforcement rule" });
    }
  });
  app2.get("/api/fundamentals/factors", authMiddleware, async (req, res) => {
    try {
      const { symbol } = req.query;
      let whereClause = void 0;
      if (symbol) {
        whereClause = eq27(universeFundamentals.symbol, symbol);
      }
      const factors = await db.query.universeFundamentals.findMany({
        where: whereClause,
        limit: 100
      });
      const factorList = [
        { id: "1", name: "P/E Ratio", source: "SEC EDGAR", cadence: "Quarterly", status: "healthy", lastUpdated: (/* @__PURE__ */ new Date()).toISOString() },
        { id: "2", name: "Revenue Growth", source: "SEC EDGAR", cadence: "Quarterly", status: "healthy", lastUpdated: (/* @__PURE__ */ new Date()).toISOString() },
        { id: "3", name: "Analyst Ratings", source: "Market Data", cadence: "Real-time", status: "healthy", lastUpdated: (/* @__PURE__ */ new Date()).toISOString() },
        { id: "4", name: "Earnings Estimates", source: "Analyst Consensus", cadence: "Weekly", status: "healthy", lastUpdated: (/* @__PURE__ */ new Date()).toISOString() }
      ];
      res.json({ factors: factorList, rawData: factors, count: factors.length });
    } catch (error) {
      log.error("Routes", "Failed to get fundamentals", { error });
      res.status(500).json({ error: "Failed to get fundamentals" });
    }
  });
  app2.post("/api/fundamentals/refresh", authMiddleware, async (req, res) => {
    try {
      res.json({ success: true, message: "Fundamental data refresh initiated" });
    } catch (error) {
      log.error("Routes", "Failed to refresh fundamentals", { error });
      res.status(500).json({ error: "Failed to refresh fundamentals" });
    }
  });
  app2.get("/api/admin/dashboard", authMiddleware, async (req, res) => {
    try {
      const { getAllAvailableProviders: getAllAvailableProviders2 } = await Promise.resolve().then(() => (init_ai(), ai_exports));
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      const aiProviders = getAllAvailableProviders2();
      const providerStatuses = await getAllProviderStatuses2();
      const activeProviders = Object.entries(providerStatuses).filter(
        ([_, status]) => status.isAvailable
      ).length;
      const pendingCount = await storage.getWorkItemCount("PENDING");
      const runningCount = await storage.getWorkItemCount("RUNNING");
      const failedCount = await storage.getWorkItemCount("FAILED");
      const agentStatus2 = await storage.getAgentStatus();
      res.json({
        providers: {
          total: aiProviders.length,
          active: activeProviders
        },
        models: {
          total: aiProviders.length,
          enabled: activeProviders
        },
        jobs: {
          running: runningCount,
          pending: pendingCount,
          failed: failedCount
        },
        killSwitch: !(agentStatus2?.autoExecuteTrades ?? false)
      });
    } catch (error) {
      log.error("Routes", "Failed to get dashboard stats", { error });
      res.status(500).json({ error: "Failed to get dashboard stats" });
    }
  });
  app2.get("/api/admin/users", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const allUsers = await storage.getAllUsers();
      const sanitizedUsers = allUsers.map(({ password, ...user }) => ({
        ...user,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
        // Users table doesn't have createdAt yet
      }));
      res.json({ users: sanitizedUsers, count: sanitizedUsers.length });
    } catch (error) {
      log.error("Routes", "Failed to get users", { error });
      res.status(500).json({ error: "Failed to get users" });
    }
  });
  app2.get("/api/admin/users/:id", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { id } = req.params;
      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password, ...sanitizedUser } = user;
      res.json(sanitizedUser);
    } catch (error) {
      log.error("Routes", "Failed to get user", { error });
      res.status(500).json({ error: "Failed to get user" });
    }
  });
  app2.post("/api/admin/users", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { username, password, isAdmin } = req.body;
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password are required" });
      }
      const existing = await storage.getUserByUsername(username);
      if (existing) {
        return res.status(409).json({ error: "Username already exists" });
      }
      const bcrypt3 = await import("bcrypt");
      const hashedPassword = await bcrypt3.hash(password, 10);
      const user = await storage.createUser({
        username,
        password: hashedPassword,
        isAdmin: isAdmin || false
      });
      const { password: _, ...sanitizedUser } = user;
      res.status(201).json(sanitizedUser);
    } catch (error) {
      log.error("Routes", "Failed to create user", { error });
      res.status(500).json({ error: "Failed to create user" });
    }
  });
  app2.patch("/api/admin/users/:id", authMiddleware, requireCapability("admin:write"), async (req, res) => {
    try {
      const { id } = req.params;
      const { username, password, isAdmin } = req.body;
      const updates = {};
      if (username !== void 0) updates.username = username;
      if (isAdmin !== void 0) updates.isAdmin = isAdmin;
      if (password) {
        const bcrypt3 = await import("bcrypt");
        updates.password = await bcrypt3.hash(password, 10);
      }
      const user = await storage.updateUser(id, updates);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const { password: _, ...sanitizedUser } = user;
      res.json(sanitizedUser);
    } catch (error) {
      log.error("Routes", "Failed to update user", { error });
      res.status(500).json({ error: "Failed to update user" });
    }
  });
  app2.delete("/api/admin/users/:id", authMiddleware, requireCapability("admin:danger"), async (req, res) => {
    try {
      const { id } = req.params;
      if (id === req.userId) {
        return res.status(400).json({ error: "Cannot delete your own account" });
      }
      const deleted = await storage.deleteUser(id);
      if (!deleted) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({ success: true });
    } catch (error) {
      log.error("Routes", "Failed to delete user", { error });
      res.status(500).json({ error: "Failed to delete user" });
    }
  });
  app2.get("/api/admin/observability/metrics", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const memUsage = process.memoryUsage();
      const uptime = process.uptime();
      const pendingJobs = await storage.getWorkItemCount("PENDING");
      const runningJobs = await storage.getWorkItemCount("RUNNING");
      const failedJobs = await storage.getWorkItemCount("FAILED");
      const completedJobs = await storage.getWorkItemCount("DONE");
      const recentLogs = await storage.getRecentAuditLogs(100);
      const logsLast24h = recentLogs.filter((log2) => {
        const logTime = new Date(log2.timestamp || log2.createdAt).getTime();
        return Date.now() - logTime < 24 * 60 * 60 * 1e3;
      }).length;
      res.json({
        system: {
          memoryUsedMB: Math.round(memUsage.heapUsed / 1024 / 1024),
          memoryTotalMB: Math.round(memUsage.heapTotal / 1024 / 1024),
          uptimeHours: Math.round(uptime / 3600 * 10) / 10,
          nodeVersion: process.version
        },
        workQueue: {
          pending: pendingJobs,
          running: runningJobs,
          failed: failedJobs,
          completed: completedJobs
        },
        activity: {
          logsLast24h,
          totalRecentLogs: recentLogs.length
        },
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get observability metrics", { error });
      res.status(500).json({ error: "Failed to get observability metrics" });
    }
  });
  app2.get("/api/admin/observability/logs", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { limit: limit4, offset, level } = req.query;
      const limitNum = parseInt(limit4) || 50;
      const offsetNum = parseInt(offset) || 0;
      const logs = await storage.getRecentAuditLogs(limitNum, offsetNum);
      const filteredLogs = level ? logs.filter((log2) => log2.level === level) : logs;
      res.json({
        logs: filteredLogs,
        count: filteredLogs.length,
        offset: offsetNum
      });
    } catch (error) {
      log.error("Routes", "Failed to get logs", { error });
      res.status(500).json({ error: "Failed to get logs" });
    }
  });
  app2.get("/api/admin/observability/health", authMiddleware, requireCapability("admin:read"), async (req, res) => {
    try {
      const { getAllProviderStatuses: getAllProviderStatuses2 } = await Promise.resolve().then(() => (init_callExternal(), callExternal_exports));
      let dbHealthy = true;
      try {
        await storage.getAgentStatus();
      } catch {
        dbHealthy = false;
      }
      const providerStatuses = await getAllProviderStatuses2();
      const providersHealthy = Object.values(providerStatuses).some((s) => s.isAvailable);
      let alpacaHealthy = false;
      try {
        const alpaca2 = await Promise.resolve().then(() => (init_alpaca(), alpaca_exports));
        const account = await alpaca2.alpacaClient.getAccount();
        alpacaHealthy = account?.status === "ACTIVE";
      } catch {
        alpacaHealthy = false;
      }
      res.json({
        services: [
          { name: "Database", status: dbHealthy ? "healthy" : "unhealthy", message: dbHealthy ? "Connected" : "Connection failed" },
          { name: "API Endpoints", status: "healthy", message: "Operational" },
          { name: "LLM Providers", status: providersHealthy ? "healthy" : "degraded", message: providersHealthy ? "Available" : "No providers" },
          { name: "Alpaca Trading", status: alpacaHealthy ? "healthy" : "unhealthy", message: alpacaHealthy ? "Connected" : "Disconnected" },
          { name: "Background Jobs", status: "healthy", message: "Running" }
        ],
        overall: dbHealthy && alpacaHealthy ? "healthy" : "degraded",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    } catch (error) {
      log.error("Routes", "Failed to get health status", { error });
      res.status(500).json({ error: "Failed to get health status" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/index.ts
init_logger();
import * as fs from "fs";
import * as path from "path";

// server/config/env-validator.ts
var REQUIRED_ENV_VARS = [
  "DATABASE_URL",
  "ALPACA_API_KEY",
  "ALPACA_SECRET_KEY"
];
var OPTIONAL_ENV_VARS = [
  { key: "FINNHUB_API_KEY", feature: "Finnhub market data" },
  { key: "OPENAI_API_KEY", feature: "OpenAI AI decisions" },
  { key: "NEWS_API_KEY", feature: "News sentiment" },
  { key: "COINMARKETCAP_API_KEY", feature: "CoinMarketCap data" },
  { key: "VALYU_API_KEY", feature: "Fundamental data" },
  { key: "FRED_API_KEY", feature: "Macro indicators" },
  { key: "HUGGINGFACE_API_KEY", feature: "HuggingFace sentiment" }
];
function validateDatabaseUrl(url) {
  if (!url.startsWith("postgres://") && !url.startsWith("postgresql://")) {
    return "DATABASE_URL must start with postgres:// or postgresql://";
  }
  const pattern = /^postgres(ql)?:\/\/[^:]+:[^@]+@[^\/]+\/.+$/;
  if (!pattern.test(url)) {
    return "DATABASE_URL appears to be malformed. Expected format: postgres://user:password@host/database";
  }
  return null;
}
function validateApiKeyLength(key, name, minLength = 16) {
  if (key.length < minLength) {
    return `${name} appears too short (minimum ${minLength} characters expected)`;
  }
  return null;
}
function validateTradingMode(mode) {
  if (mode !== "paper" && mode !== "live") {
    return "ALPACA_TRADING_MODE must be either 'paper' or 'live'";
  }
  return null;
}
function validateEnvironment() {
  const errors = [];
  const warnings = [];
  const features = [];
  for (const varName of REQUIRED_ENV_VARS) {
    const value = process.env[varName];
    if (!value) {
      errors.push(`Required environment variable ${varName} is not set`);
      continue;
    }
    if (varName === "DATABASE_URL") {
      const error = validateDatabaseUrl(value);
      if (error) {
        errors.push(error);
      }
    }
    if (varName === "ALPACA_API_KEY" || varName === "ALPACA_SECRET_KEY") {
      const error = validateApiKeyLength(value, varName);
      if (error) {
        warnings.push(error);
      }
    }
  }
  for (const { key, feature } of OPTIONAL_ENV_VARS) {
    const value = process.env[key];
    if (!value) {
      features.push({ name: feature, enabled: false });
      warnings.push(`Optional environment variable ${key} is not set - ${feature} will be disabled`);
    } else {
      features.push({ name: feature, enabled: true });
      const error = validateApiKeyLength(value, key, 10);
      if (error) {
        warnings.push(error);
      }
    }
  }
  const tradingMode = process.env.ALPACA_TRADING_MODE;
  if (tradingMode) {
    const error = validateTradingMode(tradingMode);
    if (error) {
      errors.push(error);
    }
  } else {
    warnings.push("ALPACA_TRADING_MODE not set - will default to 'paper' mode");
  }
  const port = process.env.PORT;
  if (port) {
    const portNum = parseInt(port, 10);
    if (isNaN(portNum) || portNum < 1 || portNum > 65535) {
      errors.push(`PORT must be a valid number between 1 and 65535 (got: ${port})`);
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings,
    features
  };
}
function validateAndReportEnvironment() {
  console.log("[ENV] Validating environment variables...");
  const result = validateEnvironment();
  console.log("\n[ENV] Feature Status:");
  console.log("\u2501".repeat(60));
  const enabledFeatures = result.features.filter((f) => f.enabled);
  const disabledFeatures = result.features.filter((f) => !f.enabled);
  if (enabledFeatures.length > 0) {
    console.log("  \u2713 Enabled features:");
    enabledFeatures.forEach((f) => {
      console.log(`    \u2022 ${f.name}`);
    });
  }
  if (disabledFeatures.length > 0) {
    console.log("  \u2717 Disabled features:");
    disabledFeatures.forEach((f) => {
      console.log(`    \u2022 ${f.name}`);
    });
  }
  console.log("\u2501".repeat(60));
  if (result.warnings.length > 0) {
    console.log("\n[ENV] Warnings:");
    result.warnings.forEach((warning) => {
      console.warn(`  \u26A0  ${warning}`);
    });
  }
  if (result.errors.length > 0) {
    console.error("\n[ENV] VALIDATION FAILED - Missing or invalid required environment variables:");
    console.error("\u2501".repeat(60));
    result.errors.forEach((error) => {
      console.error(`  \u2717 ${error}`);
    });
    console.error("\u2501".repeat(60));
    console.error("\n[ENV] Please set all required environment variables and restart the server.");
    console.error("[ENV] Server startup aborted.\n");
    throw new Error("Environment validation failed - missing or invalid required variables");
  }
  console.log("\n[ENV] \u2713 Environment validation passed");
  console.log("[ENV] All required variables are set and valid\n");
}

// server/index.ts
init_position_reconciliation();

// server/middleware/error-handler.ts
init_logger();
function errorHandler(err, req, res, next) {
  const correlationId = req.correlationId || "unknown";
  log.error("ErrorHandler", `Unhandled error in ${req.method} ${req.path}`, {
    correlationId,
    error: err.message,
    stack: err.stack,
    code: err.code,
    statusCode: err.statusCode,
    method: req.method,
    path: req.path,
    userId: req.userId
  });
  const isDevelopment = process.env.NODE_ENV === "development";
  const statusCode = err.statusCode || 500;
  const errorResponse = {
    error: isDevelopment ? err.message : "Internal server error",
    code: err.code || "INTERNAL_ERROR",
    correlationId
  };
  if (isDevelopment && err.stack) {
    errorResponse.stack = err.stack.split("\n").slice(0, 5);
  }
  res.status(statusCode).json(errorResponse);
}
function notFoundHandler(req, res) {
  const correlationId = req.correlationId || "unknown";
  log.warn("ErrorHandler", `Route not found: ${req.method} ${req.path}`, {
    correlationId,
    method: req.method,
    path: req.path
  });
  res.status(404).json({
    error: "Not found",
    code: "NOT_FOUND",
    message: `Route ${req.method} ${req.path} not found`,
    correlationId
  });
}

// server/middleware/request-logger.ts
init_logger();
import { randomBytes as randomBytes2 } from "crypto";
function generateCorrelationId() {
  return `req_${Date.now()}_${randomBytes2(8).toString("hex")}`;
}
function requestLogger(req, res, next) {
  const startTime = Date.now();
  const correlationId = req.headers["x-correlation-id"] || generateCorrelationId();
  req.correlationId = correlationId;
  res.setHeader("X-Correlation-ID", correlationId);
  log.info("Request", `${req.method} ${req.path}`, {
    correlationId,
    method: req.method,
    path: req.path,
    query: Object.keys(req.query).length > 0 ? req.query : void 0,
    userId: req.userId,
    ip: req.ip || req.socket.remoteAddress,
    userAgent: req.headers["user-agent"]
  });
  const originalSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - startTime;
    log.info("Response", `${req.method} ${req.path} - ${res.statusCode}`, {
      correlationId,
      method: req.method,
      path: req.path,
      statusCode: res.statusCode,
      durationMs: duration,
      userId: req.userId
    });
    return originalSend.call(this, data);
  };
  next();
}
function performanceLogger(thresholdMs = 1e3) {
  return (req, res, next) => {
    const startTime = Date.now();
    const correlationId = req.correlationId || "unknown";
    res.on("finish", () => {
      const duration = Date.now() - startTime;
      if (duration > thresholdMs) {
        log.warn("Performance", `Slow request detected: ${req.method} ${req.path}`, {
          correlationId,
          method: req.method,
          path: req.path,
          durationMs: duration,
          threshold: thresholdMs,
          statusCode: res.statusCode
        });
      }
    });
    next();
  };
}

// server/index.ts
process.on("uncaughtException", (err) => {
  log.error("FATAL", "Uncaught exception", { error: err });
});
process.on("unhandledRejection", (reason, promise) => {
  log.error("FATAL", "Unhandled rejection", { promise, reason });
});
process.on("SIGTERM", () => log.info("SIGNAL", "SIGTERM received"));
process.on("SIGINT", () => log.info("SIGNAL", "SIGINT received"));
process.on("beforeExit", (code) => log.info("PROCESS", "beforeExit", { code }));
process.on("exit", (code) => log.info("PROCESS", "exit", { code }));
var app = express();
function setupCors(app2) {
  app2.use((req, res, next) => {
    const origins = /* @__PURE__ */ new Set();
    if (process.env.REPLIT_DEV_DOMAIN) {
      origins.add(`https://${process.env.REPLIT_DEV_DOMAIN}`);
    }
    if (process.env.REPLIT_DOMAINS) {
      process.env.REPLIT_DOMAINS.split(",").forEach((d) => {
        origins.add(`https://${d.trim()}`);
      });
    }
    const origin = req.header("origin");
    if (!origin || origins.has(origin)) {
      res.header("Access-Control-Allow-Origin", origin || "*");
      res.header(
        "Access-Control-Allow-Methods",
        "GET, POST, PUT, DELETE, OPTIONS"
      );
      res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
      res.header("Access-Control-Allow-Credentials", "true");
    }
    if (req.method === "OPTIONS") {
      return res.sendStatus(200);
    }
    next();
  });
}
function setupBodyParsing(app2) {
  app2.use(
    express.json({
      verify: (req, _res, buf) => {
        req.rawBody = buf;
      }
    })
  );
  app2.use(express.urlencoded({ extended: false }));
}
function setupRequestLogging(app2) {
  app2.use(requestLogger);
  app2.use(performanceLogger(1e3));
}
function getAppName() {
  try {
    const appJsonPath = path.resolve(process.cwd(), "app.json");
    const appJsonContent = fs.readFileSync(appJsonPath, "utf-8");
    const appJson = JSON.parse(appJsonContent);
    return appJson.expo?.name || "App Landing Page";
  } catch {
    return "App Landing Page";
  }
}
function serveExpoManifest(platform, res) {
  const manifestPath = path.resolve(
    process.cwd(),
    "static-build",
    platform,
    "manifest.json"
  );
  if (!fs.existsSync(manifestPath)) {
    return res.status(404).json({ error: `Manifest not found for platform: ${platform}` });
  }
  res.setHeader("expo-protocol-version", "1");
  res.setHeader("expo-sfv-version", "0");
  res.setHeader("content-type", "application/json");
  const manifest = fs.readFileSync(manifestPath, "utf-8");
  res.send(manifest);
}
function serveLandingPage({
  req,
  res,
  landingPageTemplate,
  appName
}) {
  const forwardedProto = req.header("x-forwarded-proto");
  const protocol = forwardedProto || req.protocol || "https";
  const forwardedHost = req.header("x-forwarded-host");
  const host = forwardedHost || req.get("host");
  const baseUrl = `${protocol}://${host}`;
  const expsUrl = `${host}`;
  log.debug("Server", "Landing page URL generation", { baseUrl, expsUrl });
  const html = landingPageTemplate.replace(/BASE_URL_PLACEHOLDER/g, baseUrl).replace(/EXPS_URL_PLACEHOLDER/g, expsUrl).replace(/APP_NAME_PLACEHOLDER/g, appName);
  res.setHeader("Content-Type", "text/html; charset=utf-8");
  res.status(200).send(html);
}
function configureExpoAndLanding(app2) {
  const templatePath = path.resolve(
    process.cwd(),
    "server",
    "templates",
    "landing-page.html"
  );
  const landingPageTemplate = fs.readFileSync(templatePath, "utf-8");
  const appName = getAppName();
  log.info("Server", "Serving static Expo files with dynamic manifest routing");
  app2.use((req, res, next) => {
    if (req.path.startsWith("/api")) {
      return next();
    }
    if (req.path !== "/" && req.path !== "/manifest") {
      return next();
    }
    const platform = req.header("expo-platform");
    if (platform && (platform === "ios" || platform === "android")) {
      return serveExpoManifest(platform, res);
    }
    if (req.path === "/") {
      return serveLandingPage({
        req,
        res,
        landingPageTemplate,
        appName
      });
    }
    next();
  });
  app2.use("/assets", express.static(path.resolve(process.cwd(), "assets")));
  app2.use(express.static(path.resolve(process.cwd(), "static-build")));
  log.info("Server", "Expo routing: Checking expo-platform header on / and /manifest");
}
function setupErrorHandler(app2) {
  app2.use(notFoundHandler);
  app2.use(errorHandler);
}
(async () => {
  try {
    validateAndReportEnvironment();
    log.info("STARTUP", "Beginning server initialization...");
    setupCors(app);
    setupBodyParsing(app);
    app.use(cookieParser());
    setupRequestLogging(app);
    configureExpoAndLanding(app);
    log.info("STARTUP", "Registering routes...");
    const server = await registerRoutes(app);
    log.info("STARTUP", "Routes registered successfully");
    log.info("STARTUP", "Starting position reconciliation job...");
    positionReconciliationJob.start();
    log.info("STARTUP", "Position reconciliation job started");
    log.info("STARTUP", "Starting session cleanup job...");
    setInterval(async () => {
      try {
        await cleanupExpiredSessions();
      } catch (error) {
        log.error("SessionCleanup", "Error cleaning up expired sessions", { error });
      }
    }, 60 * 60 * 1e3);
    log.info("STARTUP", "Session cleanup job started (runs every hour)");
    setupErrorHandler(app);
    const port = parseInt(process.env.PORT || "5000", 10);
    log.info("STARTUP", `Starting server on port ${port}...`);
    server.listen(
      {
        port,
        host: "0.0.0.0",
        reusePort: true
      },
      () => {
        log.info("Server", `Express server listening on port ${port}`);
      }
    );
  } catch (error) {
    log.error("STARTUP", "Fatal error during server initialization", { error });
  }
})();
