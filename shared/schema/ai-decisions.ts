/**
 * @module schema/ai-decisions
 * @description AI decision tracking and machine learning system for algorithmic trading.
 *
 * This module tracks the complete lifecycle of AI-generated trading decisions:
 * 1. Decision creation with confidence scores and market context
 * 2. Feature extraction for ML training (technical indicators, sentiment, fundamentals)
 * 3. Trade execution and outcome tracking (P&L, slippage, hit rates)
 * 4. Model calibration and performance analysis
 *
 * The data structure supports:
 * - Supervised learning from historical trade outcomes
 * - Feature engineering for price prediction models
 * - Performance attribution and backtesting
 * - Real-time model calibration and adjustment
 *
 * Decision Lifecycle:
 * 1. AI generates decision → aiDecisions (status: 'pending')
 * 2. Extract features → aiDecisionFeatures (ML training data)
 * 3. Execute trade → aiDecisions.executedTradeId linked
 * 4. Track outcome → aiTradeOutcomes (P&L, metrics)
 * 5. Calibrate model → aiCalibrationLog (periodic analysis)
 *
 * Relationships:
 * - aiDecisions → users (many-to-one)
 * - aiDecisions → strategies (many-to-one, optional)
 * - aiDecisions → trades (one-to-one, optional)
 * - aiDecisionFeatures → aiDecisions (many-to-one)
 * - aiTradeOutcomes → aiDecisions (one-to-one)
 * - aiTradeOutcomes → trades (one-to-one, optional)
 */

import { sql } from "drizzle-orm";
import { pgTable, varchar, text, timestamp, numeric, integer, boolean, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { users } from "./auth";
import { strategies, trades } from "./trading";

// ============================================================================
// AI DECISIONS TABLES
// ============================================================================

/**
 * Core AI trading decisions table.
 *
 * Stores every trading decision generated by AI models with:
 * - Action recommendations (buy/sell/hold)
 * - Confidence scores (0-1 probability)
 * - Market context and reasoning
 * - Risk management parameters (stop loss, take profit)
 * - Execution tracking (filled price, timestamps)
 *
 * Status states:
 * - 'pending': Decision generated, awaiting execution
 * - 'executed': Trade filled, tracking outcome
 * - 'skipped': Decision rejected (see skipReason)
 * - 'cancelled': Decision cancelled before execution
 *
 * This table serves as the foundation for:
 * - Real-time trading automation
 * - ML model training (features → outcomes)
 * - Performance attribution
 * - Audit trail for compliance
 *
 * @see aiDecisionFeatures - Feature vectors for ML training
 * @see aiTradeOutcomes - Trade performance metrics
 */
export const aiDecisions = pgTable("ai_decisions", {
  id: varchar("id")
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
  symbol: text("symbol").notNull(),
  action: text("action").notNull(),
  confidence: numeric("confidence"),
  reasoning: text("reasoning"),
  marketContext: text("market_context"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  // Note: executedTradeId references trades table - foreign key defined at database level
  executedTradeId: varchar("executed_trade_id"),
  status: text("status").default("pending").notNull(),
  stopLoss: numeric("stop_loss"),
  takeProfit: numeric("take_profit"),
  entryPrice: numeric("entry_price"),
  filledPrice: numeric("filled_price"),
  filledAt: timestamp("filled_at"),
  skipReason: text("skip_reason"),
  traceId: text("trace_id"),
  metadata: text("metadata"),
}, (table) => ({
  userIdIdx: index("ai_decisions_user_id_idx").on(table.userId),
}));

/**
 * Feature vectors for machine learning training.
 *
 * Captures market state and technical indicators at decision time:
 * - Technical indicators (RSI, MACD, volatility, volume)
 * - Fundamental metrics (P/E ratio, P/B ratio)
 * - Market sentiment scores
 * - Data quality metrics (source reliability)
 *
 * Feature Engineering:
 * - All features normalized to comparable scales
 * - Feature vector stored as JSON for model input
 * - Market condition classification (trending, ranging, volatile)
 * - Signal agreement (confluence across indicators)
 *
 * ML Training Data Structure:
 * - Input: featureVector (technical + fundamental + sentiment)
 * - Target: Trade outcome (win/loss from aiTradeOutcomes)
 * - Quality: dataQuality score filters unreliable data
 * - Coverage: activeSources tracks data completeness
 *
 * This enables:
 * - Supervised learning for price prediction
 * - Feature importance analysis
 * - Model validation and backtesting
 * - Real-time inference at decision points
 *
 * @see aiDecisions - Parent decision record
 * @see aiTradeOutcomes - Training labels (win/loss outcomes)
 */
export const aiDecisionFeatures = pgTable("ai_decision_features", {
  id: varchar("id")
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
  symbol: text("symbol").notNull(),
  volatility: numeric("volatility"),
  trendStrength: numeric("trend_strength"),
  signalAgreement: numeric("signal_agreement"),
  sentimentScore: numeric("sentiment_score"),
  peRatio: numeric("pe_ratio"),
  pbRatio: numeric("pb_ratio"),
  rsi: numeric("rsi"),
  macdSignal: text("macd_signal"),
  volumeRatio: numeric("volume_ratio"),
  priceChangePercent: numeric("price_change_percent"),
  marketCondition: text("market_condition"),
  dataQuality: numeric("data_quality"),
  activeSources: integer("active_sources"),
  featureVector: text("feature_vector"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

/**
 * Trade execution outcomes and performance metrics.
 *
 * Tracks the complete lifecycle of executed trades:
 * - Entry/exit prices and execution quality (slippage)
 * - P&L calculations (absolute and percentage)
 * - Risk management outcomes (stop loss/target hits)
 * - Holding duration and market session timing
 * - Exit attribution (profit target, stop loss, time-based)
 *
 * Performance Metrics:
 * - realizedPnl: Dollar profit/loss
 * - realizedPnlPercent: Percentage return
 * - slippagePercent: Execution vs expected price
 * - maxDrawdown: Worst unrealized loss during trade
 * - maxGain: Best unrealized gain during trade
 * - holdingTimeMs: Trade duration in milliseconds
 *
 * ML Training Labels:
 * - isWin: Binary classification target (profit vs loss)
 * - Used to train models on aiDecisionFeatures
 * - Enables performance attribution analysis
 * - Supports strategy optimization
 *
 * Risk Analysis:
 * - targetPriceHit: Did trade reach profit target?
 * - stopLossHit: Was trade stopped out?
 * - exitReason: Why trade closed (crucial for learning)
 * - marketSessionAtEntry/Exit: Session timing analysis
 *
 * This data powers:
 * - ML model training (supervised learning labels)
 * - Strategy backtesting and validation
 * - Risk-adjusted performance metrics (Sharpe, Sortino)
 * - Trade execution quality analysis
 *
 * @see aiDecisions - Original decision that triggered trade
 * @see aiDecisionFeatures - Input features for prediction
 * @see trades - Actual trade execution details
 */
export const aiTradeOutcomes = pgTable("ai_trade_outcomes", {
  id: varchar("id")
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  decisionId: varchar("decision_id").references(() => aiDecisions.id, { onDelete: "cascade" }).notNull(),
  tradeId: varchar("trade_id").references(() => trades.id, { onDelete: "set null" }),
  symbol: text("symbol").notNull(),
  action: text("action").notNull(),
  predictionConfidence: numeric("prediction_confidence"),
  entryPrice: numeric("entry_price"),
  exitPrice: numeric("exit_price"),
  quantity: numeric("quantity"),
  realizedPnl: numeric("realized_pnl"),
  realizedPnlPercent: numeric("realized_pnl_percent"),
  holdingTimeMs: integer("holding_time_ms"),
  isWin: boolean("is_win"),
  slippagePercent: numeric("slippage_percent"),
  targetPriceHit: boolean("target_price_hit"),
  stopLossHit: boolean("stop_loss_hit"),
  maxDrawdown: numeric("max_drawdown"),
  maxGain: numeric("max_gain"),
  marketSessionAtEntry: text("market_session_at_entry"),
  marketSessionAtExit: text("market_session_at_exit"),
  strategyId: varchar("strategy_id").references(() => strategies.id, { onDelete: "set null" }),
  exitReason: text("exit_reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  closedAt: timestamp("closed_at"),
});

/**
 * AI model calibration and performance analysis log.
 *
 * Periodic analysis of AI decision quality and model performance:
 * - Win rate and accuracy metrics
 * - Confidence calibration (predicted vs actual)
 * - Symbol-specific performance patterns
 * - Recommended model adjustments
 *
 * Calibration Types:
 * - 'confidence': Analyze prediction confidence vs actual outcomes
 * - 'symbol': Identify best/worst performing symbols
 * - 'timing': Evaluate holding time patterns
 * - 'risk': Assess risk management effectiveness
 * - 'overall': Comprehensive model performance review
 *
 * Statistical Analysis:
 * - Win/loss distribution over time window
 * - Confidence score calibration curves
 * - Holding time analysis (winners vs losers)
 * - Symbol-specific edge detection
 *
 * Model Adjustment Recommendations:
 * - Confidence threshold tuning
 * - Symbol whitelist/blacklist updates
 * - Position sizing adjustments
 * - Risk parameter optimization (stop loss, take profit)
 * - Feature importance re-weighting
 *
 * This enables:
 * - Continuous model improvement
 * - Drift detection (market regime changes)
 * - Adaptive strategy parameters
 * - Audit trail of model versions
 *
 * Calibration Workflow:
 * 1. Aggregate outcomes over dataWindowDays
 * 2. Calculate win rate, confidence metrics
 * 3. Identify top/bottom performing symbols
 * 4. Generate adjustment recommendations
 * 5. Apply changes to next model version
 *
 * @see aiTradeOutcomes - Source data for calibration
 * @see aiDecisions - Decisions to recalibrate
 */
export const aiCalibrationLog = pgTable("ai_calibration_log", {
  id: varchar("id")
    .primaryKey()
    .default(sql`gen_random_uuid()`),
  calibrationType: text("calibration_type").notNull(),
  dataWindowDays: integer("data_window_days").default(30),
  totalDecisions: integer("total_decisions"),
  winCount: integer("win_count"),
  lossCount: integer("loss_count"),
  avgConfidenceOnWins: numeric("avg_confidence_on_wins"),
  avgConfidenceOnLosses: numeric("avg_confidence_on_losses"),
  avgHoldingTimeWins: integer("avg_holding_time_wins"),
  avgHoldingTimeLosses: integer("avg_holding_time_losses"),
  topWinningSymbols: text("top_winning_symbols"),
  topLosingSymbols: text("top_losing_symbols"),
  recommendedAdjustments: text("recommended_adjustments"),
  modelVersion: text("model_version"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// ============================================================================
// INSERT SCHEMAS
// ============================================================================

export const insertAiDecisionSchema = createInsertSchema(aiDecisions).omit({
  id: true,
  createdAt: true,
});

export const insertAiDecisionFeaturesSchema = createInsertSchema(aiDecisionFeatures).omit({
  id: true,
  createdAt: true,
});

export const insertAiTradeOutcomesSchema = createInsertSchema(aiTradeOutcomes).omit({
  id: true,
  createdAt: true,
});

export const insertAiCalibrationLogSchema = createInsertSchema(aiCalibrationLog).omit({
  id: true,
  createdAt: true,
});

// ============================================================================
// TYPES
// ============================================================================

export type InsertAiDecision = typeof aiDecisions.$inferInsert;
export type AiDecision = typeof aiDecisions.$inferSelect;

export type InsertAiDecisionFeatures = typeof aiDecisionFeatures.$inferInsert;
export type AiDecisionFeatures = typeof aiDecisionFeatures.$inferSelect;

export type InsertAiTradeOutcomes = typeof aiTradeOutcomes.$inferInsert;
export type AiTradeOutcomes = typeof aiTradeOutcomes.$inferSelect;

export type InsertAiCalibrationLog = typeof aiCalibrationLog.$inferInsert;
export type AiCalibrationLog = typeof aiCalibrationLog.$inferSelect;
