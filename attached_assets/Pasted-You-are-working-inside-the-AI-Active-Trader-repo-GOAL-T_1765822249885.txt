You are working inside the AI Active Trader repo.

GOAL (Task #2):
Make budgets + persistent caching real and enforced for ALL external providers (market data + news + LLM + Valyu), so no connector can bypass limits. This must use real data only (no mock/demo). Update docs so they match actual code behavior.

NON-NEGOTIABLE RULES:
- Do not claim a feature is done unless you can show the exact files changed + the endpoint/test output proving it works.
- No new “second budgeting system”: reuse the existing server/lib/callExternal.ts + apiBudget + persistentApiCache + apiPolicy.
- Every connector must route through callExternal() unless it is a pure local computation.
- Add provenance metadata to every external response: provider, cacheHit, cacheAgeMs, budgetStatus.
- Add a smoke-test script and run it; paste the output.

STEP 0 — READ FIRST (and briefly summarize what exists vs what is missing):
- docs/API_BUDGETING_AND_CACHING.md
- docs/CONNECTORS_AND_INTEGRATIONS.md
- docs/ARCHITECTURE.md
- server/lib/callExternal.ts
- server/lib/apiBudget.ts
- server/lib/apiPolicy.ts (or wherever the provider policies live)
- server/lib/persistentApiCache.ts
- server/connectors/*.ts (alpaca, finnhub, polygon, coingecko, coinmarketcap, newsapi, gdelt, valyu, etc.)

STEP 1 — INVENTORY & PROOF:
- List all places where the code calls fetch() directly for external providers.
- For each, identify the provider name, endpoint, and current caching behavior.

STEP 2 — DEFINE DEFAULT LIMITS (provider-specific, configurable):
Implement sane defaults in apiPolicy for:
- Alpaca: conservative under their cited 200/min (set e.g. 180/min) + caching where appropriate
- Polygon free: 5/min
- CoinGecko public: 10/min (within 5–15/min) + if DEMO key present allow 30/min
- NewsAPI dev: 100/day
- CoinMarketCap: 30/min
- Finnhub: set conservative per-minute budget and leave per-plan overrides via env
- Valyu: DO NOT limit by calls/week; limit by “retrieval units” and enforce long TTL; add a per-week ceiling as a backstop.

Expose these budgets in one config object and allow overrides via ENV (so we can tune without redeploy).

STEP 3 — REFACTOR CONNECTORS TO USE callExternal():
For each connector in server/connectors:
- Replace direct fetch() with callExternal({ provider, endpoint, cacheKey, budgetPolicy, cachePolicy })
- Ensure cacheKey is stable and includes symbol + timeframe + query intent
- If a connector currently uses ad-hoc in-memory caching, keep L1 if it helps, but L2 must be persistentApiCache
- Ensure stale serving works (if budget exhausted, serve stale data with provenance)

STEP 4 — VALYU MAX-OUTPUT PER CALL:
In server/connectors/valyu.ts:
- Add support for “batched enrichment queries” (one query returns multiple fields we need)
- Keep results small and structured
- Add TTL defaults appropriate for fundamentals/filings
- Ensure results are stored in persistent cache and reused in future analyses (even across restarts)

STEP 5 — OBSERVABILITY:
- Log (structured) every external call with provider, endpoint hash (not full URL if sensitive), cacheHit, budgetRemaining.
- Add an admin endpoint: GET /api/admin/providers/status that returns getAllProviderStatuses() and includes lastCallTime + remaining budgets.

STEP 6 — TESTS + SMOKE TEST (must run and show output):
- Add a script (e.g., scripts/smoke-external-calls.ts) that:
  1) calls 2-3 providers with caching enabled
  2) repeats the same request to prove cacheHit=true
  3) intentionally exceeds a tiny budget in dev mode to prove stale serving triggers
- Run it and paste output.

STEP 7 — DOCS MUST MATCH REALITY:
Update:
- docs/API_BUDGETING_AND_CACHING.md (replace aspirational text with exact implemented behavior + endpoints + examples)
- docs/CONNECTORS_AND_INTEGRATIONS.md (state which providers are enforced via callExternal and what TTL defaults are)
- docs/ARCHITECTURE.md (small update: external call flow diagram references callExternal + persistent cache)

DELIVERABLES:
- A short “Changed Files” list
- The smoke test output
- The exact curl examples to verify provider status + cache entries in DB
- If any provider cannot be verified due to missing API key, add a test mode that still proves budgeting/caching path works without calling the real network (but DO NOT add mock market data into the trading flow)
