You are Replit Agent working inside the AI Active Trader repo.

GOAL (Task #3):
Refactor the UI so it reflects a single coherent end-to-end flow:
Signal/Decision → Order Submitted → Broker Status Updates → Fill(s) → Position/PNL → Risk/Kill Switch events.
Eliminate duplicate/redundant UI screens/components and any “meaningless” status labels (e.g. pending_execution) that do not map to real broker + decision states.
No mock/demo data. Every UI list must be backed by working endpoints that return real values or a clear “missing config” error.

ABSOLUTE GOVERNANCE:
- You must run commands to prove changes are real (types, lint, server startup, curl calls).
- You must not mark a step “done” unless you can show: (1) files changed, (2) endpoint output, (3) UI evidence (logs or screenshot capture if available).
- Docs must be updated AFTER code, and must match code. If docs were claiming things that aren’t true, fix docs.

STEP 0 — READ FIRST (no coding)
1) Read docs:
   - docs/ARCHITECTURE.md
   - docs/TRADING_SAGA_SEQUENCES.md
   - docs/API_REFERENCE.md
   - docs/TESTING.md
   - docs/CONNECTORS_AND_INTEGRATIONS.md
2) Identify current UI inconsistencies:
   - AnalyticsScreen Trade Ledger count inflation
   - AISuggestedTradesScreen “pending_execution” spam
   - Profile ActivityFlow vs actual broker/order state
   - Duplicate navigators (MainTabNavigator.tsx vs MainTabNavigator26.tsx etc.)
3) Provide a short factual summary of what is duplicated/redundant and what must become canonical.

STEP 1 — DEFINE CANONICAL “UI DATA CONTRACTS” (types in shared/)
Create shared types (shared/types or shared/schema additions) for:
A) TimelineEvent:
  - id, ts, category (decision|order|fill|position|risk|system|data_fetch)
  - title, subtitle, status (enum)
  - entity links: decisionId?, brokerOrderId?, symbol?, strategyId?
  - provenance: provider, cacheHit, cacheAgeMs
  - details: JSON (trimmed)
B) LedgerItem:
  - id, symbol, side, qty, status, brokerOrderId, submittedAt, filledAt, avgFillPrice, strategyId?, decisionId?
C) DecisionViewModel:
  - decisionId, symbol, action, confidence, reasoningSnippet
  - status: proposed|approved|submitted_to_broker|partially_filled|filled|canceled|rejected|closed
  - brokerOrderId? and latest brokerStatus?

IMPORTANT:
- Status mapping MUST be based on real broker status concepts (Alpaca documented order statuses) and your internal decision state machine.
- Do not invent statuses that can’t be backed by broker/order data.

STEP 2 — BUILD A SINGLE “TIMELINE” BACKEND ENDPOINT
Implement:
GET /api/activity/timeline?limit=200
It must compose events from:
- ai_decisions (decision events)
- broker order sync snapshots (order events)
- fills/trade updates (fill events if available)
- risk control events (kill-switch toggles, emergency stop)
- system events (budget exhausted, stale served) if available

Rules:
- If Alpaca keys are missing, return a clear disabled status + empty array (no fake events).
- Include provenance on each event (provider + cacheHit + cacheAge).
- Provide stable ordering by ts desc.

STEP 3 — UI: CREATE ONE CANONICAL “Activity Timeline” SCREEN
A) Replace or repoint Profile’s ActivityFlow widget to the new /api/activity/timeline.
B) Create a dedicated screen/tab (or a prominent section on Dashboard) called “Timeline”.
C) Each Timeline item must show:
  - icon by category
  - title + symbol/action
  - status badge (mapped to real lifecycle)
  - time ago
  - provenance chip: e.g. “Alpaca • Live” or “Valyu • Cached”
D) Provide a detail drawer/modal:
  - shows decision reasoning, brokerOrderId, and raw JSON payload (for debugging)

STEP 4 — FIX THE TWO BROKEN SCREENS (NO MORE “MEANINGLESS LISTS”)
A) Analytics Trade Ledger:
- If Task #1 created /api/ledger?source=alpaca, use it.
- Otherwise implement a minimal unified ledger endpoint that returns real broker-derived items.
- Replace inflated “7715” counts with actual paginated counts from broker or your ledger endpoint.
- Add empty state & loading states.

B) AI Suggested Trades:
- Replace the “pending_execution list” with DecisionViewModel list.
- Show only decisions in:
  - proposed/approved (not submitted) OR submitted_to_broker (awaiting fill)
- Every row must include decisionId and (if submitted) brokerOrderId + brokerStatus.

STEP 5 — DELETE DUPLICATION / CLEAN NAVIGATION
- Find and remove unused navigators (e.g., MainTabNavigator26.tsx) and redundant routes.
- Ensure only one canonical navigation structure exists.
- If you can’t delete due to risk, deprecate by removing from app entry paths and documenting it.

STEP 6 — VERIFY EVERYTHING (MUST RUN AND SHOW OUTPUT)
Run:
- npm run check:types
- npm run lint
- start server (npm run server:dev) and show curl output for:
  - /api/activity/timeline
  - /api/ledger?source=alpaca (or your unified ledger endpoint)
  - /api/ai-decisions/history (now mapped properly)
Provide one UI proof:
- Either a screenshot export or dev logs showing the Timeline is populated and AISuggestedTrades is no longer spam.

STEP 7 — DOCS UPDATE (must match reality)
Update:
- docs/API_REFERENCE.md (new endpoints + payloads)
- docs/TRADING_SAGA_SEQUENCES.md (how statuses appear in UI)
- docs/ARCHITECTURE.md (UI -> endpoints -> broker truth)
Add:
- docs/UI_INFORMATION_ARCHITECTURE.md
  - Screens
  - Data sources per screen
  - Provenance rules
  - Empty/error states

DELIVERABLES:
- List of files changed
- Commands run + outputs
- Confirmed removal/deprecation of redundant components
- A “What’s next” plan for Task #4 with dependencies
