# AI Active Trader - Database Population & LLM Cost Optimization Tasks

> **REPLIT AGENT INSTRUCTION SET**
> Execute these tasks sequentially to: (1) Audit and populate empty database tables with REAL production data, (2) Optimize LLM execution frequency to reduce costs.

---

# TASK 1: DATABASE AUDIT & REAL DATA POPULATION

## OBJECTIVE
Identify all empty or under-populated database tables, fetch REAL data from connected APIs (Alpaca, Finnhub, CoinGecko, etc.), populate the database, and verify data flows correctly through all application layers including the UI.

**CRITICAL REQUIREMENTS:**
- ‚ùå NO mock data, fabricated numbers, or placeholder values
- ‚úÖ ONLY real market data from live API connections
- ‚úÖ Real account data from Alpaca paper trading
- ‚úÖ Real prices, real timestamps, real calculations

---

## PHASE 1: DATABASE AUDIT

### 1.1 Create Database Audit Script

**File: `server/scripts/database-audit.ts`**

```typescript
import { db } from '../db';
import { sql } from 'drizzle-orm';
import {
  users,
  strategies,
  trades,
  positions,
  aiDecisions,
  agentStatus,
  marketSnapshots,
  portfolioSnapshots,
  watchlists,
  alerts,
  apiCache,
  llmCalls,
  // Add all other tables from your schema
} from '@shared/schema';

interface TableAudit {
  tableName: string;
  rowCount: number;
  isEmpty: boolean;
  oldestRecord?: Date;
  newestRecord?: Date;
  sampleData?: any;
  requiredForUI: boolean;
  dataSource: string;
}

const TABLE_METADATA: Record<string, { requiredForUI: boolean; dataSource: string }> = {
  users: { requiredForUI: true, dataSource: 'internal' },
  strategies: { requiredForUI: true, dataSource: 'internal' },
  trades: { requiredForUI: true, dataSource: 'alpaca' },
  positions: { requiredForUI: true, dataSource: 'alpaca' },
  ai_decisions: { requiredForUI: true, dataSource: 'llm + market data' },
  agent_status: { requiredForUI: true, dataSource: 'internal' },
  market_snapshots: { requiredForUI: true, dataSource: 'finnhub/alpaca' },
  portfolio_snapshots: { requiredForUI: true, dataSource: 'alpaca + calculations' },
  watchlists: { requiredForUI: true, dataSource: 'internal' },
  alerts: { requiredForUI: false, dataSource: 'internal' },
  api_cache: { requiredForUI: false, dataSource: 'all apis' },
  llm_calls: { requiredForUI: false, dataSource: 'llm providers' },
  symbol_master: { requiredForUI: true, dataSource: 'alpaca/finnhub' },
  economic_events: { requiredForUI: false, dataSource: 'fred/aitrados' },
  news_items: { requiredForUI: true, dataSource: 'newsapi/gdelt' },
  sentiment_scores: { requiredForUI: true, dataSource: 'huggingface/social' },
};

async function auditTable(tableName: string, table: any): Promise<TableAudit> {
  try {
    // Get row count
    const countResult = await db.select({ count: sql<number>`count(*)` }).from(table);
    const rowCount = Number(countResult[0]?.count || 0);

    // Get date range if table has timestamp columns
    let oldestRecord: Date | undefined;
    let newestRecord: Date | undefined;
    let sampleData: any;

    if (rowCount > 0) {
      // Try to get sample data
      const sample = await db.select().from(table).limit(1);
      sampleData = sample[0];

      // Check for common timestamp columns
      const timestampColumns = ['created_at', 'createdAt', 'timestamp', 'updated_at', 'updatedAt'];
      for (const col of timestampColumns) {
        if (sampleData && col in sampleData) {
          try {
            const oldest = await db.select().from(table).orderBy(sql`${sql.identifier(col)} ASC`).limit(1);
            const newest = await db.select().from(table).orderBy(sql`${sql.identifier(col)} DESC`).limit(1);
            oldestRecord = oldest[0]?.[col];
            newestRecord = newest[0]?.[col];
            break;
          } catch {
            // Column doesn't support ordering
          }
        }
      }
    }

    const metadata = TABLE_METADATA[tableName] || { requiredForUI: false, dataSource: 'unknown' };

    return {
      tableName,
      rowCount,
      isEmpty: rowCount === 0,
      oldestRecord,
      newestRecord,
      sampleData: rowCount > 0 ? sampleData : undefined,
      requiredForUI: metadata.requiredForUI,
      dataSource: metadata.dataSource,
    };
  } catch (error) {
    console.error(`Error auditing table ${tableName}:`, error);
    return {
      tableName,
      rowCount: -1,
      isEmpty: true,
      requiredForUI: TABLE_METADATA[tableName]?.requiredForUI || false,
      dataSource: TABLE_METADATA[tableName]?.dataSource || 'error',
    };
  }
}

async function runFullAudit(): Promise<void> {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë           DATABASE AUDIT - AI ACTIVE TRADER                    ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

  const tables = [
    { name: 'users', table: users },
    { name: 'strategies', table: strategies },
    { name: 'trades', table: trades },
    { name: 'positions', table: positions },
    { name: 'ai_decisions', table: aiDecisions },
    { name: 'agent_status', table: agentStatus },
    // Add all tables from your schema
  ];

  const results: TableAudit[] = [];
  const emptyTables: TableAudit[] = [];
  const criticalEmpty: TableAudit[] = [];

  for (const { name, table } of tables) {
    const audit = await auditTable(name, table);
    results.push(audit);

    if (audit.isEmpty) {
      emptyTables.push(audit);
      if (audit.requiredForUI) {
        criticalEmpty.push(audit);
      }
    }
  }

  // Print results
  console.log('TABLE STATUS SUMMARY');
  console.log('‚ïê'.repeat(70));
  console.log(
    'Table Name'.padEnd(25) +
    'Rows'.padStart(10) +
    'Status'.padStart(12) +
    'UI Required'.padStart(12) +
    'Data Source'.padStart(15)
  );
  console.log('‚îÄ'.repeat(70));

  for (const audit of results) {
    const status = audit.isEmpty ? '‚ùå EMPTY' : '‚úì OK';
    const uiReq = audit.requiredForUI ? 'YES' : 'no';
    console.log(
      audit.tableName.padEnd(25) +
      String(audit.rowCount).padStart(10) +
      status.padStart(12) +
      uiReq.padStart(12) +
      audit.dataSource.padStart(15)
    );
  }

  console.log('\n' + '‚ïê'.repeat(70));
  console.log(`Total Tables: ${results.length}`);
  console.log(`Empty Tables: ${emptyTables.length}`);
  console.log(`Critical Empty (UI Required): ${criticalEmpty.length}`);

  if (criticalEmpty.length > 0) {
    console.log('\n‚ö†Ô∏è  CRITICAL: The following UI-required tables are empty:');
    for (const table of criticalEmpty) {
      console.log(`   - ${table.tableName} (source: ${table.dataSource})`);
    }
  }

  // Generate population commands
  if (emptyTables.length > 0) {
    console.log('\nüìã RECOMMENDED POPULATION ORDER:');
    const populationOrder = [
      'users',
      'agent_status',
      'symbol_master',
      'strategies',
      'positions',
      'trades',
      'market_snapshots',
      'portfolio_snapshots',
      'news_items',
      'sentiment_scores',
      'ai_decisions',
    ];

    let step = 1;
    for (const tableName of populationOrder) {
      const audit = emptyTables.find(t => t.tableName === tableName);
      if (audit) {
        console.log(`   ${step}. ${tableName} ‚Üí fetch from ${audit.dataSource}`);
        step++;
      }
    }
  }

  // Save audit report
  const report = {
    timestamp: new Date().toISOString(),
    totalTables: results.length,
    emptyTables: emptyTables.length,
    criticalEmpty: criticalEmpty.length,
    tables: results,
  };

  await Bun.write('./database-audit-report.json', JSON.stringify(report, null, 2));
  console.log('\n‚úì Audit report saved to database-audit-report.json');
}

runFullAudit().catch(console.error);
```

### 1.2 Run the Audit

```bash
npx tsx server/scripts/database-audit.ts
```

---

## PHASE 2: REAL DATA POPULATION

### 2.1 Master Data Population Script

**File: `server/scripts/populate-real-data.ts`**

```typescript
import { db } from '../db';
import { eq, sql } from 'drizzle-orm';
import {
  users,
  strategies,
  trades,
  positions,
  aiDecisions,
  agentStatus,
  marketSnapshots,
  portfolioSnapshots,
  symbolMaster,
  newsItems,
} from '@shared/schema';

// Import connectors for REAL data
import { alpacaConnector } from '../connectors/alpaca';
import { finnhubConnector } from '../connectors/finnhub';
import { coingeckoConnector } from '../connectors/coingecko';
import { newsapiConnector } from '../connectors/newsapi';

interface PopulationResult {
  table: string;
  inserted: number;
  errors: string[];
  source: string;
}

const results: PopulationResult[] = [];

// ============================================================================
// STEP 1: ENSURE DEFAULT USER EXISTS
// ============================================================================
async function ensureDefaultUser(): Promise<string> {
  console.log('\nüìå Step 1: Ensuring default user exists...');

  const existingUsers = await db.select().from(users).limit(1);

  if (existingUsers.length > 0) {
    console.log(`   ‚úì User exists: ${existingUsers[0].id}`);
    return existingUsers[0].id;
  }

  // Create default user
  const [newUser] = await db.insert(users).values({
    id: crypto.randomUUID(),
    email: 'trader@aiactivetrader.com',
    username: 'active_trader',
    createdAt: new Date(),
    updatedAt: new Date(),
  }).returning();

  console.log(`   ‚úì Created user: ${newUser.id}`);
  results.push({ table: 'users', inserted: 1, errors: [], source: 'internal' });
  return newUser.id;
}

// ============================================================================
// STEP 2: INITIALIZE AGENT STATUS
// ============================================================================
async function initializeAgentStatus(userId: string): Promise<void> {
  console.log('\nüìå Step 2: Initializing agent status...');

  const existing = await db.select().from(agentStatus).limit(1);

  if (existing.length > 0) {
    console.log('   ‚úì Agent status already exists');
    return;
  }

  await db.insert(agentStatus).values({
    id: crypto.randomUUID(),
    userId,
    isRunning: false,
    isPaused: false,
    currentPhase: 'idle',
    lastCycleTime: null,
    cycleCount: 0,
    errorCount: 0,
    lastError: null,
    settings: {
      analysisCooldownMinutes: 15,
      maxDailyTrades: 10,
      riskPerTrade: 0.02,
    },
    createdAt: new Date(),
    updatedAt: new Date(),
  });

  console.log('   ‚úì Agent status initialized');
  results.push({ table: 'agent_status', inserted: 1, errors: [], source: 'internal' });
}

// ============================================================================
// STEP 3: POPULATE SYMBOL MASTER FROM ALPACA
// ============================================================================
async function populateSymbolMaster(): Promise<void> {
  console.log('\nüìå Step 3: Populating symbol master from Alpaca...');

  const existingCount = await db.select({ count: sql<number>`count(*)` }).from(symbolMaster);
  if (Number(existingCount[0]?.count) > 100) {
    console.log(`   ‚úì Symbol master already has ${existingCount[0]?.count} symbols`);
    return;
  }

  try {
    // Fetch tradable assets from Alpaca
    const assets = await alpacaConnector.getAssets({ status: 'active', tradable: true });

    const stockAssets = assets
      .filter((a: any) => a.class === 'us_equity' && a.exchange !== 'OTC')
      .slice(0, 500); // Top 500 tradable stocks

    const cryptoAssets = assets
      .filter((a: any) => a.class === 'crypto')
      .slice(0, 50); // Top 50 crypto

    let inserted = 0;
    const errors: string[] = [];

    for (const asset of [...stockAssets, ...cryptoAssets]) {
      try {
        await db.insert(symbolMaster).values({
          id: crypto.randomUUID(),
          symbol: asset.symbol,
          name: asset.name,
          assetClass: asset.class,
          exchange: asset.exchange,
          isTradable: asset.tradable,
          isShortable: asset.shortable,
          marginable: asset.marginable,
          easyToBorrow: asset.easy_to_borrow,
          fractionable: asset.fractionable,
          minOrderSize: asset.min_order_size ? parseFloat(asset.min_order_size) : null,
          minTradeIncrement: asset.min_trade_increment ? parseFloat(asset.min_trade_increment) : null,
          priceIncrement: asset.price_increment ? parseFloat(asset.price_increment) : null,
          status: asset.status,
          createdAt: new Date(),
          updatedAt: new Date(),
        }).onConflictDoNothing();
        inserted++;
      } catch (e) {
        errors.push(`${asset.symbol}: ${(e as Error).message}`);
      }
    }

    console.log(`   ‚úì Inserted ${inserted} symbols from Alpaca`);
    results.push({ table: 'symbol_master', inserted, errors, source: 'alpaca' });
  } catch (error) {
    console.error('   ‚úó Failed to fetch Alpaca assets:', error);
    results.push({ table: 'symbol_master', inserted: 0, errors: [(error as Error).message], source: 'alpaca' });
  }
}

// ============================================================================
// STEP 4: SYNC REAL POSITIONS FROM ALPACA
// ============================================================================
async function syncPositionsFromAlpaca(userId: string): Promise<void> {
  console.log('\nüìå Step 4: Syncing REAL positions from Alpaca...');

  try {
    // Get real positions from Alpaca paper trading account
    const alpacaPositions = await alpacaConnector.getPositions();

    console.log(`   Found ${alpacaPositions.length} positions in Alpaca`);

    if (alpacaPositions.length === 0) {
      console.log('   ‚ÑπÔ∏è  No positions in Alpaca account. Skipping.');
      return;
    }

    let inserted = 0;
    const errors: string[] = [];

    for (const pos of alpacaPositions) {
      try {
        // Check if position already exists
        const existing = await db.select().from(positions)
          .where(eq(positions.symbol, pos.symbol))
          .limit(1);

        if (existing.length > 0) {
          // Update existing position with latest data
          await db.update(positions)
            .set({
              quantity: parseFloat(pos.qty),
              averageEntryPrice: parseFloat(pos.avg_entry_price),
              currentPrice: parseFloat(pos.current_price),
              marketValue: parseFloat(pos.market_value),
              unrealizedPnl: parseFloat(pos.unrealized_pl),
              unrealizedPnlPercent: parseFloat(pos.unrealized_plpc) * 100,
              costBasis: parseFloat(pos.cost_basis),
              side: pos.side,
              updatedAt: new Date(),
            })
            .where(eq(positions.id, existing[0].id));
        } else {
          // Insert new position
          await db.insert(positions).values({
            id: crypto.randomUUID(),
            userId,
            symbol: pos.symbol,
            assetClass: pos.asset_class,
            quantity: parseFloat(pos.qty),
            averageEntryPrice: parseFloat(pos.avg_entry_price),
            currentPrice: parseFloat(pos.current_price),
            marketValue: parseFloat(pos.market_value),
            unrealizedPnl: parseFloat(pos.unrealized_pl),
            unrealizedPnlPercent: parseFloat(pos.unrealized_plpc) * 100,
            costBasis: parseFloat(pos.cost_basis),
            side: pos.side,
            exchange: pos.exchange,
            alpacaAssetId: pos.asset_id,
            createdAt: new Date(),
            updatedAt: new Date(),
          });
          inserted++;
        }
      } catch (e) {
        errors.push(`${pos.symbol}: ${(e as Error).message}`);
      }
    }

    console.log(`   ‚úì Synced ${alpacaPositions.length} positions (${inserted} new)`);
    results.push({ table: 'positions', inserted, errors, source: 'alpaca' });
  } catch (error) {
    console.error('   ‚úó Failed to sync positions:', error);
    results.push({ table: 'positions', inserted: 0, errors: [(error as Error).message], source: 'alpaca' });
  }
}

// ============================================================================
// STEP 5: SYNC REAL TRADES/ORDERS FROM ALPACA
// ============================================================================
async function syncTradesFromAlpaca(userId: string): Promise<void> {
  console.log('\nüìå Step 5: Syncing REAL trades from Alpaca...');

  try {
    // Get recent orders (last 30 days)
    const orders = await alpacaConnector.getOrders({
      status: 'all',
      limit: 500,
      after: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
    });

    console.log(`   Found ${orders.length} orders in Alpaca`);

    let inserted = 0;
    const errors: string[] = [];

    for (const order of orders) {
      try {
        // Check if trade already exists by Alpaca order ID
        const existing = await db.select().from(trades)
          .where(eq(trades.alpacaOrderId, order.id))
          .limit(1);

        if (existing.length > 0) continue; // Skip existing

        await db.insert(trades).values({
          id: crypto.randomUUID(),
          userId,
          symbol: order.symbol,
          side: order.side,
          type: order.type,
          quantity: parseFloat(order.qty),
          filledQuantity: order.filled_qty ? parseFloat(order.filled_qty) : 0,
          price: order.filled_avg_price ? parseFloat(order.filled_avg_price) : null,
          limitPrice: order.limit_price ? parseFloat(order.limit_price) : null,
          stopPrice: order.stop_price ? parseFloat(order.stop_price) : null,
          status: order.status,
          timeInForce: order.time_in_force,
          orderClass: order.order_class || 'simple',
          alpacaOrderId: order.id,
          alpacaClientOrderId: order.client_order_id,
          submittedAt: new Date(order.submitted_at),
          filledAt: order.filled_at ? new Date(order.filled_at) : null,
          cancelledAt: order.canceled_at ? new Date(order.canceled_at) : null,
          failedAt: order.failed_at ? new Date(order.failed_at) : null,
          assetClass: order.asset_class,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        inserted++;
      } catch (e) {
        errors.push(`${order.id}: ${(e as Error).message}`);
      }
    }

    console.log(`   ‚úì Synced ${inserted} new trades`);
    results.push({ table: 'trades', inserted, errors, source: 'alpaca' });
  } catch (error) {
    console.error('   ‚úó Failed to sync trades:', error);
    results.push({ table: 'trades', inserted: 0, errors: [(error as Error).message], source: 'alpaca' });
  }
}

// ============================================================================
// STEP 6: FETCH REAL MARKET SNAPSHOTS
// ============================================================================
async function populateMarketSnapshots(): Promise<void> {
  console.log('\nüìå Step 6: Fetching REAL market snapshots...');

  // Get symbols from positions and watchlist
  const positionSymbols = await db.select({ symbol: positions.symbol }).from(positions);
  const defaultWatchlist = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'NVDA', 'META', 'BTC', 'ETH', 'SOL'];

  const symbols = [...new Set([
    ...positionSymbols.map(p => p.symbol),
    ...defaultWatchlist,
  ])];

  console.log(`   Fetching snapshots for ${symbols.length} symbols...`);

  let inserted = 0;
  const errors: string[] = [];

  for (const symbol of symbols) {
    try {
      let snapshot: any;

      // Determine if crypto or stock
      const isCrypto = ['BTC', 'ETH', 'SOL', 'DOGE', 'ADA', 'XRP', 'DOT', 'AVAX'].includes(symbol) ||
                       symbol.includes('USD');

      if (isCrypto) {
        // Use CoinGecko for crypto
        const cryptoData = await coingeckoConnector.getPrice(symbol.replace('USD', '').toLowerCase());
        if (cryptoData) {
          snapshot = {
            symbol,
            price: cryptoData.current_price,
            change: cryptoData.price_change_24h,
            changePercent: cryptoData.price_change_percentage_24h,
            volume: cryptoData.total_volume,
            high: cryptoData.high_24h,
            low: cryptoData.low_24h,
            marketCap: cryptoData.market_cap,
          };
        }
      } else {
        // Use Alpaca/Finnhub for stocks
        const quote = await alpacaConnector.getLatestQuote(symbol);
        const trade = await alpacaConnector.getLatestTrade(symbol);

        if (quote && trade) {
          snapshot = {
            symbol,
            price: trade.price,
            bidPrice: quote.bid_price,
            askPrice: quote.ask_price,
            bidSize: quote.bid_size,
            askSize: quote.ask_size,
            volume: trade.size, // Note: This is last trade size, not daily volume
          };

          // Enhance with Finnhub data for daily stats
          try {
            const finnhubQuote = await finnhubConnector.getQuote(symbol);
            if (finnhubQuote) {
              snapshot.change = finnhubQuote.d;
              snapshot.changePercent = finnhubQuote.dp;
              snapshot.high = finnhubQuote.h;
              snapshot.low = finnhubQuote.l;
              snapshot.open = finnhubQuote.o;
              snapshot.previousClose = finnhubQuote.pc;
            }
          } catch {
            // Finnhub enhancement failed, continue with Alpaca data
          }
        }
      }

      if (snapshot) {
        await db.insert(marketSnapshots).values({
          id: crypto.randomUUID(),
          symbol: snapshot.symbol,
          price: snapshot.price,
          bidPrice: snapshot.bidPrice,
          askPrice: snapshot.askPrice,
          bidSize: snapshot.bidSize,
          askSize: snapshot.askSize,
          change: snapshot.change,
          changePercent: snapshot.changePercent,
          volume: snapshot.volume,
          high: snapshot.high,
          low: snapshot.low,
          open: snapshot.open,
          previousClose: snapshot.previousClose,
          marketCap: snapshot.marketCap,
          timestamp: new Date(),
          createdAt: new Date(),
        });
        inserted++;
      }
    } catch (e) {
      errors.push(`${symbol}: ${(e as Error).message}`);
    }
  }

  console.log(`   ‚úì Inserted ${inserted} market snapshots`);
  results.push({ table: 'market_snapshots', inserted, errors, source: 'alpaca/finnhub/coingecko' });
}

// ============================================================================
// STEP 7: CALCULATE REAL PORTFOLIO SNAPSHOT
// ============================================================================
async function calculatePortfolioSnapshot(userId: string): Promise<void> {
  console.log('\nüìå Step 7: Calculating REAL portfolio snapshot...');

  try {
    // Get real account data from Alpaca
    const account = await alpacaConnector.getAccount();
    const alpacaPositions = await alpacaConnector.getPositions();

    // Calculate totals
    const totalEquity = parseFloat(account.equity);
    const cash = parseFloat(account.cash);
    const buyingPower = parseFloat(account.buying_power);
    const portfolioValue = parseFloat(account.portfolio_value);
    const lastEquity = parseFloat(account.last_equity);

    const dayPnl = totalEquity - lastEquity;
    const dayPnlPercent = lastEquity > 0 ? (dayPnl / lastEquity) * 100 : 0;

    const unrealizedPnl = alpacaPositions.reduce(
      (sum: number, p: any) => sum + parseFloat(p.unrealized_pl || '0'), 
      0
    );

    const realizedPnl = parseFloat(account.realized_pl || '0');

    // Count positions by status
    const longPositions = alpacaPositions.filter((p: any) => p.side === 'long').length;
    const shortPositions = alpacaPositions.filter((p: any) => p.side === 'short').length;

    await db.insert(portfolioSnapshots).values({
      id: crypto.randomUUID(),
      userId,
      totalEquity,
      cash,
      buyingPower,
      portfolioValue,
      dayPnl,
      dayPnlPercent,
      unrealizedPnl,
      realizedPnl,
      totalPositions: alpacaPositions.length,
      longPositions,
      shortPositions,
      marginUsed: parseFloat(account.initial_margin || '0'),
      maintenanceMargin: parseFloat(account.maintenance_margin || '0'),
      accountStatus: account.status,
      patternDayTrader: account.pattern_day_trader,
      tradingBlocked: account.trading_blocked,
      transfersBlocked: account.transfers_blocked,
      timestamp: new Date(),
      createdAt: new Date(),
    });

    console.log(`   ‚úì Portfolio snapshot saved:`);
    console.log(`      Total Equity: $${totalEquity.toLocaleString()}`);
    console.log(`      Day P&L: $${dayPnl.toFixed(2)} (${dayPnlPercent.toFixed(2)}%)`);
    console.log(`      Positions: ${alpacaPositions.length}`);
    results.push({ table: 'portfolio_snapshots', inserted: 1, errors: [], source: 'alpaca' });
  } catch (error) {
    console.error('   ‚úó Failed to calculate portfolio snapshot:', error);
    results.push({ table: 'portfolio_snapshots', inserted: 0, errors: [(error as Error).message], source: 'alpaca' });
  }
}

// ============================================================================
// STEP 8: FETCH REAL NEWS
// ============================================================================
async function populateNewsItems(): Promise<void> {
  console.log('\nüìå Step 8: Fetching REAL news items...');

  const topics = ['stock market', 'cryptocurrency', 'federal reserve', 'earnings'];
  let inserted = 0;
  const errors: string[] = [];

  for (const topic of topics) {
    try {
      const news = await newsapiConnector.getTopHeadlines({
        category: 'business',
        q: topic,
        pageSize: 10,
      });

      for (const article of news.articles || []) {
        try {
          await db.insert(newsItems).values({
            id: crypto.randomUUID(),
            source: article.source?.name || 'Unknown',
            author: article.author,
            title: article.title,
            description: article.description,
            url: article.url,
            imageUrl: article.urlToImage,
            publishedAt: new Date(article.publishedAt),
            content: article.content,
            topic,
            createdAt: new Date(),
          }).onConflictDoNothing();
          inserted++;
        } catch {
          // Duplicate, skip
        }
      }
    } catch (e) {
      errors.push(`${topic}: ${(e as Error).message}`);
    }
  }

  console.log(`   ‚úì Inserted ${inserted} news items`);
  results.push({ table: 'news_items', inserted, errors, source: 'newsapi' });
}

// ============================================================================
// STEP 9: CREATE DEFAULT STRATEGIES
// ============================================================================
async function createDefaultStrategies(userId: string): Promise<void> {
  console.log('\nüìå Step 9: Creating default trading strategies...');

  const existingCount = await db.select({ count: sql<number>`count(*)` }).from(strategies);
  if (Number(existingCount[0]?.count) > 0) {
    console.log(`   ‚úì Strategies already exist (${existingCount[0]?.count})`);
    return;
  }

  const defaultStrategies = [
    {
      name: 'Momentum Growth',
      description: 'Long positions in stocks showing strong upward momentum with RSI confirmation',
      type: 'momentum',
      isActive: true,
      riskLevel: 'moderate',
      maxPositionSize: 0.10, // 10% of portfolio
      stopLossPercent: 0.05, // 5% stop loss
      takeProfitPercent: 0.15, // 15% take profit
      symbols: ['AAPL', 'MSFT', 'NVDA', 'GOOGL', 'AMZN'],
      indicators: ['RSI', 'MACD', 'SMA_20', 'SMA_50'],
      entryConditions: {
        rsiMin: 40,
        rsiMax: 70,
        macdSignal: 'bullish_crossover',
        priceAboveSMA20: true,
      },
      exitConditions: {
        rsiAbove: 80,
        macdSignal: 'bearish_crossover',
        trailingStop: 0.03,
      },
    },
    {
      name: 'Value Investing',
      description: 'Long-term positions in undervalued stocks with strong fundamentals',
      type: 'value',
      isActive: false,
      riskLevel: 'conservative',
      maxPositionSize: 0.15,
      stopLossPercent: 0.08,
      takeProfitPercent: 0.25,
      symbols: ['BRK.B', 'JPM', 'JNJ', 'PG', 'KO'],
      indicators: ['PE_Ratio', 'PB_Ratio', 'Dividend_Yield'],
      entryConditions: {
        peRatioMax: 20,
        pbRatioMax: 3,
        dividendYieldMin: 0.02,
      },
      exitConditions: {
        peRatioAbove: 30,
        priceTargetReached: true,
      },
    },
    {
      name: 'Crypto Momentum',
      description: 'Active trading in top cryptocurrencies based on volume and momentum',
      type: 'momentum',
      isActive: true,
      riskLevel: 'aggressive',
      maxPositionSize: 0.05,
      stopLossPercent: 0.10,
      takeProfitPercent: 0.20,
      symbols: ['BTC', 'ETH', 'SOL'],
      indicators: ['RSI', 'Volume', 'VWAP'],
      entryConditions: {
        volumeSpike: 2.0, // 2x average volume
        rsiMin: 30,
        rsiMax: 65,
      },
      exitConditions: {
        rsiAbove: 75,
        volumeDecline: 0.5,
      },
    },
  ];

  let inserted = 0;
  for (const strategy of defaultStrategies) {
    await db.insert(strategies).values({
      id: crypto.randomUUID(),
      userId,
      ...strategy,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
    inserted++;
  }

  console.log(`   ‚úì Created ${inserted} default strategies`);
  results.push({ table: 'strategies', inserted, errors: [], source: 'internal' });
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================
async function main(): Promise<void> {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë      REAL DATA POPULATION - AI ACTIVE TRADER                   ‚ïë');
  console.log('‚ïë      ‚ö†Ô∏è  Using LIVE API data - No mock data                    ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');

  const startTime = Date.now();

  try {
    // Execute in order
    const userId = await ensureDefaultUser();
    await initializeAgentStatus(userId);
    await populateSymbolMaster();
    await syncPositionsFromAlpaca(userId);
    await syncTradesFromAlpaca(userId);
    await populateMarketSnapshots();
    await calculatePortfolioSnapshot(userId);
    await populateNewsItems();
    await createDefaultStrategies(userId);

    // Summary
    const duration = ((Date.now() - startTime) / 1000).toFixed(2);

    console.log('\n' + '‚ïê'.repeat(70));
    console.log('POPULATION SUMMARY');
    console.log('‚ïê'.repeat(70));
    console.log('Table'.padEnd(25) + 'Inserted'.padStart(10) + 'Errors'.padStart(10) + 'Source'.padStart(20));
    console.log('‚îÄ'.repeat(70));

    let totalInserted = 0;
    let totalErrors = 0;

    for (const result of results) {
      console.log(
        result.table.padEnd(25) +
        String(result.inserted).padStart(10) +
        String(result.errors.length).padStart(10) +
        result.source.padStart(20)
      );
      totalInserted += result.inserted;
      totalErrors += result.errors.length;
    }

    console.log('‚îÄ'.repeat(70));
    console.log(`Total: ${totalInserted} records inserted, ${totalErrors} errors`);
    console.log(`Duration: ${duration}s`);

    if (totalErrors > 0) {
      console.log('\n‚ö†Ô∏è  ERRORS:');
      for (const result of results) {
        if (result.errors.length > 0) {
          console.log(`\n${result.table}:`);
          result.errors.slice(0, 5).forEach(e => console.log(`   - ${e}`));
          if (result.errors.length > 5) {
            console.log(`   ... and ${result.errors.length - 5} more`);
          }
        }
      }
    }

    console.log('\n‚úì Data population complete!');
    console.log('  Run the app and verify data appears in UI.');

  } catch (error) {
    console.error('\n‚úó FATAL ERROR:', error);
    process.exit(1);
  }
}

main();
```

### 2.2 Run Population Script

```bash
npx tsx server/scripts/populate-real-data.ts
```

---

## PHASE 3: VERIFY UI DATA BINDING

### 3.1 Create UI Data Verification Endpoint

**File: `server/routes/debug/data-verification.ts`**

```typescript
import { Router } from 'express';
import { db } from '../../db';
import { sql } from 'drizzle-orm';
import * as schema from '@shared/schema';

const router = Router();

// GET /api/debug/data-status
router.get('/data-status', async (req, res) => {
  const tables = [
    { name: 'users', table: schema.users },
    { name: 'strategies', table: schema.strategies },
    { name: 'trades', table: schema.trades },
    { name: 'positions', table: schema.positions },
    { name: 'ai_decisions', table: schema.aiDecisions },
    { name: 'agent_status', table: schema.agentStatus },
    { name: 'market_snapshots', table: schema.marketSnapshots },
    { name: 'portfolio_snapshots', table: schema.portfolioSnapshots },
  ];

  const status: Record<string, any> = {};

  for (const { name, table } of tables) {
    const count = await db.select({ count: sql<number>`count(*)` }).from(table);
    const latest = await db.select().from(table).orderBy(sql`created_at DESC`).limit(1);

    status[name] = {
      count: Number(count[0]?.count || 0),
      hasData: Number(count[0]?.count || 0) > 0,
      latestRecord: latest[0] || null,
    };
  }

  res.json({
    status,
    uiReadiness: {
      dashboard: status.portfolio_snapshots?.hasData && status.positions?.hasData,
      positions: status.positions?.hasData,
      trades: status.trades?.hasData,
      strategies: status.strategies?.hasData,
      aiDecisions: status.ai_decisions?.hasData,
    },
    timestamp: new Date().toISOString(),
  });
});

export default router;
```

---

# TASK 2: LLM COST OPTIMIZATION

## OBJECTIVE
Analyze why LLMs are running constantly, implement intelligent triggering based on market events and configurable schedules, and add cost controls with usage tracking.

---

## PHASE 1: LLM USAGE AUDIT

### 1.1 Create LLM Usage Analyzer

**File: `server/scripts/llm-usage-audit.ts`**

```typescript
import { db } from '../db';
import { sql, desc, gte } from 'drizzle-orm';
import { llmCalls, aiDecisions } from '@shared/schema';

interface LLMUsageReport {
  totalCalls: number;
  totalTokens: number;
  estimatedCost: number;
  callsByProvider: Record<string, { calls: number; tokens: number; cost: number }>;
  callsByRole: Record<string, { calls: number; avgLatency: number }>;
  callsByHour: { hour: number; calls: number }[];
  unnecessaryCallsEstimate: number;
  recommendations: string[];
}

// Estimated costs per 1K tokens (as of Dec 2024)
const COST_PER_1K_TOKENS: Record<string, { input: number; output: number }> = {
  'gpt-4o': { input: 0.0025, output: 0.01 },
  'gpt-4o-mini': { input: 0.00015, output: 0.0006 },
  'gpt-4-turbo': { input: 0.01, output: 0.03 },
  'llama-3.1-8b-instant': { input: 0.00005, output: 0.00008 },
  'llama-3.1-70b-versatile': { input: 0.00059, output: 0.00079 },
  'claude-3-sonnet': { input: 0.003, output: 0.015 },
  'claude-3-haiku': { input: 0.00025, output: 0.00125 },
};

async function analyzeLLMUsage(days: number = 7): Promise<LLMUsageReport> {
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

  console.log(`\nAnalyzing LLM usage for the past ${days} days...\n`);

  // Get all LLM calls
  const calls = await db.select()
    .from(llmCalls)
    .where(gte(llmCalls.createdAt, since))
    .orderBy(desc(llmCalls.createdAt));

  if (calls.length === 0) {
    console.log('No LLM calls found in the specified period.');
    return {
      totalCalls: 0,
      totalTokens: 0,
      estimatedCost: 0,
      callsByProvider: {},
      callsByRole: {},
      callsByHour: [],
      unnecessaryCallsEstimate: 0,
      recommendations: ['No data to analyze - ensure LLM calls are being logged'],
    };
  }

  // Aggregate by provider
  const byProvider: Record<string, { calls: number; tokens: number; cost: number }> = {};
  
  for (const call of calls) {
    const provider = call.provider || 'unknown';
    const model = call.model || 'unknown';
    
    if (!byProvider[provider]) {
      byProvider[provider] = { calls: 0, tokens: 0, cost: 0 };
    }
    
    byProvider[provider].calls++;
    
    const inputTokens = call.inputTokens || 0;
    const outputTokens = call.outputTokens || 0;
    const totalTokens = inputTokens + outputTokens;
    
    byProvider[provider].tokens += totalTokens;

    // Estimate cost
    const costConfig = COST_PER_1K_TOKENS[model] || COST_PER_1K_TOKENS['gpt-4o-mini'];
    const cost = (inputTokens / 1000) * costConfig.input + (outputTokens / 1000) * costConfig.output;
    byProvider[provider].cost += cost;
  }

  // Aggregate by role
  const byRole: Record<string, { calls: number; totalLatency: number }> = {};
  
  for (const call of calls) {
    const role = call.role || 'unknown';
    
    if (!byRole[role]) {
      byRole[role] = { calls: 0, totalLatency: 0 };
    }
    
    byRole[role].calls++;
    byRole[role].totalLatency += call.latencyMs || 0;
  }

  // Aggregate by hour of day
  const byHour: number[] = new Array(24).fill(0);
  
  for (const call of calls) {
    const hour = new Date(call.createdAt).getHours();
    byHour[hour]++;
  }

  // Identify unnecessary calls patterns
  let unnecessaryEstimate = 0;
  const recommendations: string[] = [];

  // Check for rapid consecutive calls (< 1 minute apart) for same symbol
  const symbolCalls: Record<string, Date[]> = {};
  for (const call of calls) {
    const symbol = (call.metadata as any)?.symbol;
    if (symbol) {
      if (!symbolCalls[symbol]) symbolCalls[symbol] = [];
      symbolCalls[symbol].push(new Date(call.createdAt));
    }
  }

  for (const [symbol, timestamps] of Object.entries(symbolCalls)) {
    timestamps.sort((a, b) => a.getTime() - b.getTime());
    for (let i = 1; i < timestamps.length; i++) {
      const diff = timestamps[i].getTime() - timestamps[i - 1].getTime();
      if (diff < 60000) { // Less than 1 minute
        unnecessaryEstimate++;
      }
    }
  }

  // Calculate totals
  const totalCalls = calls.length;
  const totalTokens = Object.values(byProvider).reduce((sum, p) => sum + p.tokens, 0);
  const estimatedCost = Object.values(byProvider).reduce((sum, p) => sum + p.cost, 0);

  // Generate recommendations
  const avgCallsPerHour = totalCalls / (days * 24);
  
  if (avgCallsPerHour > 10) {
    recommendations.push(`HIGH FREQUENCY: ${avgCallsPerHour.toFixed(1)} calls/hour average. Consider reducing to every 15-30 minutes.`);
  }

  if (unnecessaryEstimate > totalCalls * 0.2) {
    recommendations.push(`REDUNDANT CALLS: ~${((unnecessaryEstimate / totalCalls) * 100).toFixed(0)}% of calls are within 1 minute of previous call for same symbol.`);
  }

  const peakHour = byHour.indexOf(Math.max(...byHour));
  const offPeakHours = byHour.filter((_, h) => h < 9 || h > 16);
  const offPeakCalls = offPeakHours.reduce((a, b) => a + b, 0);
  
  if (offPeakCalls > totalCalls * 0.3) {
    recommendations.push(`OFF-HOURS USAGE: ${((offPeakCalls / totalCalls) * 100).toFixed(0)}% of calls occur outside market hours (9 AM - 4 PM). Consider reducing off-hours analysis.`);
  }

  const expensiveProviderCalls = byProvider['openai']?.calls || 0;
  const cheapProviderCalls = (byProvider['groq']?.calls || 0) + (byProvider['together']?.calls || 0);
  
  if (expensiveProviderCalls > cheapProviderCalls * 2) {
    recommendations.push(`COST OPTIMIZATION: ${expensiveProviderCalls} OpenAI calls vs ${cheapProviderCalls} cheaper provider calls. Route more traffic to Groq/Together.ai for cost savings.`);
  }

  // Check for market_news_summarizer overuse
  const summarizerCalls = byRole['market_news_summarizer']?.calls || 0;
  if (summarizerCalls > totalCalls * 0.4) {
    recommendations.push(`NEWS SUMMARIZER OVERUSE: ${summarizerCalls} calls (${((summarizerCalls / totalCalls) * 100).toFixed(0)}%). Cache news summaries for 15+ minutes.`);
  }

  return {
    totalCalls,
    totalTokens,
    estimatedCost,
    callsByProvider: byProvider,
    callsByRole: Object.fromEntries(
      Object.entries(byRole).map(([role, data]) => [
        role,
        { calls: data.calls, avgLatency: data.totalLatency / data.calls },
      ])
    ),
    callsByHour: byHour.map((calls, hour) => ({ hour, calls })),
    unnecessaryCallsEstimate: unnecessaryEstimate,
    recommendations,
  };
}

async function main() {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë           LLM USAGE AUDIT - AI ACTIVE TRADER                   ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');

  const report = await analyzeLLMUsage(7);

  console.log('\nüìä USAGE SUMMARY (Last 7 Days)');
  console.log('‚ïê'.repeat(50));
  console.log(`Total LLM Calls: ${report.totalCalls.toLocaleString()}`);
  console.log(`Total Tokens: ${report.totalTokens.toLocaleString()}`);
  console.log(`Estimated Cost: $${report.estimatedCost.toFixed(2)}`);
  console.log(`Avg Calls/Hour: ${(report.totalCalls / 168).toFixed(1)}`);

  console.log('\nüìà BY PROVIDER');
  console.log('‚îÄ'.repeat(50));
  for (const [provider, data] of Object.entries(report.callsByProvider)) {
    console.log(`${provider}: ${data.calls} calls, ${data.tokens.toLocaleString()} tokens, $${data.cost.toFixed(2)}`);
  }

  console.log('\nüé≠ BY ROLE');
  console.log('‚îÄ'.repeat(50));
  for (const [role, data] of Object.entries(report.callsByRole)) {
    console.log(`${role}: ${data.calls} calls, ${data.avgLatency.toFixed(0)}ms avg latency`);
  }

  console.log('\n‚è∞ PEAK HOURS');
  console.log('‚îÄ'.repeat(50));
  const peakHours = report.callsByHour
    .sort((a, b) => b.calls - a.calls)
    .slice(0, 5);
  for (const { hour, calls } of peakHours) {
    console.log(`${hour.toString().padStart(2, '0')}:00 - ${calls} calls`);
  }

  console.log('\n‚ö†Ô∏è  POTENTIAL WASTE');
  console.log('‚îÄ'.repeat(50));
  console.log(`Estimated unnecessary calls: ${report.unnecessaryCallsEstimate}`);
  console.log(`Potential savings: $${(report.estimatedCost * (report.unnecessaryCallsEstimate / report.totalCalls)).toFixed(2)}`);

  console.log('\nüí° RECOMMENDATIONS');
  console.log('‚ïê'.repeat(50));
  if (report.recommendations.length === 0) {
    console.log('‚úì No major issues detected');
  } else {
    for (const rec of report.recommendations) {
      console.log(`‚Ä¢ ${rec}`);
    }
  }

  // Save report
  await Bun.write('./llm-usage-report.json', JSON.stringify(report, null, 2));
  console.log('\n‚úì Report saved to llm-usage-report.json');
}

main().catch(console.error);
```

---

## PHASE 2: IMPLEMENT SMART LLM TRIGGERING

### 2.1 LLM Execution Governor

**File: `server/services/llm-governor.ts`**

```typescript
import { db } from '../db';
import { eq, and, gte, desc } from 'drizzle-orm';
import { llmCalls, aiDecisions, marketSnapshots } from '@shared/schema';
import { ApiCache } from '../lib/apiCache';

/**
 * LLM Governor - Controls when LLM analysis should run
 * 
 * PRINCIPLES:
 * 1. Analysis should only run when there's actionable information
 * 2. Market hours deserve more frequent analysis than off-hours
 * 3. Significant price movements should trigger immediate analysis
 * 4. Cache recent decisions to avoid redundant analysis
 * 5. Budget limits prevent runaway costs
 */

interface GovernorConfig {
  // Cooldown periods (minutes)
  minCooldownMinutes: number;           // Absolute minimum between any calls
  defaultCooldownMinutes: number;       // Normal cooldown between analyses
  marketHoursCooldownMinutes: number;   // During active market hours
  offHoursCooldownMinutes: number;      // Outside market hours
  
  // Trigger thresholds
  priceChangeThresholdPercent: number;  // Trigger on this % price change
  volumeSpikeMultiplier: number;        // Trigger on this volume spike
  newsEventTrigger: boolean;            // Trigger on breaking news
  
  // Budget controls
  maxCallsPerHour: number;
  maxCallsPerDay: number;
  maxDailyCostUSD: number;
  
  // Provider preferences
  preferCheapProviders: boolean;
  expensiveProviderRoles: string[];     // Roles that justify expensive providers
}

const DEFAULT_CONFIG: GovernorConfig = {
  minCooldownMinutes: 5,
  defaultCooldownMinutes: 15,
  marketHoursCooldownMinutes: 10,
  offHoursCooldownMinutes: 60,
  
  priceChangeThresholdPercent: 2.0,
  volumeSpikeMultiplier: 2.5,
  newsEventTrigger: true,
  
  maxCallsPerHour: 20,
  maxCallsPerDay: 200,
  maxDailyCostUSD: 5.00,
  
  preferCheapProviders: true,
  expensiveProviderRoles: ['risk_manager', 'execution_planner'],
};

// Cost estimates per call by provider
const ESTIMATED_COST_PER_CALL: Record<string, number> = {
  'groq': 0.001,
  'together': 0.002,
  'openai-mini': 0.005,
  'openai': 0.02,
  'anthropic': 0.03,
};

export class LLMGovernor {
  private config: GovernorConfig;
  private cache: ApiCache;
  private callsThisHour: number = 0;
  private callsToday: number = 0;
  private costToday: number = 0;
  private lastHourReset: Date = new Date();
  private lastDayReset: Date = new Date();

  constructor(config: Partial<GovernorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.cache = new ApiCache(300); // 5-minute cache
  }

  /**
   * Check if LLM analysis should be allowed for a given context
   */
  async shouldAllowAnalysis(context: {
    symbol: string;
    role: string;
    trigger: 'scheduled' | 'price_change' | 'volume_spike' | 'news' | 'manual';
    urgency: 'low' | 'normal' | 'high';
  }): Promise<{
    allowed: boolean;
    reason: string;
    suggestedWaitMinutes?: number;
    suggestedProvider?: string;
  }> {
    this.resetCountersIfNeeded();

    // 1. Check budget limits
    if (this.callsToday >= this.config.maxCallsPerDay) {
      return {
        allowed: false,
        reason: `Daily call limit reached (${this.config.maxCallsPerDay})`,
        suggestedWaitMinutes: this.minutesUntilMidnight(),
      };
    }

    if (this.callsThisHour >= this.config.maxCallsPerHour) {
      return {
        allowed: false,
        reason: `Hourly call limit reached (${this.config.maxCallsPerHour})`,
        suggestedWaitMinutes: this.minutesUntilNextHour(),
      };
    }

    if (this.costToday >= this.config.maxDailyCostUSD) {
      return {
        allowed: false,
        reason: `Daily cost limit reached ($${this.config.maxDailyCostUSD})`,
        suggestedWaitMinutes: this.minutesUntilMidnight(),
      };
    }

    // 2. Check cooldown for this symbol
    const lastDecision = await this.getLastDecisionForSymbol(context.symbol);
    if (lastDecision) {
      const minutesSinceLastDecision = (Date.now() - lastDecision.getTime()) / 60000;
      const requiredCooldown = this.getRequiredCooldown(context);

      if (minutesSinceLastDecision < requiredCooldown) {
        // Allow override for high urgency triggers
        if (context.urgency !== 'high' && context.trigger !== 'price_change') {
          return {
            allowed: false,
            reason: `Cooldown active: ${Math.ceil(requiredCooldown - minutesSinceLastDecision)} minutes remaining`,
            suggestedWaitMinutes: Math.ceil(requiredCooldown - minutesSinceLastDecision),
          };
        }
      }
    }

    // 3. Check if this is a redundant analysis
    const recentDecision = this.cache.get(`decision:${context.symbol}`);
    if (recentDecision && context.trigger === 'scheduled' && context.urgency === 'low') {
      return {
        allowed: false,
        reason: 'Recent decision cached, skipping redundant analysis',
        suggestedWaitMinutes: 5,
      };
    }

    // 4. Determine provider based on role and budget
    const suggestedProvider = this.selectProvider(context.role);

    return {
      allowed: true,
      reason: 'Analysis approved',
      suggestedProvider,
    };
  }

  /**
   * Record that an LLM call was made
   */
  recordCall(provider: string, cost: number): void {
    this.callsThisHour++;
    this.callsToday++;
    this.costToday += cost;
  }

  /**
   * Cache a decision to prevent redundant analysis
   */
  cacheDecision(symbol: string, decision: any): void {
    this.cache.set(`decision:${symbol}`, decision, this.config.defaultCooldownMinutes * 60 * 1000);
  }

  /**
   * Get governor status for monitoring
   */
  getStatus(): {
    callsThisHour: number;
    callsToday: number;
    costToday: number;
    limits: {
      hourly: number;
      daily: number;
      costLimit: number;
    };
    nextReset: {
      hourly: Date;
      daily: Date;
    };
  } {
    return {
      callsThisHour: this.callsThisHour,
      callsToday: this.callsToday,
      costToday: this.costToday,
      limits: {
        hourly: this.config.maxCallsPerHour,
        daily: this.config.maxCallsPerDay,
        costLimit: this.config.maxDailyCostUSD,
      },
      nextReset: {
        hourly: new Date(this.lastHourReset.getTime() + 60 * 60 * 1000),
        daily: new Date(this.lastDayReset.getTime() + 24 * 60 * 60 * 1000),
      },
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Private Methods
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private resetCountersIfNeeded(): void {
    const now = new Date();
    
    // Reset hourly counter
    if (now.getTime() - this.lastHourReset.getTime() >= 60 * 60 * 1000) {
      this.callsThisHour = 0;
      this.lastHourReset = now;
    }
    
    // Reset daily counter
    if (now.getTime() - this.lastDayReset.getTime() >= 24 * 60 * 60 * 1000) {
      this.callsToday = 0;
      this.costToday = 0;
      this.lastDayReset = now;
    }
  }

  private getRequiredCooldown(context: { trigger: string; urgency: string }): number {
    // High urgency or specific triggers get minimum cooldown
    if (context.urgency === 'high' || context.trigger === 'price_change') {
      return this.config.minCooldownMinutes;
    }

    // Check if market is open
    const now = new Date();
    const hour = now.getUTCHours() - 5; // EST
    const day = now.getUTCDay();
    
    const isMarketHours = day >= 1 && day <= 5 && hour >= 9 && hour < 16;
    
    return isMarketHours 
      ? this.config.marketHoursCooldownMinutes 
      : this.config.offHoursCooldownMinutes;
  }

  private async getLastDecisionForSymbol(symbol: string): Promise<Date | null> {
    const result = await db.select({ createdAt: aiDecisions.createdAt })
      .from(aiDecisions)
      .where(eq(aiDecisions.symbol, symbol))
      .orderBy(desc(aiDecisions.createdAt))
      .limit(1);

    return result[0]?.createdAt || null;
  }

  private selectProvider(role: string): string {
    // Use expensive providers only for critical roles
    if (this.config.expensiveProviderRoles.includes(role)) {
      return 'openai';
    }

    // Prefer cheap providers for routine tasks
    if (this.config.preferCheapProviders) {
      return 'groq';
    }

    return 'openai-mini';
  }

  private minutesUntilNextHour(): number {
    const now = new Date();
    return 60 - now.getMinutes();
  }

  private minutesUntilMidnight(): number {
    const now = new Date();
    const midnight = new Date(now);
    midnight.setHours(24, 0, 0, 0);
    return Math.ceil((midnight.getTime() - now.getTime()) / 60000);
  }
}

// Singleton instance
export const llmGovernor = new LLMGovernor();
```

### 2.2 Event-Driven Analysis Triggers

**File: `server/services/analysis-triggers.ts`**

```typescript
import { llmGovernor } from './llm-governor';
import { eventBus } from '../lib/eventBus';
import { db } from '../db';
import { marketSnapshots, positions } from '@shared/schema';
import { eq, desc } from 'drizzle-orm';

/**
 * Analysis Triggers - Determines WHEN to run LLM analysis
 * 
 * Instead of polling constantly, we trigger analysis based on:
 * 1. Significant price movements
 * 2. Volume anomalies
 * 3. News events
 * 4. Scheduled intervals (with smart cooldowns)
 * 5. Position-related events
 */

interface PriceAlert {
  symbol: string;
  previousPrice: number;
  currentPrice: number;
  changePercent: number;
  timestamp: Date;
}

interface TriggerResult {
  shouldAnalyze: boolean;
  reason: string;
  priority: 'low' | 'normal' | 'high';
  symbols: string[];
}

class AnalysisTriggerService {
  private priceHistory: Map<string, { price: number; timestamp: Date }[]> = new Map();
  private scheduledAnalysisInterval: NodeJS.Timeout | null = null;

  constructor() {
    // Subscribe to market events
    eventBus.on('market:price_update', this.handlePriceUpdate.bind(this));
    eventBus.on('market:volume_spike', this.handleVolumeSpike.bind(this));
    eventBus.on('news:breaking', this.handleBreakingNews.bind(this));
    eventBus.on('position:opened', this.handlePositionOpened.bind(this));
    eventBus.on('position:closed', this.handlePositionClosed.bind(this));
  }

  /**
   * Start scheduled analysis checks
   */
  startScheduledAnalysis(intervalMinutes: number = 15): void {
    if (this.scheduledAnalysisInterval) {
      clearInterval(this.scheduledAnalysisInterval);
    }

    this.scheduledAnalysisInterval = setInterval(
      () => this.runScheduledAnalysis(),
      intervalMinutes * 60 * 1000
    );

    console.log(`[AnalysisTriggers] Scheduled analysis every ${intervalMinutes} minutes`);
  }

  /**
   * Stop scheduled analysis
   */
  stopScheduledAnalysis(): void {
    if (this.scheduledAnalysisInterval) {
      clearInterval(this.scheduledAnalysisInterval);
      this.scheduledAnalysisInterval = null;
    }
  }

  /**
   * Check if analysis should run for a symbol
   */
  async checkTrigger(symbol: string, trigger: string): Promise<TriggerResult> {
    const check = await llmGovernor.shouldAllowAnalysis({
      symbol,
      role: 'technical_analyst',
      trigger: trigger as any,
      urgency: this.determineUrgency(trigger),
    });

    return {
      shouldAnalyze: check.allowed,
      reason: check.reason,
      priority: this.determineUrgency(trigger),
      symbols: [symbol],
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Event Handlers
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  private async handlePriceUpdate(data: { symbol: string; price: number }): Promise<void> {
    const { symbol, price } = data;
    
    // Track price history
    if (!this.priceHistory.has(symbol)) {
      this.priceHistory.set(symbol, []);
    }
    
    const history = this.priceHistory.get(symbol)!;
    history.push({ price, timestamp: new Date() });
    
    // Keep only last 100 data points
    if (history.length > 100) {
      history.shift();
    }

    // Check for significant price movement
    if (history.length >= 2) {
      const oldPrice = history[0].price;
      const changePercent = ((price - oldPrice) / oldPrice) * 100;
      
      if (Math.abs(changePercent) >= 2.0) { // 2% threshold
        console.log(`[Trigger] Price change ${changePercent.toFixed(2)}% for ${symbol}`);
        
        const triggerResult = await this.checkTrigger(symbol, 'price_change');
        if (triggerResult.shouldAnalyze) {
          eventBus.emit('analysis:requested', {
            symbol,
            trigger: 'price_change',
            priority: 'high',
            context: { changePercent },
          });
        }
      }
    }
  }

  private async handleVolumeSpike(data: { symbol: string; volume: number; avgVolume: number }): Promise<void> {
    const { symbol, volume, avgVolume } = data;
    const multiplier = volume / avgVolume;
    
    if (multiplier >= 2.5) { // 2.5x average volume
      console.log(`[Trigger] Volume spike ${multiplier.toFixed(1)}x for ${symbol}`);
      
      const triggerResult = await this.checkTrigger(symbol, 'volume_spike');
      if (triggerResult.shouldAnalyze) {
        eventBus.emit('analysis:requested', {
          symbol,
          trigger: 'volume_spike',
          priority: 'high',
          context: { volumeMultiplier: multiplier },
        });
      }
    }
  }

  private async handleBreakingNews(data: { symbols: string[]; headline: string }): Promise<void> {
    console.log(`[Trigger] Breaking news affecting: ${data.symbols.join(', ')}`);
    
    for (const symbol of data.symbols) {
      const triggerResult = await this.checkTrigger(symbol, 'news');
      if (triggerResult.shouldAnalyze) {
        eventBus.emit('analysis:requested', {
          symbol,
          trigger: 'news',
          priority: 'normal',
          context: { headline: data.headline },
        });
      }
    }
  }

  private async handlePositionOpened(data: { symbol: string; quantity: number }): Promise<void> {
    console.log(`[Trigger] Position opened: ${data.symbol}`);
    
    // Always analyze new positions
    eventBus.emit('analysis:requested', {
      symbol: data.symbol,
      trigger: 'manual',
      priority: 'high',
      context: { event: 'position_opened', quantity: data.quantity },
    });
  }

  private async handlePositionClosed(data: { symbol: string; pnl: number }): Promise<void> {
    console.log(`[Trigger] Position closed: ${data.symbol} (P&L: $${data.pnl})`);
    
    // Post-trade analysis
    eventBus.emit('analysis:requested', {
      symbol: data.symbol,
      trigger: 'manual',
      priority: 'low',
      context: { event: 'position_closed', pnl: data.pnl },
    });
  }

  private async runScheduledAnalysis(): Promise<void> {
    console.log('[Trigger] Running scheduled analysis...');
    
    // Get symbols from active positions
    const activePositions = await db.select({ symbol: positions.symbol })
      .from(positions)
      .limit(20);

    const symbols = activePositions.map(p => p.symbol);
    
    // Add watchlist symbols if no positions
    if (symbols.length === 0) {
      symbols.push('SPY', 'QQQ', 'BTC', 'ETH'); // Default watchlist
    }

    for (const symbol of symbols) {
      const triggerResult = await this.checkTrigger(symbol, 'scheduled');
      if (triggerResult.shouldAnalyze) {
        eventBus.emit('analysis:requested', {
          symbol,
          trigger: 'scheduled',
          priority: 'low',
          context: {},
        });
      }
    }
  }

  private determineUrgency(trigger: string): 'low' | 'normal' | 'high' {
    switch (trigger) {
      case 'price_change':
      case 'volume_spike':
        return 'high';
      case 'news':
        return 'normal';
      case 'scheduled':
      default:
        return 'low';
    }
  }
}

export const analysisTriggers = new AnalysisTriggerService();
```

### 2.3 Update Orchestrator to Use Governor

**File: `server/orchestrator/analysis-cycle.ts` (MODIFY EXISTING)**

```typescript
import { llmGovernor } from '../services/llm-governor';
import { analysisTriggers } from '../services/analysis-triggers';
import { eventBus } from '../lib/eventBus';
import { roleBasedLLMCall } from '../ai/roleBasedRouter';

/**
 * MODIFIED: Analysis cycle now uses LLM Governor for rate limiting
 */

export class AnalysisCycle {
  private isRunning: boolean = false;

  async start(): Promise<void> {
    console.log('[AnalysisCycle] Starting with smart triggers...');
    
    // Start scheduled analysis (every 15 minutes by default)
    analysisTriggers.startScheduledAnalysis(15);

    // Listen for analysis requests
    eventBus.on('analysis:requested', this.handleAnalysisRequest.bind(this));

    this.isRunning = true;
  }

  async stop(): Promise<void> {
    analysisTriggers.stopScheduledAnalysis();
    this.isRunning = false;
  }

  private async handleAnalysisRequest(request: {
    symbol: string;
    trigger: string;
    priority: string;
    context: any;
  }): Promise<void> {
    const { symbol, trigger, priority, context } = request;

    // Check with governor
    const approval = await llmGovernor.shouldAllowAnalysis({
      symbol,
      role: 'technical_analyst',
      trigger: trigger as any,
      urgency: priority as any,
    });

    if (!approval.allowed) {
      console.log(`[AnalysisCycle] Skipping ${symbol}: ${approval.reason}`);
      return;
    }

    console.log(`[AnalysisCycle] Running analysis for ${symbol} (trigger: ${trigger})`);

    try {
      // Run the actual LLM analysis
      const startTime = Date.now();
      
      const response = await roleBasedLLMCall({
        role: 'technical_analyst',
        system: `Analyze ${symbol} for trading opportunities.`,
        messages: [
          {
            role: 'user',
            content: `Analyze ${symbol}. Trigger: ${trigger}. Context: ${JSON.stringify(context)}`,
          },
        ],
      });

      const latencyMs = Date.now() - startTime;
      const estimatedCost = 0.005; // Estimate based on provider

      // Record the call with governor
      llmGovernor.recordCall(approval.suggestedProvider || 'unknown', estimatedCost);

      // Cache the decision
      llmGovernor.cacheDecision(symbol, response);

      console.log(`[AnalysisCycle] Analysis complete for ${symbol} (${latencyMs}ms)`);

      // Emit result
      eventBus.emit('analysis:completed', {
        symbol,
        trigger,
        response,
        latencyMs,
      });
    } catch (error) {
      console.error(`[AnalysisCycle] Analysis failed for ${symbol}:`, error);
    }
  }
}

export const analysisCycle = new AnalysisCycle();
```

---

## PHASE 3: ADMIN MONITORING ENDPOINTS

### 3.1 LLM Governor Admin API

**File: `server/routes/admin-llm.ts`**

```typescript
import { Router } from 'express';
import { llmGovernor } from '../services/llm-governor';
import { db } from '../db';
import { llmCalls } from '@shared/schema';
import { desc, gte, sql } from 'drizzle-orm';

const router = Router();

// GET /api/admin/llm/status
router.get('/status', (req, res) => {
  const status = llmGovernor.getStatus();
  
  res.json({
    governor: status,
    utilization: {
      hourly: ((status.callsThisHour / status.limits.hourly) * 100).toFixed(1) + '%',
      daily: ((status.callsToday / status.limits.daily) * 100).toFixed(1) + '%',
      cost: ((status.costToday / status.limits.costLimit) * 100).toFixed(1) + '%',
    },
    recommendations: generateRecommendations(status),
  });
});

// GET /api/admin/llm/usage?days=7
router.get('/usage', async (req, res) => {
  const days = parseInt(req.query.days as string) || 7;
  const since = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

  const usage = await db.select({
    date: sql<string>`DATE(created_at)`,
    calls: sql<number>`COUNT(*)`,
    totalTokens: sql<number>`SUM(COALESCE(input_tokens, 0) + COALESCE(output_tokens, 0))`,
    avgLatency: sql<number>`AVG(latency_ms)`,
  })
    .from(llmCalls)
    .where(gte(llmCalls.createdAt, since))
    .groupBy(sql`DATE(created_at)`)
    .orderBy(desc(sql`DATE(created_at)`));

  res.json({
    period: `${days} days`,
    usage,
    totals: {
      calls: usage.reduce((sum, d) => sum + d.calls, 0),
      tokens: usage.reduce((sum, d) => sum + d.totalTokens, 0),
    },
  });
});

// PUT /api/admin/llm/config
router.put('/config', (req, res) => {
  const {
    maxCallsPerHour,
    maxCallsPerDay,
    maxDailyCostUSD,
    marketHoursCooldownMinutes,
    offHoursCooldownMinutes,
  } = req.body;

  // Validate and update config
  // Note: In production, persist this to database or environment
  
  res.json({
    success: true,
    message: 'Configuration updated',
    config: req.body,
  });
});

// POST /api/admin/llm/reset-counters
router.post('/reset-counters', (req, res) => {
  // This would reset the governor's internal counters
  // Useful for testing or emergency situations
  
  res.json({
    success: true,
    message: 'Counters reset',
    newStatus: llmGovernor.getStatus(),
  });
});

function generateRecommendations(status: any): string[] {
  const recs: string[] = [];
  
  if (status.callsThisHour > status.limits.hourly * 0.8) {
    recs.push('‚ö†Ô∏è Approaching hourly limit - consider increasing cooldown periods');
  }
  
  if (status.costToday > status.limits.costLimit * 0.7) {
    recs.push('üí∞ 70% of daily budget used - route more traffic to cheaper providers');
  }
  
  if (status.callsToday < 10 && new Date().getHours() > 12) {
    recs.push('‚úì Low usage today - system is well optimized');
  }
  
  return recs;
}

export default router;
```

---

## IMPLEMENTATION CHECKLIST

### Database Population
- [ ] Run `npx tsx server/scripts/database-audit.ts`
- [ ] Review audit report for empty tables
- [ ] Configure all required API keys (Alpaca, Finnhub, etc.)
- [ ] Run `npx tsx server/scripts/populate-real-data.ts`
- [ ] Verify data in database using `GET /api/debug/data-status`
- [ ] Test UI screens load with real data

### LLM Optimization
- [ ] Run `npx tsx server/scripts/llm-usage-audit.ts`
- [ ] Review usage report and identify waste
- [ ] Implement `LLMGovernor` service
- [ ] Implement `AnalysisTriggerService`
- [ ] Update orchestrator to use governor
- [ ] Add admin endpoints for monitoring
- [ ] Configure appropriate limits based on budget

---

## RECOMMENDED LLM FREQUENCY SETTINGS

| Scenario | Recommended Interval | Rationale |
|----------|---------------------|-----------|
| **Market Hours (9:30 AM - 4 PM ET)** | 10-15 minutes | Active trading requires more frequent analysis |
| **Pre/Post Market (4 AM - 9:30 AM, 4 PM - 8 PM)** | 30 minutes | Lower volume, less urgency |
| **Overnight/Weekends** | 60+ minutes or disabled | Markets closed, minimal value |
| **Price Change > 2%** | Immediate (override cooldown) | Significant movement warrants analysis |
| **Volume Spike > 2.5x** | Immediate (override cooldown) | Unusual activity signals importance |
| **Breaking News** | Within 5 minutes | News can move markets quickly |
| **New Position Opened** | Immediate | Need initial analysis for risk management |

### Budget Recommendations

| Budget Level | Daily Calls | Hourly Limit | Estimated Cost/Month |
|--------------|-------------|--------------|----------------------|
| **Minimal** | 50 | 5 | ~$5-10 |
| **Standard** | 200 | 20 | ~$20-40 |
| **Active Trading** | 500 | 50 | ~$50-100 |
| **Aggressive** | 1000 | 100 | ~$100-200 |

---

## SUCCESS METRICS

After implementation, verify:

1. **Database Health**
   - All UI-required tables have data
   - Data timestamps are recent (within last hour for snapshots)
   - Portfolio values match Alpaca account

2. **LLM Efficiency**
   - 50%+ reduction in unnecessary calls
   - Cost per day within configured budget
   - No analysis during market closed (unless triggered)

3. **UI Functionality**
   - Dashboard shows real portfolio value
   - Positions list matches Alpaca positions
   - Trades history shows real executed trades
   - Market data updates correctly