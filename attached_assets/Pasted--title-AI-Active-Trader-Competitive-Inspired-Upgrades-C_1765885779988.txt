{
"title": "AI Active Trader — Competitive-Inspired Upgrades (Capitalise/AI-Trader/Lean patterns) WITHOUT duplication",
"role": "Act as a CTO + senior engineer + QA lead. Do only verifiable work. Never claim completion without running checks.",
"non_negotiables": [
"NO mock/demo data in UI or backend. If any mock paths exist, gate them behind an explicit DEV flag and keep prod path real only.",
"Broker (Alpaca paper) is the single source of truth for positions/orders/fills. DB ledger/history must reconcile to broker truth.",
"Every external call must go through the existing budget+cache abstraction (no raw fetchWithRetry, no bypass).",
"Every decision/order step must be traceable: traceId + decisionId + order intent + broker orderId + fill events, all linked.",
"UI must reflect the real state machine (decision→intent→submit→accepted→filled/partial/canceled/rejected), not vague statuses."
],
"read_first": {
"docs_to_read_in_repo": [
"docs/APP_OVERVIEW.md",
"docs/ARCHITECTURE.md",
"docs/ORCHESTRATOR_AND_AGENT_RUNTIME.md",
"docs/ORDER_LIFECYCLE.md",
"docs/SOURCE_OF_TRUTH_CONTRACT.md",
"docs/TRADING_SAGA_SEQUENCES.md",
"docs/API_BUDGETING_AND_CACHING.md",
"docs/AI_MODELS_AND_PROVIDERS.md",
"docs/SYMBOL_MASTER_AND_TRADABILITY.md",
"docs/UI_INFORMATION_ARCHITECTURE.md",
"docs/ADMIN_DASHBOARD.md",
"docs/ADMIN_ACCESS.md",
"docs/COMPETITIVE_BENCHMARKING.md",
"docs/AUDIT_DOC_VS_IMPLEMENTATION_GAP.md"
],
"code_areas_to_inspect": [
"server/ai/* (llmRouter, llmGateway, openrouter provider, roleBasedRouter)",
"server/lib/fetchWithBudgetAndCache.ts and server/lib/callExternal.ts",
"server/trading/* (alpaca engine + any saga/work-queue execution path)",
"client/screens/AdminHubScreen.tsx + AdminScreen.tsx + ApiBudgetScreen.tsx + ModelRouterScreen.tsx",
"shared/types/* (admin-module + decision/order structs)"
],
"output_required_before_coding": [
"Create docs/REALITY_CHECKS/COMPETITOR_FEATURE_MAP.md mapping: (AI-Trader/Capitalise/Lean-like) feature → do we already have it? (yes/no/partial) → exact file paths proving it.",
"Create docs/REALITY_CHECKS/ADMIN_CONSOLIDATION_PLAN.md listing every admin-related screen/component and how it will be unified under the existing AdminHubScreen (do NOT create a new admin app)."
]
},
"goal": "Adopt high-value competitor patterns safely: (1) Capitalise-like Strategy Rules/Wizard, (2) AI-Trader-style Temporal Replay + Future-Info Filtering, (3) Hardened tool surfaces (MCP-like) for data/news/scraping, (4) Admin becomes a true control-plane (WordPress-like) by consolidating what already exists.",
"phase_plan": [
{
"phase": "P2.1 — Admin Control Plane Consolidation (NO duplication)",
"why": "You already have AdminHub + multiple admin screens; unify into one coherent WordPress-like admin with working buttons and end-to-end flows.",
"tasks": [
"Find the existing Admin entry points (navigation). Add a separate, explicit entry route for admin (web path + mobile route). Do NOT break main user nav.",
"Implement an AdminRouteGuard: require ADMIN_TOKEN (env) OR an admin role flag (if auth exists). If auth is not ready, use ADMIN_TOKEN only.",
"Inside AdminHubScreen, add a left-nav / tab sections for: Overview, Orchestrator, Orders, Brokers, AI Models Router, Budgets & Cache, Connectors, Work Queue, Observability, Docs/Reality Checks.",
"Wire every button to real endpoints (or create the endpoints). No placeholder UI.",
"Add an Admin ‘Reality Check’ page that loads and displays: docs/REALITY_CHECKS/*.md and docs/DOC_REALITY_MATRIX.json (if present)."
],
"definition_of_done": [
"I can access Admin via a documented URL/route and token.",
"All Admin cards/actions produce real server effects and show confirmations/errors.",
"No duplicate admin pages: everything reachable under AdminHub."
],
"docs_update": [
"Update docs/ADMIN_ACCESS.md with exact steps and screenshots/route names.",
"Update docs/ADMIN_DASHBOARD.md reflecting the consolidated modules."
]
},
{
"phase": "P2.2 — Capitalise-like Strategy Rules & Wizard (compile to Orchestrator runs)",
"why": "Capitalise-style automation is the fastest way to make the system usable: user defines rules, system schedules triggers, orchestrator executes safely.",
"tasks": [
"Create a StrategySpec JSON schema (shared/types) with: id, name, universe (symbols or dynamic filter), triggers, guards, actions, risk constraints, model policy, enabled flag, createdAt/updatedAt.",
"Build a Strategy Wizard UI (client) inside Admin: create/edit/enable/disable strategies. Include a ‘Test Run’ button.",
"Implement compiler: StrategySpec → scheduled jobs + trigger evaluation. Triggers can be: cron, price threshold, indicator crossing, news event signal (if available).",
"When a trigger fires, enqueue a run via the durable work queue (existing) with traceId/runId; orchestrator executes and produces decisions; execution goes through existing order submit/cancel queue path.",
"Add strict safety guards: max orders/day, max notional/day, per-symbol cooldown, kill-switch at admin."
],
"definition_of_done": [
"I can create a strategy, enable it, and see it schedule.",
"A trigger fires → work item created → orchestrator run → decision recorded → order intent generated → broker order submitted (paper).",
"All artifacts link via traceId (UI shows the chain)."
],
"docs_update": [
"Update docs/AGENT_EXECUTION_GUIDE.md and docs/ORCHESTRATOR_AND_AGENT_RUNTIME.md to include StrategySpec + trigger lifecycle.",
"Update docs/UI_INFORMATION_ARCHITECTURE.md to include the Strategy Wizard and its user journeys."
]
},
{
"phase": "P2.3 — AI-Trader-style Temporal Replay + Future-Info Filtering (prevent leakage)",
"why": "If we add web/news/scraping tools, replay/backtests will silently leak future info unless we enforce temporal constraints everywhere.",
"tasks": [
"Introduce a required 'asOf' timestamp on every orchestrator run/decision context (server + DB). Default: now() for live runs.",
"Enforce temporal constraints in data access: market data queries must respect asOf; cached entries must include fetchedAt and (when possible) sourcePublishedAt.",
"Add 'Future Info Filter' middleware for any web/news ingestion: reject/ignore items where publishedAt > asOf. If publishedAt missing, mark as 'untrusted' and exclude from backtests/replay.",
"Create a Replay Runner: given (startDate,endDate,step), it replays triggers and orchestrator runs using only asOf-safe data. Store results separately as 'replay sessions'.",
"Add Admin UI: Replay Sessions list + run controls + export results."
],
"definition_of_done": [
"Replay produces identical results when rerun with same inputs.",
"Backtest/replay cannot consume any content published after asOf (proved by tests)."
],
"tests_required": [
"Unit test: future-news item is filtered out during replay.",
"Integration test: replay run creates decisions and orders but never violates the asOf constraint."
],
"docs_update": [
"Update docs/BACKTESTING.md with temporal replay and leakage prevention.",
"Update docs/OBSERVABILITY.md to include replay metrics."
]
},
{
"phase": "P2.4 — Tool Surface Hardening (MCP-like internally) + Optional Jina connector",
"why": "AI-Trader + Alpaca MCP show the right way: tools are explicit, schema’d, auditable. This reduces hallucinations and improves safety.",
"tasks": [
"Inventory all tools/functions the LLM can call today. Create a single ToolRegistry with JSON Schemas for inputs/outputs. Enforce validation at runtime.",
"Add SSRF + allowlist protections for any URL-fetch tools (deny local IPs, metadata endpoints, file://, etc).",
"Add secrets redaction everywhere logs/LLM context could include keys.",
"Add OPTIONAL connector: Jina Reader/Search behind budgets+caching. Store raw docs + extracted facts, with fetchedAt and publishedAt when available.",
"Expose tool usage telemetry in Admin (calls per tool, failures, costs)."
],
"definition_of_done": [
"Every tool call is validated + logged with traceId + stored in DB.",
"Admin shows a tool audit trail and per-tool costs."
],
"docs_update": [
"Update docs/CONNECTORS_AND_INTEGRATIONS.md with tool registry + Jina connector + security constraints.",
"Update docs/API_BUDGETING_AND_CACHING.md with new provider budgets and caching keys."
]
},
{
"phase": "P2.5 — LLM Cost/Value Optimization (OpenRouter + OpenAI routing you already have)",
"why": "You already have OpenAI + OpenRouter. Now enforce model policies so expensive models are used only for high-value steps.",
"tasks": [
"Confirm the existing router supports: role-based selection, fallback, parallel voting (optional). Extend WITHOUT rewriting.",
"Implement ModelPolicy per task type: (cheap) summarization, parsing, labeling → small models; (critical) final trade decision/risk signoff → best models.",
"Add caching for deterministic prompts (e.g., symbol profiles, repeated news summaries) keyed by (task,asOf,symbol,inputs hash).",
"Add Admin controls: per-role model, max tokens, max cost/day, fallback chain, and ‘panic switch’ to downgrade to cheap-only mode."
],
"definition_of_done": [
"Admin can change router policy live.",
"Logs + DB show model used, cost estimate, and why it was selected for each task."
],
"docs_update": [
"Update docs/AI_MODELS_AND_PROVIDERS.md with policy matrix and fallback strategy.",
"Update docs/ADMIN_DASHBOARD.md with Model Router controls."
]
}
],
"execution_rules": [
"After each phase, run tests and show evidence: which endpoints called, sample DB rows, and UI screenshots.",
"If you discover a feature already exists, do not re-implement—extend it and cite the file path in the docs/REALITY_CHECKS map.",
"Keep changes small and incremental: one phase PR at a time with clear commit messages."
],
"final_output_required": [
"A checklist report in docs/REALITY_CHECKS/PHASE_2_PROGRESS.md with (done/blocked/next).",
"A consolidated AdminHub that controls everything above.",
"No regressions in order execution flows and traceId propagation."
]
}