You are Replit operating inside the AI-Active-Trader repository.

GOAL: Continue migration + infra upgrade + full function implementation by using the docs as the contract, validating reality against code, fixing gaps, and upgrading the Admin UI into a WordPress-like Admin Center.

ABSOLUTE RULE: NO HALLUCINATIONS.
- Do not say ‚Äúdone‚Äù unless you show proof (diff + runtime evidence).
- If docs claim something exists but it doesn‚Äôt, either implement it OR update docs to match reality (with a clear ‚ÄúDecision Log‚Äù entry).

========================================================
PHASE 0 ‚Äî REPO REALITY INVENTORY (MUST DO FIRST)
========================================================
0.1 Read ALL docs in /docs (including docs/adr, docs/providers, docs/services).
0.2 Build a ‚ÄúDoc‚ÜíImplementation Map‚Äù:
- For each doc, list:
  (a) Key claims/contracts
  (b) Referenced code files / endpoints / tables
  (c) Reality verdict: ‚úÖ implemented, ‚ö†Ô∏è partial, ‚ùå missing, üßæ doc outdated
  (d) What must change: code vs docs

0.3 Extract every item marked as:
- ‚ÄúKnown Issues‚Äù, ‚ÄúTODO‚Äù, ‚ÄúPlanned‚Äù, ‚ÄúNext phase‚Äù, ‚ÄúRoadmap‚Äù, ‚ÄúFuture Work‚Äù, checklists (- [ ])
Create a single backlog list with:
- ID, Title, Doc source, Severity (Critical/Major/Minor), Effort (S/M/L), Dependencies, Owner (service/UI), Acceptance criteria.

0.4 Produce a ‚ÄúDiscrepancy Report‚Äù as output:
- Top 20 highest-impact mismatches between docs and code.
- Include file paths + line references where possible.

IMPORTANT: inspect these folders and include them in the map:
- /server (monolith)
- /services (microservices)
- /infrastructure (k8s/nats/vault)
- /client (mobile/web UI)
- /shared/schema.ts (DB contract)
- /docs (all)

========================================================
PHASE 1 ‚Äî MAKE THE SYSTEM EXECUTIONALLY TRUE (TOP PRIORITY FIXES)
========================================================
1.1 Trading data integrity (Orders vs Trades vs Fills)
Problem to solve:
- ‚Äútrades‚Äù currently get created with price=0 or before fills, causing broken P&L and misleading UI statuses.

Required changes:
A) Introduce an ORDERS table (or equivalent) to store broker orders as first-class:
- order_id (broker), client_order_id, symbol, side, qty, type, limit_price, status, submitted_at, filled_at, filled_avg_price, raw_json, trace_id, decision_id.
B) Re-define TRADES as FILLS/EXECUTIONS only:
- a trade record is created ONLY when order is filled/partially filled with a real fill price.
C) Add a reconciliation job:
- scan historical trades where price=0 and backfill from Alpaca orders if possible; otherwise mark as ‚Äúunreconcilable‚Äù and exclude from P&L.
D) Update endpoints used by UI:
- UI must show Orders (broker truth) + Fills (trade history), not a mixed fake ledger.

Use Alpaca ‚ÄúGet Order by client_order_id‚Äù to map decisions‚Üíorders reliably, and enforce deterministic client_order_id format.
- client_order_id = trace_{traceId}_dec_{decisionId}_sym_{SYMBOL} (keep within limits).
- On each order action, verify broker state by fetching the order (by id or client_order_id) before marking local state. 

1.2 Orchestration + Work Queue must actually run
Docs describe a durable queue and saga-like sequences. Validate reality and fix gaps:
A) Ensure the work queue worker is started in runtime (monolith OR orchestrator service), not just defined.
B) Fix any queue claiming logic bugs (e.g., type filtering must happen in the SQL query, not after selecting one item).
C) Add a kill-switch / pause / resume that stops new work items from being claimed.
D) Add dead-letter handling + ‚Äúretry‚Äù action.

1.3 Traceability end-to-end (single trace_id)
A) Ensure trace_id is stored across:
- ai_decisions
- llm_calls
- work_items
- orders
- trades/fills
B) Confirm GET /api/traces/:traceId returns complete chain:
decision ‚Üí llm calls ‚Üí work items ‚Üí orders ‚Üí fills ‚Üí final outcome

========================================================
PHASE 2 ‚Äî WORDPRESS-LIKE ADMIN CENTER (CONTROL & OBSERVE EVERYTHING)
========================================================
2.1 Create a modular Admin Center UI (like WordPress):
- Left sidebar navigation
- ‚ÄúPlugins/modules‚Äù registry approach so new admin pages can be added easily
- Global search + filters + status chips

2.2 Minimum Admin pages (must be real and connected to real endpoints):
A) Admin Dashboard (Overview)
- system health, last run, open positions, open orders, queue depth, budget usage, cache hit rate, LLM spend estimate (best-effort), error rate.
B) Orchestrator
- cycle status, active tasks, next scheduled run, start/stop/pause, concurrency settings, mode (paper/live disabled).
C) Work Queue
- list work_items with status, attempts, next_run_at, payload preview, claim/force retry/dead-letter actions.
D) Providers & Budgets
- per provider: enabled toggle, call limits, current usage, last call, cache stats
E) Persistent Cache Inspector
- browse cached entries by provider/symbol/time, invalidate keys.
F) LLM Router
- roles ‚Üí model chains, criticality, fallbacks; show last 50 calls per role.
OpenRouter must support fallbacks via ‚Äúmodels‚Äù parameter and structured outputs where supported. 
G) Trades / Orders / Decisions
- split tabs: Orders (broker truth), Fills/Trades, AI Decisions
- drill-down: show ‚Äúwhy‚Äù factors and the evidence chain
H) Observability
- structured logs viewer (even if basic), SLO/SLA panel (from docs), error traces.

2.3 Admin API contract
Add/confirm backend endpoints for each Admin page.
Each endpoint must return REAL data (DB or broker) and include ‚Äúsource‚Äù: {db|alpaca|computed}.

========================================================
PHASE 3 ‚Äî MIGRATION & INFRASTRUCTURE UPGRADE (DOC-DRIVEN)
========================================================
3.1 Validate services/ docker-compose:
- bring up NATS + services
- confirm health endpoints
- produce a ‚ÄúService Readiness Table‚Äù (build, run, health, integration tests).
3.2 Tackle roadmap items marked incomplete:
- Secrets injection via Vault (if marked not done)
- Event replay tests
- Latency SLO checks
- Monolith read-only plan (if required by docs)
Make this incremental and verifiable.

========================================================
PHASE 4 ‚Äî TRADE HISTORY FORENSICS (WHAT WENT RIGHT/WRONG)
========================================================
4.1 Generate a forensic report (stored in docs/LESSONS_LEARNED.md addendum + new docs/TRADE_FORENSICS_REPORT.md):
- count anomalies: price=0, missing fills, decisions without orders, orders without decisions, pending stuck.
- root cause per category + fix.
4.2 Add a ‚ÄúReconciliation‚Äù admin action:
- can re-sync orders/positions from Alpaca and backfill missing fills.

========================================================
OUTPUT & PROOF REQUIREMENTS (MANDATORY)
========================================================
At the end of each phase you execute, output:
1) ‚ÄúWhat I read‚Äù checklist (docs + key files)
2) The Doc‚ÜíImplementation Map (summary + top discrepancies)
3) git diff --stat
4) Commands run + outputs:
   - npm run check:types
   - npm run lint (if exists)
   - minimal smoke test: call 2-3 critical endpoints (curl)
5) Evidence screenshots/log snippets if UI changes were made
6) Update docs/ to match reality (only if implemented)

START WITH PHASE 0 + PHASE 1 ONLY in this run.
Do not begin Phase 2+ until Phase 1 is proven working.
