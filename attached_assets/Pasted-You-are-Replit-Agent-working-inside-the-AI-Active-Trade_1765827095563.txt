You are Replit Agent working inside the AI Active Trader repo.

GOAL (Task #5):
Implement a broker-backed Symbol Master + Tradability Gate so that:
- Any symbol shown as “executable” is actually tradable on our broker (Alpaca paper).
- No AI decision can be submitted as an order unless it passes tradability + session eligibility rules.
- UI clearly marks symbols as: Tradable / Not tradable / Unknown (missing config) with reasons.
- No mock/demo data is introduced.

AUTHORITATIVE SOURCES TO FOLLOW:
- Alpaca /v2/assets is the master list of assets available for trade and data consumption.
- Alpaca docs show checking a symbol’s tradability via get_asset(symbol) and asset.tradable.
- Alpaca docs describe orders submitted outside eligible hours and the extended_hours flag behavior.
(Use Alpaca docs exactly; don’t invent fields or semantics.)

NON-NEGOTIABLE RULES:
- No hallucinations: if you can’t verify a field from Alpaca, don’t use it.
- Every “block execution” must return a structured reason (for UI + logs).
- Every claimed change must include: files changed list + command outputs + curl proof + docs updates.

STEP 0 — READ FIRST (no coding)
1) Read docs:
- docs/ARCHITECTURE.md
- docs/TRADING_SAGA_SEQUENCES.md
- docs/API_REFERENCE.md
- docs/ORCHESTRATOR_AND_AGENT_RUNTIME.md
- docs/API_BUDGETING_AND_CACHING.md

2) Inspect existing code:
- Alpaca connector/service (where you call Alpaca endpoints)
- The order submission path (broker engine)
- The decision→order orchestration path
- UI screens that show “AI suggested trades” and “trade ledger” and “auto trading”
Summarize where symbols are currently introduced without validation.

STEP 1 — CREATE “SYMBOL MASTER” DATA MODEL (minimal & correct)
Add a DB table (or extend existing) to persist an Alpaca-backed universe snapshot:

Table: broker_assets
- broker (text) default "alpaca"
- symbol (text) PRIMARY KEY (or unique with broker)
- assetClass (text)
- exchange (text)
- status (text)
- tradable (boolean)
- marginable (boolean nullable)
- shortable (boolean nullable)
- fractionable (boolean nullable)
- easyToBorrow (boolean nullable)
- updatedAt (timestamp)

Notes:
- Only store fields you can confirm Alpaca returns (if uncertain, store raw JSON as assetRaw JSON).
- Add a JSON column assetRaw if needed for future-proofing.

Add a migration and apply it.

STEP 2 — BUILD THE UNIVERSE SYNC JOB (broker truth)
Implement a scheduled work item (ties into Task #4 durable work model):
- WORK ITEM: ASSET_UNIVERSE_SYNC (every 6–24h configurable)
- Calls Alpaca GET /v2/assets?status=active (and/or asset_class=us_equity by default)
- Upserts into broker_assets

All network calls MUST go through your centralized external-call gate (callExternal/fetchWithBudgetAndCache).
Cache:
- /v2/assets list: cache 6–24h
Fallback:
- If budget exhausted, serve stale cached asset list and keep last updated timestamp.

STEP 3 — ADD A FAST “TRADABILITY CHECK” SERVICE (runtime gate)
Create a service function:
validateSymbolTradable({symbol, side, qty, extendedHours?}) -> {ok, reasonCode, message, details}

Rules:
A) If Alpaca keys missing:
- return ok=false with reasonCode=MISSING_BROKER_CONFIG (UI must show disabled state)

B) If symbol not found in broker_assets:
- attempt a direct lookup via Alpaca getAsset(symbol) (as in docs) and store result
- if still not found, ok=false reasonCode=ASSET_NOT_FOUND

C) If asset.tradable is false:
- ok=false reasonCode=NOT_TRADABLE

D) Session eligibility:
- if extendedHours is required but not enabled (or order is outside eligible hours per our order type):
  ok=false reasonCode=SESSION_NOT_ELIGIBLE
(Use Alpaca “orders outside eligible trading hours” + extended_hours semantics.)

Return structured “reasons” for UI.

STEP 4 — ENFORCE THE GATE AT EVERY EXECUTION ENTRY POINT
Wherever the system can place/cancel/close:
- Before submit_order: call validateSymbolTradable; if not ok, block and persist the failure on the decision/work item.
- If a decision is blocked, it must surface in:
  - /api/activity/timeline
  - AI Suggested Trades list (as “blocked” with reason)

IMPORTANT:
- This applies to both manual user execution AND orchestrator auto-trading.

STEP 5 — UI INTEGRATION (no redesign, just correctness)
A) AI Suggested Trades:
- Each row must show tradability badge:
  - Tradable (green)
  - Not tradable (red + reason)
  - Unknown (gray) if broker config missing
- Disable Execute button when not tradable.
- Show tooltip/reason text.

B) Watchlist / symbol input:
- Validate on entry with debounce.
- If symbol isn’t in Alpaca universe, warn and prevent adding to “execution-enabled” strategies.

STEP 6 — NEW ENDPOINTS (for UI + debugging)
Implement:
- GET /api/universe/assets?broker=alpaca&status=active&search=...
- GET /api/universe/asset/:symbol?broker=alpaca
- POST /api/universe/validate-symbol { symbol, side, qty, extendedHours }

Each response must include provenance:
{ provider: "alpaca", cacheHit, cacheAgeMs, lastUniverseSyncAt }

STEP 7 — PROOF (must run)
Run and paste output:
- migration applied
- server starts
- curl GET /api/universe/asset/AAPL (or any common symbol)
- curl POST /api/universe/validate-symbol for a known tradable symbol
- curl POST /api/universe/validate-symbol for an intentionally invalid symbol -> must return NOT_TRADABLE or ASSET_NOT_FOUND (real response, not mock)

If Alpaca keys are missing in environment, demonstrate the MISSING_BROKER_CONFIG path (no fake data).

STEP 8 — DOCS UPDATE (must match actual code)
Update:
- docs/ARCHITECTURE.md (Symbol Master + gating layer)
- docs/TRADING_SAGA_SEQUENCES.md (decision blocked states + reasons)
- docs/API_REFERENCE.md (new /api/universe endpoints)
Add:
- docs/SYMBOL_MASTER_AND_TRADABILITY.md (how it works, TTLs, failure modes, UI behavior)

DELIVERABLES:
- Files changed list
- Commands run + outputs
- Curl examples
- “Next task” plan: Task #6 Backtesting integrity (how to use normalized data + universe)
