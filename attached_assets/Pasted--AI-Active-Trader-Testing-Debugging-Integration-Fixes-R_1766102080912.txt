# AI Active Trader - Testing, Debugging & Integration Fixes

> **REPLIT AGENT INSTRUCTION SET**
> Execute this comprehensive testing and debugging task to identify and fix:
> - Incomplete data rendering (stock lists showing partial data)
> - Broken UI navigation and component linking
> - AI decisions not flowing to trade execution
> - Disconnected orchestrator/trading engine components
> - Duplicate/redundant UI elements

---

## OVERVIEW

This task performs a full-stack diagnostic and repair:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        DIAGNOSTIC FLOW                               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  1. DATABASE ‚Üí Are all records being fetched?                       ‚îÇ
‚îÇ  2. API ROUTES ‚Üí Are endpoints returning complete data?             ‚îÇ
‚îÇ  3. STATE MANAGEMENT ‚Üí Is frontend receiving all data?              ‚îÇ
‚îÇ  4. UI RENDERING ‚Üí Are components displaying everything?            ‚îÇ
‚îÇ  5. NAVIGATION ‚Üí Do clickable elements route correctly?             ‚îÇ
‚îÇ  6. AI PIPELINE ‚Üí Do decisions flow to execution?                   ‚îÇ
‚îÇ  7. ORCHESTRATOR ‚Üí Are all services connected?                      ‚îÇ
‚îÇ  8. DUPLICATES ‚Üí Which components are redundant?                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# PHASE 1: SETUP TESTING INFRASTRUCTURE

## 1.1 Install Testing Dependencies

```bash
# Unit testing
npm install -D vitest @vitest/coverage-v8 @vitest/ui

# API testing
npm install -D supertest @types/supertest

# E2E testing for React Native/Expo
npm install -D detox jest @testing-library/react-native

# Component testing
npm install -D @testing-library/react @testing-library/jest-dom

# Mocking
npm install -D msw

# Database testing
npm install -D testcontainers @testcontainers/postgresql
```

## 1.2 Vitest Configuration

**File: `vitest.config.ts`**

```typescript
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['**/*.{test,spec}.{js,ts,tsx}'],
    exclude: ['node_modules', 'dist', '.expo'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: ['node_modules', 'tests', '**/*.d.ts'],
    },
    setupFiles: ['./tests/setup.ts'],
    testTimeout: 30000,
    alias: {
      '@': path.resolve(__dirname, './'),
      '@shared': path.resolve(__dirname, './shared'),
      'server': path.resolve(__dirname, './server'),
    },
  },
});
```

## 1.3 Test Setup File

**File: `tests/setup.ts`**

```typescript
import { beforeAll, afterAll, afterEach } from 'vitest';

// Mock environment variables for testing
process.env.NODE_ENV = 'test';
process.env.DATABASE_URL = process.env.TEST_DATABASE_URL || process.env.DATABASE_URL;

// Global test utilities
global.testUtils = {
  async waitFor(condition: () => boolean, timeout: number = 5000): Promise<void> {
    const start = Date.now();
    while (!condition() && Date.now() - start < timeout) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    if (!condition()) {
      throw new Error('Condition not met within timeout');
    }
  },
};

beforeAll(async () => {
  console.log('üß™ Test suite starting...');
});

afterAll(async () => {
  console.log('üß™ Test suite complete.');
});

afterEach(() => {
  // Clean up any mocks
});
```

---

# PHASE 2: DATA FLOW DIAGNOSTIC TESTS

## 2.1 Database ‚Üí API Data Flow Test

**File: `tests/integration/data-flow.test.ts`**

```typescript
import { describe, it, expect, beforeAll } from 'vitest';
import { db } from '../../server/db';
import { sql, count } from 'drizzle-orm';
import * as schema from '@shared/schema';

describe('Data Flow: Database ‚Üí API', () => {
  
  describe('Symbol Master Data Flow', () => {
    let dbCount: number;
    let apiCount: number;

    beforeAll(async () => {
      // Get count from database
      const result = await db.select({ count: count() }).from(schema.symbolMaster);
      dbCount = Number(result[0]?.count || 0);

      // Get count from API
      const response = await fetch('http://localhost:3000/api/symbols');
      const data = await response.json();
      apiCount = Array.isArray(data) ? data.length : (data.symbols?.length || 0);
    });

    it('should have symbols in database', () => {
      expect(dbCount).toBeGreaterThan(0);
      console.log(`üìä Database has ${dbCount} symbols`);
    });

    it('should return all symbols from API', () => {
      expect(apiCount).toBeGreaterThan(0);
      console.log(`üìä API returns ${apiCount} symbols`);
    });

    it('should have matching counts (DB === API)', () => {
      // Allow for pagination, but flag if significantly different
      if (apiCount < dbCount) {
        console.warn(`‚ö†Ô∏è API returns fewer symbols (${apiCount}) than DB (${dbCount})`);
        console.warn('   POSSIBLE ISSUES:');
        console.warn('   - API has pagination but UI only fetches first page');
        console.warn('   - API query has a LIMIT clause');
        console.warn('   - Filter is excluding records');
      }
      expect(apiCount).toBeGreaterThanOrEqual(Math.min(dbCount, 100)); // Allow for reasonable pagination
    });
  });

  describe('Positions Data Flow', () => {
    let dbPositions: any[];
    let apiPositions: any[];

    beforeAll(async () => {
      dbPositions = await db.select().from(schema.positions);
      
      const response = await fetch('http://localhost:3000/api/positions');
      const data = await response.json();
      apiPositions = Array.isArray(data) ? data : (data.positions || []);
    });

    it('should return all positions from API', () => {
      console.log(`üìä DB positions: ${dbPositions.length}, API positions: ${apiPositions.length}`);
      
      if (apiPositions.length < dbPositions.length) {
        console.error('‚ùå MISSING POSITIONS IN API RESPONSE');
        const dbSymbols = new Set(dbPositions.map(p => p.symbol));
        const apiSymbols = new Set(apiPositions.map(p => p.symbol));
        const missing = [...dbSymbols].filter(s => !apiSymbols.has(s));
        console.error(`   Missing symbols: ${missing.join(', ')}`);
      }

      expect(apiPositions.length).toBe(dbPositions.length);
    });

    it('should include all required fields for UI', () => {
      const requiredFields = [
        'id', 'symbol', 'quantity', 'averageEntryPrice', 
        'currentPrice', 'marketValue', 'unrealizedPnl', 'unrealizedPnlPercent'
      ];

      for (const position of apiPositions) {
        for (const field of requiredFields) {
          if (!(field in position)) {
            console.error(`‚ùå Position ${position.symbol} missing field: ${field}`);
          }
          expect(position).toHaveProperty(field);
        }
      }
    });
  });

  describe('Trades Data Flow', () => {
    let dbTrades: any[];
    let apiTrades: any[];

    beforeAll(async () => {
      dbTrades = await db.select().from(schema.trades).limit(100);
      
      const response = await fetch('http://localhost:3000/api/trades?limit=100');
      const data = await response.json();
      apiTrades = Array.isArray(data) ? data : (data.trades || []);
    });

    it('should return trades with correct structure', () => {
      console.log(`üìä DB trades: ${dbTrades.length}, API trades: ${apiTrades.length}`);

      if (apiTrades.length === 0 && dbTrades.length > 0) {
        console.error('‚ùå API RETURNING EMPTY TRADES ARRAY');
        console.error('   Check: GET /api/trades route handler');
      }

      expect(apiTrades.length).toBe(dbTrades.length);
    });
  });

  describe('AI Decisions Data Flow', () => {
    let dbDecisions: any[];
    let apiDecisions: any[];

    beforeAll(async () => {
      dbDecisions = await db.select().from(schema.aiDecisions).limit(50);
      
      const response = await fetch('http://localhost:3000/api/ai/decisions?limit=50');
      const data = await response.json();
      apiDecisions = Array.isArray(data) ? data : (data.decisions || []);
    });

    it('should expose AI decisions to API', () => {
      console.log(`üìä DB AI decisions: ${dbDecisions.length}, API AI decisions: ${apiDecisions.length}`);

      if (apiDecisions.length === 0 && dbDecisions.length > 0) {
        console.error('‚ùå AI DECISIONS NOT EXPOSED VIA API');
        console.error('   This explains why AI suggestions may not appear in UI');
      }
    });

    it('should include action recommendations', () => {
      for (const decision of apiDecisions) {
        const hasAction = decision.action || decision.recommendation || decision.signal;
        if (!hasAction) {
          console.warn(`‚ö†Ô∏è AI Decision ${decision.id} has no actionable recommendation`);
        }
      }
    });
  });
});
```

## 2.2 API Endpoint Completeness Test

**File: `tests/integration/api-endpoints.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import request from 'supertest';

const API_BASE = 'http://localhost:3000';

describe('API Endpoint Completeness', () => {

  // Define all expected endpoints
  const EXPECTED_ENDPOINTS = [
    // Core data
    { method: 'GET', path: '/api/symbols', description: 'List all tradable symbols' },
    { method: 'GET', path: '/api/symbols/:symbol', description: 'Get single symbol details' },
    { method: 'GET', path: '/api/positions', description: 'List all positions' },
    { method: 'GET', path: '/api/trades', description: 'List trade history' },
    { method: 'GET', path: '/api/portfolio', description: 'Portfolio summary' },
    
    // Market data
    { method: 'GET', path: '/api/market/quotes', description: 'Get market quotes' },
    { method: 'GET', path: '/api/market/snapshot/:symbol', description: 'Symbol snapshot' },
    
    // AI/Analysis
    { method: 'GET', path: '/api/ai/decisions', description: 'AI trading decisions' },
    { method: 'GET', path: '/api/ai/analysis/:symbol', description: 'Symbol analysis' },
    { method: 'POST', path: '/api/ai/analyze', description: 'Trigger analysis' },
    
    // Trading
    { method: 'POST', path: '/api/trading/order', description: 'Place order' },
    { method: 'GET', path: '/api/trading/orders', description: 'List orders' },
    { method: 'DELETE', path: '/api/trading/order/:id', description: 'Cancel order' },
    
    // Strategies
    { method: 'GET', path: '/api/strategies', description: 'List strategies' },
    { method: 'GET', path: '/api/strategies/:id', description: 'Get strategy details' },
    { method: 'PUT', path: '/api/strategies/:id', description: 'Update strategy' },
    
    // Agent control
    { method: 'GET', path: '/api/agent/status', description: 'Agent status' },
    { method: 'POST', path: '/api/agent/start', description: 'Start agent' },
    { method: 'POST', path: '/api/agent/stop', description: 'Stop agent' },
    
    // Watchlist
    { method: 'GET', path: '/api/watchlist', description: 'Get watchlist' },
    { method: 'POST', path: '/api/watchlist', description: 'Add to watchlist' },
    { method: 'DELETE', path: '/api/watchlist/:symbol', description: 'Remove from watchlist' },
    
    // News
    { method: 'GET', path: '/api/news', description: 'Get news feed' },
    { method: 'GET', path: '/api/news/:symbol', description: 'Symbol-specific news' },
    
    // Alerts
    { method: 'GET', path: '/api/alerts', description: 'Get alerts' },
    { method: 'POST', path: '/api/alerts', description: 'Create alert' },
  ];

  const missingEndpoints: string[] = [];
  const workingEndpoints: string[] = [];
  const errorEndpoints: { path: string; status: number; error: string }[] = [];

  it('should verify all expected endpoints exist', async () => {
    for (const endpoint of EXPECTED_ENDPOINTS) {
      try {
        // Replace path params with test values
        const testPath = endpoint.path
          .replace(':symbol', 'AAPL')
          .replace(':id', '1');

        let response;
        if (endpoint.method === 'GET') {
          response = await fetch(`${API_BASE}${testPath}`);
        } else if (endpoint.method === 'POST') {
          response = await fetch(`${API_BASE}${testPath}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}),
          });
        } else if (endpoint.method === 'PUT') {
          response = await fetch(`${API_BASE}${testPath}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({}),
          });
        } else if (endpoint.method === 'DELETE') {
          response = await fetch(`${API_BASE}${testPath}`, { method: 'DELETE' });
        }

        if (response?.status === 404) {
          missingEndpoints.push(`${endpoint.method} ${endpoint.path} - ${endpoint.description}`);
        } else if (response?.status && response.status >= 500) {
          errorEndpoints.push({
            path: `${endpoint.method} ${endpoint.path}`,
            status: response.status,
            error: await response.text(),
          });
        } else {
          workingEndpoints.push(`${endpoint.method} ${endpoint.path}`);
        }
      } catch (error) {
        missingEndpoints.push(`${endpoint.method} ${endpoint.path} - CONNECTION ERROR`);
      }
    }

    // Report findings
    console.log('\nüìã API ENDPOINT AUDIT RESULTS');
    console.log('‚ïê'.repeat(60));
    
    console.log(`\n‚úÖ Working Endpoints (${workingEndpoints.length}):`);
    workingEndpoints.forEach(e => console.log(`   ${e}`));
    
    if (missingEndpoints.length > 0) {
      console.log(`\n‚ùå Missing Endpoints (${missingEndpoints.length}):`);
      missingEndpoints.forEach(e => console.log(`   ${e}`));
    }
    
    if (errorEndpoints.length > 0) {
      console.log(`\n‚ö†Ô∏è Error Endpoints (${errorEndpoints.length}):`);
      errorEndpoints.forEach(e => console.log(`   ${e.path} ‚Üí ${e.status}`));
    }

    // Fail if critical endpoints missing
    const criticalMissing = missingEndpoints.filter(e => 
      e.includes('/positions') || 
      e.includes('/portfolio') || 
      e.includes('/ai/decisions') ||
      e.includes('/agent/status')
    );

    if (criticalMissing.length > 0) {
      console.error('\nüö® CRITICAL ENDPOINTS MISSING:');
      criticalMissing.forEach(e => console.error(`   ${e}`));
    }

    expect(criticalMissing.length).toBe(0);
  });
});
```

## 2.3 Data Pagination & Limits Diagnostic

**File: `tests/integration/pagination-diagnostic.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import { db } from '../../server/db';
import { count } from 'drizzle-orm';
import * as schema from '@shared/schema';

describe('Pagination & Data Limits Diagnostic', () => {
  
  it('should identify truncated data issues', async () => {
    const issues: string[] = [];

    // Check each table for pagination issues
    const tables = [
      { name: 'symbolMaster', table: schema.symbolMaster, apiPath: '/api/symbols' },
      { name: 'positions', table: schema.positions, apiPath: '/api/positions' },
      { name: 'trades', table: schema.trades, apiPath: '/api/trades' },
      { name: 'aiDecisions', table: schema.aiDecisions, apiPath: '/api/ai/decisions' },
      { name: 'newsItems', table: schema.newsItems, apiPath: '/api/news' },
      { name: 'strategies', table: schema.strategies, apiPath: '/api/strategies' },
    ];

    for (const { name, table, apiPath } of tables) {
      try {
        // Get DB count
        const dbResult = await db.select({ count: count() }).from(table);
        const dbCount = Number(dbResult[0]?.count || 0);

        // Get API count
        const response = await fetch(`http://localhost:3000${apiPath}`);
        const data = await response.json();
        const apiData = Array.isArray(data) ? data : (data[name] || data.data || data.items || []);
        const apiCount = apiData.length;

        // Check for pagination metadata
        const hasPagination = data.pagination || data.meta || data.total || data.hasMore;

        console.log(`\nüìä ${name}:`);
        console.log(`   DB Records: ${dbCount}`);
        console.log(`   API Returns: ${apiCount}`);
        console.log(`   Has Pagination: ${hasPagination ? 'Yes' : 'No'}`);

        if (dbCount > apiCount && !hasPagination) {
          issues.push(
            `${name}: DB has ${dbCount} records but API only returns ${apiCount} with NO pagination`
          );
          console.error(`   ‚ùå TRUNCATION DETECTED - UI will show incomplete data!`);
        } else if (dbCount > apiCount && hasPagination) {
          console.log(`   ‚úì Paginated correctly`);
        } else if (dbCount === apiCount) {
          console.log(`   ‚úì All data returned`);
        }

        // Check for common limit issues
        if (apiCount === 10 || apiCount === 20 || apiCount === 25 || apiCount === 50 || apiCount === 100) {
          if (dbCount > apiCount) {
            console.warn(`   ‚ö†Ô∏è Likely hard-coded LIMIT ${apiCount} in query`);
          }
        }
      } catch (error) {
        console.error(`   ‚ùå Error checking ${name}: ${error}`);
      }
    }

    if (issues.length > 0) {
      console.error('\nüö® DATA TRUNCATION ISSUES FOUND:');
      issues.forEach(issue => console.error(`   - ${issue}`));
      console.error('\n   FIX: Add pagination support or increase limits in API routes');
    }

    expect(issues.length).toBe(0);
  });
});
```

---

# PHASE 3: UI COMPONENT DIAGNOSTICS

## 3.1 Component Rendering Diagnostic

**File: `tests/ui/component-rendering.test.ts`**

```typescript
import { describe, it, expect } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';

describe('UI Component Rendering Diagnostic', () => {

  // Scan for common rendering issues in component files
  const componentDirs = [
    'mobile/components',
    'mobile/screens', 
    'mobile/app',
    'client/src/components',
    'client/src/pages',
  ];

  it('should identify incomplete list renderings', () => {
    const issues: string[] = [];

    for (const dir of componentDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = walkDir(dir).filter(f => f.endsWith('.tsx') || f.endsWith('.jsx'));

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');

        // Check for lists that might only render first item
        if (content.includes('FlatList') || content.includes('.map(')) {
          
          // Check for .slice() which might truncate data
          const sliceMatch = content.match(/\.slice\(0,\s*(\d+)\)/);
          if (sliceMatch) {
            issues.push(`${file}: Data sliced to ${sliceMatch[1]} items - may truncate display`);
          }

          // Check for array[0] access instead of mapping
          if (content.match(/data\[0\]|items\[0\]|positions\[0\]|trades\[0\]|symbols\[0\]/)) {
            issues.push(`${file}: Only accessing first array element - should map entire array`);
          }

          // Check for missing keyExtractor in FlatList
          if (content.includes('FlatList') && !content.includes('keyExtractor')) {
            issues.push(`${file}: FlatList missing keyExtractor - may cause rendering issues`);
          }
        }

        // Check for conditional rendering that might hide data
        if (content.match(/\{.*length\s*===\s*0.*&&/)) {
          // This is fine - shows empty state
        } else if (content.match(/\{.*length\s*[<>]=?\s*\d+.*&&/)) {
          issues.push(`${file}: Conditional rendering based on length - verify threshold is correct`);
        }
      }
    }

    console.log('\nüìã UI COMPONENT RENDERING AUDIT');
    console.log('‚ïê'.repeat(60));
    
    if (issues.length > 0) {
      console.error('\n‚ö†Ô∏è Potential Rendering Issues:');
      issues.forEach(issue => console.error(`   - ${issue}`));
    } else {
      console.log('\n‚úì No obvious rendering issues found');
    }
  });

  it('should identify missing navigation handlers', () => {
    const issues: string[] = [];

    for (const dir of componentDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = walkDir(dir).filter(f => f.endsWith('.tsx') || f.endsWith('.jsx'));

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');

        // Check for Pressable/TouchableOpacity without onPress
        const pressableWithoutHandler = content.match(
          /<(Pressable|TouchableOpacity|TouchableHighlight)[^>]*(?!onPress)[^>]*>/g
        );
        if (pressableWithoutHandler) {
          issues.push(`${file}: Clickable element without onPress handler`);
        }

        // Check for onPress={() => {}} empty handlers
        if (content.match(/onPress=\{\s*\(\)\s*=>\s*\{\s*\}\s*\}/)) {
          issues.push(`${file}: Empty onPress handler - click does nothing`);
        }

        // Check for console.log in onPress (debug code left in)
        if (content.match(/onPress=\{[^}]*console\.log/)) {
          issues.push(`${file}: onPress only has console.log - likely incomplete implementation`);
        }

        // Check for TODO/FIXME in navigation
        if (content.match(/(TODO|FIXME).*navig/i)) {
          issues.push(`${file}: TODO/FIXME related to navigation found`);
        }

        // Check for navigation.navigate with undefined route
        if (content.match(/navigate\(\s*['"`]\s*['"`]\s*\)/)) {
          issues.push(`${file}: Empty route in navigation.navigate()`);
        }
      }
    }

    console.log('\nüìã UI NAVIGATION AUDIT');
    console.log('‚ïê'.repeat(60));
    
    if (issues.length > 0) {
      console.error('\n‚ö†Ô∏è Navigation Issues:');
      issues.forEach(issue => console.error(`   - ${issue}`));
    } else {
      console.log('\n‚úì No obvious navigation issues found');
    }
  });
});

function walkDir(dir: string): string[] {
  const files: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory() && !entry.name.includes('node_modules')) {
      files.push(...walkDir(fullPath));
    } else if (entry.isFile()) {
      files.push(fullPath);
    }
  }
  
  return files;
}
```

## 3.2 Screen Navigation Map Generator

**File: `tests/ui/navigation-map.test.ts`**

```typescript
import { describe, it } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';

interface ScreenInfo {
  name: string;
  file: string;
  navigatesTo: string[];
  pressableElements: number;
  hasDetailView: boolean;
  linkedFromOthers: string[];
}

describe('Navigation Map Generator', () => {

  it('should generate complete navigation map', () => {
    const screenDirs = [
      'mobile/screens',
      'mobile/app',
      'client/src/pages',
    ];

    const screens: Map<string, ScreenInfo> = new Map();
    const allNavigationTargets: Set<string> = new Set();

    // First pass: identify all screens
    for (const dir of screenDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = walkDir(dir).filter(f => 
        (f.endsWith('.tsx') || f.endsWith('.jsx')) && 
        !f.includes('.test.') &&
        !f.includes('index')
      );

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');
        const screenName = path.basename(file, path.extname(file));

        // Find navigation targets
        const navMatches = content.matchAll(/navigate\(\s*['"`]([^'"`]+)['"`]/g);
        const navigatesTo = [...navMatches].map(m => m[1]);
        navigatesTo.forEach(t => allNavigationTargets.add(t));

        // Count pressable elements
        const pressableCount = (content.match(/<(Pressable|TouchableOpacity|TouchableHighlight|Button)/g) || []).length;

        // Check for detail view pattern
        const hasDetailView = content.includes('DetailScreen') || 
                             content.includes('Details') ||
                             content.includes('/:id') ||
                             content.includes('[id]');

        screens.set(screenName, {
          name: screenName,
          file,
          navigatesTo,
          pressableElements: pressableCount,
          hasDetailView,
          linkedFromOthers: [],
        });
      }
    }

    // Second pass: find reverse links
    for (const [screenName, info] of screens) {
      for (const target of info.navigatesTo) {
        const targetScreen = screens.get(target);
        if (targetScreen) {
          targetScreen.linkedFromOthers.push(screenName);
        }
      }
    }

    // Generate report
    console.log('\nüìç NAVIGATION MAP');
    console.log('‚ïê'.repeat(70));

    // Find orphan screens (no links to them)
    const orphanScreens = [...screens.values()].filter(s => 
      s.linkedFromOthers.length === 0 && 
      !['Home', 'Dashboard', 'App', 'Layout', 'Root', 'Index', '_layout'].includes(s.name)
    );

    // Find dead-end screens (no navigation out, but have pressables)
    const deadEndScreens = [...screens.values()].filter(s => 
      s.navigatesTo.length === 0 && 
      s.pressableElements > 0
    );

    // Find undefined navigation targets
    const undefinedTargets = [...allNavigationTargets].filter(t => !screens.has(t));

    console.log('\nüîó Screen Connections:');
    for (const [name, info] of screens) {
      console.log(`\n   ${name}:`);
      console.log(`      File: ${info.file}`);
      console.log(`      Clickables: ${info.pressableElements}`);
      console.log(`      Links to: ${info.navigatesTo.length > 0 ? info.navigatesTo.join(', ') : '(none)'}`);
      console.log(`      Linked from: ${info.linkedFromOthers.length > 0 ? info.linkedFromOthers.join(', ') : '(none)'}`);
    }

    if (orphanScreens.length > 0) {
      console.log('\n‚ö†Ô∏è ORPHAN SCREENS (not linked from anywhere):');
      orphanScreens.forEach(s => console.log(`   - ${s.name} (${s.file})`));
      console.log('   FIX: Add navigation to these screens from parent screens');
    }

    if (deadEndScreens.length > 0) {
      console.log('\n‚ö†Ô∏è DEAD-END SCREENS (have clickables but no navigation):');
      deadEndScreens.forEach(s => console.log(`   - ${s.name} (${s.pressableElements} clickables)`));
      console.log('   FIX: Implement onPress handlers for clickable elements');
    }

    if (undefinedTargets.length > 0) {
      console.log('\n‚ùå UNDEFINED NAVIGATION TARGETS:');
      undefinedTargets.forEach(t => console.log(`   - "${t}" - no screen found`));
      console.log('   FIX: Create missing screens or fix navigation route names');
    }
  });
});

function walkDir(dir: string): string[] {
  const files: string[] = [];
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        files.push(...walkDir(fullPath));
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }
  } catch (e) {
    // Directory doesn't exist
  }
  return files;
}
```

## 3.3 Duplicate Component Finder

**File: `tests/ui/duplicate-components.test.ts`**

```typescript
import { describe, it } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

interface ComponentSignature {
  name: string;
  file: string;
  hash: string;
  size: number;
  props: string[];
  similarTo: string[];
}

describe('Duplicate Component Finder', () => {

  it('should identify duplicate and similar components', () => {
    const componentDirs = [
      'mobile/components',
      'mobile/screens',
      'client/src/components',
    ];

    const components: ComponentSignature[] = [];
    const duplicates: { original: string; duplicate: string; similarity: number }[] = [];

    for (const dir of componentDirs) {
      if (!fs.existsSync(dir)) continue;

      const files = walkDir(dir).filter(f => 
        (f.endsWith('.tsx') || f.endsWith('.jsx')) && 
        !f.includes('.test.') &&
        !f.includes('index')
      );

      for (const file of files) {
        const content = fs.readFileSync(file, 'utf-8');
        const name = path.basename(file, path.extname(file));

        // Extract component signature
        const propsMatch = content.match(/interface\s+\w*Props\s*\{([^}]+)\}/);
        const props = propsMatch 
          ? propsMatch[1].split('\n').map(p => p.trim()).filter(p => p && !p.startsWith('//'))
          : [];

        // Create content hash (excluding imports and whitespace for comparison)
        const normalizedContent = content
          .replace(/import[^;]+;/g, '')
          .replace(/\/\/.*/g, '')
          .replace(/\/\*[\s\S]*?\*\//g, '')
          .replace(/\s+/g, ' ')
          .trim();

        const hash = crypto.createHash('md5').update(normalizedContent).digest('hex');

        components.push({
          name,
          file,
          hash,
          size: normalizedContent.length,
          props,
          similarTo: [],
        });
      }
    }

    // Find exact duplicates (same hash)
    const hashGroups = new Map<string, ComponentSignature[]>();
    for (const comp of components) {
      if (!hashGroups.has(comp.hash)) {
        hashGroups.set(comp.hash, []);
      }
      hashGroups.get(comp.hash)!.push(comp);
    }

    // Find similar components (by name patterns)
    const namePatterns = [
      /^(.+)Card$/,
      /^(.+)List$/,
      /^(.+)Item$/,
      /^(.+)Modal$/,
      /^(.+)Button$/,
      /^(.+)Header$/,
      /^(.+)Row$/,
    ];

    const similarByPattern: Map<string, ComponentSignature[]> = new Map();
    for (const comp of components) {
      for (const pattern of namePatterns) {
        const match = comp.name.match(pattern);
        if (match) {
          const patternKey = pattern.source;
          if (!similarByPattern.has(patternKey)) {
            similarByPattern.set(patternKey, []);
          }
          similarByPattern.get(patternKey)!.push(comp);
        }
      }
    }

    // Report
    console.log('\nüìã DUPLICATE COMPONENT ANALYSIS');
    console.log('‚ïê'.repeat(70));

    // Exact duplicates
    const exactDupes = [...hashGroups.values()].filter(g => g.length > 1);
    if (exactDupes.length > 0) {
      console.log('\n‚ùå EXACT DUPLICATES (identical code):');
      for (const group of exactDupes) {
        console.log(`\n   Duplicate group:`);
        group.forEach(c => console.log(`      - ${c.file}`));
        console.log(`   ACTION: Delete all but one and update imports`);
      }
    }

    // Similar by naming pattern
    console.log('\n‚ö†Ô∏è POTENTIALLY SIMILAR COMPONENTS:');
    for (const [pattern, comps] of similarByPattern) {
      if (comps.length > 2) {
        console.log(`\n   Pattern: ${pattern} (${comps.length} components)`);
        comps.forEach(c => console.log(`      - ${c.name} (${c.file})`));
        console.log(`   REVIEW: Consider consolidating into a single component with props`);
      }
    }

    // Find components with very similar sizes (potential near-duplicates)
    console.log('\nüìä SIZE-BASED SIMILARITY:');
    const sortedBySize = [...components].sort((a, b) => a.size - b.size);
    for (let i = 0; i < sortedBySize.length - 1; i++) {
      const curr = sortedBySize[i];
      const next = sortedBySize[i + 1];
      const sizeDiff = (next.size - curr.size) / curr.size;
      
      if (sizeDiff < 0.1 && curr.size > 500) { // Within 10% size and substantial
        console.log(`   Similar size: ${curr.name} (${curr.size}) ~ ${next.name} (${next.size})`);
      }
    }

    // Recommendations
    console.log('\nüí° RECOMMENDATIONS:');
    console.log('   1. Review components with same naming patterns for consolidation');
    console.log('   2. Create shared base components with configurable props');
    console.log('   3. Use composition over duplication');
    console.log('   4. Consider a component library for common UI patterns');
  });
});

function walkDir(dir: string): string[] {
  const files: string[] = [];
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        files.push(...walkDir(fullPath));
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }
  } catch (e) {}
  return files;
}
```

---

# PHASE 4: AI DECISION ‚Üí TRADE EXECUTION FLOW

## 4.1 AI Pipeline Integration Test

**File: `tests/integration/ai-to-trade-flow.test.ts`**

```typescript
import { describe, it, expect, beforeAll } from 'vitest';
import { db } from '../../server/db';
import { eq, desc, and, gte } from 'drizzle-orm';
import * as schema from '@shared/schema';

describe('AI Decision ‚Üí Trade Execution Flow', () => {

  let recentDecisions: any[];
  let recentTrades: any[];
  let agentStatus: any;

  beforeAll(async () => {
    // Get recent AI decisions
    recentDecisions = await db.select()
      .from(schema.aiDecisions)
      .orderBy(desc(schema.aiDecisions.createdAt))
      .limit(50);

    // Get recent trades
    recentTrades = await db.select()
      .from(schema.trades)
      .orderBy(desc(schema.trades.createdAt))
      .limit(50);

    // Get agent status
    const status = await db.select()
      .from(schema.agentStatus)
      .limit(1);
    agentStatus = status[0];
  });

  it('should verify AI decisions contain actionable recommendations', () => {
    console.log(`\nüìä AI Decisions: ${recentDecisions.length}`);
    
    const actionableDecisions = recentDecisions.filter(d => {
      // Check for actionable fields
      const hasAction = d.action || d.recommendation || d.signal;
      const hasSymbol = d.symbol;
      const hasConfidence = d.confidence !== undefined || d.score !== undefined;
      
      return hasAction && hasSymbol;
    });

    console.log(`   Actionable: ${actionableDecisions.length}`);
    console.log(`   Non-actionable: ${recentDecisions.length - actionableDecisions.length}`);

    if (actionableDecisions.length === 0 && recentDecisions.length > 0) {
      console.error('\n‚ùå AI DECISIONS LACK ACTIONABLE FIELDS');
      console.error('   Sample decision structure:');
      console.error(JSON.stringify(recentDecisions[0], null, 2));
      console.error('\n   REQUIRED FIELDS:');
      console.error('   - action: "buy" | "sell" | "hold"');
      console.error('   - symbol: "AAPL"');
      console.error('   - confidence: 0.0 - 1.0');
      console.error('   - quantity or positionSize');
    }

    // Report decision types
    const actionCounts: Record<string, number> = {};
    for (const d of actionableDecisions) {
      const action = d.action || d.recommendation || d.signal || 'unknown';
      actionCounts[action] = (actionCounts[action] || 0) + 1;
    }
    
    console.log('\n   Decision breakdown:');
    for (const [action, count] of Object.entries(actionCounts)) {
      console.log(`      ${action}: ${count}`);
    }
  });

  it('should verify trade execution follows AI decisions', () => {
    console.log(`\nüìä Recent Trades: ${recentTrades.length}`);

    // Find AI decisions that should have triggered trades
    const buyDecisions = recentDecisions.filter(d => 
      (d.action === 'buy' || d.recommendation === 'buy' || d.signal === 'bullish') &&
      (d.confidence >= 0.7 || d.score >= 0.7)
    );

    const sellDecisions = recentDecisions.filter(d => 
      (d.action === 'sell' || d.recommendation === 'sell' || d.signal === 'bearish') &&
      (d.confidence >= 0.7 || d.score >= 0.7)
    );

    console.log(`   High-confidence BUY decisions: ${buyDecisions.length}`);
    console.log(`   High-confidence SELL decisions: ${sellDecisions.length}`);

    // Check if corresponding trades exist
    const decisionSymbols = new Set([
      ...buyDecisions.map(d => d.symbol),
      ...sellDecisions.map(d => d.symbol),
    ]);

    const tradedSymbols = new Set(recentTrades.map(t => t.symbol));

    const decisionsWithoutTrades = [...decisionSymbols].filter(s => !tradedSymbols.has(s));
    
    if (decisionsWithoutTrades.length > 0) {
      console.warn('\n‚ö†Ô∏è AI DECISIONS WITHOUT CORRESPONDING TRADES:');
      decisionsWithoutTrades.forEach(s => console.warn(`   - ${s}`));
      console.warn('\n   POSSIBLE CAUSES:');
      console.warn('   - Trade execution disabled');
      console.warn('   - Insufficient buying power');
      console.warn('   - Position size rules blocked trade');
      console.warn('   - Orchestrator not processing decisions');
      console.warn('   - Trading engine disconnected');
    }

    // Check trade-decision correlation by time
    for (const trade of recentTrades.slice(0, 10)) {
      const tradeTime = new Date(trade.createdAt).getTime();
      
      // Find AI decisions within 1 hour before trade
      const relatedDecisions = recentDecisions.filter(d => {
        const decisionTime = new Date(d.createdAt).getTime();
        return d.symbol === trade.symbol && 
               decisionTime < tradeTime && 
               tradeTime - decisionTime < 3600000; // 1 hour
      });

      if (relatedDecisions.length === 0) {
        console.warn(`‚ö†Ô∏è Trade ${trade.symbol} (${trade.side}) has no preceding AI decision`);
      }
    }
  });

  it('should verify agent status and orchestrator connectivity', () => {
    console.log('\nüìä Agent Status:');
    
    if (!agentStatus) {
      console.error('‚ùå NO AGENT STATUS FOUND');
      console.error('   The orchestrator may not be initialized');
      return;
    }

    console.log(`   Running: ${agentStatus.isRunning}`);
    console.log(`   Paused: ${agentStatus.isPaused}`);
    console.log(`   Phase: ${agentStatus.currentPhase}`);
    console.log(`   Cycle Count: ${agentStatus.cycleCount}`);
    console.log(`   Error Count: ${agentStatus.errorCount}`);
    console.log(`   Last Cycle: ${agentStatus.lastCycleTime}`);

    if (!agentStatus.isRunning) {
      console.warn('\n‚ö†Ô∏è AGENT IS NOT RUNNING');
      console.warn('   AI decisions will not be processed');
      console.warn('   FIX: Start agent via POST /api/agent/start');
    }

    if (agentStatus.errorCount > 10) {
      console.error('\n‚ùå HIGH ERROR COUNT');
      console.error(`   Last error: ${agentStatus.lastError}`);
    }

    if (agentStatus.lastCycleTime) {
      const lastCycle = new Date(agentStatus.lastCycleTime);
      const minutesSinceLastCycle = (Date.now() - lastCycle.getTime()) / 60000;
      
      if (minutesSinceLastCycle > 30) {
        console.warn(`\n‚ö†Ô∏è Agent hasn't run in ${minutesSinceLastCycle.toFixed(0)} minutes`);
      }
    }
  });

  it('should trace full decision-to-execution pipeline', async () => {
    console.log('\nüìä PIPELINE TRACE');
    console.log('‚ïê'.repeat(60));

    // Step 1: Check market data flow
    const marketSnapshots = await db.select()
      .from(schema.marketSnapshots)
      .orderBy(desc(schema.marketSnapshots.timestamp))
      .limit(1);

    if (marketSnapshots.length === 0) {
      console.error('‚ùå Step 1 FAILED: No market data');
    } else {
      const age = (Date.now() - new Date(marketSnapshots[0].timestamp).getTime()) / 60000;
      if (age > 15) {
        console.warn(`‚ö†Ô∏è Step 1: Market data is ${age.toFixed(0)} minutes old`);
      } else {
        console.log(`‚úì Step 1: Market data fresh (${age.toFixed(0)} min old)`);
      }
    }

    // Step 2: Check LLM calls
    const llmCalls = await db.select()
      .from(schema.llmCalls)
      .orderBy(desc(schema.llmCalls.createdAt))
      .limit(10);

    if (llmCalls.length === 0) {
      console.error('‚ùå Step 2 FAILED: No LLM calls recorded');
    } else {
      console.log(`‚úì Step 2: LLM calls active (${llmCalls.length} recent)`);
    }

    // Step 3: Check AI decisions generated
    if (recentDecisions.length === 0) {
      console.error('‚ùå Step 3 FAILED: No AI decisions generated');
    } else {
      console.log(`‚úì Step 3: AI decisions generated (${recentDecisions.length})`);
    }

    // Step 4: Check decision processing
    const processedDecisions = recentDecisions.filter(d => d.processed || d.executedAt);
    console.log(`   Step 4: ${processedDecisions.length}/${recentDecisions.length} decisions processed`);

    // Step 5: Check trade creation
    if (recentTrades.length === 0) {
      console.warn('‚ö†Ô∏è Step 5: No trades created');
    } else {
      console.log(`‚úì Step 5: Trades created (${recentTrades.length})`);
    }

    // Step 6: Check trade execution
    const executedTrades = recentTrades.filter(t => 
      t.status === 'filled' || t.status === 'partially_filled'
    );
    console.log(`   Step 6: ${executedTrades.length}/${recentTrades.length} trades executed`);

    // Summary
    console.log('\nüìã PIPELINE HEALTH:');
    const steps = [
      marketSnapshots.length > 0,
      llmCalls.length > 0,
      recentDecisions.length > 0,
      processedDecisions.length > 0,
      recentTrades.length > 0,
      executedTrades.length > 0,
    ];
    
    const healthPercent = (steps.filter(Boolean).length / steps.length) * 100;
    console.log(`   ${healthPercent.toFixed(0)}% operational`);

    if (healthPercent < 100) {
      console.log('\nüîß FIXES NEEDED:');
      if (!steps[0]) console.log('   - Ensure market data connectors are running');
      if (!steps[1]) console.log('   - Check LLM provider connectivity');
      if (!steps[2]) console.log('   - Verify AI analysis is generating decisions');
      if (!steps[3]) console.log('   - Check orchestrator decision processing logic');
      if (!steps[4]) console.log('   - Verify trading engine is creating orders');
      if (!steps[5]) console.log('   - Check Alpaca connectivity and account status');
    }
  });
});
```

## 4.2 Orchestrator Component Connection Audit

**File: `tests/integration/orchestrator-connections.test.ts`**

```typescript
import { describe, it } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';

describe('Orchestrator Component Connection Audit', () => {

  it('should verify orchestrator imports and uses all required services', () => {
    // Find orchestrator files
    const orchestratorPaths = [
      'server/orchestrator/index.ts',
      'server/orchestrator/orchestrator.ts',
      'server/orchestrator/tradingOrchestrator.ts',
      'server/services/orchestrator.ts',
      'server/core/orchestrator.ts',
    ];

    let orchestratorFile: string | null = null;
    let orchestratorContent: string = '';

    for (const p of orchestratorPaths) {
      if (fs.existsSync(p)) {
        orchestratorFile = p;
        orchestratorContent = fs.readFileSync(p, 'utf-8');
        break;
      }
    }

    if (!orchestratorFile) {
      console.error('‚ùå ORCHESTRATOR FILE NOT FOUND');
      console.error('   Expected locations:', orchestratorPaths.join(', '));
      return;
    }

    console.log(`\nüìç Orchestrator found: ${orchestratorFile}`);
    console.log('‚ïê'.repeat(60));

    // Required service connections
    const requiredConnections = [
      { name: 'Market Data', patterns: ['marketData', 'MarketDataService', 'getQuote', 'getSnapshot'] },
      { name: 'AI/LLM Service', patterns: ['llm', 'ai', 'openai', 'groq', 'analyze', 'roleBasedLLM'] },
      { name: 'Trading Engine', patterns: ['trading', 'TradingEngine', 'placeOrder', 'executeOrder'] },
      { name: 'Risk Manager', patterns: ['risk', 'RiskManager', 'checkRisk', 'validatePosition'] },
      { name: 'Position Manager', patterns: ['position', 'PositionManager', 'getPositions'] },
      { name: 'Portfolio Service', patterns: ['portfolio', 'PortfolioService', 'getPortfolio'] },
      { name: 'Strategy Manager', patterns: ['strategy', 'StrategyManager', 'getStrategies'] },
      { name: 'News/Sentiment', patterns: ['news', 'sentiment', 'NewsService', 'SentimentService'] },
      { name: 'Alert System', patterns: ['alert', 'AlertService', 'notification'] },
      { name: 'Database', patterns: ['db', 'database', 'prisma', 'drizzle'] },
      { name: 'Event Bus', patterns: ['eventBus', 'EventEmitter', 'emit', 'on('] },
    ];

    const connections: { service: string; connected: boolean; evidence: string }[] = [];

    for (const { name, patterns } of requiredConnections) {
      const found = patterns.some(p => orchestratorContent.includes(p));
      const evidence = patterns.find(p => orchestratorContent.includes(p)) || 'not found';
      
      connections.push({
        service: name,
        connected: found,
        evidence,
      });
    }

    // Report
    console.log('\nüìä Service Connections:');
    for (const conn of connections) {
      const status = conn.connected ? '‚úì' : '‚ùå';
      console.log(`   ${status} ${conn.service}: ${conn.evidence}`);
    }

    const disconnected = connections.filter(c => !c.connected);
    if (disconnected.length > 0) {
      console.error('\n‚ùå DISCONNECTED SERVICES:');
      for (const conn of disconnected) {
        console.error(`   - ${conn.service}`);
      }
      console.error('\n   FIX: Import and integrate these services in orchestrator');
    }

    // Check for proper cycle structure
    console.log('\nüìä Orchestrator Cycle Structure:');
    
    const hasCycleMethod = orchestratorContent.match(/async\s+(runCycle|cycle|executeCycle|tick)/);
    const hasStartMethod = orchestratorContent.match(/async\s+(start|run|begin)/);
    const hasStopMethod = orchestratorContent.match(/async\s+(stop|halt|shutdown)/);
    
    console.log(`   ${hasCycleMethod ? '‚úì' : '‚ùå'} Has cycle method`);
    console.log(`   ${hasStartMethod ? '‚úì' : '‚ùå'} Has start method`);
    console.log(`   ${hasStopMethod ? '‚úì' : '‚ùå'} Has stop method`);

    // Check cycle steps
    const cycleSteps = [
      { step: 'Fetch Market Data', patterns: ['getMarket', 'fetchQuotes', 'getSnapshot'] },
      { step: 'Run AI Analysis', patterns: ['analyze', 'llm', 'getDecision'] },
      { step: 'Check Risk', patterns: ['checkRisk', 'validateRisk', 'riskCheck'] },
      { step: 'Execute Trades', patterns: ['execute', 'placeOrder', 'trade'] },
      { step: 'Update State', patterns: ['updateStatus', 'saveState', 'persist'] },
      { step: 'Emit Events', patterns: ['emit', 'publish', 'notify'] },
    ];

    console.log('\nüìä Cycle Steps:');
    for (const { step, patterns } of cycleSteps) {
      const found = patterns.some(p => orchestratorContent.includes(p));
      console.log(`   ${found ? '‚úì' : '‚ùå'} ${step}`);
    }
  });

  it('should verify trading engine connections', () => {
    const enginePaths = [
      'server/trading/engine.ts',
      'server/trading/tradingEngine.ts',
      'server/services/trading.ts',
      'server/core/trading.ts',
    ];

    let engineFile: string | null = null;
    let engineContent: string = '';

    for (const p of enginePaths) {
      if (fs.existsSync(p)) {
        engineFile = p;
        engineContent = fs.readFileSync(p, 'utf-8');
        break;
      }
    }

    if (!engineFile) {
      console.warn('‚ö†Ô∏è Trading engine file not found');
      return;
    }

    console.log(`\nüìç Trading Engine: ${engineFile}`);
    console.log('‚ïê'.repeat(60));

    // Check broker connections
    const brokerConnections = [
      { broker: 'Alpaca', patterns: ['alpaca', 'Alpaca', 'ALPACA'] },
    ];

    for (const { broker, patterns } of brokerConnections) {
      const found = patterns.some(p => engineContent.includes(p));
      console.log(`   ${found ? '‚úì' : '‚ùå'} ${broker} integration`);
    }

    // Check order flow
    const orderFlowSteps = [
      'validateOrder',
      'calculatePosition',
      'checkBuyingPower',
      'placeOrder',
      'confirmExecution',
      'updatePosition',
      'logTrade',
    ];

    console.log('\nüìä Order Flow:');
    for (const step of orderFlowSteps) {
      const found = engineContent.toLowerCase().includes(step.toLowerCase());
      console.log(`   ${found ? '‚úì' : '‚ùå'} ${step}`);
    }
  });
});
```

---

# PHASE 5: AUTOMATED FIX SCRIPTS

## 5.1 Fix Incomplete Data Rendering

**File: `server/scripts/fix-data-rendering.ts`**

```typescript
import * as fs from 'fs';
import * as path from 'path';

/**
 * This script identifies and suggests fixes for incomplete data rendering
 */

interface Fix {
  file: string;
  issue: string;
  currentCode: string;
  suggestedFix: string;
  automated: boolean;
}

const fixes: Fix[] = [];

function scanAndFix() {
  const dirs = ['server/routes', 'server/api', 'server/controllers'];

  for (const dir of dirs) {
    if (!fs.existsSync(dir)) continue;

    const files = walkDir(dir).filter(f => f.endsWith('.ts'));

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');
      let modified = content;
      let hasChanges = false;

      // Fix 1: Remove hard-coded LIMIT without pagination
      const limitMatch = content.match(/\.limit\((\d+)\)(?!.*offset)/g);
      if (limitMatch) {
        fixes.push({
          file,
          issue: 'Hard-coded LIMIT without pagination',
          currentCode: limitMatch[0],
          suggestedFix: `
// Add pagination support
const page = parseInt(req.query.page as string) || 1;
const limit = parseInt(req.query.limit as string) || 50;
const offset = (page - 1) * limit;

const [data, total] = await Promise.all([
  db.select().from(table).limit(limit).offset(offset),
  db.select({ count: count() }).from(table),
]);

res.json({
  data,
  pagination: {
    page,
    limit,
    total: total[0].count,
    totalPages: Math.ceil(total[0].count / limit),
  },
});`,
          automated: false,
        });
      }

      // Fix 2: Add missing response wrapper
      if (content.includes('res.json(') && !content.includes('pagination')) {
        const arrayResponseMatch = content.match(/res\.json\(\s*(await\s+db\.select)/);
        if (arrayResponseMatch) {
          fixes.push({
            file,
            issue: 'Array response without metadata',
            currentCode: 'res.json(await db.select()...)',
            suggestedFix: `
res.json({
  data: results,
  count: results.length,
  timestamp: new Date().toISOString(),
});`,
            automated: false,
          });
        }
      }

      // Fix 3: Ensure symbols endpoint returns all symbols
      if (file.includes('symbol') && content.includes('limit')) {
        fixes.push({
          file,
          issue: 'Symbols endpoint may be limited',
          currentCode: 'Found limit() in symbols route',
          suggestedFix: `
// For symbol list, return all or use high limit
const symbols = await db.select().from(symbolMaster)
  .where(eq(symbolMaster.isTradable, true))
  .orderBy(symbolMaster.symbol);
  // Remove .limit() or set to 1000+`,
          automated: false,
        });
      }

      if (hasChanges) {
        fs.writeFileSync(file, modified);
      }
    }
  }

  // Report
  console.log('\nüìã DATA RENDERING FIXES');
  console.log('‚ïê'.repeat(70));

  if (fixes.length === 0) {
    console.log('‚úì No obvious data rendering issues found');
    return;
  }

  for (const fix of fixes) {
    console.log(`\nüìç ${fix.file}`);
    console.log(`   Issue: ${fix.issue}`);
    console.log(`   Current: ${fix.currentCode}`);
    console.log(`   Fix: ${fix.automated ? '(AUTO-APPLIED)' : '(MANUAL)'}`);
    if (!fix.automated) {
      console.log(`   Suggested code:\n${fix.suggestedFix}`);
    }
  }
}

function walkDir(dir: string): string[] {
  const files: string[] = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) files.push(...walkDir(fullPath));
    else files.push(fullPath);
  }
  return files;
}

scanAndFix();
```

## 5.2 Fix Broken Navigation

**File: `server/scripts/fix-navigation.ts`**

```typescript
import * as fs from 'fs';
import * as path from 'path';

/**
 * Identifies and fixes broken navigation in UI components
 */

interface NavigationFix {
  file: string;
  line: number;
  issue: string;
  currentCode: string;
  fixedCode: string;
}

function fixNavigation() {
  const componentDirs = ['mobile/components', 'mobile/screens', 'mobile/app'];
  const fixes: NavigationFix[] = [];

  for (const dir of componentDirs) {
    if (!fs.existsSync(dir)) continue;

    const files = walkDir(dir).filter(f => f.endsWith('.tsx'));

    for (const file of files) {
      const content = fs.readFileSync(file, 'utf-8');
      const lines = content.split('\n');
      let modified = false;
      const newLines = [...lines];

      lines.forEach((line, index) => {
        // Fix 1: Empty onPress handlers
        if (line.match(/onPress=\{\s*\(\)\s*=>\s*\{\s*\}\s*\}/)) {
          const componentMatch = line.match(/<(\w+)/);
          const component = componentMatch ? componentMatch[1] : 'Element';
          
          // Try to infer navigation target from context
          const contextLines = lines.slice(Math.max(0, index - 5), index + 5).join('\n');
          const symbolMatch = contextLines.match(/symbol['":\s]+['"]?(\w+)/i);
          const idMatch = contextLines.match(/\bid['":\s]+['"]?(\w+)/i);

          let suggestedNavigation = '';
          if (symbolMatch) {
            suggestedNavigation = `navigation.navigate('SymbolDetail', { symbol: item.symbol })`;
          } else if (idMatch) {
            suggestedNavigation = `navigation.navigate('Detail', { id: item.id })`;
          } else {
            suggestedNavigation = `console.log('TODO: Add navigation')`;
          }

          fixes.push({
            file,
            line: index + 1,
            issue: 'Empty onPress handler',
            currentCode: line.trim(),
            fixedCode: line.replace(/\{\s*\(\)\s*=>\s*\{\s*\}\s*\}/, `{() => ${suggestedNavigation}}`),
          });
        }

        // Fix 2: onPress with only console.log
        if (line.match(/onPress=\{[^}]*console\.log[^}]*\}/) && !line.includes('navigation')) {
          fixes.push({
            file,
            line: index + 1,
            issue: 'onPress only logs to console',
            currentCode: line.trim(),
            fixedCode: '// TODO: Replace console.log with actual navigation',
          });
        }

        // Fix 3: Pressable without onPress
        if (line.includes('<Pressable') && !line.includes('onPress')) {
          // Check next few lines for onPress
          const nextLines = lines.slice(index, index + 3).join('');
          if (!nextLines.includes('onPress')) {
            fixes.push({
              file,
              line: index + 1,
              issue: 'Pressable without onPress',
              currentCode: line.trim(),
              fixedCode: line.replace('<Pressable', '<Pressable onPress={() => {}}'),
            });
          }
        }
      });
    }
  }

  // Report
  console.log('\nüìã NAVIGATION FIXES');
  console.log('‚ïê'.repeat(70));

  if (fixes.length === 0) {
    console.log('‚úì No broken navigation found');
    return;
  }

  // Group by file
  const byFile = new Map<string, NavigationFix[]>();
  for (const fix of fixes) {
    if (!byFile.has(fix.file)) byFile.set(fix.file, []);
    byFile.get(fix.file)!.push(fix);
  }

  for (const [file, fileFixes] of byFile) {
    console.log(`\nüìç ${file}`);
    for (const fix of fileFixes) {
      console.log(`   Line ${fix.line}: ${fix.issue}`);
      console.log(`   Current: ${fix.currentCode.substring(0, 60)}...`);
      console.log(`   Fix: ${fix.fixedCode.substring(0, 60)}...`);
    }
  }

  // Generate fix file
  const fixScript = `
// Auto-generated navigation fixes
// Review and apply manually

${[...byFile.entries()].map(([file, fileFixes]) => `
// File: ${file}
${fileFixes.map(f => `// Line ${f.line}: ${f.issue}
// Current: ${f.currentCode}
// Fixed: ${f.fixedCode}`).join('\n\n')}`).join('\n')}
`;

  fs.writeFileSync('navigation-fixes.txt', fixScript);
  console.log('\n‚úì Fix suggestions saved to navigation-fixes.txt');
}

function walkDir(dir: string): string[] {
  const files: string[] = [];
  try {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.includes('node_modules')) {
        files.push(...walkDir(fullPath));
      } else if (entry.isFile()) {
        files.push(fullPath);
      }
    }
  } catch (e) {}
  return files;
}

fixNavigation();
```

## 5.3 Fix AI Decision Processing

**File: `server/scripts/fix-ai-processing.ts`**

```typescript
/**
 * Ensures AI decisions are properly processed and connected to trade execution
 */

import * as fs from 'fs';

function fixAIProcessing() {
  console.log('\nüìã AI DECISION PROCESSING FIXES');
  console.log('‚ïê'.repeat(70));

  // Check if decision processor exists
  const processorPaths = [
    'server/orchestrator/decisionProcessor.ts',
    'server/services/decisionProcessor.ts',
    'server/ai/decisionProcessor.ts',
  ];

  let processorExists = false;
  for (const p of processorPaths) {
    if (fs.existsSync(p)) {
      processorExists = true;
      console.log(`‚úì Decision processor found: ${p}`);
      break;
    }
  }

  if (!processorExists) {
    console.error('‚ùå No decision processor found');
    console.log('\n   Creating decision processor...');

    const processorCode = `
import { db } from '../db';
import { eq, and, isNull } from 'drizzle-orm';
import { aiDecisions, trades } from '@shared/schema';
import { tradingEngine } from '../trading/engine';
import { riskManager } from '../risk/manager';

interface ProcessingResult {
  processed: number;
  executed: number;
  skipped: number;
  errors: string[];
}

export class DecisionProcessor {
  private minConfidence: number = 0.7;
  private maxPositionPercent: number = 0.1;

  async processUnprocessedDecisions(): Promise<ProcessingResult> {
    const result: ProcessingResult = {
      processed: 0,
      executed: 0,
      skipped: 0,
      errors: [],
    };

    // Get unprocessed decisions
    const decisions = await db.select()
      .from(aiDecisions)
      .where(
        and(
          isNull(aiDecisions.processedAt),
          // Only recent decisions (last 1 hour)
        )
      )
      .limit(50);

    for (const decision of decisions) {
      result.processed++;

      try {
        // Check if decision meets execution criteria
        if (!this.meetsExecutionCriteria(decision)) {
          result.skipped++;
          await this.markProcessed(decision.id, 'skipped', 'Did not meet criteria');
          continue;
        }

        // Check risk
        const riskCheck = await riskManager.validateDecision(decision);
        if (!riskCheck.approved) {
          result.skipped++;
          await this.markProcessed(decision.id, 'skipped', riskCheck.reason);
          continue;
        }

        // Execute trade
        const tradeResult = await tradingEngine.executeDecision(decision);
        
        if (tradeResult.success) {
          result.executed++;
          await this.markProcessed(decision.id, 'executed', tradeResult.orderId);
        } else {
          result.errors.push(\`\${decision.symbol}: \${tradeResult.error}\`);
          await this.markProcessed(decision.id, 'failed', tradeResult.error);
        }
      } catch (error) {
        result.errors.push(\`\${decision.symbol}: \${error}\`);
        await this.markProcessed(decision.id, 'error', String(error));
      }
    }

    return result;
  }

  private meetsExecutionCriteria(decision: any): boolean {
    // Check confidence threshold
    const confidence = decision.confidence || decision.score || 0;
    if (confidence < this.minConfidence) return false;

    // Check for valid action
    const action = decision.action || decision.recommendation;
    if (!['buy', 'sell'].includes(action?.toLowerCase())) return false;

    // Check for valid symbol
    if (!decision.symbol) return false;

    return true;
  }

  private async markProcessed(
    decisionId: string, 
    status: string, 
    notes: string
  ): Promise<void> {
    await db.update(aiDecisions)
      .set({
        processedAt: new Date(),
        processingStatus: status,
        processingNotes: notes,
      })
      .where(eq(aiDecisions.id, decisionId));
  }
}

export const decisionProcessor = new DecisionProcessor();
`;

    fs.mkdirSync('server/services', { recursive: true });
    fs.writeFileSync('server/services/decisionProcessor.ts', processorCode);
    console.log('   ‚úì Created server/services/decisionProcessor.ts');
  }

  // Check orchestrator integration
  const orchestratorPaths = [
    'server/orchestrator/index.ts',
    'server/orchestrator/orchestrator.ts',
  ];

  for (const p of orchestratorPaths) {
    if (fs.existsSync(p)) {
      const content = fs.readFileSync(p, 'utf-8');
      
      if (!content.includes('decisionProcessor')) {
        console.warn(`\n‚ö†Ô∏è Orchestrator doesn't import decisionProcessor`);
        console.log('   Add to orchestrator:');
        console.log(`
   import { decisionProcessor } from '../services/decisionProcessor';

   // In run cycle:
   async runCycle() {
     // ... existing code ...

     // Process AI decisions
     const processingResult = await decisionProcessor.processUnprocessedDecisions();
     console.log(\`Processed \${processingResult.processed} decisions, executed \${processingResult.executed}\`);
   }
`);
      } else {
        console.log('‚úì Orchestrator imports decisionProcessor');
      }
    }
  }

  // Check for required schema fields
  console.log('\nüìä Schema Check:');
  const schemaPath = 'shared/schema.ts';
  if (fs.existsSync(schemaPath)) {
    const schema = fs.readFileSync(schemaPath, 'utf-8');
    
    const requiredFields = [
      'processedAt',
      'processingStatus',
      'processingNotes',
    ];

    for (const field of requiredFields) {
      if (!schema.includes(field)) {
        console.warn(`   ‚ö†Ô∏è aiDecisions missing field: ${field}`);
        console.log(`      Add to schema: ${field}: timestamp('${field}')`);
      } else {
        console.log(`   ‚úì ${field} exists in schema`);
      }
    }
  }
}

fixAIProcessing();
```

---

# PHASE 6: RUN ALL DIAGNOSTICS

## 6.1 Master Test Runner Script

**File: `package.json` scripts section (ADD)**

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    
    "diagnose": "npm run diagnose:all",
    "diagnose:all": "npm-run-all diagnose:db diagnose:api diagnose:ui diagnose:ai diagnose:orchestrator",
    
    "diagnose:db": "npx tsx tests/integration/data-flow.test.ts",
    "diagnose:api": "npx tsx tests/integration/api-endpoints.test.ts",
    "diagnose:ui": "npx tsx tests/ui/component-rendering.test.ts && npx tsx tests/ui/navigation-map.test.ts",
    "diagnose:ai": "npx tsx tests/integration/ai-to-trade-flow.test.ts",
    "diagnose:orchestrator": "npx tsx tests/integration/orchestrator-connections.test.ts",
    "diagnose:duplicates": "npx tsx tests/ui/duplicate-components.test.ts",
    "diagnose:pagination": "npx tsx tests/integration/pagination-diagnostic.test.ts",
    
    "fix:all": "npm-run-all fix:data fix:navigation fix:ai",
    "fix:data": "npx tsx server/scripts/fix-data-rendering.ts",
    "fix:navigation": "npx tsx server/scripts/fix-navigation.ts",
    "fix:ai": "npx tsx server/scripts/fix-ai-processing.ts"
  }
}
```

## 6.2 Run Full Diagnostic

```bash
# Install test dependencies
npm install -D vitest @vitest/coverage-v8 supertest npm-run-all

# Run all diagnostics
npm run diagnose

# Or run individually:
npm run diagnose:db        # Database ‚Üí API data flow
npm run diagnose:api       # API endpoint completeness
npm run diagnose:ui        # UI rendering issues
npm run diagnose:ai        # AI decision ‚Üí trade flow
npm run diagnose:orchestrator  # Service connections
npm run diagnose:duplicates    # Duplicate components
npm run diagnose:pagination    # Data truncation

# Apply fixes
npm run fix:all
```

---

# PHASE 7: CHECKLIST

## Pre-Run Checklist
- [ ] Server is running (`npm run dev`)
- [ ] Database is accessible
- [ ] All API keys configured
- [ ] Alpaca paper trading account connected

## Diagnostic Checklist
- [ ] Run `npm run diagnose:db` - verify all data flows
- [ ] Run `npm run diagnose:api` - verify all endpoints exist
- [ ] Run `npm run diagnose:pagination` - check for truncated data
- [ ] Run `npm run diagnose:ui` - check component rendering
- [ ] Run `npm run diagnose:ai` - verify AI ‚Üí trade flow
- [ ] Run `npm run diagnose:orchestrator` - verify service connections
- [ ] Run `npm run diagnose:duplicates` - identify redundant components

## Fix Checklist
- [ ] Apply pagination to limited endpoints
- [ ] Fix empty onPress handlers
- [ ] Connect orphan screens to navigation
- [ ] Integrate decision processor with orchestrator
- [ ] Remove or consolidate duplicate components
- [ ] Verify AI decisions have required fields

## Verification Checklist
- [ ] Stock list shows all symbols (not just 1-2)
- [ ] Position list shows all positions
- [ ] Clicking items navigates to detail screens
- [ ] AI decisions appear in decisions list
- [ ] AI suggestions result in trades (when criteria met)
- [ ] Agent status shows running/active
- [ ] No duplicate screens in navigation

---

# EXPECTED ISSUES & FIXES SUMMARY

| Issue | Likely Cause | Fix |
|-------|--------------|-----|
| Stock list shows 1-2 items | Hard-coded LIMIT or `.slice(0, 2)` | Remove limit or add pagination |
| Clicks don't navigate | Empty `onPress` handlers | Add `navigation.navigate()` |
| AI decisions not executing | Missing decision processor | Create and integrate processor |
| Orchestrator not trading | Services not imported | Import all required services |
| Duplicate UI components | Copy-paste development | Consolidate into shared components |
| Stale market data | Polling stopped | Check market data connector status |
| No trades despite decisions | Risk checks blocking | Review risk manager thresholds |

---

**Run this entire diagnostic suite to identify and fix all integration issues in the AI Active Trader platform.**