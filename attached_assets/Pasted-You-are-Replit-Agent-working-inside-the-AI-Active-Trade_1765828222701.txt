You are Replit Agent working inside the AI Active Trader repo.

GOAL (Task #6):
Implement a real, reproducible backtesting subsystem with:
- no look-ahead bias (trades can only execute on the next bar, not on the same bar you “observe”)
- explicit execution model (fill price rules, slippage, fees)
- data provenance (exact provider, cache status, date ranges, bar timeframe)
- strict separation of Backtest vs Paper vs Live in the DB + UI
- no mock/demo returns and no mixing backtest results into “real” trade ledger

AUTHORITATIVE RULES (do not violate):
- Avoid look-ahead bias and survivorship bias as standard backtesting pitfalls (CFA/QuantConnect guidance).
- Use Alpaca Historical API + bars endpoints for historical data where available; handle pagination/limits correctly.
- Update docs only after code is real and verified.

READ FIRST (mandatory, no coding yet)
1) docs/ARCHITECTURE.md
2) docs/API_REFERENCE.md
3) docs/TRADING_SAGA_SEQUENCES.md
4) docs/ORCHESTRATOR_AND_AGENT_RUNTIME.md
5) docs/API_BUDGETING_AND_CACHING.md
6) Search codebase for any “backtest”, “simulation”, “pnl”, “ledger” logic and list existing endpoints and UI screens.

STEP 1 — DEFINE A BACKTEST “CONTRACT” (shared types)
Add canonical types:
A) BacktestRun:
- id, createdAt, status (QUEUED/RUNNING/DONE/FAILED)
- strategyId or strategyConfigHash
- universe (symbols list + broker)
- timeframe (e.g., 1Min/5Min/1Hour/1Day)
- start/end
- initialCash, feesModel, slippageModel, executionPriceRule (NEXT_OPEN / NEXT_CLOSE)
- dataSource (alpaca|polygon|...)
- provenance: { provider, cacheHitRate, dataPulledAt, barsCountBySymbol }
- resultsSummary (CAGR, maxDrawdown, Sharpe optional, winRate, tradesCount)
B) BacktestTradeEvent:
- ts, symbol, side, qty, price, reason, orderType(simulated), fees, slippage
C) BacktestEquityPoint:
- ts, equity, cash, exposure

STEP 2 — DB SCHEMA (strict separation)
Create dedicated tables for backtesting:
- backtest_runs
- backtest_trade_events
- backtest_equity_curve
Do NOT reuse “trades” table used for broker/paper execution.
Add migration and apply it.

STEP 3 — HISTORICAL DATA PIPELINE (real, cached, reproducible)
Implement a data access layer:
- getHistoricalBars(symbols, timeframe, start, end, provider="alpaca")
Use Alpaca historical bars endpoints (stocks and options if needed) and Historical API guidance.
Important: Alpaca stock bars endpoint returns results sorted by symbol then timestamp; implement pagination and per-symbol handling properly.
All calls go through your centralized callExternal/budget/cache layer.
Cache keys must include: provider + symbols + timeframe + start/end + adjustment flags.
Store provenance: provider, cacheHit, cacheAgeMs, barsCount.

STEP 4 — EXECUTION MODEL (no cheating)
Implement a deterministic simulator:
- At time t, compute indicators/signals ONLY using bars <= t.
- If a trade signal triggers at bar t, the simulated fill happens at bar t+1 using:
  - NEXT_OPEN (default) or NEXT_CLOSE (configurable)
- Apply:
  - fees model (fixed per trade or %)
  - slippage model (bps or spread proxy)
- Record every trade event and the cash/equity changes.

STEP 5 — BIAS GUARDRAILS (hard checks)
Add safeguards:
- Look-ahead detector: if any indicator tries to access bar t+1 or beyond, throw.
- Reporting lag option for fundamentals/news-based signals if present (default: lag = 1 day).
- Universe disclaimer: if your symbol universe is built only from “currently active” assets, display a warning about survivorship bias risk in docs + UI.
Do not pretend survivorship bias is solved unless you implement point-in-time universe snapshots.

STEP 6 — ENDPOINTS (separate from live/paper)
Implement:
- POST /api/backtests/run  (strategyConfig + date range + params)
- GET  /api/backtests/:id
- GET  /api/backtests/:id/equity-curve
- GET  /api/backtests/:id/trades
All endpoints must return provenance and must not mix with /api/ledger (broker).

STEP 7 — UI (strict separation, minimal but correct)
- Add a Backtests screen:
  - list runs + status + summary metrics
  - open run detail: equity curve + trades list
- Ensure no backtest results appear in Analytics “Trade Ledger” or “Positions”.
- Add clear labeling: “BACKTEST” badge.

STEP 8 — VERIFICATION (MUST RUN + SHOW OUTPUT)
- Run migrations
- Run server
- Trigger one backtest on 1–2 symbols for a short window (e.g., last 30 days daily bars)
- Show curl outputs:
  - POST /api/backtests/run
  - GET /api/backtests/:id
  - GET /api/backtests/:id/equity-curve
Prove:
- cache is used on second run
- trade fills occur on NEXT bar (no same-bar fills)

STEP 9 — DOCS UPDATE (must match reality)
Update:
- docs/API_REFERENCE.md (backtest endpoints)
- docs/ARCHITECTURE.md (Backtest subsystem + separation)
Add:
- docs/BACKTESTING_INTEGRITY.md
  - execution model
  - slippage/fees assumptions
  - look-ahead bias prevention
  - survivorship bias disclaimer (unless solved)
  - data provenance rules

DELIVERABLES:
- Files changed list
- Commands run + outputs
- One example run id + curl examples
- “Next task plan” for Task #7 (LLM router) but DO NOT implement it yet
